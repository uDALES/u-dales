var tipuesearch = {"pages":[{"title":" uDALES ","text":"uDALES Developer Info The uDALES Team","tags":"home","url":"index.html"},{"title":"domainptr – uDALES ","text":"type, private :: domainptr Components Type Visibility Attributes Name Initial real, public, pointer :: point (:,:,:) Source Code type domainptr real , pointer :: point (:,:,:) end type domainptr","tags":"","url":"type/domainptr.html"},{"title":"solid_info_type – uDALES ","text":"type, public :: solid_info_type Components Type Visibility Attributes Name Initial integer, public :: nsolpts integer, public, allocatable :: solpts (:,:) logical, public, allocatable :: lsolptsrank (:) integer, public, allocatable :: solptsrank (:) integer, public :: nsolptsrank integer, public, allocatable :: solpts_loc (:,:) Source Code TYPE solid_info_type integer :: nsolpts integer , allocatable :: solpts (:,:) logical , allocatable :: lsolptsrank (:) ! integer , allocatable :: solptsrank (:) ! indices of points on current rank integer :: nsolptsrank integer , allocatable :: solpts_loc (:,:) end TYPE solid_info_type","tags":"","url":"type/solid_info_type.html"},{"title":"bound_info_type – uDALES ","text":"type, public :: bound_info_type Components Type Visibility Attributes Name Initial integer, public :: nbndpts integer, public, allocatable :: bndpts (:,:) real, public, allocatable :: recpts (:,:) integer, public, allocatable :: recids_u (:,:) integer, public, allocatable :: recids_v (:,:) integer, public, allocatable :: recids_w (:,:) integer, public, allocatable :: recids_c (:,:) real, public, allocatable :: bnddst (:) integer, public, allocatable :: bndptsrank (:) logical, public, allocatable :: lcomprec (:) logical, public, allocatable :: lskipsec (:) integer, public :: nbndptsrank integer, public, allocatable :: bndpts_loc (:,:) integer, public :: nfctsecs integer, public, allocatable :: secbndptids (:) integer, public, allocatable :: secfacids (:) real, public, allocatable :: secareas (:) integer, public, allocatable :: fctsecsrank (:) integer, public :: nfctsecsrank integer, public, allocatable :: secfacids_loc (:) real, public, allocatable :: secareas_loc (:) integer, public, allocatable :: secbndpts_loc (:,:) real, public, allocatable :: bnddst_loc (:) real, public, allocatable :: recpts_loc (:,:) integer, public, allocatable :: recids_u_loc (:,:) integer, public, allocatable :: recids_v_loc (:,:) integer, public, allocatable :: recids_w_loc (:,:) integer, public, allocatable :: recids_c_loc (:,:) logical, public, allocatable :: lcomprec_loc (:) logical, public, allocatable :: lskipsec_loc (:) Source Code TYPE bound_info_type integer :: nbndpts integer , allocatable :: bndpts (:,:) ! ijk location of fluid boundary point !real, allocatable    :: intpts(:,:) ! xyz location of boundary intercept point !real, allocatable    :: bndvec(:,:) ! vector from boundary to fluid point (normalised) real , allocatable :: recpts (:,:) ! xyz location of reconstruction point integer , allocatable :: recids_u (:,:) ! ijk location of u grid cell that rec point is in integer , allocatable :: recids_v (:,:) ! ijk location of u grid cell that rec point is in integer , allocatable :: recids_w (:,:) ! ijk location of u grid cell that rec point is in integer , allocatable :: recids_c (:,:) ! ijk location of u grid cell that rec point is in real , allocatable :: bnddst (:) ! distance between surface & bound point integer , allocatable :: bndptsrank (:) ! indices of points on current rank !integer, allocatable :: bndpts_loc(:,:) ! indices of points on current rank logical , allocatable :: lcomprec (:) ! Switch whether reconstruction point is a computational point logical , allocatable :: lskipsec (:) ! Switch whether to skip finding the shear stress at this point integer :: nbndptsrank integer , allocatable :: bndpts_loc (:,:) ! ijk location of fluid boundary point on rank integer :: nfctsecs integer , allocatable :: secbndptids (:) integer , allocatable :: secfacids (:) real , allocatable :: secareas (:) integer , allocatable :: fctsecsrank (:) integer :: nfctsecsrank integer , allocatable :: secfacids_loc (:) real , allocatable :: secareas_loc (:) integer , allocatable :: secbndpts_loc (:,:) real , allocatable :: bnddst_loc (:) real , allocatable :: recpts_loc (:,:) integer , allocatable :: recids_u_loc (:,:) integer , allocatable :: recids_v_loc (:,:) integer , allocatable :: recids_w_loc (:,:) integer , allocatable :: recids_c_loc (:,:) logical , allocatable :: lcomprec_loc (:) logical , allocatable :: lskipsec_loc (:) end TYPE bound_info_type","tags":"","url":"type/bound_info_type.html"},{"title":"interp_velocity – uDALES","text":"interface public  function interp_velocity(i, j, k) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k Return Value real(3)","tags":"","url":"interface/interp_velocity.html"},{"title":"interp_temperature – uDALES","text":"interface public  function interp_temperature(i, j, k) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k Return Value real","tags":"","url":"interface/interp_temperature.html"},{"title":"advecc_2nd – uDALES","text":"subroutine advecc_2nd(hi, hj, hk, putin, putout) Uses modmpi initfac modglobal modibm modfields proc~~advecc_2nd~~UsesGraph proc~advecc_2nd advecc_2nd module~initfac initfac proc~advecc_2nd->module~initfac module~modfields modfields proc~advecc_2nd->module~modfields module~modglobal modglobal proc~advecc_2nd->module~modglobal module~modibm modibm proc~advecc_2nd->module~modibm module~modmpi modmpi proc~advecc_2nd->module~modmpi module~initfac->module~modglobal module~initfac->module~modmpi mpi mpi module~initfac->mpi netcdf netcdf module~initfac->netcdf decomp_2d decomp_2d module~modfields->decomp_2d module~modibmdata modibmdata module~modibm->module~modibmdata module~modibm->mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name integer, intent(in) :: hi integer, intent(in) :: hj integer, intent(in) :: hk real, intent(in), dimension(ib - hi:ie + hi, jb - hj:je + hj, kb - hk:ke + hk) :: putin real, intent(inout), dimension(ib - hi:ie + hi, jb - hj:je + hj, kb:ke + hk) :: putout Source Code subroutine advecc_2nd ( hi , hj , hk , putin , putout ) use modglobal , only : ih , jh , kh , kb , ke , ib , ie , jb , je , dxi , dxi5 , dyi , dyi5 , dzf , dzfi , dzhi , dzfi5 , libm , jmax use modfields , only : u0 , v0 , w0 use modibm , only : nxwallsnorm , nzwallsnorm , nywallsm , nywallsp , ywallsm , ywallsp , & xwallsnorm , zwallsnorm , iypluswall , iyminwall , nyminwall , nypluswall use initfac , only : block use modmpi , only : myid implicit none integer , intent ( in ) :: hi !< size of halo in i integer , intent ( in ) :: hj !< size of halo in j integer , intent ( in ) :: hk !< size of halo in k real , dimension ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ), intent ( in ) :: putin !< Input: the cell centered field real , dimension ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ), intent ( inout ) :: putout !< Output: the tendency integer :: i , j , k , ip , im , jp , jm , kp , km , il , iu , jl , ju , kl , ku , n do k = kb , ke km = k - 1 kp = k + 1 do j = jb , je jm = j - 1 jp = j + 1 do i = ib , ie im = i - 1 ip = i + 1 putout ( i , j , k ) = putout ( i , j , k ) - ( & ( & u0 ( ip , j , k ) * ( putin ( ip , j , k ) + putin ( i , j , k )) & - u0 ( i , j , k ) * ( putin ( im , j , k ) + putin ( i , j , k )) & ! d(uc)/dx ) * dxi5 & + ( & ! v0 ( i , jp , k ) * ( putin ( i , jp , k ) + putin ( i , j , k )) & - v0 ( i , j , k ) * ( putin ( i , jm , k ) + putin ( i , j , k )) & ! d(vc)/dy ) * dyi5 ) end do end do end do do j = jb , je jm = j - 1 jp = j + 1 do i = ib , ie im = i - 1 ip = i + 1 do k = kb , ke km = k - 1 kp = k + 1 putout ( i , j , k ) = putout ( i , j , k ) - ( & w0 ( i , j , kp ) * ( putin ( i , j , kp ) * dzf ( k ) + putin ( i , j , k ) * dzf ( kp )) * dzhi ( kp ) & - w0 ( i , j , k ) * ( putin ( i , j , km ) * dzf ( k ) + putin ( i , j , k ) * dzf ( km )) * dzhi ( k ) & ) * dzfi5 ( k ) end do end do end do end subroutine advecc_2nd","tags":"","url":"proc/advecc_2nd.html"},{"title":"advecu_2nd – uDALES","text":"subroutine advecu_2nd(putin, putout) Uses modmpi decomp_2d modglobal modibm modfields proc~~advecu_2nd~~UsesGraph proc~advecu_2nd advecu_2nd decomp_2d decomp_2d proc~advecu_2nd->decomp_2d module~modfields modfields proc~advecu_2nd->module~modfields module~modglobal modglobal proc~advecu_2nd->module~modglobal module~modibm modibm proc~advecu_2nd->module~modibm module~modmpi modmpi proc~advecu_2nd->module~modmpi module~modfields->decomp_2d module~modibmdata modibmdata module~modibm->module~modibmdata mpi mpi module~modibm->mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(in), dimension(ib - ih:ie + ih, jb - jh:je + jh, kb - kh:ke + kh) :: putin real, intent(inout), dimension(ib - ih:ie + ih, jb - jh:je + jh, kb:ke + kh) :: putout Source Code subroutine advecu_2nd ( putin , putout ) use modglobal , only : ih , ib , ie , jb , je , jh , kb , ke , kh , dxi , dxiq , dyiq , dzf , dzfi5 , dzhi , libm , imax , jmax , ktot use modfields , only : u0 , v0 , w0 , pres0 , uh , vh , wh , pres0h use modibm , only : nxwallsnorm , nzwallsnorm , nywallsm , nywallsp , ywallsm , ywallsp , & xwallsnorm , zwallsnorm use modmpi , only : myid use decomp_2d implicit none real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ), intent ( in ) :: putin !< Input: the u-field real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ), intent ( inout ) :: putout !< Output: the tendency integer :: i , j , k , ip , im , jp , jm , kp , km , il , iu , jl , ju , kl , ku , n do k = kb , ke km = k - 1 kp = k + 1 do j = jb , je jm = j - 1 jp = j + 1 do i = ib , ie im = i - 1 ip = i + 1 putout ( i , j , k ) = putout ( i , j , k ) - ( & ( & ( putin ( i , j , k ) + putin ( ip , j , k )) * ( u0 ( i , j , k ) + u0 ( ip , j , k )) & - ( putin ( i , j , k ) + putin ( im , j , k )) * ( u0 ( i , j , k ) + u0 ( im , j , k )) & ! d(uu)/dx ) * dxiq & + ( & ( putin ( i , j , k ) + putin ( i , jp , k )) * ( v0 ( i , jp , k ) + v0 ( im , jp , k )) & - ( putin ( i , j , k ) + putin ( i , jm , k )) * ( v0 ( i , j , k ) + v0 ( im , j , k )) & ! d(vu)/dy ) * dyiq ) & - (( pres0 ( i , j , k ) - pres0 ( i - 1 , j , k )) * dxi ) ! - dp/dx end do end do end do do j = jb , je jm = j - 1 jp = j + 1 do i = ib , ie im = i - 1 ip = i + 1 do k = kb , ke km = k - 1 kp = k + 1 putout ( i , j , k ) = putout ( i , j , k ) - ( & ( putin ( i , j , kp ) * dzf ( k ) + putin ( i , j , k ) * dzf ( kp )) * dzhi ( kp ) & * ( w0 ( i , j , kp ) + w0 ( im , j , kp )) & - ( putin ( i , j , k ) * dzf ( km ) + putin ( i , j , km ) * dzf ( k )) * dzhi ( k ) & * ( w0 ( i , j , k ) + w0 ( im , j , k )) & ) * 0.5 * dzfi5 ( k ) end do end do end do end subroutine advecu_2nd","tags":"","url":"proc/advecu_2nd.html"},{"title":"advecv_2nd – uDALES","text":"subroutine advecv_2nd(putin, putout) Uses modfields modglobal proc~~advecv_2nd~~UsesGraph proc~advecv_2nd advecv_2nd module~modfields modfields proc~advecv_2nd->module~modfields module~modglobal modglobal proc~advecv_2nd->module~modglobal decomp_2d decomp_2d module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(in), dimension(ib - ih:ie + ih, jb - jh:je + jh, kb - kh:ke + kh) :: putin real, intent(inout), dimension(ib - ih:ie + ih, jb - jh:je + jh, kb:ke + kh) :: putout Source Code subroutine advecv_2nd ( putin , putout ) use modglobal , only : ih , ib , ie , jh , jb , je , kb , ke , kh , dx , dxi , dxiq , dyiq , dzf , dzfi5 , dzhi , dyi use modfields , only : u0 , v0 , w0 , pres0 implicit none real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ), intent ( in ) :: putin !< Input: the v-field real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ), intent ( inout ) :: putout !< Output: the tendency integer :: i , j , k , ip , im , jp , jm , kp , km do k = kb , ke km = k - 1 kp = k + 1 do j = jb , je jm = j - 1 jp = j + 1 do i = ib , ie im = i - 1 ip = i + 1 putout ( i , j , k ) = putout ( i , j , k ) - ( & ( & ( u0 ( ip , j , k ) + u0 ( ip , jm , k )) * ( putin ( i , j , k ) + putin ( ip , j , k )) & - ( u0 ( i , j , k ) + u0 ( i , jm , k )) * ( putin ( i , j , k ) + putin ( im , j , k )) & ! d(uv)/dx ) * dxiq & + ( & ( v0 ( i , jp , k ) + v0 ( i , j , k )) * ( putin ( i , j , k ) + putin ( i , jp , k )) & - ( v0 ( i , jm , k ) + v0 ( i , j , k )) * ( putin ( i , j , k ) + putin ( i , jm , k )) & ! d(vv)/dy ) * dyiq & ) & - (( pres0 ( i , j , k ) - pres0 ( i , jm , k )) * dyi ) ! - dp/dy end do end do end do do j = jb , je jm = j - 1 jp = j + 1 do i = ib , ie im = i - 1 ip = i + 1 do k = kb , ke km = k - 1 kp = k + 1 putout ( i , j , k ) = putout ( i , j , k ) - ( & ( w0 ( i , j , kp ) + w0 ( i , jm , kp )) & * ( putin ( i , j , kp ) * dzf ( k ) + putin ( i , j , k ) * dzf ( kp )) * dzhi ( kp ) & - ( w0 ( i , j , k ) + w0 ( i , jm , k )) & * ( putin ( i , j , km ) * dzf ( k ) + putin ( i , j , k ) * dzf ( km )) * dzhi ( k ) & ) * 0.5 * dzfi5 ( k ) end do end do end do end subroutine advecv_2nd","tags":"","url":"proc/advecv_2nd.html"},{"title":"advecw_2nd – uDALES","text":"subroutine advecw_2nd(putin, putout) Uses modfields modglobal proc~~advecw_2nd~~UsesGraph proc~advecw_2nd advecw_2nd module~modfields modfields proc~advecw_2nd->module~modfields module~modglobal modglobal proc~advecw_2nd->module~modglobal decomp_2d decomp_2d module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(in), dimension(ib - ih:ie + ih, jb - jh:je + jh, kb - kh:ke + kh) :: putin real, intent(inout), dimension(ib - ih:ie + ih, jb - jh:je + jh, kb:ke + kh) :: putout Source Code subroutine advecw_2nd ( putin , putout ) use modglobal , only : ih , ib , ie , jh , jb , je , kb , ke , kh , dx , dxi , dxiq , dyiq , dzf , dzhi , dzhiq use modfields , only : u0 , v0 , w0 , pres0 ! use modmpi, only : myid implicit none real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ), intent ( in ) :: putin !< Input: the w-field real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ), intent ( inout ) :: putout !< Output: the tendency integer :: i , j , k , ip , im , jp , jm , kp , km do k = kb + 1 , ke km = k - 1 kp = k + 1 do j = jb , je jm = j - 1 jp = j + 1 do i = ib , ie im = i - 1 ip = i + 1 putout ( i , j , k ) = putout ( i , j , k ) - ( & ( & ( putin ( ip , j , k ) + putin ( i , j , k )) * ( dzf ( km ) * u0 ( ip , j , k ) + dzf ( k ) * u0 ( ip , j , km )) & - ( putin ( i , j , k ) + putin ( im , j , k )) * ( dzf ( km ) * u0 ( i , j , k ) + dzf ( k ) * u0 ( i , j , km )) & ) * dxiq * dzhi ( k ) & ! d(uw)/dx + ( & ( putin ( i , jp , k ) + putin ( i , j , k )) * ( dzf ( km ) * v0 ( i , jp , k ) + dzf ( k ) * v0 ( i , jp , km )) & - ( putin ( i , j , k ) + putin ( i , jm , k )) * ( dzf ( km ) * v0 ( i , j , k ) + dzf ( k ) * v0 ( i , j , km )) & ) * dyiq * dzhi ( k ) & ! d(vw)/dy + ( & ( putin ( i , j , k ) + putin ( i , j , kp )) * ( w0 ( i , j , k ) + w0 ( i , j , kp )) & - ( putin ( i , j , k ) + putin ( i , j , km )) * ( w0 ( i , j , k ) + w0 ( i , j , km )) & ) * dzhiq ( k ) & ! d(ww)/dz ) & - (( pres0 ( i , j , k ) - pres0 ( i , j , km )) * dzhi ( k )) ! - dp/dz end do end do end do end subroutine advecw_2nd","tags":"","url":"proc/advecw_2nd.html"},{"title":"advection – uDALES","text":"subroutine advection() Uses modfields decomp_2d modsubgriddata modglobal proc~~advection~~UsesGraph proc~advection advection decomp_2d decomp_2d proc~advection->decomp_2d module~modfields modfields proc~advection->module~modfields module~modglobal modglobal proc~advection->module~modglobal module~modsubgriddata modsubgriddata proc~advection->module~modsubgriddata module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~advection~~CallsGraph proc~advection advection advecc_2nd advecc_2nd proc~advection->advecc_2nd advecc_kappa advecc_kappa proc~advection->advecc_kappa advecc_upw advecc_upw proc~advection->advecc_upw advecu_2nd advecu_2nd proc~advection->advecu_2nd advecv_2nd advecv_2nd proc~advection->advecv_2nd advecw_2nd advecw_2nd proc~advection->advecw_2nd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine advection use modglobal , only : lmoist , nsv , iadv_mom , iadv_tke , iadv_thl , iadv_qt , iadv_sv , & iadv_cd2 , iadv_kappa , iadv_upw , & ltempeq , ih , jh , kh , ihc , jhc , khc , kb , ke , ib , ie , jb , je use modfields , only : u0 , up , v0 , vp , w0 , wp , e120 , e12p , thl0 , thl0c , thlp , thlpc , qt0 , qtp , sv0 , svp , pres0 , uh , vh , wh , pres0h use modsubgriddata , only : loneeqn use decomp_2d implicit none integer :: n select case ( iadv_mom ) case ( iadv_cd2 ) call advecu_2nd ( u0 , up ) call advecv_2nd ( v0 , vp ) call advecw_2nd ( w0 , wp ) case default write ( 0 , * ) \"ERROR: Unknown advection scheme\" stop 1 end select if ( loneeqn ) then select case ( iadv_tke ) case ( iadv_cd2 ) call advecc_2nd ( ih , jh , kh , e120 , e12p ) case default write ( 0 , * ) \"ERROR: Unknown advection scheme\" stop 1 end select end if select case ( iadv_thl ) case ( iadv_cd2 ) if ( ltempeq ) call advecc_2nd ( ih , jh , kh , thl0 , thlp ) case ( iadv_kappa ) thlpc ( ib : ie , jb : je , kb : ke ) = thlp ( ib : ie , jb : je , kb : ke ) if ( ltempeq ) call advecc_kappa ( ihc , jhc , khc , thl0c , thlpc ) thlp ( ib : ie , jb : je , kb : ke ) = thlpc ( ib : ie , jb : je , kb : ke ) case default write ( 0 , * ) \"ERROR: Unknown advection scheme\" stop 1 end select if ( lmoist ) then select case ( iadv_qt ) case ( iadv_cd2 ) call advecc_2nd ( ih , jh , kh , qt0 , qtp ) case default write ( 0 , * ) \"ERROR: Unknown advection scheme\" stop 1 end select end if do n = 1 , nsv select case ( iadv_sv ( n )) case ( iadv_cd2 ) call advecc_2nd ( ihc , jhc , khc , sv0 (:, :, :, n ), svp (:, :, :, n )) case ( iadv_kappa ) call advecc_kappa ( ihc , jhc , khc , sv0 (:, :, :, n ), svp (:, :, :, n )) case ( iadv_upw ) call advecc_upw ( ihc , jhc , khc , sv0 (:, :, :, n ), svp (:, :, :, n )) case default write ( 0 , * ) \"ERROR: Unknown advection scheme\" stop 1 end select end do end subroutine advection","tags":"","url":"proc/advection.html"},{"title":"rlim – uDALES","text":"function rlim(d1, d2) Uses modglobal proc~~rlim~~UsesGraph proc~rlim rlim module~modglobal modglobal proc~rlim->module~modglobal Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(in) :: d1 real, intent(in) :: d2 Return Value real Source Code real function rlim ( d1 , d2 ) use modglobal , only : eps1 implicit none real , intent ( in ) :: d1 !< Scalar flux at 1.5 cells upwind real , intent ( in ) :: d2 !< Scalar flux at 0.5 cells upwind real ri , phir ri = ( d2 + eps1 ) / ( d1 + eps1 ) phir = max ( 0. , min ( 2. * ri , min ( 1. / 3. + 2. / 3. * ri , 2. ))) rlim = 0.5 * phir * d1 end function rlim","tags":"","url":"proc/rlim.html"},{"title":"advecc_kappa – uDALES","text":"subroutine advecc_kappa(hi, hj, hk, var, varp) Uses modibmdata modfields modglobal proc~~advecc_kappa~~UsesGraph proc~advecc_kappa advecc_kappa module~modfields modfields proc~advecc_kappa->module~modfields module~modglobal modglobal proc~advecc_kappa->module~modglobal module~modibmdata modibmdata proc~advecc_kappa->module~modibmdata decomp_2d decomp_2d module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name integer, intent(in) :: hi integer, intent(in) :: hj integer, intent(in) :: hk real, intent(in), dimension(ib - hi:ie + hi, jb - hj:je + hj, kb - hk:ke + hk) :: var real, intent(inout), dimension(ib - hi:ie + hi, jb - hj:je + hj, kb:ke + hk) :: varp Calls proc~~advecc_kappa~~CallsGraph proc~advecc_kappa advecc_kappa rlim rlim proc~advecc_kappa->rlim Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine advecc_kappa ( hi , hj , hk , var , varp ) !  use modglobal, only : i1,i2,ih,j1,j2,jh,k1,kmax,dxi,dyi,dzi use modglobal , only : ib , ie , ihc , jb , je , jhc , kb , ke , khc , dxhci , dyi , dzhci , dxfc , dzfc , dxfci , dzfci , libm use modibmdata , only : nxwallsnorm , nywallsnorm , nzwallsnorm , xwallsnorm , & ywallsnorm , zwallsnorm , nywallsp , nywallsm , ywallsp , ywallsm use modfields , only : u0 , v0 , w0 implicit none real , external :: rlim integer , intent ( in ) :: hi !< size of halo in i integer , intent ( in ) :: hj !< size of halo in j integer , intent ( in ) :: hk !< size of halo in k real , dimension ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ), intent ( in ) :: var !< Input: the cell centered field real , dimension ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ), intent ( inout ) :: varp !< Output: the tendency real , dimension ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ) :: duml ! 3d dummy variable: lower cell side real , dimension ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ) :: dumu ! 3d dummy variable: upper cell side integer i , j , k , il , iu , jl , ju , kl , ku , n real :: cf , d1 , d2 dumu (:, :, :) = 0. duml (:, :, :) = 0. ! -d(uc)/dx (stretched grid) do k = kb , ke do j = jb , je do i = ib , ie + 1 if ( u0 ( i , j , k ) > 0 ) then d1 = ( var ( i - 1 , j , k ) - var ( i - 2 , j , k )) * dxhci ( i - 1 ) d2 = ( var ( i , j , k ) - var ( i - 1 , j , k )) * dxhci ( i ) cf = var ( i - 1 , j , k ) else d1 = ( var ( i , j , k ) - var ( i + 1 , j , k )) * dxhci ( i + 1 ) d2 = ( var ( i - 1 , j , k ) - var ( i , j , k )) * dxhci ( i ) cf = var ( i , j , k ) end if cf = cf + dxfc ( i ) * rlim ( d1 , d2 ) dumu ( i - 1 , j , k ) = - cf * u0 ( i , j , k ) * dxfci ( i - 1 ) !swapped the -1s here !tg3315 !now also swapped the signs... duml ( i , j , k ) = cf * u0 ( i , j , k ) * dxfci ( i ) end do end do end do varp (:,:,:) = varp (:,:,:) + dumu (:,:,:) + duml (:,:,:) dumu (:,:,:) = 0. duml (:,:,:) = 0. ! -d(vc)/dy (no stretched grid) do k = kb , ke do j = jb , je + 1 do i = ib , ie if ( v0 ( i , j , k ) > 0 ) then d1 = var ( i , j - 1 , k ) - var ( i , j - 2 , k ) d2 = var ( i , j , k ) - var ( i , j - 1 , k ) cf = var ( i , j - 1 , k ) else d1 = var ( i , j , k ) - var ( i , j + 1 , k ) d2 = var ( i , j - 1 , k ) - var ( i , j , k ) cf = var ( i , j , k ) end if cf = cf + rlim ( d1 , d2 ) duml ( i , j , k ) = cf * v0 ( i , j , k ) * dyi !tg3315 dumu ( i , j - 1 , k ) = - cf * v0 ( i , j , k ) * dyi end do end do end do varp (:,:,:) = varp (:,:,:) + dumu (:,:,:) + duml (:,:,:) dumu (:,:,:) = 0. duml (:,:,:) = 0. ! -d(wc)/dz (stretched grid) !  do k=kb,ke+1 do k = kb + 1 , ke + 1 do j = jb , je do i = ib , ie if ( w0 ( i , j , k ) > 0 ) then d1 = ( var ( i , j , k - 1 ) - var ( i , j , k - 2 )) * dzhci ( k - 1 ) d2 = ( var ( i , j , k ) - var ( i , j , k - 1 )) * dzhci ( k ) cf = var ( i , j , k - 1 ) else d1 = ( var ( i , j , k ) - var ( i , j , k + 1 )) * dzhci ( k + 1 ) d2 = ( var ( i , j , k - 1 ) - var ( i , j , k )) * dzhci ( k ) cf = var ( i , j , k ) end if cf = cf + dzfc ( k ) * rlim ( d1 , d2 ) duml ( i , j , k ) = cf * w0 ( i , j , k ) * dzfci ( k ) !tg3315 swapped dumu ( i , j , k - 1 ) = - cf * w0 ( i , j , k ) * dzfci ( k - 1 ) end do end do end do varp (:,:,:) = varp (:,:,:) + dumu (:,:,:) + duml (:,:,:) return end subroutine advecc_kappa","tags":"","url":"proc/advecc_kappa.html"},{"title":"tstep_update – uDALES","text":"subroutine tstep_update() Uses modfields modmpi modsubgriddata modglobal proc~~tstep_update~~UsesGraph proc~tstep_update tstep_update module~modfields modfields proc~tstep_update->module~modfields module~modglobal modglobal proc~tstep_update->module~modglobal module~modmpi modmpi proc~tstep_update->module~modmpi module~modsubgriddata modsubgriddata proc~tstep_update->module~modsubgriddata decomp_2d decomp_2d module~modfields->decomp_2d mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~tstep_update~~CallsGraph proc~tstep_update tstep_update mpi_allreduce mpi_allreduce proc~tstep_update->mpi_allreduce Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine tstep_update use modglobal , only : ib , ie , jb , je , rk3step , timee , runtime , dtmax , dt , ntimee , ntrun , courant , diffnr ,& kb , ke , dx , dxi , dx2i , dyi , dy2i , dzh , dt_lim , ladaptive , timeleft , dt , lwarmstart ,& dzh2i use modfields , only : um , vm , wm use modsubgriddata , only : ekm , ekh use modmpi , only : myid , comm3d , mpierr , mpi_max , my_real implicit none integer :: i , j , k , imin , kmin real , save :: courtot =- 1. , diffnrtot =- 1. real :: courtotl , courold , diffnrtotl , diffnrold !  logical,save  :: spinup=.true. logical , save :: spinup = . false . if ( lwarmstart ) spinup = . false . rk3step = mod ( rk3step , 3 ) + 1 if ( rk3step == 1 ) then ! Initialization if ( spinup ) then write ( 6 , * ) '!spinup!' if ( ladaptive ) then courold = courtot diffnrold = diffnrtot courtotl = 0. diffnrtotl = 0. do k = kb , ke do j = jb , je do i = ib , ie courtotl = max ( courtotl ,( abs ( um ( i , j , k )) * dxi + abs ( vm ( i , j , k )) * dyi + abs ( wm ( i , j , k )) / dzh ( k )) * dt ) !          diffnrtotl = max(diffnrtotl,  ekm(i,j,k)*(1/dzh(k)**2 + dxh2i(i) + dy2i)*dt ) diffnrtotl = max ( diffnrtotl , ekm ( i , j , k ) * ( dzh2i ( k ) + dx2i + dy2i ) * dt , & ekh ( i , j , k ) * ( dzh2i ( k ) + dx2i + dy2i ) * dt ) end do end do end do call MPI_ALLREDUCE ( courtotl , courtot , 1 , MY_REAL , MPI_MAX , comm3d , mpierr ) call MPI_ALLREDUCE ( diffnrtotl , diffnrtot , 1 , MY_REAL , MPI_MAX , comm3d , mpierr ) if ( diffnrold > 0 ) then dt = min ( dtmax , dt * courant / courtot , dt * diffnr / diffnrtot ) if (( abs ( courtot - courold ) / courold < 0.1 ) . and . ( abs ( diffnrtot - diffnrold ) / diffnrold < 0.1 )) then spinup = . false . end if end if dt = dt dt_lim = timeleft timee = timee + dt timeleft = timeleft - dt ntimee = ntimee + 1 ntrun = ntrun + 1 else dt = 2 * dt if ( dt >= dtmax ) then dt = dtmax spinup = . false . end if end if ! Normal time loop else !spinup = .false. if ( ladaptive ) then courtotl = 0. diffnrtotl = 1e-5 do k = kb , ke do j = jb , je do i = ib , ie courtotl = max ( courtotl ,( abs ( um ( i , j , k )) * dxi + abs ( vm ( i , j , k )) * dyi + abs ( wm ( i , j , k )) / dzh ( k )) * dt ) diffnrtotl = max ( diffnrtotl , ekm ( i , j , k ) * ( dzh2i ( k ) + dx2i + dy2i ) * dt ,& ekh ( i , j , k ) * ( dzh2i ( k ) + dx2i + dy2i ) * dt ) !          if (diffnrtotl ==  ekh(i,j,k)*(dzh2i(k) + dxh2i(i) + dy2i)*dt) then !           imin = i !           kmin = k !          end if end do end do end do !     write(6,*) 'Peclet criterion at proc,i,k = ', myid,imin,kmin call MPI_ALLREDUCE ( courtotl , courtot , 1 , MY_REAL , MPI_MAX , comm3d , mpierr ) call MPI_ALLREDUCE ( diffnrtotl , diffnrtot , 1 , MY_REAL , MPI_MAX , comm3d , mpierr ) if ( courtot <= 0 ) then write ( 6 , * ) 'courtot=0!' end if if ( diffnrtot <= 0 ) then write ( 6 , * ) 'diffnrtot=0!' end if dt = min ( dtmax , dt * courant / courtot , dt * diffnr / diffnrtot ) timeleft = timeleft - dt dt_lim = timeleft timee = timee + dt ntimee = ntimee + 1 ntrun = ntrun + 1 else dt = dtmax ntimee = ntimee + 1 ntrun = ntrun + 1 timee = timee + dt timeleft = timeleft - dt end if end if end if end subroutine tstep_update","tags":"","url":"proc/tstep_update.html"},{"title":"tstep_integrate – uDALES","text":"subroutine tstep_integrate() Uses modmpi modsubgriddata decomp_2d modpois modchem modinletdata modglobal modfields proc~~tstep_integrate~~UsesGraph proc~tstep_integrate tstep_integrate decomp_2d decomp_2d proc~tstep_integrate->decomp_2d modpois modpois proc~tstep_integrate->modpois module~modchem modchem proc~tstep_integrate->module~modchem module~modfields modfields proc~tstep_integrate->module~modfields module~modglobal modglobal proc~tstep_integrate->module~modglobal module~modinletdata modinletdata proc~tstep_integrate->module~modinletdata module~modmpi modmpi proc~tstep_integrate->module~modmpi module~modsubgriddata modsubgriddata proc~tstep_integrate->module~modsubgriddata module~modfields->decomp_2d mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~tstep_integrate~~CallsGraph proc~tstep_integrate tstep_integrate proc~chem chem proc~tstep_integrate->proc~chem Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine tstep_integrate use modglobal , only : ib , ie , jb , jgb , je , kb , ke , nsv , dt , rk3step , e12min , lmoist , timee , ntrun ,& linoutflow , iinletgen , ltempeq , idriver , BCtopm , BCtopm_pressure , BCxm_periodic , BCym_periodic , & dzf , dzhi , dzf , dxf , ifixuinf , thlsrc , lchem , ibrank , ierank , jerank , jbrank , BCxm , BCym , ihc , jhc , khc , dyi , dxfi , BCxT , BCxq , BCxs , BCyT , BCyq , BCys use modmpi , only : cmyid , myid , nprocs use modfields , only : u0 , um , up , v0 , vm , vp , w0 , wm , wp ,& thl0 , thlm , thlp , qt0 , qtm , qtp , e120 , e12m , e12p , sv0 , svm , svp , uouttot ,& wouttot , dpdxl , dgdt , momfluxb , tfluxb , qfluxb , thl0c use modinletdata , only : totalu , di_test , dr , thetar , thetai , displ , irecy , & dti_test , dtr , thetati , thetatr , q0 , lmoi , lmor , utaui , utaur ,& storetdriver , nstepread , nstepreaddriver , irecydriver use modsubgriddata , only : loneeqn , ekm , ekh use modchem , only : chem use decomp_2d , only : exchange_halo_z use modpois , only : pij , dpdztop implicit none integer i , j , k , n , m real rk3coef , rk3coefi rk3coef = dt / ( 4. - dble ( rk3step )) rk3coefi = 1. / rk3coef if ( ifixuinf == 2 ) then dpdxl (:) = dpdxl (:) + dgdt * rk3coef !    if(ltempeq) then !      thlsrc = thlsrc + thlsrcdt*rk3coef !    end if !    write(6,*) 'dpdx = ', dpdxl(kb) end if if ( loneeqn ) then do k = kb , ke do j = jb , je do i = ib , ie u0 ( i , j , k ) = um ( i , j , k ) + rk3coef * up ( i , j , k ) v0 ( i , j , k ) = vm ( i , j , k ) + rk3coef * vp ( i , j , k ) w0 ( i , j , k ) = wm ( i , j , k ) + rk3coef * wp ( i , j , k ) e120 ( i , j , k ) = e12m ( i , j , k ) + rk3coef * e12p ( i , j , k ) e120 ( i , j , k ) = max ( e12min , e120 ( i , j , k )) e12m ( i , j , k ) = max ( e12min , e12m ( i , j , k )) do n = 1 , nsv sv0 ( i , j , k , n ) = svm ( i , j , k , n ) + rk3coef * svp ( i , j , k , n ) enddo enddo enddo end do else do k = kb , ke do j = jb , je do i = ib , ie u0 ( i , j , k ) = um ( i , j , k ) + rk3coef * up ( i , j , k ) v0 ( i , j , k ) = vm ( i , j , k ) + rk3coef * vp ( i , j , k ) w0 ( i , j , k ) = wm ( i , j , k ) + rk3coef * wp ( i , j , k ) do n = 1 , nsv sv0 ( i , j , k , n ) = svm ( i , j , k , n ) + rk3coef * svp ( i , j , k , n ) enddo enddo enddo enddo end if if ( lchem . and . rk3coef == dt ) then call chem end if if ( ltempeq ) then do k = kb , ke do j = jb , je do i = ib , ie thl0 ( i , j , k ) = thlm ( i , j , k ) + rk3coef * thlp ( i , j , k ) enddo enddo enddo thl0c ( ib : ie , jb : je , kb : ke ) = thl0 ( ib : ie , jb : je , kb : ke ) end if if ( lmoist ) then do k = kb , ke do j = jb , je do i = ib , ie qt0 ( i , j , k ) = qtm ( i , j , k ) + rk3coef * qtp ( i , j , k ) enddo enddo enddo end if if (( BCxm . ne . BCxm_periodic ) . and . ierank ) then u0 ( ie + 1 , jb : je , kb : ke ) = um ( ie + 1 , jb : je , kb : ke ) + rk3coef * up ( ie + 1 , jb : je , kb : ke ) end if if (( BCym . ne . BCym_periodic ) . and . jerank ) then v0 ( ib : ie , je + 1 , kb : ke ) = vm ( ib : ie , je + 1 , kb : ke ) + rk3coef * vp ( ib : ie , je + 1 , kb : ke ) end if if ( BCtopm . eq . BCtopm_pressure ) then ! do i=ib,ie !   do j=jb,je !     ! w0(i,j,ke+1) = w0(i,j,ke) - dzhi(ke)*((u0(i+1,j,ke)-u0(i,j,ke))*dxfi(i) + & !     !                                       (v0(i,j+1,ke)-v0(i,j,ke))*dyi) !     ! if (myid ==0 .and. (i==32 .and. j==1)) write(*,*) rk3coefi*(w0(i,j,ke) - dzhi(ke)*((u0(i+1,j,ke)-u0(i,j,ke))*dxfi(i) + & !     ! (v0(i,j+1,ke)-v0(i,j,ke))*dyi) - wm(i,j,ke+1)), & !     ! dpdztop(i,j), & !     ! 2*pij(ke)*dzhi(ke+1) !     ! !     ! wp(i,j,ke+1) = rk3coefi*(w0(i,j,ke) - dzhi(ke)*((u0(i+1,j,ke)-u0(i,j,ke))*dxfi(i) + & !     !            (v0(i,j+1,ke)-v0(i,j,ke))*dyi) - wm(i,j,ke+1)) !     ! wp(i,j,ke+1) = 2*pij(ke)*dzhi(ke+1) !   end do ! end do w0 ( ib : ie , jb : je , ke + 1 ) = wm ( ib : ie , jb : je , ke + 1 ) + rk3coef * wp ( ib : ie , jb : je , ke + 1 ) end if !  Write some statistics to monitoring file if (( myid == 0 ) . and . ( rk3step == 3 )) then open ( unit = 11 , file = 'monitor' // cmyid // '.txt' , position = 'append' ) if ( iinletgen == 1 ) then write ( 11 , 3001 ) timee elseif ( idriver == 1 ) then write ( 11 , '(I4)' ) nstepreaddriver write ( 11 , 3001 ) timee , u0 ( irecydriver , 1 , 32 ) ! elseif (idriver == 2) then ! write(11, '(I4)') nstepreaddriver ! write(11, 3001) timee, storetdriver(nstepreaddriver), u0(irecydriver, 1, 32) else write ( 11 , 3001 ) timee end if 3001 format ( 13 ( 6e14 . 6 )) close ( 11 ) if ( ifixuinf == 2 ) then open ( unit = 11 , file = 'dpdx___.txt' , position = 'append' ) write ( 11 , 3002 ) timee , dpdxl ( kb ) 3002 format ( 13 ( 6e20 . 12 )) close ( 11 ) if ( ltempeq ) then open ( unit = 11 , file = 'thlsrc.txt' , position = 'append' ) write ( 11 , 3002 ) timee , thlsrc 3003 format ( 13 ( 6e20 . 12 )) close ( 11 ) end if end if endif up = 0. vp = 0. wp = 0. thlp = 0. svp = 0. e12p = 0. qtp = 0. if ( rk3step == 3 ) then um = u0 vm = v0 wm = w0 thlm = thl0 e12m = e120 svm = sv0 qtm = qt0 end if end subroutine tstep_integrate","tags":"","url":"proc/tstep_integrate.html"},{"title":"createscals – uDALES","text":"subroutine createscals() Uses modmpi modglobal proc~~createscals~~UsesGraph proc~createscals createscals module~modglobal modglobal proc~createscals->module~modglobal module~modmpi modmpi proc~createscals->module~modmpi mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~createscals~~CallsGraph proc~createscals createscals mpi_bcast mpi_bcast proc~createscals->mpi_bcast Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/createscals.html"},{"title":"scalsource – uDALES","text":"subroutine scalsource() Uses modfields modmpi modglobal proc~~scalsource~~UsesGraph proc~scalsource scalsource module~modfields modfields proc~scalsource->module~modfields module~modglobal modglobal proc~scalsource->module~modglobal module~modmpi modmpi proc~scalsource->module~modmpi decomp_2d decomp_2d module~modfields->decomp_2d mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Source Code subroutine scalsource use modglobal , only : pi , nsv , ib , ie , jb , je , kb , ke , ih , jh , kh , ihc , jhc , khc , xf , zf , xh , zh , dx , dy , imax , itot , jmax , jtot , lchem ,& xS , yS , zS , xSb , ySb , zSb , xSe , ySe , zSe , SS , sigS , lscasrc , lscasrcl , lscasrcr , libm , dxfi , dzfi , nscasrc , scasrcp , nscasrcl , scasrcl use modfields , only : svp , svpp use modmpi , only : myid , myidx , myidy , mpierr , MY_REAL , comm3d , MPI_SUM implicit none integer :: i , j , k , n , ns real :: dxi , dyi real :: ra2 = 0. real :: scalsum = 0. real :: scalsumt = 0. real :: px = 0. , py = 0. , pz = 0.0 , vx = 0. , vy = 0. , vz = 0. , lsx = 0. , lsy = 0. , lsz = 0. , dot_projection = 0. dxi = 1. / dx dyi = 1. / dy !  Input passive scalar point sources if ( lscasrc . AND . nsv . gt . 0 ) then do n = 1 , nsv do ns = 1 , nscasrc xS = scasrcp ( ns , 1 , n ) yS = scasrcp ( ns , 2 , n ) zS = scasrcp ( ns , 3 , n ) SS = scasrcp ( ns , 4 , n ) sigS = scasrcp ( ns , 5 , n ) do k = kb , ke do j = jb , je do i = ib , ie ra2 = (( i + myidx * imax - 0.5 ) * dx - xS ) ** 2 + (( j + myidy * jmax - 0.5 ) * dy - yS ) ** 2 + ( zf ( k ) - zS ) ** 2 if ( ra2 . LE . 9 * sigS ** 2 ) then svp ( i , j , k , n ) = svp ( i , j , k , n ) + dxi * dyi * dzfi ( k ) * SS * exp ( - ra2 / ( 2 * sigS ** 2 )) end if end do end do end do end do end do end if !lscasrc !  Input passive scalar line sources if ( lscasrcl . AND . nsv . gt . 0 ) then do n = 1 , nsv do ns = 1 , nscasrcl xSb = scasrcl ( ns , 1 , n ) ySb = scasrcl ( ns , 2 , n ) zSb = scasrcl ( ns , 3 , n ) xSe = scasrcl ( ns , 4 , n ) ySe = scasrcl ( ns , 5 , n ) zSe = scasrcl ( ns , 6 , n ) SS = scasrcl ( ns , 7 , n ) sigS = scasrcl ( ns , 8 , n ) lsx = xSe - xSb lsy = ySe - ySb lsz = zSe - zSb do k = kb , ke do j = jb , je do i = ib , ie px = ( i + myidx * imax - 0.5 ) * dx py = ( j + myidy * jmax - 0.5 ) * dy pz = zf ( k ) vx = px - xSb vy = py - ySb vz = pz - zSb dot_projection = ( vx * lsx + vy * lsy + vz * lsz ) / ( lsx * lsx + lsy * lsy + lsz * lsz ) if ( dot_projection < 0.0 ) then ra2 = ( px - xSb ) ** 2 + ( py - ySb ) ** 2 + ( pz - zSb ) ** 2 elseif ( dot_projection > 1.0 ) then ra2 = ( px - xSe ) ** 2 + ( py - ySe ) ** 2 + ( pz - zSe ) ** 2 else ra2 = ( px - ( xSb + dot_projection * lsx )) ** 2 + ( py - ( ySb + dot_projection * lsy )) ** 2 + ( pz - ( zSb + dot_projection * lsz )) ** 2 end if if ( ra2 . LE . 9 * sigS ** 2 ) then svp ( i , j , k , n ) = svp ( i , j , k , n ) + dxi * dyi * dzfi ( k ) * & sqrt ( 2.0 * pi ) * SS * sigS * exp ( - ra2 / ( 2 * sigS ** 2 )) * erf ( sqrt (( 9 * sigS ** 2 - ra2 ) / ( 2 * sigS ** 2 ))) end if end do end do end do end do end do end if !lscasrcl end subroutine scalsource","tags":"","url":"proc/scalsource.html"},{"title":"wfmneutral – uDALES","text":"subroutine wfmneutral(hi, hj, hk, iout1, iout2, iomomflux, utang1, utang2, z0, n, ind, wforient) Uses modmpi modsubgriddata initfac modibmdata modglobal proc~~wfmneutral~~UsesGraph proc~wfmneutral wfmneutral module~initfac initfac proc~wfmneutral->module~initfac module~modglobal modglobal proc~wfmneutral->module~modglobal module~modibmdata modibmdata proc~wfmneutral->module~modibmdata module~modmpi modmpi proc~wfmneutral->module~modmpi module~modsubgriddata modsubgriddata proc~wfmneutral->module~modsubgriddata module~initfac->module~modglobal module~initfac->module~modmpi mpi mpi module~initfac->mpi netcdf netcdf module~initfac->netcdf module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name integer, intent(in) :: hi integer, intent(in) :: hj integer, intent(in) :: hk real, intent(inout) :: iout1 (ib-hi:ie+hi,jb-hj:je+hj,kb:ke+hk) real, intent(inout) :: iout2 (ib-hi:ie+hi,jb-hj:je+hj,kb:ke+hk) real, intent(inout) :: iomomflux (ib-hi:ie+hi,jb-hj:je+hj,kb-hk:ke+hk) real, intent(in) :: utang1 (ib-hi:ie+hi,jb-hj:je+hj,kb-hk:ke+hk) real, intent(in) :: utang2 (ib-hi:ie+hi,jb-hj:je+hj,kb-hk:ke+hk) real, intent(in) :: z0 integer, intent(in) :: n integer, intent(in) :: ind integer, intent(in) :: wforient Source Code SUBROUTINE wfmneutral ( hi , hj , hk , iout1 , iout2 , iomomflux , utang1 , utang2 , z0 , n , ind , wforient ) !wfmneutral !wf for momentum under neutral conditions !calculating wall function for momentum assuming neutral conditions !follow approach in wfuno !fluxes in m2/s2 USE modglobal , ONLY : dzf , dzfi , dzh2i , dzhi , dzhiq , dy , dyi , dy2i , dyi5 , dxf , dxh , dxfi , dxhi , dxh2i , ib , ie , jb , je , kb , ke , fkar , jmax , rk3step , kmax , jge , jgb USE modsubgriddata , ONLY : ekh , ekm USE modmpi , ONLY : myid USE initfac , ONLY : block USE modibmdata INTEGER i , j , k , jl , ju , kl , ku , il , iu , km , im , jm , ip , jp , kp REAL :: bcmomflux = 0. !temp storage for momentum flux REAL :: ctm = 0. !momentum transfer coefficient REAL :: dummy = 0. !for debugging REAL :: delta = 0. !distance from wall REAL :: logdz2 = 0. !log(delta/z0)**2 REAL :: utang1Int !Interpolated 1st tangential velocity component needed for stability calculation (to T location) REAL :: utang2Int !Interpolated 2nd tangential velocity component needed for stability calculation (to T location) REAL :: fkar2 !fkar&#94;2, von Karman constant squared REAL :: emmo = 0. , epmo = 0. , epom = 0. , emom = 0. , eopm = 0. , eomm = 0. , empo = 0. REAL :: umin = 0.0001 !m&#94;2/s&#94;2 INTEGER , INTENT ( in ) :: hi !<size of halo in i INTEGER , INTENT ( in ) :: hj !<size of halo in j INTEGER , INTENT ( in ) :: hk !<size of halo in k REAL , INTENT ( inout ) :: iout1 ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ) !updated prognostic tangential velocity (component1) REAL , INTENT ( inout ) :: iout2 ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ) !updated prognostic tangential velocity (component2) REAL , INTENT ( inout ) :: iomomflux ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) !a field to save the momentum flux REAL , INTENT ( in ) :: z0 REAL , INTENT ( in ) :: utang1 ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) !tangential velocity field REAL , INTENT ( in ) :: utang2 ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) !second tangential velocity field INTEGER , INTENT ( in ) :: n ! number of the block, used to get i,j,k-indeces INTEGER , INTENT ( in ) :: ind ! in case of y-wall (case 3x & 4x) \"ind\" is used for j-index, otherwise this is irrelevant INTEGER , INTENT ( in ) :: wforient !orientation of the facet see below: !frist digit, orientation of wall, determines iteration indices !second digit, if for momentum or for scalar (necessary because of staggered grid -> which variable to interpolate) !xlow=1,xup=2,yup=3,ylow=4,z=5 !momentum=1 fkar2 = fkar ** 2 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!CASES!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!CASES FOR MOMENTUM!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! SELECT CASE ( wforient ) !!!!!!!!!!!!!!!SPECIAL CASES FOR THE SURFACE!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !can actually be made redundant and just be replaced by standard horizontal case (doesn't really matter though) ! SO: This code is essentially unchanged from uDALES v1, and should probably be moved out of this file in a later release. CASE ( 91 ) !surface momentum flux k = kb ! km = k - 1 ! il = ib iu = ie jl = jb ju = je delta = 0.5 * dzf ( k ) !might need attention on streched grids! as well as the dzfi when updating up logdz2 = LOG ( delta / z0 ) ** 2 DO j = jl , ju !u component DO i = il , iu utang1Int = utang1 ( i , j , k ) utang2Int = ( utang2 ( i , j , k ) + utang2 ( i - 1 , j , k ) + utang2 ( i , j + 1 , k ) + utang2 ( i - 1 , j + 1 , k )) * 0.25 utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) ctm = fkar2 / ( logdz2 ) !dummy = (utang1Int**2)*ctm dummy = abs ( utang1Int ) * sqrt ( utangInt ) * ctm bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dzfi ( k ) emom = ( dzf ( km ) * ( ekm ( i , j , k ) * dxf ( i - 1 ) + ekm ( i - 1 , j , k ) * dxf ( i )) + & ! dx is non-equidistant dzf ( k ) * ( ekm ( i , j , km ) * dxf ( i - 1 ) + ekm ( i - 1 , j , km ) * dxf ( i ))) * dxhi ( i ) * dzhiq ( k ) iout1 ( i , j , k ) = iout1 ( i , j , k ) + ( utang1 ( i , j , k ) - utang1 ( i , j , km )) * emom * dzhi ( k ) * dzfi ( k ) - bcmomflux * dzfi ( k ) ! END DO END DO DO j = jl , ju !v component DO i = il , iu utang1Int = ( utang1 ( i , j , k ) + utang1 ( i , j - 1 , k ) + utang1 ( i + 1 , j - 1 , k ) + utang1 ( i + 1 , j , k )) * 0.25 utang2Int = utang2 ( i , j , k ) utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) ctm = fkar2 / ( logdz2 ) !dummy = (utang2Int**2)*ctm dummy = abs ( utang2Int ) * sqrt ( utangInt ) * ctm bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dzfi ( k ) eomm = ( dzf ( km ) * ( ekm ( i , j , k ) + ekm ( i , j - 1 , k )) + dzf ( k ) * ( ekm ( i , j , km ) + ekm ( i , j - 1 , km ))) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) + ( utang2 ( i , j , k ) - utang2 ( i , j , km )) * eomm * dzhi ( k ) * dzfi ( k ) - bcmomflux * dzfi ( k ) ! END DO END DO END SELECT END SUBROUTINE wfmneutral","tags":"","url":"proc/wfmneutral.html"},{"title":"advecc_upw – uDALES","text":"subroutine advecc_upw(hi, hj, hk, putin, putout) Uses modfields modglobal proc~~advecc_upw~~UsesGraph proc~advecc_upw advecc_upw module~modfields modfields proc~advecc_upw->module~modfields module~modglobal modglobal proc~advecc_upw->module~modglobal decomp_2d decomp_2d module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name integer, intent(in) :: hi integer, intent(in) :: hj integer, intent(in) :: hk real, intent(in), dimension(ib - hi:ie + hi, jb - hj:je + hj, kb - hk:ke + hk) :: putin real, intent(inout), dimension(ib - hi:ie + hi, jb - hj:je + hj, kb:ke + hk) :: putout Source Code subroutine advecc_upw ( hi , hj , hk , putin , putout ) use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , dyi , dxfci , dzfci use modfields , only : u0 , v0 , w0 implicit none integer , intent ( in ) :: hi !< size of halo in i integer , intent ( in ) :: hj !< size of halo in j integer , intent ( in ) :: hk !< size of halo in k real , dimension ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ), intent ( in ) :: putin !< Input: the cell centered field real , dimension ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ), intent ( inout ) :: putout !< Output: the tendency real , allocatable , dimension (:, :, :) :: put integer :: i , j , k allocate ( put ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk )) do k = kb , ke do j = jb , je do i = ib , ie + 1 if ( u0 ( i , j , k ) > 0 ) then put ( i , j , k ) = putin ( i - 1 , j , k ) else put ( i , j , k ) = putin ( i , j , k ) endif enddo enddo enddo do k = kb , ke do j = jb , je do i = ib , ie putout ( i , j , k ) = putout ( i , j , k ) - & ( u0 ( i + 1 , j , k ) * put ( i + 1 , j , k ) - u0 ( i , j , k ) * put ( i , j , k )) * dxfci ( i ) enddo enddo enddo do k = kb , ke do j = jb , je + 1 do i = ib , ie if ( v0 ( i , j , k ) > 0 ) then put ( i , j , k ) = putin ( i , j - 1 , k ) else put ( i , j , k ) = putin ( i , j , k ) endif enddo enddo enddo do k = kb , ke do j = jb , je do i = ib , ie putout ( i , j , k ) = putout ( i , j , k ) - & ( v0 ( i , j + 1 , k ) * put ( i , j + 1 , k ) - v0 ( i , j , k ) * put ( i , j , k )) * dyi enddo enddo enddo do k = kb , ke + 1 do j = jb , je do i = ib , ie if ( w0 ( i , j , k ) > 0 ) then put ( i , j , k ) = putin ( i , j , k - 1 ) else put ( i , j , k ) = putin ( i , j , k ) endif enddo enddo enddo do k = kb , ke do j = jb , je do i = ib , ie putout ( i , j , k ) = putout ( i , j , k ) - & ( w0 ( i , j , k + 1 ) * put ( i , j , k + 1 ) - w0 ( i , j , k ) * put ( i , j , k )) * dzfci ( k ) enddo enddo enddo deallocate ( put ) end subroutine advecc_upw","tags":"","url":"proc/advecc_upw.html"},{"title":"wfGR – uDALES","text":"subroutine wfGR(hi, hj, hk, ioq, ioqflux, icth, obcqfluxA, qcell, qwall, hurel, resc, ress, n, ind, wforient) Uses modmpi modsubgriddata initfac modibmdata modglobal proc~~wfgr~~UsesGraph proc~wfgr wfGR module~initfac initfac proc~wfgr->module~initfac module~modglobal modglobal proc~wfgr->module~modglobal module~modibmdata modibmdata proc~wfgr->module~modibmdata module~modmpi modmpi proc~wfgr->module~modmpi module~modsubgriddata modsubgriddata proc~wfgr->module~modsubgriddata module~initfac->module~modglobal module~initfac->module~modmpi mpi mpi module~initfac->mpi netcdf netcdf module~initfac->netcdf module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name integer, intent(in) :: hi integer, intent(in) :: hj integer, intent(in) :: hk real, intent(inout) :: ioq (ib-hi:ie+hi,jb-hj:je+hj,kb:ke+hk) real, intent(inout) :: ioqflux (ib-hi:ie+hi,jb-hj:je+hj,kb-hk:ke+hk) real, intent(in) :: icth (ib-hi:ie+hi,jb-hj:je+hj,kb-hk:ke+hk) real, intent(out) :: obcqfluxA real, intent(in) :: qcell (ib-hi:ie+hi,jb-hj:je+hj,kb-hk:ke+hk) real, intent(in) :: qwall real, intent(in) :: hurel real, intent(in) :: resc real, intent(in) :: ress integer, intent(in) :: n integer, intent(in) :: ind integer, intent(in) :: wforient Source Code SUBROUTINE wfGR ( hi , hj , hk , ioq , ioqflux , icth , obcqfluxA , qcell , qwall , hurel , resc , ress , n , ind , wforient ) !wfGR USE modglobal , ONLY : dzf , dzfi , dzh2i , dzhi , dzhiq , dy , dyi , dy2i , dyi5 , dxf , dxh , dxfi , dxhi , dxh2i , ib , ie , jb , je , kb , ke , fkar , grav , jmax , rk3step USE modsubgriddata , ONLY : ekh USE modmpi , ONLY : myid USE initfac , ONLY : block USE modibmdata INTEGER i , j , k , jl , ju , kl , ku , il , iu , km , im , jm , ip , jp , kp REAL :: bcqflux = 0. !temp storage for temperature flux REAL :: bcmomflux = 0. !temp storage for momentum flux REAL :: dummy = 0. !for debugging REAL :: delta = 0. !distance from wall REAL :: fkar2 !fkar&#94;2, von Karman constant squared REAL :: emmo = 0. , epmo = 0. , epom = 0. , emom = 0. , eopm = 0. , eomm = 0. , empo = 0. REAL :: umin = 0.0001 !m&#94;2/s&#94;2 REAL :: cveg = 0.8 !hardcoded for now, !fraction of GR covered in vegetation, should be made into a proper model parameter (-> modglobal) INTEGER , INTENT ( in ) :: hi !<size of halo in i INTEGER , INTENT ( in ) :: hj !<size of halo in j INTEGER , INTENT ( in ) :: hk !<size of halo in k REAL , INTENT ( out ) :: obcqfluxA ; !temperature flux of entire wall facet (double sum over indeces) [Km/s] REAL , INTENT ( inout ) :: ioq ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ) !updated prognostic temperature REAL , INTENT ( inout ) :: ioqflux ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) !a field to save the momentum flux REAL , INTENT ( in ) :: icth ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) ; !heat transfer coefficient, used to calculate moisture flux REAL , INTENT ( in ) :: qcell ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) !Temperature of fluid cell !       real, intent(in)    :: Troof(ib:ie,jb:je,kb:ke)  !Temperature of horizontal surfaces (also includes roads) REAL , INTENT ( in ) :: qwall REAL , INTENT ( in ) :: hurel REAL , INTENT ( in ) :: resc REAL , INTENT ( in ) :: ress INTEGER , INTENT ( in ) :: n ! number of the block, used to get i,j,k-indeces INTEGER , INTENT ( in ) :: ind ! in case of y-wall (case 3x & 4x) \"ind\" is used for j-index, otherwise this is irrelevant INTEGER , INTENT ( in ) :: wforient !frist digit, orientation of wall, determines iteration idices and if Twall or Troof is used obcqfluxA = 0. fkar2 = fkar ** 2 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!CASES!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!CASES FOR SCALARS!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! SELECT CASE ( wforient ) CASE ( 12 ) !wall in yz -> wf in x (=vertical), lower wall, west wall i = block ( n , 1 ) - 1 !wall property and fluid index ip = i + 1 !index to remove subgrid flux jl = MAX ( block ( n , 3 ) - myid * jmax , 1 ) ! starting j-index ju = MIN ( block ( n , 4 ) - myid * jmax , jmax ) ! ending j-index kl = block ( n , 5 ) ! starting k-index ku = block ( n , 6 ) ! ending k-index delta = dxf ( i ) * 0.5 ! DO k = kl , ku DO j = jl , ju bcqflux = min ( 0. , cveg * ( qcell ( i , j , k ) - qwall ) * 1 / ( 1 / icth ( i , j , k ) + resc ) + ( 1 - cveg ) * ( qcell ( i , j , k ) - qwall * hurel ) * 1 / ( 1 / icth ( i , j , k ) + ress )) obcqfluxA = obcqfluxA + bcqflux ioqflux ( i , j , k ) = ioqflux ( i , j , k ) + bcqflux * dxfi ( i ) ioq ( i , j , k ) = ioq ( i , j , k ) - 0.5 * ( ekh ( ip , j , k ) * dxf ( i ) + ekh ( i , j , k ) * dxf ( ip )) * ( qcell ( ip , j , k ) - qcell ( i , j , k )) * dxh2i ( ip ) * dxfi ( i ) - bcqflux * dxfi ( i ) ! END DO END DO !!! case 22 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! CASE ( 22 ) i = block ( n , 2 ) + 1 ! im = i - 1 ! jl = MAX ( block ( n , 3 ) - myid * jmax , 1 ) ! starting j-index ju = MIN ( block ( n , 4 ) - myid * jmax , jmax ) ! ending j-index kl = block ( n , 5 ) ! starting k-index ku = block ( n , 6 ) ! ending k-index delta = dxh ( i ) * 0.5 DO k = kl , ku DO j = jl , ju !dq * 1/res, where res is in [s/m] bcqflux = min ( 0. , cveg * ( qcell ( i , j , k ) - qwall ) * 1 / ( 1 / icth ( i , j , k ) + resc ) + ( 1 - cveg ) * ( qcell ( i , j , k ) - qwall * hurel ) * 1 / ( 1 / icth ( i , j , k ) + ress )) obcqfluxA = obcqfluxA + bcqflux ioqflux ( i , j , k ) = ioqflux ( i , j , k ) + bcqflux * dxfi ( i ) ioq ( i , j , k ) = ioq ( i , j , k ) + 0.5 * ( ekh ( i , j , k ) * dxf ( im ) + ekh ( im , j , k ) * dxf ( i )) * ( qcell ( i , j , k ) - qcell ( im , j , k )) * dxh2i ( i ) * dxfi ( i ) - bcqflux * dxfi ( i ) END DO END DO !!! case 32 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! CASE ( 32 ) !wall in xz -> wf in y (=vertical) upper, north wall j = ind jm = j - 1 il = block ( n , 1 ) iu = block ( n , 2 ) kl = block ( n , 5 ) ku = block ( n , 6 ) DO k = kl , ku DO i = il , iu bcqflux = min ( 0. , cveg * ( qcell ( i , j , k ) - qwall ) * 1 / ( 1 / icth ( i , j , k ) + resc ) + ( 1 - cveg ) * ( qcell ( i , j , k ) - qwall * hurel ) * 1 / ( 1 / icth ( i , j , k ) + ress )) obcqfluxA = obcqfluxA + bcqflux ioqflux ( i , j , k ) = ioqflux ( i , j , k ) + bcqflux * dyi ioq ( i , j , k ) = ioq ( i , j , k ) + ( & 0.5 * ( ekh ( i , j , k ) + ekh ( i , jm , k )) * ( qcell ( i , j , k ) - qcell ( i , jm , k ))) * dy2i & - bcqflux * dyi END DO END DO !!! case 42 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! CASE ( 42 ) !wall in xz -> wf in y (=vertical) lower, south wall j = ind jp = j + 1 il = block ( n , 1 ) iu = block ( n , 2 ) kl = block ( n , 5 ) ku = block ( n , 6 ) DO k = kl , ku DO i = il , iu bcqflux = min ( 0. , cveg * ( qcell ( i , j , k ) - qwall ) * 1 / ( 1 / icth ( i , j , k ) + resc ) + ( 1 - cveg ) * ( qcell ( i , j , k ) - qwall * hurel ) * 1 / ( 1 / icth ( i , j , k ) + ress )) obcqfluxA = obcqfluxA + bcqflux ioqflux ( i , j , k ) = ioqflux ( i , j , k ) + bcqflux * dyi ioq ( i , j , k ) = ioq ( i , j , k ) - & 0.5 * ( ekh ( i , jp , k ) + ekh ( i , j , k )) * ( qcell ( i , jp , k ) - qcell ( i , j , k )) * dy2i & - bcqflux * dyi END DO END DO !!! case 52 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! CASE ( 52 ) !wall in xy -> wf in z (=horizontal), top wall k = block ( n , 6 ) + 1 !block location km = k - 1 ! il = block ( n , 1 ) iu = block ( n , 2 ) jl = MAX ( block ( n , 3 ) - myid * jmax , 1 ) ju = MIN ( block ( n , 4 ) - myid * jmax , jmax ) delta = dzf ( k ) * 0.5 DO j = jl , ju DO i = il , iu bcqflux = min ( 0. , cveg * ( qcell ( i , j , k ) - qwall ) * 1 / ( 1 / icth ( i , j , k ) + resc ) + ( 1 - cveg ) * ( qcell ( i , j , k ) - qwall * hurel ) * 1 / ( 1 / icth ( i , j , k ) + ress )) obcqfluxA = obcqfluxA + bcqflux ioqflux ( i , j , k ) = ioqflux ( i , j , k ) + bcqflux * dzfi ( k ) ioq ( i , j , k ) = ioq ( i , j , k ) & + 0.5 * ( dzf ( km ) * ekh ( i , j , k ) + dzf ( k ) * ekh ( i , j , km )) * ( qcell ( i , j , k ) - qcell ( i , j , km )) * dzh2i ( k ) * dzfi ( k ) & - bcqflux * dzfi ( k ) END DO END DO END SELECT END SUBROUTINE wfGR","tags":"","url":"proc/wfgr.html"},{"title":"unom – uDALES","text":"function unom(logdz, logdzh, logzh, sqdz, utangInt, dT, Ribl0, fkar2) Uses modglobal proc~~unom~~UsesGraph proc~unom unom module~modglobal modglobal proc~unom->module~modglobal Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(in) :: logdz real, intent(in) :: logdzh real, intent(in) :: logzh real, intent(in) :: sqdz real, intent(in) :: utangInt real, intent(in) :: dT real, intent(in) :: Ribl0 real, intent(in) :: fkar2 Return Value real Source Code REAL FUNCTION unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !for momentum, this bit is not depended on orientation etc use modglobal , only : prandtlturb !momentum flux in m2/s2 !dT,utang and logdzh are unused and could be removed IMPLICIT NONE REAL , INTENT ( in ) :: logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 REAL :: Ribl1 , Fm , Fh , cm , ch , Ctm , M REAL , PARAMETER :: b1 = 9.4 !parameters from Uno1995 REAL , PARAMETER :: b2 = 4.7 REAL , PARAMETER :: dm = 7.4 REAL , PARAMETER :: dh = 5.3 !REAL, PARAMETER :: prandtlmol = 0.71 IF ( Ribl0 > 0. ) THEN !0.25 approx critical for bulk Richardson number  => stable Fm = 1. / ( 1. + b2 * Ribl0 ) ** 2 !Eq. 4 Fh = Fm !Eq. 4 ELSE ! => unstable cm = ( dm * fkar2 ) / ( logdz ** 2 ) * b1 * sqdz !Eq. 5 ch = ( dh * fkar2 ) / ( logdz ** 2 ) * b1 * sqdz !Eq. 5 Fm = 1. - ( b1 * Ribl0 ) / ( 1. + cm * SQRT ( ABS ( Ribl0 ))) !Eq. 3 Fh = 1. - ( b1 * Ribl0 ) / ( 1. + ch * SQRT ( ABS ( Ribl0 ))) !Eq. 3 END IF M = prandtlturb * logdz * SQRT ( Fm ) / Fh !Eq. 14 Ribl1 = Ribl0 - Ribl0 * prandtlturb * logzh / ( prandtlturb * logzh + M ) !Eq. 17 !interate to get new Richardson number IF ( Ribl1 > 0. ) THEN !0.25 approx critical for bulk Richardson number  => stable Fm = 1. / ( 1. + b2 * Ribl1 ) ** 2 !Eq. 4 ELSE ! => unstable cm = ( dm * fkar2 ) / ( logdz ** 2 ) * b1 * sqdz !Eq. 5 Fm = 1. - ( b1 * Ribl1 ) / ( 1. + cm * SQRT ( ABS ( Ribl1 ))) !Eq. 3 END IF Ctm = fkar2 / ( logdz ** 2 ) * Fm !Eq. 7 unom = Ctm !Eq. 2, Eq. 8 END FUNCTION unom","tags":"","url":"proc/unom.html"},{"title":"wfuno – uDALES","text":"subroutine wfuno(hi, hj, hk, iout1, iout2, iot, iomomflux, iotflux, iocth, obcTfluxA, utang1, utang2, Tcell, Twall, z0, z0h, n, ind, wforient) Uses modmpi modsubgriddata initfac modibmdata modglobal proc~~wfuno~~UsesGraph proc~wfuno wfuno module~initfac initfac proc~wfuno->module~initfac module~modglobal modglobal proc~wfuno->module~modglobal module~modibmdata modibmdata proc~wfuno->module~modibmdata module~modmpi modmpi proc~wfuno->module~modmpi module~modsubgriddata modsubgriddata proc~wfuno->module~modsubgriddata module~initfac->module~modglobal module~initfac->module~modmpi mpi mpi module~initfac->mpi netcdf netcdf module~initfac->netcdf module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name integer, intent(in) :: hi integer, intent(in) :: hj integer, intent(in) :: hk real, intent(inout) :: iout1 (ib-hi:ie+hi,jb-hj:je+hj,kb:ke+hk) real, intent(inout) :: iout2 (ib-hi:ie+hi,jb-hj:je+hj,kb:ke+hk) real, intent(inout) :: iot (ib-hi:ie+hi,jb-hj:je+hj,kb:ke+hk) real, intent(inout) :: iomomflux (ib-hi:ie+hi,jb-hj:je+hj,kb-hk:ke+hk) real, intent(inout) :: iotflux (ib-hi:ie+hi,jb-hj:je+hj,kb-hk:ke+hk) real, intent(inout) :: iocth (ib-hi:ie+hi,jb-hj:je+hj,kb-hk:ke+hk) real, intent(out) :: obcTfluxA real, intent(in) :: utang1 (ib-hi:ie+hi,jb-hj:je+hj,kb-hk:ke+hk) real, intent(in) :: utang2 (ib-hi:ie+hi,jb-hj:je+hj,kb-hk:ke+hk) real, intent(in) :: Tcell (ib-hi:ie+hi,jb-hj:je+hj,kb-hk:ke+hk) real, intent(in) :: Twall real, intent(in) :: z0 real, intent(in) :: z0h integer, intent(in) :: n integer, intent(in) :: ind integer, intent(in) :: wforient Calls proc~~wfuno~~CallsGraph proc~wfuno wfuno unoh unoh proc~wfuno->unoh Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code SUBROUTINE wfuno ( hi , hj , hk , iout1 , iout2 , iot , iomomflux , iotflux , iocth , obcTfluxA , utang1 , utang2 , Tcell , Twall , z0 , z0h , n , ind , wforient ) !wfuno !calculating wall function for momentum and scalars following Cai2012&Uno1995, extension of Louis 1979 method to rough walls !fluxes in m2/s2 and Km/s USE modglobal , ONLY : dzf , dzfi , dzh2i , dzhi , dzhiq , dy , dyi , dy2i , dyi5 , dxf , dxh , dxfi , dxhi , dxh2i , ib , ie , jb , je , kb , ke , fkar , grav , jmax , rk3step , kmax , jge , jgb USE modsubgriddata , ONLY : ekh , ekm USE modmpi , ONLY : myid USE initfac , ONLY : block USE modibmdata REAL , EXTERNAL :: unom INTEGER i , j , k , jl , ju , kl , ku , il , iu , km , im , jm , ip , jp , kp REAL :: Ribl0 = 0. !initial guess of Ribl based on Ts REAL :: bcTflux = 0. !temp storage for temperature flux REAL :: bcmomflux = 0. !temp storage for momentum flux REAL :: ctm = 0. !momentum transfer coefficient REAL :: cth = 0. !heat transfer coefficient REAL :: dummy = 0. !for debugging REAL :: delta = 0. !distance from wall REAL :: logdz = 0. !log(delta/z0) REAL :: logdzh = 0. !log(delta/z0h) REAL :: logzh = 0. !log(z0/z0h) REAL :: sqdz = 0. !sqrt(delta/z0) REAL :: utang1Int !Interpolated 1st tangential velocity component needed for stability calculation (to T location) REAL :: utang2Int !Interpolated 2nd tangential velocity component needed for stability calculation (to T location) REAL :: utangInt !Interpolated absolute tangential velocity REAL :: dT !Temperature difference between wall and cell REAL :: fkar2 !fkar&#94;2, von Karman constant squared REAL :: emmo = 0. , epmo = 0. , epom = 0. , emom = 0. , eopm = 0. , eomm = 0. , empo = 0. REAL :: umin = 0.0001 !m&#94;2/s&#94;2 INTEGER , INTENT ( in ) :: hi !<size of halo in i INTEGER , INTENT ( in ) :: hj !<size of halo in j INTEGER , INTENT ( in ) :: hk !<size of halo in k REAL , INTENT ( out ) :: obcTfluxA !temperature flux of entire wall facet (double sum over indeces) [Km/s] REAL , INTENT ( inout ) :: iout1 ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ) !updated prognostic tangential velocity (component1) REAL , INTENT ( inout ) :: iout2 ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ) !updated prognostic tangential velocity (component2) REAL , INTENT ( inout ) :: iot ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ) !updated prognostic temperature REAL , INTENT ( inout ) :: iomomflux ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) !a field to save the momentum flux REAL , INTENT ( inout ) :: iotflux ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) !a field to save the heat flux REAL , INTENT ( inout ) :: iocth ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) !heat transfer coefficient, used to calculate moisture flux REAL , INTENT ( in ) :: Tcell ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) !Temperature of fluid cell REAL , INTENT ( in ) :: Twall !Temperature of surfaces !SINCE EVERY WALL HAS PRECISELY ONE TEMPERATURE (at the outside). CAREFUL IF THIS EVER CHANGES (i.e. multiple EB facets per wall) REAL , INTENT ( in ) :: z0 REAL , INTENT ( in ) :: z0h REAL , INTENT ( in ) :: utang1 ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) !tangential velocity field REAL , INTENT ( in ) :: utang2 ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) !second tangential velocity field INTEGER , INTENT ( in ) :: n ! number of the block, used to get i,j,k-indeces INTEGER , INTENT ( in ) :: ind ! in case of y-wall (case 3x & 4x) \"ind\" is used for j-index, otherwise this is irrelevant INTEGER , INTENT ( in ) :: wforient !orientation of the facet see below: !frist digit, orientation of wall, determines iteration indices !second digit, if for momentum or for scalar (necessary because of staggered grid -> which variable to interpolate) !xlow=1,xup=2,yup=3,ylow=4,z=5 !momentum=1,scalar=2 fkar2 = fkar ** 2 obcTfluxA = 0. !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!CASES!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!CASES FOR SCALARS!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! SELECT CASE ( wforient ) !!!!!!!!!!!!!!!SPECIAL CASES FOR THE SURFACE!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !can actually be made redundant and just be replaced by standard horizontal case (doesn't really matter though) ! SO: This code is essentially unchanged from uDALES v1, and should probably be moved out of this file in a later release. CASE ( 91 ) !surface momentum flux k = kb ! km = k - 1 ! il = ib iu = ie jl = jb ju = je delta = 0.5 * dzf ( k ) !might need attention on streched grids! as well as the dzfi when updating up logdz = LOG ( delta / z0 ) logdzh = LOG ( delta / z0h ) logzh = LOG ( z0 / z0h ) sqdz = SQRT ( delta / z0 ) DO j = jl , ju !u component DO i = il , iu utang1Int = utang1 ( i , j , k ) utang2Int = ( utang2 ( i , j , k ) + utang2 ( i - 1 , j , k ) + utang2 ( i , j + 1 , k ) + utang2 ( i - 1 , j + 1 , k )) * 0.25 utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = (( Tcell ( i , j , k ) + Tcell ( i - 1 , j , k )) - ( Twall + Twall )) * 0.5 Ribl0 = grav * delta * dT * 2 / (( Twall + Twall ) * utangInt ) !Eq. 6, guess initial Ri ctm = unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field !dummy = (utang1Int**2)*ctm dummy = abs ( utang1Int ) * sqrt ( utangInt ) * ctm bcmomflux = SIGN ( dummy , utang1Int ) !bcmomflux=u_star&#94;2 iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dzfi ( k ) emom = ( dzf ( km ) * ( ekm ( i , j , k ) * dxf ( i - 1 ) + ekm ( i - 1 , j , k ) * dxf ( i )) + & ! dx is non-equidistant dzf ( k ) * ( ekm ( i , j , km ) * dxf ( i - 1 ) + ekm ( i - 1 , j , km ) * dxf ( i ))) * dxhi ( i ) * dzhiq ( k ) iout1 ( i , j , k ) = iout1 ( i , j , k ) + ( utang1 ( i , j , k ) - utang1 ( i , j , km )) * emom * dzhi ( k ) * dzfi ( k ) - bcmomflux * dzfi ( k ) ! END DO END DO DO j = jl , ju DO i = il , iu utang1Int = ( utang1 ( i , j , k ) + utang1 ( i , j - 1 , k ) + utang1 ( i + 1 , j - 1 , k ) + utang1 ( i + 1 , j , k )) * 0.25 utang2Int = utang2 ( i , j , k ) utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = (( Tcell ( i , j , k ) + Tcell ( i , j - 1 , k )) - ( Twall + Twall )) * 0.5 Ribl0 = grav * delta * dT * 2 / (( Twall + Twall ) * utangInt ) !Eq. 6, guess initial Ri ctm = unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field !dummy = (utang2Int**2)*ctm !save result and update field dummy = abs ( utang2Int ) * sqrt ( utangInt ) * ctm bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dzfi ( k ) eomm = ( dzf ( km ) * ( ekm ( i , j , k ) + ekm ( i , j - 1 , k )) + dzf ( k ) * ( ekm ( i , j , km ) + ekm ( i , j - 1 , km ))) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) + ( utang2 ( i , j , k ) - utang2 ( i , j , km )) * eomm * dzhi ( k ) * dzfi ( k ) - bcmomflux * dzfi ( k ) ! END DO END DO !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! CASE ( 92 ) !surface temperature flux k = kb !block location ku = k !shear velocity location il = ib iu = ie jl = jb ju = je delta = dzf ( k ) * 0.5 logdz = LOG ( delta / z0 ) logdzh = LOG ( delta / z0h ) logzh = LOG ( z0 / z0h ) sqdz = SQRT ( delta / z0 ) DO j = jl , ju DO i = il , iu utang1Int = ( utang1 ( i , j , ku ) + utang1 ( i + 1 , j , ku )) * 0.5 utang2Int = ( utang2 ( i , j , ku ) + utang2 ( i , j + 1 , ku )) * 0.5 utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = ( Tcell ( i , j , ku ) - Twall ) Ribl0 = grav * delta * dT / ( Twall * utangInt ) ! call unoh ( bcTflux , cth , logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) obcTfluxA = obcTfluxA + bcTflux iotflux ( i , j , k ) = iotflux ( i , j , k ) + bcTflux * dzfi ( k ) iot ( i , j , ku ) = iot ( i , j , ku ) + & 0.5 * ( dzf ( k - 1 ) * ekh ( i , j , k ) + dzf ( k ) * ekh ( i , j , k - 1 )) * & ! zero flux ( Tcell ( i , j , k ) - Tcell ( i , j , k - 1 )) * dzh2i ( ku ) * dzfi ( ku ) & - bcTflux * dzfi ( k ) END DO END DO END SELECT END SUBROUTINE wfuno","tags":"","url":"proc/wfuno.html"},{"title":"unoh – uDALES","text":"subroutine unoh(otf, octh, logdz, logdzh, logzh, sqdz, utangInt, dT, Ribl0, fkar2) Uses modglobal proc~~unoh~~UsesGraph proc~unoh unoh module~modglobal modglobal proc~unoh->module~modglobal Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(out) :: otf real, intent(out) :: octh real, intent(in) :: logdz real, intent(in) :: logdzh real, intent(in) :: logzh real, intent(in) :: sqdz real, intent(in) :: utangInt real, intent(in) :: dT real, intent(in) :: Ribl0 real, intent(in) :: fkar2 Source Code SUBROUTINE unoh ( otf , octh , logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !for heat, the bit that does not change no matter what wall use modglobal , only : prandtlturb !flux in Km/s IMPLICIT NONE REAL , INTENT ( in ) :: logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 REAL , INTENT ( out ) :: octh , otf REAL :: Ribl1 , Fm , Fh , cm , ch , M , dTrough , cth REAL , PARAMETER :: b1 = 9.4 !parameters from Uno1995 REAL , PARAMETER :: b2 = 4.7 REAL , PARAMETER :: dm = 7.4 REAL , PARAMETER :: dh = 5.3 octh = 0. otf = 0. IF ( Ribl0 > 0. ) THEN !0.25 approx critical for bulk Richardson number  => stable Fm = 1. / ( 1. + b2 * Ribl0 ) ** 2 !Eq. 4 Fh = Fm !Eq. 4 ELSE ! => unstable cm = ( dm * fkar2 ) / ( logdz ** 2 ) * b1 * sqdz !Eq. 5 ch = ( dh * fkar2 ) / ( logdz ** 2 ) * b1 * sqdz !Eq. 5 Fm = 1. - ( b1 * Ribl0 ) / ( 1. + cm * SQRT ( ABS ( Ribl0 ))) !Eq. 3 Fh = 1. - ( b1 * Ribl0 ) / ( 1. + ch * SQRT ( ABS ( Ribl0 ))) !Eq. 3 END IF M = prandtlturb * logdz * SQRT ( Fm ) / Fh !Eq. 14 Ribl1 = Ribl0 - Ribl0 * prandtlturb * logzh / ( prandtlturb * logzh + M ) !Eq. 17 !interate to get new Richardson number IF ( Ribl1 > 0. ) THEN !0.25 approx critical for bulk Richardson number  => stable Fm = 1. / ( 1. + b2 * Ribl1 ) ** 2 !Eq. 4 Fh = Fm !Eq. 4 ELSE ! => unstable cm = ( dm * fkar2 ) / ( logdz ** 2 ) * b1 * sqdz !Eq. 5 ch = ( dh * fkar2 ) / ( logdz ** 2 ) * b1 * sqdz !Eq. 5 Fm = 1. - ( b1 * Ribl1 ) / ( 1. + cm * SQRT ( ABS ( Ribl1 ))) !Eq. 3 Fh = 1. - ( b1 * Ribl1 ) / ( 1. + ch * SQRT ( ABS ( Ribl1 ))) !Eq. 3 END IF ! Uno (2) M = prandtlturb * logdz * SQRT ( Fm ) / Fh !Eq. 14 dTrough = dT * 1. / ( prandtlturb * logzh / M + 1. ) !Eq. 13a octh = SQRT ( utangInt ) * fkar2 / ( logdz * logdz ) * Fh / prandtlturb !Eq. 8 otf = octh * dTrough !Eq. 2, Eq. 8 ! ! Uno (8) ! octh = SQRT(utangInt)*fkar2/(logdz*logdzh)*Fh/prandtlturb !Eq. 8 ! otf = octh*dT !Eq. 2, Eq. 8 END SUBROUTINE unoh","tags":"","url":"proc/unoh.html"},{"title":"inittimedep – uDALES","text":"public  subroutine inittimedep() Uses modibmdata modfields modmpi modglobal proc~~inittimedep~~UsesGraph proc~inittimedep inittimedep module~modfields modfields proc~inittimedep->module~modfields module~modglobal modglobal proc~inittimedep->module~modglobal module~modibmdata modibmdata proc~inittimedep->module~modibmdata module~modmpi modmpi proc~inittimedep->module~modmpi decomp_2d decomp_2d module~modfields->decomp_2d mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~inittimedep~~CallsGraph proc~inittimedep inittimedep mpi_bcast mpi_bcast proc~inittimedep->mpi_bcast proc~timedep timedep proc~inittimedep->proc~timedep proc~timedeplw timedeplw proc~timedep->proc~timedeplw proc~timedepnudge timedepnudge proc~timedep->proc~timedepnudge proc~timedepsurf timedepsurf proc~timedep->proc~timedepsurf proc~timedepsw timedepsw proc~timedep->proc~timedepsw Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~inittimedep~~CalledByGraph proc~inittimedep inittimedep program~dalesurban DALESURBAN program~dalesurban->proc~inittimedep Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine inittimedep use modmpi , only : myid , my_real , mpi_logical , mpierr , comm3d use modglobal , only : cexpnr , kb , ke , kh , kmax , ifinput , runtime , zf , skyLW , nfcts use modibmdata , only : bctfxm , bctfxp , bctfym , bctfyp , bctfz !, bctfzf use modfields , only : thlprof !use initfac, only : netsw !Should probably be moved to somewhere else implicit none character ( 80 ) :: chmess character ( 1 ) :: chmess1 integer :: k , t , n , ierr real :: dummyr real , allocatable , dimension (:) :: height ltimedep = ( ltimedepsurf . or . ltimedepnudge ) . or . ( ltimedeplw . or . ltimedepsw ) if (. not . ltimedep ) return if ( ltimedepsurf ) then allocate ( timeflux ( 1 : ntimedepsurf )) allocate ( bctfxmt ( 1 : ntimedepsurf )) allocate ( bctfxpt ( 1 : ntimedepsurf )) allocate ( bctfymt ( 1 : ntimedepsurf )) allocate ( bctfypt ( 1 : ntimedepsurf )) allocate ( bctfzt ( 1 : ntimedepsurf )) !allocate(bctfzft (1:ntimedepsurf)) timeflux = 0. bctfxmt = bctfxm bctfxpt = bctfxp bctfymt = bctfym bctfypt = bctfyp bctfzt = bctfz !bctfzft = bctfzf if ( myid == 0 ) then open ( ifinput , file = 'timedepsurf.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess !write(6,*) chmess read ( ifinput , '(a80)' ) chmess !write(6,*) chmess !--- load fluxes--- !t    = 1 ierr = 0 do t = 1 , ntimedepsurf read ( ifinput , * , iostat = ierr ) timeflux ( t ), bctfxmt ( t ), bctfxpt ( t ), bctfymt ( t ), bctfypt ( t ), bctfzt ( t ) !, bctfzft(t) !write(*,*) t, timeflux(t), bctfxmt(t), bctfxpt(t), bctfymt(t), bctfypt(t), bctfzt(t)!, bctfzft(t) !if (ierr < 0) then !stop 'STOP: No time dependend data for end of run (surface fluxes)' !end if end do !if(timeflux(1)>runtime) then !write(6,*) 'Time dependent surface variables do not change before end of simulation' !ltimedepsurf=.false. !endif ! flush to the end of fluxlist !do while (ierr ==0) !read (ifinput,*,iostat=ierr) dummyr !end do !backspace (ifinput) !close(ifinput) end if !myid==0 call MPI_BCAST ( timeflux , ntimedepsurf , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( bctfxmt , ntimedepsurf , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( bctfxpt , ntimedepsurf , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( bctfymt , ntimedepsurf , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( bctfypt , ntimedepsurf , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( bctfzt , ntimedepsurf , MY_REAL , 0 , comm3d , mpierr ) !call MPI_BCAST(bctfzft , ntimedepsurf, MY_REAL, 0, comm3d,mpierr) end if if ( ltimedepnudge ) then allocate ( timenudge ( 1 : ntimedepnudge )) allocate ( height ( kb : ke + kh )) allocate ( uproft ( kb : ke + kh , ntimedepnudge )) allocate ( vproft ( kb : ke + kh , ntimedepnudge )) allocate ( thlproft ( kb : ke + kh , ntimedepnudge )) allocate ( qtproft ( kb : ke + kh , ntimedepnudge )) timenudge = 0 thlproft = 0 qtproft = 0 uproft = 0 vproft = 0 if ( myid == 0 ) then !---load nudging profiles---- open ( ifinput , file = 'timedepnudge.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess !write(6,*) chmess !t = 0 do t = 1 , ntimedepnudge !t = t + 1 chmess1 = \"#\" ierr = 1 ! not zero do while (. not .( chmess1 == \"#\" . and . ierr == 0 )) !search for the next line consisting of \"# time\", from there onwards the profiles will be read read ( ifinput , * , iostat = ierr ) chmess1 , timenudge ( t ) !if (ierr < 0) then !stop 'STOP: No time dependend data for end of run' !end if end do !write (*,*) 'timenudge = ',timenudge(t) !write(*,*) 'Nudging profiles' do k = kb , ke read ( ifinput , * ) & height ( k ) , & thlproft ( k , t ), & qtproft ( k , t ), & uproft ( k , t ), & vproft ( k , t ) !write(*,*) height(k), thlproft (k,t), qtproft(k,t), uproft(k,t), vproft(k,t) end do end do end if !myid == 0 call MPI_BCAST ( timenudge , ntimedepnudge , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( thlproft , ( kmax + 1 ) * ntimedepnudge , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( qtproft , ( kmax + 1 ) * ntimedepnudge , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( uproft , ( kmax + 1 ) * ntimedepnudge , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( vproft , ( kmax + 1 ) * ntimedepnudge , MY_REAL , 0 , comm3d , mpierr ) deallocate ( height ) end if if ( ltimedeplw ) then allocate ( timelw ( 1 : ntimedeplw )) allocate ( skyLWt ( 1 : ntimedeplw )) ! Read longwave timelw = 0. skyLWt = skyLW if ( myid == 0 ) then open ( ifinput , file = 'timedeplw.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess !write(6,*) chmess read ( ifinput , '(a80)' ) chmess !write(6,*) chmess !--- load fluxes--- !t    = 1 ierr = 0 do t = 1 , ntimedeplw read ( ifinput , * , iostat = ierr ) timelw ( t ), skyLWt ( t ) !write(*,*) t, timelw(t), skyLWt(t) !if (ierr < 0) then !stop 'STOP: No time dependend data for end of run (surface fluxes)' !end if end do !if(timelw(1)>runtime) then !write(6,*) 'Time dependent surface variables do not change before end of simulation' !ltimedeplw=.false. !endif ! flush to the end of fluxlist !do while (ierr ==0) !read (ifinput,*,iostat=ierr) dummyr !end do !backspace (ifinput) !close(ifinput) end if ! myid = 0 call MPI_BCAST ( timelw , ntimedeplw , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( skyLWt , ntimedeplw , MY_REAL , 0 , comm3d , mpierr ) end if !ltimedeplw if ( ltimedepsw ) then allocate ( timesw ( 1 : ntimedepsw )) allocate ( netswt ( 1 : nfcts , 1 : ntimedepsw )) timesw = 0. netswt = 0. if ( myid == 0 ) then ! Read shortwave open ( ifinput , file = 'timedepsw.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess ! first line is a description of the file read ( ifinput , * ) ( timesw ( t ), t = 1 , ntimedepsw ) ! second line is the times do n = 1 , nfcts read ( ifinput , * ) ( netswt ( n , t ), t = 1 , ntimedepsw ) end do !write(*,*) \"read timedepsw\" end if !myid==0 call MPI_BCAST ( timesw , ntimedepsw , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( netswt , ntimedepsw * nfcts , MY_REAL , 0 , comm3d , mpierr ) end if ! timedepsw call MPI_BCAST ( ltimedepsurf , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( ltimedepnudge , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( ltimedeplw , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( ltimedepsw , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call timedep end subroutine inittimedep","tags":"","url":"proc/inittimedep.html"},{"title":"timedep – uDALES","text":"public  subroutine timedep() Arguments None Calls proc~~timedep~~CallsGraph proc~timedep timedep proc~timedeplw timedeplw proc~timedep->proc~timedeplw proc~timedepnudge timedepnudge proc~timedep->proc~timedepnudge proc~timedepsurf timedepsurf proc~timedep->proc~timedepsurf proc~timedepsw timedepsw proc~timedep->proc~timedepsw Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~timedep~~CalledByGraph proc~timedep timedep proc~inittimedep inittimedep proc~inittimedep->proc~timedep program~dalesurban DALESURBAN program~dalesurban->proc~timedep program~dalesurban->proc~inittimedep Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine timedep !-----------------------------------------------------------------| !                                                                 | !*** *timedep*  calculates ls forcings and surface forcings       | !               case as a funtion of timee                        | !                                                                 | !      Roel Neggers    K.N.M.I.     01/05/2001                    | !                                                                 | !                                                                 | !    calls                                                        | !    * timedepz                                                   | !      calculation of large scale advection, radiation and        | !      surface fluxes by interpolation between prescribed         | !      values at certain times                                    | !                                                                 | !    * timedepsurf                                                | !      calculation  surface fluxes by interpolation               | !      between prescribed values at certain times                 | !                                                                 | !                                                                 | !-----------------------------------------------------------------| implicit none if (. not . ltimedep ) return call timedepsurf call timedepnudge call timedeplw call timedepsw end subroutine timedep","tags":"","url":"proc/timedep.html"},{"title":"timedepsurf – uDALES","text":"private  subroutine timedepsurf() Uses modibmdata modmpi modglobal proc~~timedepsurf~~UsesGraph proc~timedepsurf timedepsurf module~modglobal modglobal proc~timedepsurf->module~modglobal module~modibmdata modibmdata proc~timedepsurf->module~modibmdata module~modmpi modmpi proc~timedepsurf->module~modmpi mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~timedepsurf~~CalledByGraph proc~timedepsurf timedepsurf proc~timedep timedep proc~timedep->proc~timedepsurf proc~inittimedep inittimedep proc~inittimedep->proc~timedep program~dalesurban DALESURBAN program~dalesurban->proc~timedep program~dalesurban->proc~inittimedep Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine timedepsurf use modmpi , only : myid use modglobal , only : timee use modibmdata , only : bctfxm , bctfxp , bctfym , bctfyp , bctfz !, bctfzf implicit none integer t real fac if (. not .( ltimedepsurf )) return !     --- interpolate! ---- do t = ntimedepsurf , 1 , - 1 if ( timee . ge . timeflux ( t )) then exit endif end do ! if ((myid == 0) .or. (myid == 1)) then !   write(*, *) \"myid\", myid, \"t\", t, \"timee\", timee, \"timeflux(t)\", timeflux(t) ! end if if ( t . ne . ntimedepsurf ) then fac = ( timee - timeflux ( t )) / ( timeflux ( t + 1 ) - timeflux ( t )) bctfxm = bctfxmt ( t ) + fac * ( bctfxmt ( t + 1 ) - bctfxmt ( t )) bctfxp = bctfxpt ( t ) + fac * ( bctfxpt ( t + 1 ) - bctfxpt ( t )) bctfym = bctfymt ( t ) + fac * ( bctfymt ( t + 1 ) - bctfymt ( t )) bctfyp = bctfypt ( t ) + fac * ( bctfypt ( t + 1 ) - bctfypt ( t )) bctfz = bctfzt ( t ) + fac * ( bctfzt ( t + 1 ) - bctfzt ( t )) !bctfzf = bctfzft(t) + fac * (bctfzft(t+1) - bctfzft(t)) end if ! if ((myid == 0) .or. (myid == 1)) then !   write(*, *) \"myid\", myid, \"bctfz\", bctfz, \"bctfzf\", bctfzf ! end if return end subroutine timedepsurf","tags":"","url":"proc/timedepsurf.html"},{"title":"timedepnudge – uDALES","text":"private  subroutine timedepnudge() Uses modglobal modmpi modfields proc~~timedepnudge~~UsesGraph proc~timedepnudge timedepnudge module~modfields modfields proc~timedepnudge->module~modfields module~modglobal modglobal proc~timedepnudge->module~modglobal module~modmpi modmpi proc~timedepnudge->module~modmpi decomp_2d decomp_2d module~modfields->decomp_2d mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~timedepnudge~~CalledByGraph proc~timedepnudge timedepnudge proc~timedep timedep proc~timedep->proc~timedepnudge proc~inittimedep inittimedep proc~inittimedep->proc~timedep program~dalesurban DALESURBAN program~dalesurban->proc~timedep program~dalesurban->proc~inittimedep Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine timedepnudge use modfields , only : thlprof , qtprof , uprof , vprof use modglobal , only : timee , dzf , dzh , kb , ke , kh , kmax use modmpi , only : myid implicit none integer t , k real fac if (. not .( ltimedepnudge )) return !---- interpolate ---- do t = ntimedepnudge , 1 , - 1 if ( timee . ge . timenudge ( t )) then exit endif end do if ( t . ne . ntimedepnudge ) then fac = ( timee - timenudge ( t )) / ( timenudge ( t + 1 ) - timenudge ( t )) thlprof = thlproft (:, t ) + fac * ( thlproft (:, t + 1 ) - thlproft (:, t )) qtprof = qtproft (:, t ) + fac * ( qtproft (:, t + 1 ) - qtproft (:, t )) uprof = uproft (:, t ) + fac * ( uproft (:, t + 1 ) - uproft (:, t )) vprof = vproft (:, t ) + fac * ( vproft (:, t + 1 ) - vproft (:, t )) end if ! if ((myid == 0) .or. (myid == 1)) then !   write(*, *) \"myid, t, timee, timenudge(t), thlproft(ke,t), thlproft(ke,t+1), thlprof(ke)\" !   write(*, *) myid, t, timee, timenudge(t), thlproft(ke,t), thlproft(ke,t+1), thlprof(ke) ! end if !write(*, *) \"myid, thlproft(k,t), thlprof(k)\" !do k = kb,ke !write(*,*) myid, thlproft(k, t), thlprof(k) !end do return end subroutine timedepnudge","tags":"","url":"proc/timedepnudge.html"},{"title":"timedeplw – uDALES","text":"private  subroutine timedeplw() Uses modmpi modglobal proc~~timedeplw~~UsesGraph proc~timedeplw timedeplw module~modglobal modglobal proc~timedeplw->module~modglobal module~modmpi modmpi proc~timedeplw->module~modmpi mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~timedeplw~~CalledByGraph proc~timedeplw timedeplw proc~timedep timedep proc~timedep->proc~timedeplw proc~inittimedep inittimedep proc~inittimedep->proc~timedep program~dalesurban DALESURBAN program~dalesurban->proc~timedep program~dalesurban->proc~inittimedep Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine timedeplw use modglobal , only : timee , skyLW , rk3step , tnextEB use modmpi , only : myid implicit none integer t , k real fac if (. not .( ltimedeplw )) return if (( rk3step . eq . 3 ) . and . ( timee . ge . tnextEB )) then ! if (myid == 0) then !  write(*,*) \"EB coming up so changing longwave forcing\" ! end if !---- interpolate ---- do t = ntimedeplw , 1 , - 1 if ( timee . ge . timelw ( t )) then exit endif end do if ( t . ne . ntimedeplw ) then fac = ( timee - timelw ( t )) / ( timelw ( t + 1 ) - timelw ( t )) skyLW = skyLWt ( t ) + fac * ( skyLWt ( t + 1 ) - skyLWt ( t )) end if end if end subroutine timedeplw","tags":"","url":"proc/timedeplw.html"},{"title":"timedepsw – uDALES","text":"private  subroutine timedepsw() Uses modmpi initfac modglobal proc~~timedepsw~~UsesGraph proc~timedepsw timedepsw module~initfac initfac proc~timedepsw->module~initfac module~modglobal modglobal proc~timedepsw->module~modglobal module~modmpi modmpi proc~timedepsw->module~modmpi module~initfac->module~modglobal module~initfac->module~modmpi mpi mpi module~initfac->mpi netcdf netcdf module~initfac->netcdf module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~timedepsw~~CalledByGraph proc~timedepsw timedepsw proc~timedep timedep proc~timedep->proc~timedepsw proc~inittimedep inittimedep proc~inittimedep->proc~timedep program~dalesurban DALESURBAN program~dalesurban->proc~timedep program~dalesurban->proc~inittimedep Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine timedepsw use modglobal , only : timee , nfcts , rk3step , tnextEB use initfac , only : netsw use modmpi , only : myid implicit none integer t , n real fac if (. not .( ltimedepsw . and . myid == 0 )) return if (( rk3step . eq . 3 ) . and . ( timee . ge . tnextEB )) then ! if (myid == 0) then !  write(*,*) \"EB coming up so changing solar position\" ! end if !---- interpolate ---- do t = ntimedepsw , 1 , - 1 if ( timee . ge . timesw ( t )) then exit endif end do if ( t . ne . ntimedepsw ) then fac = ( timee - timesw ( t )) / ( timesw ( t + 1 ) - timesw ( t )) do n = 1 , nfcts netsw ( n ) = netswt ( n , t ) + fac * ( netswt ( n , t + 1 ) - netswt ( n , t )) end do end if end if end subroutine timedepsw","tags":"","url":"proc/timedepsw.html"},{"title":"exittimedep – uDALES","text":"public  subroutine exittimedep() Arguments None","tags":"","url":"proc/exittimedep.html"},{"title":"initfields – uDALES","text":"public  subroutine initfields() Uses decomp_2d modglobal proc~~initfields~~UsesGraph proc~initfields initfields decomp_2d decomp_2d proc~initfields->decomp_2d module~modglobal modglobal proc~initfields->module~modglobal Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~initfields~~CallsGraph proc~initfields initfields alloc_z alloc_z proc~initfields->alloc_z Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~initfields~~CalledByGraph proc~initfields initfields program~dalesurban DALESURBAN program~dalesurban->proc~initfields Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine initfields use modglobal , only : ib , ie , jb , je , ih , jh , kb , ke , kh , jtot , nsv ,& ihc , jhc , khc , ltdump , lmintdump , lytdump , lxytdump , ltkedump , ltempeq , lmoist , lchem , lscasrcr , ltreedump !, iadv_kappa,iadv_sv use decomp_2d , only : alloc_z ! Allocation of prognostic variables implicit none udef = 0. ; vdef = 0. !allocate(worksave(2*imax*jmax*ktot)) ! Maybe define in poisson ! ! Original ! allocate(um(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)); um = 0. ! allocate(vm(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)); vm = 0. ! allocate(wm(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)); wm = 0. ! allocate(u0(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)); u0 = 0. ! allocate(v0(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)); v0 = 0. ! allocate(w0(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)); w0 = 0. allocate ( up ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) ; up = 0. allocate ( vp ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) ; vp = 0. allocate ( wp ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) ; wp = 0. allocate ( ru ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) ; ru = 0. allocate ( rv ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) ; rv = 0. allocate ( rw ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) ; rw = 0. ! allocate(pres0(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)); pres0 = 0. ! ! ! Always have to allocate these, even if they are constant ! ! Maybe change this eventually ! allocate(thlm(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)); thlm = 0. ! allocate(thl0(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)); thl0 = 0. ! allocate(thl0h(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)); thl0h = 0. allocate ( thlp ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )); thlp = 0. allocate ( thlpc ( ib - ihc : ie + ihc , jb - jhc : je + jhc , kb : ke + khc )); thlpc = 0. ! allocate(qtm(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)); qtm = 0. ! allocate(qt0(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)); qt0 = 0. ! allocate(ql0(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)); ql0 = 0. ! allocate(qt0h(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)); qt0h = 0. allocate ( qtp ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )); qtp = 0. ! allocate(e12m(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)); e12m = 0. ! allocate(e120(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)); e120 = 0. allocate ( e12p ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )); e12p = 0. allocate ( ql0h ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )); ql0h = 0. allocate ( dthvdz ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )); dthvdz = 0. allocate ( thv0h ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )); thv0h = 0. ! allocate(mindist(ib:ie,jb:je,kb:ke)); mindist = 0. !! Allocate 3D fields using 2DECOMP&FFT in z-pencil. call alloc_z ( um ); um = 0. call alloc_z ( vm ); vm = 0. call alloc_z ( wm ); wm = 0. call alloc_z ( u0 ); u0 = 0. call alloc_z ( v0 ); v0 = 0. call alloc_z ( w0 ); w0 = 0. call alloc_z ( tau_x ); tau_x = 0. call alloc_z ( tau_y ); tau_y = 0. call alloc_z ( tau_z ); tau_z = 0. call alloc_z ( thl_flux ); thl_flux = 0. call alloc_z ( uinit ); uinit = 0. call alloc_z ( vinit ); vinit = 0. ! call alloc_z(up); up = 0. ! call alloc_z(vp); vp = 0. ! call alloc_z(wp); wp = 0. call alloc_z ( pres0 ); pres0 = 0. call alloc_z ( div , opt_zlevel = ( / 0 , 0 , 0 / )) call alloc_z ( dudx , opt_zlevel = ( / 0 , 0 , 0 / )) call alloc_z ( dvdy , opt_zlevel = ( / 0 , 0 , 0 / )) call alloc_z ( dwdz , opt_zlevel = ( / 0 , 0 , 0 / )) ! Always have to allocate these, even if ltempeq/lmoist = .false. call alloc_z ( thlm ); thlm = 0. !allocate(thlm(ib-ihc:ie+ihc,jb-jhc:je+jhc,kb-khc:ke+khc)); thlm = 0. call alloc_z ( thl0 ); thl0 = 0. allocate ( thl0c ( ib - ihc : ie + ihc , jb - jhc : je + jhc , kb - khc : ke + khc )); thl0c = 0. ! call alloc_z(thlp); thlp = 0. call alloc_z ( thl0h ); thl0h = 0. ! call alloc_z(thv0h); thv0h = 0. ! call alloc_z(dthvdz); dthvdz = 0. call alloc_z ( qtm ); qtm = 0. call alloc_z ( qt0 ); qt0 = 0. call alloc_z ( ql0 ); ql0 = 0. ! call alloc_z(qtp); qtp = 0. call alloc_z ( qt0h ); qt0h = 0. ! call alloc_z(ql0h); ql0h = 0. call alloc_z ( e12m ); e12m = 0. call alloc_z ( e120 ); e120 = 0. ! call alloc_z(e12p); e12p = 0. call alloc_z ( mindist , opt_zlevel = ( / 0 , 0 , 0 / )); mindist = 0. ! These always have to be allocated differently? !if (nsv>0) then allocate ( svm ( ib - ihc : ie + ihc , jb - jhc : je + jhc , kb - khc : ke + khc , nsv )); svm = 0. allocate ( sv0 ( ib - ihc : ie + ihc , jb - jhc : je + jhc , kb - khc : ke + khc , nsv )); sv0 = 0. allocate ( svp ( ib - ihc : ie + ihc , jb - jhc : je + jhc , kb : ke + khc , nsv )); svp = 0. allocate ( svpp ( ib - ihc : ie + ihc , jb - jhc : je + jhc , kb : ke + khc , 1 )); svpp = 0. !end if ! Allocation of diagnostic variables ! Only used in nearwall in modibm, which is not being used any more allocate ( whls ( kb : ke + kh )); whls = 0. allocate ( presf ( kb : ke + kh )); presf = 0. allocate ( presh ( kb : ke + kh )); presh = 0. allocate ( exnf ( kb : ke + kh )); exnf = 0. allocate ( exnh ( kb : ke + kh )); exnh = 0. allocate ( thvf ( kb : ke + kh )); thvf = 0. allocate ( thvh ( kb : ke + kh )); thvh = 0. allocate ( rhof ( kb : ke + kh )); rhof = 0. allocate ( qt0av ( kb : ke + kh )); qt0av = 0. allocate ( ql0av ( kb : ke + kh )); ql0av = 0. allocate ( thl0av ( kb : ke + kh )); thl0av = 0. allocate ( u0av ( kb : ke + kh )); u0av = 0. allocate ( v0av ( kb : ke + kh )); v0av = 0. allocate ( ug ( kb : ke + kh )); ug = 0. allocate ( vg ( kb : ke + kh )); vg = 0. allocate ( pgx ( kb : ke + kh )); pgx = 0. allocate ( pgy ( kb : ke + kh )); pgy = 0. allocate ( dpdxl ( kb : ke + kh )); dpdxl = 0. allocate ( dpdyl ( kb : ke + kh )); dpdyl = 0. allocate ( dthldxls ( kb : ke + kh )); dthldxls = 0. allocate ( dthldyls ( kb : ke + kh )); dthldyls = 0. allocate ( dqtdxls ( kb : ke + kh )); dqtdxls = 0. allocate ( dqtdyls ( kb : ke + kh )); dqtdyls = 0. allocate ( dqtdtls ( kb : ke + kh )); dqtdtls = 0. allocate ( dudxls ( kb : ke + kh )); dudxls = 0. allocate ( dudyls ( kb : ke + kh )); dudyls = 0. allocate ( dvdxls ( kb : ke + kh )); dvdxls = 0. allocate ( dvdyls ( kb : ke + kh )); dvdyls = 0. allocate ( wfls ( kb : ke + kh )); wfls = 0. allocate ( thlprof ( kb : ke + kh )); thlprof = 0. allocate ( qtprof ( kb : ke + kh )); qtprof = 0. allocate ( qlprof ( kb : ke + kh )); qlprof = 0. allocate ( uprof ( kb : ke + kh )); uprof = 0. allocate ( vprof ( kb : ke + kh )); vprof = 0. allocate ( e12prof ( kb : ke + kh )); e12prof = 0. allocate ( sv0av ( kb : ke + khc , nsv )); sv0av = 0. allocate ( svprof ( kb : ke + kh , nsv )); svprof = 0. allocate ( thlpcar ( kb : ke + kh )); thlpcar = 0. allocate ( wout ( ib : ie )); wout = 0. ; ! j -averaged top velocity !allocate(friction(ib:ie)); friction = 0. ! line-averaged (along j) skin friction !allocate(momthick(ib:ie)); momthick = 0.     ! line-averaged (along j) momentum thickness !allocate(displthick(ib:ie)); displthick = 0.   ! line-averaged (along j) displacement thickness !allocate(SW_up_TOA(ib-ih:ie+ih,jb-jh:je+jh)); SW_up_TOA = 0. !allocate(SW_dn_TOA(ib-ih:ie+ih,jb-jh:je+jh)); SW_dn_TOA = 0. !allocate(LW_up_TOA(ib-ih:ie+ih,jb-jh:je+jh)); LW_up_TOA = 0. !allocate(LW_dn_TOA(ib-ih:ie+ih,jb-jh:je+jh)); LW_dn_TOA = 0. !allocate(viscratioav(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)); viscratioav = 0. allocate ( rhobf ( kb : ke + kh )); rhobf = 1. allocate ( rhobh ( kb : ke + kh )); rhobh = 1. allocate ( IIc ( ib - ihc : ie + ihc , jb - jhc : je + jhc , kb : ke + khc )) allocate ( IIu ( ib - ihc : ie + ihc , jb - jhc : je + jhc , kb : ke + khc )) allocate ( IIv ( ib - ihc : ie + ihc , jb - jhc : je + jhc , kb : ke + khc )) allocate ( IIw ( ib - ihc : ie + ihc , jb - jhc : je + jhc , kb : ke + khc )) allocate ( IIuw ( ib - ihc : ie + ihc , jb - jhc : je + jhc , kb : ke + khc )) allocate ( IIvw ( ib - ihc : ie + ihc , jb - jhc : je + jhc , kb : ke + khc )) allocate ( IIuv ( ib - ihc : ie + ihc , jb - jhc : je + jhc , kb : ke + khc )) allocate ( IIct ( ib : ie , kb : ke )) allocate ( IIwt ( ib : ie , kb : ke )) allocate ( IIuwt ( ib : ie , kb : ke )) allocate ( IIut ( ib : ie , kb : ke )) allocate ( IIvt ( ib : ie , kb : ke )) allocate ( IIcs ( kb : ke + khc )) allocate ( IIus ( kb : ke + khc )) allocate ( IIvs ( kb : ke + khc )) allocate ( IIws ( kb : ke + khc )) allocate ( IIuws ( kb : ke + khc )) allocate ( IIvws ( kb : ke + khc )) allocate ( IIuvs ( kb : ke + khc )) IIc = 1 ; IIu = 1 ; IIv = 1 ; IIct = 1 ; IIw = 1 ; IIuw = 1 ; IIvw = 1 ; IIuwt = 1 ; IIut = 1 ; IIvt = 1 ; IIwt = 1 ; IIcs = 1 ; IIus = 1 ; IIvs = 1 ; IIws = 1 ; IIuws = 1 ; IIvws = 1 ; IIuw = 1 ; IIuvs = 1 if ( ltreedump ) then allocate ( qc ( kb : ke )) allocate ( qa ( kb : ke )) allocate ( ladzf ( kb : ke )) allocate ( ladzh ( kb : ke )) allocate ( Rn ( kb : ke )) allocate ( clai ( kb : ke )) allocate ( tr_u ( ib : ie , jb : je , kb : ke )) allocate ( tr_v ( ib : ie , jb : je , kb : ke )) allocate ( tr_w ( ib : ie , jb : je , kb : ke )) allocate ( tr_qt ( ib : ie , jb : je , kb : ke )) allocate ( tr_qtR ( ib : ie , jb : je , kb : ke )) allocate ( tr_qtA ( ib : ie , jb : je , kb : ke )) allocate ( tr_thl ( ib : ie , jb : je , kb : ke )) allocate ( tr_sv ( ib : ie , jb : je , kb : ke , 1 : nsv )) allocate ( tr_omega ( ib : ie , jb : je , kb : ke )) allocate ( tr_ut ( ib : ie , jb : je , kb : ke )) allocate ( tr_vt ( ib : ie , jb : je , kb : ke )) allocate ( tr_wt ( ib : ie , jb : je , kb : ke )) allocate ( tr_qtt ( ib : ie , jb : je , kb : ke )) allocate ( tr_qtRt ( ib : ie , jb : je , kb : ke )) allocate ( tr_qtAt ( ib : ie , jb : je , kb : ke )) allocate ( tr_thlt ( ib : ie , jb : je , kb : ke )) allocate ( tr_sv1t ( ib : ie , jb : je , kb : ke )) allocate ( tr_sv2t ( ib : ie , jb : je , kb : ke )) allocate ( tr_omegat ( ib : ie , jb : je , kb : ke )) clai = 0. ; Rn = 0. ; qc = 0. ; qa = 0. ; ladzf = 0. ; ladzh = 0. ; tr_u = 0. ; tr_v = 0. ; tr_w = 0. ; tr_thl = 0. ; tr_qt = 0. ; tr_qtR = 0. ; tr_qtA = 0. ; tr_sv = 0. tr_ut = 0. ; tr_vt = 0. ; tr_wt = 0. ; tr_thlt = 0. ; tr_qtt = 0. ; tr_qtRt = 0. ; tr_qtAt = 0. ; tr_sv1t = 0. ; tr_sv2t = 0. ; tr_omega = 0. ; tr_omegat = 0. end if ! Statistics - currenly not implemented. if ( lytdump ) then allocate ( uyt ( ib : ie , kb : ke )) allocate ( uytik ( ib : ie , kb : ke )) allocate ( vyt ( ib : ie , kb : ke )) allocate ( wyt ( ib : ie , kb : ke )) allocate ( wytik ( ib : ie , kb : ke )) allocate ( thlyt ( ib : ie , kb : ke )) allocate ( qtyt ( ib : ie , kb : ke )) allocate ( thlytk ( ib : ie , kb : ke )) allocate ( sca1yt ( ib : ie , kb : ke )) allocate ( sca2yt ( ib : ie , kb : ke )) allocate ( sca3yt ( ib : ie , kb : ke )) allocate ( usgsyt ( ib : ie , kb : ke )) allocate ( thlsgsyt ( ib : ie , kb : ke )) allocate ( qtsgsyt ( ib : ie , kb : ke )) allocate ( wsgsyt ( ib : ie , kb : ke )) allocate ( sv1sgsyt ( ib : ie , kb : ke )) allocate ( sv2sgsyt ( ib : ie , kb : ke )) allocate ( sv3sgsyt ( ib : ie , kb : ke )) uyt = 0. ; uytik = 0. ; vyt = 0. ; wyt = 0. ; wytik = 0. ; thlyt = 0. ; qtyt = 0. ; thlytk = 0. ; sca1yt = 0. ; sca2yt = 0. ; sca3yt = 0. ; usgsyt = 0. ; thlsgsyt = 0. ; wsgsyt = 0. ; qtsgsyt = 0. ; sv1sgsyt = 0. ; sv2sgsyt = 0. ; sv3sgsyt = 0. end if if ( lxytdump ) then allocate ( uxyt ( kb : ke + kh )) allocate ( vxyt ( kb : ke + kh )) allocate ( wxyt ( kb : ke + kh )) allocate ( thlxyt ( kb : ke + kh )) allocate ( qtxyt ( kb : ke + kh )) allocate ( pxyt ( kb : ke + kh )) allocate ( usgsxyt ( kb : ke + kh )) allocate ( thlsgsxyt ( kb : ke + kh )) allocate ( vsgsxyt ( kb : ke + kh )) uxyt = 0. ; vxyt = 0. ; wxyt = 0. ; thlxyt = 0. ; qtxyt = 0. ; pxyt = 0. ; usgsxyt = 0. ; vsgsxyt = 0. ; thlsgsxyt = 0. ; end if if ( lxytdump . or . lytdump . or . ltdump . or . lmintdump ) then allocate ( umt ( ib : ie , jb : je , kb : ke + kh )); umt = 0 ; allocate ( vmt ( ib : ie , jb : je , kb : ke + kh )); vmt = 0 ; allocate ( wmt ( ib : ie , jb : je , kb : ke + kh )); wmt = 0 ; allocate ( utc ( ib : ie , jb : je , kb : ke + kh )); utc = 0 ; allocate ( vtc ( ib : ie , jb : je , kb : ke + kh )); vtc = 0 ; allocate ( wtc ( ib : ie , jb : je , kb : ke + kh )); wtc = 0 ; allocate ( utij ( ib : ie , jb : je , kb : ke + kh )); utij = 0 ; allocate ( utik ( ib : ie , jb : je , kb : ke + kh )); utik = 0 ; allocate ( vtij ( ib : ie , jb : je , kb : ke + kh )); vtij = 0 ; allocate ( vtjk ( ib : ie , jb : je , kb : ke + kh )); vtjk = 0 ; allocate ( wtik ( ib : ie , jb : je , kb : ke + kh )); wtik = 0 ; allocate ( wtjk ( ib : ie , jb : je , kb : ke + kh )); wtjk = 0 ; allocate ( uvtij ( ib : ie , jb : je , kb : ke + kh )); uvtij = 0 ; allocate ( uwtik ( ib : ie , jb : je , kb : ke + kh )); uwtik = 0 ; allocate ( vwtjk ( ib : ie , jb : je , kb : ke + kh )); vwtjk = 0 ; allocate ( uutc ( ib : ie , jb : je , kb : ke + kh )); uutc = 0 ; allocate ( vvtc ( ib : ie , jb : je , kb : ke + kh )); vvtc = 0 ; allocate ( wwtc ( ib : ie , jb : je , kb : ke + kh )); wwtc = 0 ; allocate ( pt ( ib : ie , jb : je , kb : ke + kh )); pt = 0 ; !if (ltempeq) then ! can't have this switch for now because arrays will be wrong size in tdump file e.g. allocate ( thlt ( ib : ie , jb : je , kb : ke + kh )); thlt = 0 ; allocate ( thltk ( ib : ie , jb : je , kb : ke + kh )); thltk = 0 ; allocate ( wthltk ( ib : ie , jb : je , kb : ke + kh )); wthltk = 0 ; allocate ( thlthlt ( ib : ie , jb : je , kb : ke + kh )); thlthlt = 0 ; !end if !if (lmoist) then allocate ( qtt ( ib : ie , jb : je , kb : ke + kh )); qtt = 0 ; allocate ( qttk ( ib : ie , jb : je , kb : ke + kh )); qttk = 0 ; allocate ( wqttk ( ib : ie , jb : je , kb : ke + kh )); wqttk = 0 ; allocate ( qtqtt ( ib : ie , jb : je , kb : ke + kh )); qtqtt = 0 ; !end if !if (nsv>0) then allocate ( sv1t ( ib : ie , jb : je , kb : ke + kh )); sv1t = 0 ; allocate ( sv1tk ( ib : ie , jb : je , kb : ke + kh )); sv1tk = 0 ; allocate ( wsv1tk ( ib : ie , jb : je , kb : ke + kh )); wsv1tk = 0 ; allocate ( sv1sv1t ( ib : ie , jb : je , kb : ke + kh )); sv1sv1t = 0 ; allocate ( sv1sgst ( ib : ie , jb : je , kb : ke + kh )); sv1sgst = 0 ; !if (nsv>1) then allocate ( sv2t ( ib : ie , jb : je , kb : ke + kh )); sv2t = 0 ; allocate ( sv2tk ( ib : ie , jb : je , kb : ke + kh )); sv2tk = 0 ; allocate ( wsv2tk ( ib : ie , jb : je , kb : ke + kh )); wsv2tk = 0 ; allocate ( sv2sv2t ( ib : ie , jb : je , kb : ke + kh )); sv2sv2t = 0 ; allocate ( sv2sgst ( ib : ie , jb : je , kb : ke + kh )); sv2sgst = 0 ; !if (nsv>2) then allocate ( sv3t ( ib : ie , jb : je , kb : ke + kh )); sv3t = 0 ; allocate ( sv3tk ( ib : ie , jb : je , kb : ke + kh )); sv3tk = 0 ; allocate ( wsv3tk ( ib : ie , jb : je , kb : ke + kh )); wsv3tk = 0 ; allocate ( sv3sv3t ( ib : ie , jb : je , kb : ke + kh )); sv3sv3t = 0 ; allocate ( sv3sgst ( ib : ie , jb : je , kb : ke + kh )); sv3sgst = 0 ; !if (nsv>3) then allocate ( sv4t ( ib : ie , jb : je , kb : ke + kh )); sv4t = 0 ; allocate ( sv4tk ( ib : ie , jb : je , kb : ke + kh )); sv4tk = 0 ; allocate ( wsv4tk ( ib : ie , jb : je , kb : ke + kh )); wsv4tk = 0 ; allocate ( sv4sv4t ( ib : ie , jb : je , kb : ke + kh )); sv4sv4t = 0 ; allocate ( sv4sgst ( ib : ie , jb : je , kb : ke + kh )); sv4sgst = 0 ; !end if !end if !end if !end if !if ((lchem .eqv. .true.) .and. (nsv>2)) then allocate ( PSSt ( ib : ie , jb : je , kb : ke + kh )); PSSt = 0 ; !end if ! uwtik=0.;wthltk=0.;wqttk=0.;thlthlt=0.;qtqtt=0.;sv1sv1t=0.;sv2sv2t=0.;sv3sv3t=0.;sv4sv4t=0.;uutc=0.;vvtc=0.;wwtc=0.;vwtjk=0.;uvtij=0.;utik=0.;wtik=0.;wtjk=0.;vtjk=0.;utij=0.;vtij=0.; ! wmt=0.;thltk=0.;qttk=0.;thlt=0.;utc=0.;vtc=0.;wtc=0. ! wsv1tk=0.;wsv2tk=0.;wsv3tk=0.;wsv4tk=0.;sv1sgst=0.;sv2sgst=0.;sv3sgst=0.;sv4sgst=0.;qtt=0.;pt=0. ! PSSt = 0. !sv1max = 0.; sv2max = 0.; sv3max = 0.; sv4max = 0. end if if ( lscasrcr . and . nsv > 0 ) then allocate ( scar ( ib : ie , jb : jtot )) allocate ( scarl ( ib : ie , jb : je )) scar = 0. ; scarl = 0. end if if ( ltkedump ) then ! this is currently not usable ! allocate averaged variables allocate ( uav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( vav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( wav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( thlav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( qtav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( qlav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( presav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( svav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh , 1 : nsv )) allocate ( umint ( ib : ie , jb : je , kb : ke )) allocate ( vmint ( ib : ie , jb : je , kb : ke )) allocate ( wmint ( ib : ie , jb : je , kb : ke )) allocate ( uuav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( vvav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( wwav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( uvav ( ib : ie + ih , jb : je + jh , kb : ke )) allocate ( uwav ( ib : ie + ih , jb : je , kb : ke + kh )) allocate ( vwav ( ib : ie , jb : je + jh , kb : ke + kh )) !TKE budget terms allocate ( tvmx ( ib - 1 : ie + 1 , jb - 1 : je + 1 , kb : ke )) allocate ( tvmy ( ib - 1 : ie + 1 , jb - 1 : je + 1 , kb : ke )) allocate ( tvmz ( ib : ie , jb : je , kb : ke + 1 )) allocate ( tpm ( ib : ie , jb : je , kb : ke )) allocate ( ttmx ( ib - 1 : ie + 1 , jb - 1 : je + 1 , kb : ke )) allocate ( ttmy ( ib - 1 : ie + 1 , jb - 1 : je + 1 , kb : ke )) allocate ( ttmz ( ib : ie , jb : je , kb : ke + 1 )) allocate ( tsgsmx1 ( ib - 1 : ie + 1 , jb - 1 : je + 1 , kb : ke )) allocate ( tsgsmy1 ( ib - 1 : ie + 1 , jb - 1 : je + 1 , kb : ke )) allocate ( tsgsmz1 ( ib : ie , jb : je , kb : ke + 1 )) allocate ( tsgsmx2 ( ib - 1 : ie + 1 , jb - 1 : je + 1 , kb : ke )) allocate ( tsgsmy2 ( ib - 1 : ie + 1 , jb - 1 : je + 1 , kb : ke )) allocate ( tsgsmz2 ( ib : ie , jb : je , kb : ke + 1 )) allocate ( t_pav ( ib : ie , jb : je , kb : ke )) allocate ( t_vav ( ib : ie , jb : je , kb : ke )) allocate ( t_tav ( ib : ie , jb : je , kb : ke )) allocate ( t_sgsav ( ib : ie , jb : je , kb : ke )) allocate ( p_tav ( ib : ie , jb : je , kb : ke )) allocate ( p_bav ( ib : ie , jb : je , kb : ke )) allocate ( d_sgsav ( ib : ie , jb : je , kb : ke )) allocate ( tkeadv ( ib : ie , jb : je , kb : ke )) allocate ( t_p ( kb : ke )) allocate ( t_v ( kb : ke )) allocate ( t_t ( kb : ke )) allocate ( t_sgs ( kb : ke )) allocate ( p_t ( kb : ke )) allocate ( p_b ( kb : ke )) allocate ( d_sgs ( kb : ke )) allocate ( adv ( kb : ke )) uav = 0. ; vav = 0. ; wav = 0. ; thlav = 0. ; qtav = 0. ; svav = 0. ;; uuav = 0. ; vvav = 0. wwav = 0. ; uvav = 0. ; uwav = 0. ; vwav = 0. ; presav = 0. umint = 0. ; vmint = 0. ; wmint = 0. t_vav = 0. ; tvmx = 0. ; tvmy = 0. ; tvmz = 0. ; tpm = 0. ; ttmx = 0. ; ttmy = 0. ; ttmz = 0. ; t_sgsav = 0. ; p_tav = 0. tsgsmx1 = 0. ; tsgsmy1 = 0. ; tsgsmz1 = 0. ; tsgsmx2 = 0. ; tsgsmy2 = 0. ; tsgsmz2 = 0. t_pav = 0. ; t_tav = 0. ; p_bav = 0. ; d_sgsav = 0. ; tkeadv = 0. ; t_p = 0. ; t_v = 0. ; t_t = 0. ; t_sgs = 0. ; p_t = 0. ; p_b = 0. ; d_sgs = 0. ; adv = 0. allocate ( thl2av ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( ql2av ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( qt2av ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( sv2av ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh , 1 : nsv )) allocate ( thluav ( ib : ie + ih , jb : je , kb : ke )) allocate ( thlvav ( ib : ie , jb : je + jh , kb : ke )) allocate ( thlwav ( ib : ie , jb : je , kb : ke + kh )) allocate ( thlthlav ( ib : ie , jb : je , kb : ke + kh )) allocate ( qluav ( ib : ie + ih , jb : je , kb : ke )) allocate ( qlvav ( ib : ie , jb : je + jh , kb : ke )) allocate ( qlwav ( ib : ie , jb : je , kb : ke + kh )) allocate ( qtuav ( ib : ie + ih , jb : je , kb : ke )) allocate ( qtvav ( ib : ie , jb : je + jh , kb : ke )) allocate ( qtwav ( ib : ie , jb : je , kb : ke + kh )) allocate ( svuav ( ib : ie + ih , jb : je , kb : ke , 1 : nsv )) allocate ( svvav ( ib : ie , jb : je + jh , kb : ke , 1 : nsv )) allocate ( svwav ( ib : ie , jb : je , kb : ke + kh , 1 : nsv )) thluav = 0. ; thlvav = 0. ; thlwav = 0. ; thlthlav = 0. ; svuav = 0. ; svvav = 0. ; svwav = 0. ; sv2av = 0. ; thl2av = 0. ; ql2av = 0. ; qt2av = 0. ; ! <x'x> ( = <xx> -<x><x> ) allocate ( upupav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( vpvpav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( wpwpav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( upvpav ( ib : ie + ih , jb : je + jh , kb : ke )) allocate ( upwpav ( ib : ie + ih , jb : je , kb : ke + kh )) allocate ( vpwpav ( ib : ie , jb : je + jh , kb : ke + kh )) allocate ( thlpthlpav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( thlpupav ( ib : ie + ih , jb : je , kb : ke )) allocate ( thlpvpav ( ib : ie , jb : je + jh , kb : ke )) allocate ( thlpwpav ( ib : ie , jb : je , kb : ke + kh )) allocate ( qlpqlpav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( qlpupav ( ib : ie + ih , jb : je , kb : ke )) allocate ( qlpvpav ( ib : ie , jb : je + jh , kb : ke )) allocate ( qlpwpav ( ib : ie , jb : je , kb : ke + kh )) allocate ( qtpqtpav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( qtpupav ( ib : ie + ih , jb : je , kb : ke )) allocate ( qtpvpav ( ib : ie , jb : je + jh , kb : ke )) allocate ( qtpwpav ( ib : ie , jb : je , kb : ke + kh )) allocate ( svpsvpav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh , 1 : nsv )) allocate ( svpupav ( ib : ie + ih , jb : je , kb : ke , 1 : nsv )) allocate ( svpvpav ( ib : ie , jb : je + jh , kb : ke , 1 : nsv )) allocate ( svpwpav ( ib : ie , jb : je , kb : ke + kh , 1 : nsv )) upupav = 0. ; vpvpav = 0. ; wpwpav = 0. ; thlpthlpav = 0. ; qlpqlpav = 0. ; qtpqtpav = 0. ; svpsvpav = 0. ; upvpav = 0. ; upwpav = 0. ; vpwpav = 0. thlpupav = 0. ; thlpvpav = 0. ; thlpwpav = 0. ; qlpupav = 0. ; qlpvpav = 0. ; qlpwpav = 0. ; qtpwpav = 0. ; qtpvpav = 0. ; qtpupav = 0. ; svpupav = 0. ; svpvpav = 0. ; svpwpav = 0. ! Subgrid allocate ( uusgsav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( vvsgsav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( wwsgsav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( uwsgsav ( ib : ie + ih , jb : je , kb : ke + kh )) allocate ( thlusgsav ( ib : ie + ih , jb : je , kb : ke )) allocate ( thlwsgsav ( ib : ie , jb : je , kb : ke + kh )) allocate ( qlusgsav ( ib : ie + ih , jb : je , kb : ke )) allocate ( qlwsgsav ( ib : ie , jb : je , kb : ke + kh )) allocate ( qtusgsav ( ib : ie + ih , jb : je , kb : ke )) allocate ( qtwsgsav ( ib : ie , jb : je , kb : ke + kh )) allocate ( tkesgsav ( ib : ie , jb : je , kb : ke )) allocate ( svusgsav ( ib : ie + ih , jb : je , kb : ke , 1 : nsv )) allocate ( svwsgsav ( ib : ie , jb : je , kb : ke + kh , 1 : nsv )) allocate ( nusgsav ( ib : ie , jb : je , kb : ke )) uusgsav = 0. ; vvsgsav = 0. ; wwsgsav = 0. ; uwsgsav = 0. ; thlusgsav = 0. ; thlwsgsav = 0. ; qlusgsav = 0. ; qlwsgsav = 0. ; qtwsgsav = 0. ; qtusgsav = 0. ; svusgsav = 0. ; svwsgsav = 0. ; tkesgsav = 0. ; nusgsav = 0. allocate ( strain2av ( ib : ie , jb : je , kb : ke )) ! resolved dissipation allocate ( disssgsav ( ib : ie , jb : je , kb : ke )) ! Subgrid dissipation strain2av = 0. disssgsav = 0. end if ! allocate wall shear-stress terms (immersed boundaries) allocate ( shear ( ib - 1 : ie + 1 , jb - 1 : je + 1 , kb - 1 : ke + 1 , 0 : 12 )) ! halo is set to 1 allocate ( momfluxb ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( tfluxb ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( qfluxb ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( cth ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( wall ( ib : ie , jb : je , kb : ke , 5 )) momfluxb = 0. ; tfluxb = 0. ; qfluxb = 0. ; cth = 0. shear = 0. ! domain fluid volume and area calculations uoutarea = 0. ; voutarea = 0. ; fluidvol = 0. end subroutine initfields","tags":"","url":"proc/initfields.html"},{"title":"exitfields – uDALES","text":"public  subroutine exitfields() Arguments None Called by proc~~exitfields~~CalledByGraph proc~exitfields exitfields proc~exitmodules exitmodules proc~exitmodules->proc~exitfields Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine exitfields implicit none deallocate ( um , vm , wm , thlm , e12m , qtm , u0 , v0 , w0 , pres0 , thl0 , thl0h , qt0h , e120 , qt0 ) deallocate ( up , vp , wp , thlp , e12p , qtp ) deallocate ( svm , sv0 , svp , svpp ) deallocate ( ql0 , ql0h , thv0h , dthvdz , whls , presf , presh , exnf , exnh , thvf , thvh , rhof , qt0av , ql0av , thl0av , u0av , v0av ) deallocate ( ug , vg , pgx , pgy , dpdxl , dpdyl , dthldxls , dthldyls , dqtdxls , dqtdyls , dqtdtls , dudxls , dudyls , dvdxls , dvdyls , wfls ) deallocate ( thlprof , qtprof , uprof , vprof , e12prof , sv0av , svprof ) deallocate ( thlpcar ) deallocate ( momfluxb , tfluxb , qfluxb , cth ) deallocate ( SW_up_TOA , SW_dn_TOA , LW_up_TOA , LW_dn_TOA ) end subroutine exitfields","tags":"","url":"proc/exitfields.html"},{"title":"genstats – uDALES","text":"public  subroutine genstats(tsamplep, tstatsdumpp, umint, vmint, wmint) Uses modglobal modmpi modfields proc~~genstats~~UsesGraph proc~genstats genstats module~modfields modfields proc~genstats->module~modfields module~modglobal modglobal proc~genstats->module~modglobal module~modmpi modmpi proc~genstats->module~modmpi decomp_2d decomp_2d module~modfields->decomp_2d mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real :: tsamplep real :: tstatsdumpp real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) :: umint real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) :: vmint real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) :: wmint Calls proc~~genstats~~CallsGraph proc~genstats genstats proc~tkestats tkestats proc~genstats->proc~tkestats Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine genstats ( tsamplep , tstatsdumpp , umint , vmint , wmint ) use modfields , only : um , up , vm , wm , thlm , uav , vav , wav , uuav , vvav , wwav , uvav , vwav , uwav , thlav , thlwav , thlthlav , & upupav , vpvpav , wpwpav , upvpav , upwpav , vpwpav , thlpwpav use modglobal , only : ib , ie , ih , jb , je , dy , jh , ke , kb , kh , rk3step , timee , cexpnr , tsample , tstatsdump ,& ltempeq , dxf , dzf , dzhi use modmpi , only : myid , cmyid , my_real , mpi_sum , mpierr , comm3d implicit none real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ) :: umint real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ) :: vmint real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ) :: wmint real :: tstatsdumppi , tsamplep , tstatsdumpp integer :: km tstatsdumppi = 1. / tstatsdumpp !  if (lydump) then if (. not . rk3step == 3 ) return !      if (tsamplep > tsample) then !> Interpolate velocity fields to cell centers !        do k=kb-kh,ke !          do j=jb-jh,je+jh !            do i=ib-ih,ie+ih !              umint(i,j,k) = 0.5*(um(i,j,k)+um(i+1,j,k)) !              vmint(i,j,k) = 0.5*(vm(i,j,k)+vm(i,j+1,k)) !              wmint(i,j,k) = 0.5*(wm(i,j,k)+wm(i,j,k+1)) !            enddo !          enddo !        enddo do k = kb , ke do j = jb , je do i = ib , ie uav ( i , j , k ) = ( uav ( i , j , k ) * ( tstatsdumpp - tsamplep ) + umint ( i , j , k ) * tsamplep ) * tstatsdumppi vav ( i , j , k ) = ( vav ( i , j , k ) * ( tstatsdumpp - tsamplep ) + vmint ( i , j , k ) * tsamplep ) * tstatsdumppi wav ( i , j , k ) = ( wav ( i , j , k ) * ( tstatsdumpp - tsamplep ) + wmint ( i , j , k ) * tsamplep ) * tstatsdumppi uuav ( i , j , k ) = ( uuav ( i , j , k ) * ( tstatsdumpp - tsamplep ) + ( umint ( i , j , k ) ** 2 ) * tsamplep ) * tstatsdumppi vvav ( i , j , k ) = ( vvav ( i , j , k ) * ( tstatsdumpp - tsamplep ) + ( vmint ( i , j , k ) ** 2 ) * tsamplep ) * tstatsdumppi wwav ( i , j , k ) = ( wwav ( i , j , k ) * ( tstatsdumpp - tsamplep ) + ( wmint ( i , j , k ) ** 2 ) * tsamplep ) * tstatsdumppi uvav ( i , j , k ) = ( uvav ( i , j , k ) * ( tstatsdumpp - tsamplep ) + umint ( i , j , k ) * vmint ( i , j , k ) * tsamplep ) * tstatsdumppi vwav ( i , j , k ) = ( vwav ( i , j , k ) * ( tstatsdumpp - tsamplep ) + vmint ( i , j , k ) * wmint ( i , j , k ) * tsamplep ) * tstatsdumppi uwav ( i , j , k ) = ( uwav ( i , j , k ) * ( tstatsdumpp - tsamplep ) + umint ( i , j , k ) * wmint ( i , j , k ) * tsamplep ) * tstatsdumppi if ( ltempeq ) then thlav ( i , j , k ) = ( thlav ( i , j , k ) * ( tstatsdumpp - tsamplep ) + thlm ( i , j , k ) * tsamplep ) * tstatsdumppi thlwav ( i , j , k ) = ( thlwav ( i , j , k ) * ( tstatsdumpp - tsamplep ) + thlm ( i , j , k ) * wmint ( i , j , k ) * tsamplep ) * tstatsdumppi thlthlav ( i , j , k ) = ( thlthlav ( i , j , k ) * ( tstatsdumpp - tsamplep ) + ( thlm ( i , j , k ) ** 2 ) * tsamplep ) * tstatsdumppi end if end do end do end do upupav = uuav - uav ** 2 ! overline(u'u') = overline(uu) - U&#94;2 vpvpav = vvav - vav ** 2 ! overline(v'v') = overline(vv) - V&#94;2 wpwpav = wwav - wav ** 2 ! overline(w'w') = overline(ww) - W&#94;2 upvpav = uvav - uav * vav ! overline(u'v') = overline(uv) - U*V upwpav = uwav - uav * wav ! overline(u'w') = overline(uw) - U*W vpwpav = vwav - vav * wav ! overline(v'w') = overline(vw) - V*W ! thlw and svw: ib:ie jb:je kb:ke+1  (located on w-faces) !tg3315 BUT thlwav is on cell centre... do k = kb , ke + 1 km = k - 1 do j = jb , je do i = ib , ie thlpwpav ( i , j , k ) = thlwav ( i , j , k ) - & 0.5 * wav ( i , j , k ) * & ! no interpolation ( thlav ( i , j , km ) * dzf ( k ) + thlav ( i , j , k ) * dzf ( km )) * dzhi ( k ) ! interpolate thl to w-faces !              qlpwpav(i,j,k) = thlwav(i,j,k) - & !                                0.5 * wav(i,j,k) * & ! no interpolation !                               (qlav(i,j,km)*dzf(k) + qlav(i,j,k)*dzf(km))*dzhi(k) ! interpolate thl to w-faces !              qtpwpav(i,j,k) = qtwav(i,j,k) - & !                                0.5 * wav(i,j,k) * & ! no interpolation !                                (qtav(i,j,km)*dzf(k) + qtav(i,j,k)*dzf(km))*dzhi(k) ! interpolate thl to w-faces ! !              do n=1,nsv !                svpwpav(i,j,k,n) = svwav(i,j,k,n) - & !                                   0.5 * wav(i,j,k) * & ! no interpolation !                                   (svav(i,j,km,n)*dzf(k) + svav(i,j,k,n)*dzf(km))*dzhi(k) ! interpolate svav to w-faces !              end do end do end do end do !> generate time averaged stats for TKE budget and call subroutine final field values if ( ltkedump ) then call tkestats ( tsamplep , tstatsdumpp ) end if !        tsample = dt !     else !timestatsdumpp < tsample !       tsamplep = tsamplep + dt !      end if !    end if !  end if end subroutine genstats","tags":"","url":"proc/genstats.html"},{"title":"tkestats – uDALES","text":"public  subroutine tkestats(tsamplep, tstatsdumpp) Uses modsubgriddata modsurfdata modfields modstat_nc modglobal proc~~tkestats~~UsesGraph proc~tkestats tkestats module~modfields modfields proc~tkestats->module~modfields module~modglobal modglobal proc~tkestats->module~modglobal module~modstat_nc modstat_nc proc~tkestats->module~modstat_nc module~modsubgriddata modsubgriddata proc~tkestats->module~modsubgriddata module~modsurfdata modsurfdata proc~tkestats->module~modsurfdata decomp_2d decomp_2d module~modfields->decomp_2d module~modmpi modmpi module~modstat_nc->module~modmpi netcdf netcdf module~modstat_nc->netcdf mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real :: tsamplep real :: tstatsdumpp Called by proc~~tkestats~~CalledByGraph proc~tkestats tkestats proc~genstats genstats proc~genstats->proc~tkestats Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine tkestats ( tsamplep , tstatsdumpp ) ! change of variable names not yet translated across to here ! tg3315 30/11/17 use modfields , only : u0 , v0 , w0 , thlm , uyt , vyt , wyt , thlyt , pres0 ,& tvmx , tvmy , tvmz , strain2av , tsgsmx1 , tsgsmx2 , tsgsmy1 , tsgsmy2 ,& tsgsmz1 , tsgsmz2 , pres0 use modglobal , only : ib , ie , ih , jb , je , jgb , jge , dy , jh , ke , kb , kh , rk3step , cexpnr , tsample , tstatsdump , dzf , zh , dxf , dzf , numol ,& dzfi , dxfi , dyi , dy2i , dxfiq , dxhiq , dyiq , dzfi5 , dzh , dzf , dzhi , dzhiq , dxf , dxhi use modstat_nc , only : writestat_nc use modsurfdata , only : thls use modsubgriddata , only : ekm implicit none real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ) :: tekm ! turbulent viscosity !  real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)  :: emom !  real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)  :: eomm !  real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)  :: eopm !  real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)  :: epom !  real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)  :: emmo !  real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)  :: eomp !  real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)  :: epmo !  real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)  :: emop !  real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)  :: empo !  real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)  :: tkesgs !  real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)  :: nusgs !  real :: dummy integer i , j , k , im , ip , jm , jp , km , kp real tstatsdumppi , tsamplep , tstatsdumpp , strain2 , tkesgs , nusgs ,& emom , eomm , eopm , epom , emmo , eomp , epmo , emop , empo , dummy tekm (:,:,:) = ekm (:,:,:) - numol tstatsdumppi = 1. / tstatsdumpp !--------------------------------------- ! Viscous transport TKE !--------------------------------------- !> Time averaged viscous transport in x,y and z to be used to calculate the total viscous transport for TKE ! Tvmx at u-locations (ib:ih+ih:jb:je,kb:ke) ! This is similar to routine diffu time u_i do k = kb , ke kp = k + 1 km = k - 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie ip = i + 1 im = i - 1 dummy = u0 ( i , j , k ) * ( & ( numol * ( u0 ( i + 1 , j , k ) - u0 ( i , j , k )) * dxfi ( i ) & - numol * ( u0 ( i , j , k ) - u0 ( i - 1 , j , k )) * dxfi ( i - 1 ) ) * 2. * dxhi ( i ) & + & ( numol * ( ( u0 ( i , jp , k ) - u0 ( i , j , k )) * dyi & + ( v0 ( i , jp , k ) - v0 ( i - 1 , jp , k )) * dxhi ( i )) & - numol * ( ( u0 ( i , j , k ) - u0 ( i , jm , k )) * dyi & + ( v0 ( i , j , k ) - v0 ( i - 1 , j , k )) * dxhi ( i )) & ) * dyi & + & ( numol * ( ( u0 ( i , j , kp ) - u0 ( i , j , k )) * dzhi ( kp ) & + ( w0 ( i , j , kp ) - w0 ( i - 1 , j , kp )) * dxhi ( i )) & - numol * ( ( u0 ( i , j , k ) - u0 ( i , j , km )) * dzhi ( k ) & + ( w0 ( i , j , k ) - w0 ( i - 1 , j , k )) * dxhi ( i )) & ) * dzfi ( k ) ) tvmx ( i , j , k ) = ( tvmx ( i , j , k ) * ( tstatsdumpp - tsamplep ) + dummy * tsamplep ) * tstatsdumppi ! update average tvmx ! Tvmv at v-locations (ib:ih:jb:je+1,kb:ke) ! This is similar to routine diffv time v dummy = v0 ( i , j , k ) * ( & ( numol * ( ( v0 ( i + 1 , j , k ) - v0 ( i , j , k )) * dxhi ( i + 1 ) & + ( u0 ( i + 1 , j , k ) - u0 ( i + 1 , jm , k )) * dyi ) & - numol * ( ( v0 ( i , j , k ) - v0 ( i - 1 , j , k )) * dxhi ( i ) & + ( u0 ( i , j , k ) - u0 ( i , jm , k )) * dyi ) & ) * dxfi ( i ) & ! = d/dx( Km*(dv/dx + du/dy) ) + & ( numol * ( v0 ( i , jp , k ) - v0 ( i , j , k )) & - numol * ( v0 ( i , j , k ) - v0 ( i , jm , k )) ) * 2. * dy2i & ! = d/dy( 2*Km*(dv/dy) ) + & ( numol * ( ( v0 ( i , j , kp ) - v0 ( i , j , k )) * dzhi ( kp ) & + ( w0 ( i , j , kp ) - w0 ( i , jm , kp )) * dyi ) & - numol * ( ( v0 ( i , j , k ) - v0 ( i , j , km )) * dzhi ( k ) & + ( w0 ( i , j , k ) - w0 ( i , jm , k )) * dyi ) & ) * dzfi ( k ) ) ! = d/dz( Km*(dv/dz + dw/dy) ) tvmy ( i , j , k ) = ( tvmy ( i , j , k ) * ( tstatsdumpp - tsamplep ) + dummy * tsamplep ) * tstatsdumppi ! update average tvmy ! Tvmz at w-locations (ib:ih:jb:je,kb:ke+kh) ! This is similar to routine diffw time w dummy = w0 ( i , j , k ) * ( & ( numol * ( ( w0 ( i + 1 , j , k ) - w0 ( i , j , k )) * dxhi ( i + 1 ) & + ( u0 ( i + 1 , j , k ) - u0 ( i + 1 , j , km )) * dzhi ( k ) ) & - numol * ( ( w0 ( i , j , k ) - w0 ( i - 1 , j , k )) * dxhi ( i ) & + ( u0 ( i , j , k ) - u0 ( i , j , km )) * dzhi ( k ) ) & ) * dxfi ( i ) & + & ( numol * ( ( w0 ( i , jp , k ) - w0 ( i , j , k )) * dyi & + ( v0 ( i , jp , k ) - v0 ( i , jp , km )) * dzhi ( k ) ) & - numol * ( ( w0 ( i , j , k ) - w0 ( i , jm , k )) * dyi & + ( v0 ( i , j , k ) - v0 ( i , j , km )) * dzhi ( k ) ) & ) * dyi & + & ( numol * ( w0 ( i , j , kp ) - w0 ( i , j , k )) * dzfi ( k ) & - numol * ( w0 ( i , j , k ) - w0 ( i , j , km )) * dzfi ( km ) ) * 2. & * dzhi ( k ) ) tvmz ( i , j , k ) = ( tvmz ( i , j , k ) * ( tstatsdumpp - tsamplep ) + dummy * tsamplep ) * tstatsdumppi ! update average uwsgsav ! Compute stresses and fluxes at c.c. , also used in total viscous transport strain2 = ( & (( u0 ( ip , j , k ) - u0 ( i , j , k )) * dxfi ( i ) ) ** 2 + & (( v0 ( i , jp , k ) - v0 ( i , j , k )) * dyi ) ** 2 + & (( w0 ( i , j , kp ) - w0 ( i , j , k )) * dzfi ( k ) ) ** 2 ) strain2 = strain2 + 0.125 * ( & (( w0 ( i , j , kp ) - w0 ( im , j , kp )) * dxhi ( i ) + & ( u0 ( i , j , kp ) - u0 ( i , j , k )) * dzhi ( kp ) ) ** 2 + & (( w0 ( i , j , k ) - w0 ( im , j , k )) * dxhi ( i ) + & ( u0 ( i , j , k ) - u0 ( i , j , km )) * dzhi ( k ) ) ** 2 + & (( w0 ( ip , j , k ) - w0 ( i , j , k )) * dxhi ( ip ) + & ( u0 ( ip , j , k ) - u0 ( ip , j , km )) * dzhi ( k ) ) ** 2 + & (( w0 ( ip , j , kp ) - w0 ( i , j , kp )) * dxhi ( ip ) + & ( u0 ( ip , j , kp ) - u0 ( ip , j , k )) * dzhi ( kp ) ) ** 2 ) strain2 = strain2 + 0.125 * ( & (( u0 ( i , jp , k ) - u0 ( i , j , k )) * dyi + & ( v0 ( i , jp , k ) - v0 ( im , jp , k )) * dxhi ( i ) ) ** 2 + & (( u0 ( i , j , k ) - u0 ( i , jm , k )) * dyi + & ( v0 ( i , j , k ) - v0 ( im , j , k )) * dxhi ( i ) ) ** 2 + & (( u0 ( ip , j , k ) - u0 ( ip , jm , k )) * dyi + & ( v0 ( ip , j , k ) - v0 ( i , j , k )) * dxhi ( ip ) ) ** 2 + & (( u0 ( ip , jp , k ) - u0 ( ip , j , k )) * dyi + & ( v0 ( ip , jp , k ) - v0 ( i , jp , k )) * dxhi ( ip ) ) ** 2 ) strain2 = strain2 + 0.125 * ( & (( v0 ( i , j , kp ) - v0 ( i , j , k )) * dzhi ( kp ) + & ( w0 ( i , j , kp ) - w0 ( i , jm , kp )) * dyi ) ** 2 + & (( v0 ( i , j , k ) - v0 ( i , j , km )) * dzhi ( k ) + & ( w0 ( i , j , k ) - w0 ( i , jm , k )) * dyi ) ** 2 + & (( v0 ( i , jp , k ) - v0 ( i , jp , km )) * dzhi ( k ) + & ( w0 ( i , jp , k ) - w0 ( i , j , k )) * dyi ) ** 2 + & (( v0 ( i , jp , kp ) - v0 ( i , jp , k )) * dzhi ( kp ) + & ( w0 ( i , jp , kp ) - w0 ( i , j , kp )) * dyi ) ** 2 ) strain2av ( i , j , k ) = ( strain2av ( i , j , k ) * ( tstatsdumpp - tsamplep ) + strain2 * tsamplep ) * tstatsdumppi ! update average strain2av !-------------------------------------------------- !> SGS TKE !-------------------------------------------------- ! x-direction emom = ( dzf ( km ) * ( tekm ( i , j , k ) * dxf ( i - 1 ) + tekm ( i - 1 , j , k ) * dxf ( i ) ) + & ! dx is non-equidistant dzf ( k ) * ( tekm ( i , j , km ) * dxf ( i - 1 ) + tekm ( i - 1 , j , km ) * dxf ( i ) ) ) * dxhi ( i ) * dzhiq ( k ) emop = ( dzf ( kp ) * ( tekm ( i , j , k ) * dxf ( i - 1 ) + tekm ( i - 1 , j , k ) * dxf ( i ) ) + & ! dx is non-equidistant dzf ( k ) * ( tekm ( i , j , kp ) * dxf ( i - 1 ) + tekm ( i - 1 , j , kp ) * dxf ( i ) ) ) * dxhi ( i ) * dzhiq ( kp ) empo = 0.25 * ( ( tekm ( i , j , k ) + tekm ( i , jp , k )) * dxf ( i - 1 ) + ( tekm ( i - 1 , j , k ) + tekm ( i - 1 , jp , k )) * dxf ( i ) ) * dxhi ( i ) ! dx is non-equidistant emmo = 0.25 * ( ( tekm ( i , j , k ) + tekm ( i , jm , k )) * dxf ( i - 1 ) + ( tekm ( i - 1 , jm , k ) + tekm ( i - 1 , j , k )) * dxf ( i ) ) * dxhi ( i ) ! dx is non-equidistant !        dummy =  u0(i,j,k)*(                           & dummy = ( & ( tekm ( i , j , k ) * ( u0 ( i + 1 , j , k ) - u0 ( i , j , k )) * dxfi ( i ) & - tekm ( i - 1 , j , k ) * ( u0 ( i , j , k ) - u0 ( i - 1 , j , k )) * dxfi ( i - 1 ) ) * 2. * dxhi ( i ) & + & ( empo * ( ( u0 ( i , jp , k ) - u0 ( i , j , k )) * dyi & + ( v0 ( i , jp , k ) - v0 ( i - 1 , jp , k )) * dxhi ( i )) & - emmo * ( ( u0 ( i , j , k ) - u0 ( i , jm , k )) * dyi & + ( v0 ( i , j , k ) - v0 ( i - 1 , j , k )) * dxhi ( i )) & ) * dyi & + & ( emop * ( ( u0 ( i , j , kp ) - u0 ( i , j , k )) * dzhi ( kp ) & + ( w0 ( i , j , kp ) - w0 ( i - 1 , j , kp )) * dxhi ( i )) & - emom * ( ( u0 ( i , j , k ) - u0 ( i , j , km )) * dzhi ( k ) & + ( w0 ( i , j , k ) - w0 ( i - 1 , j , k )) * dxhi ( i )) & ) * dzfi ( k ) ) tsgsmx1 ( i , j , k ) = ( tsgsmx1 ( i , j , k ) * ( tstatsdumpp - tsamplep ) + dummy * u0 ( i , j , k ) * tsamplep ) * tstatsdumppi ! update average tsgsmx1 tsgsmx2 ( i , j , k ) = ( tsgsmx2 ( i , j , k ) * ( tstatsdumpp - tsamplep ) + dummy * tsamplep ) * tstatsdumppi ! update average tsgsmx2 ! y-direction eomm = ( dzf ( km ) * ( tekm ( i , j , k ) + tekm ( i , jm , k ) ) + & dzf ( k ) * ( tekm ( i , j , km ) + tekm ( i , jm , km ) ) ) * dzhiq ( k ) eomp = ( dzf ( kp ) * ( tekm ( i , j , k ) + tekm ( i , jm , k ) ) + & dzf ( k ) * ( tekm ( i , j , kp ) + tekm ( i , jm , kp ) ) ) * dzhiq ( kp ) emmo = 0.25 * ( ( tekm ( i , j , k ) + tekm ( i , jm , k )) * dxf ( i - 1 ) + ( tekm ( i - 1 , jm , k ) + tekm ( i - 1 , j , k )) * dxf ( i ) ) * dxhi ( i ) ! dx is non-equidistant epmo = 0.25 * ( ( tekm ( i , j , k ) + tekm ( i , jm , k )) * dxf ( i + 1 ) + ( tekm ( i + 1 , jm , k ) + tekm ( i + 1 , j , k )) * dxf ( i ) ) * dxhi ( i + 1 ) ! dx is non-equidistant !       dummy = v0(i,j,k) * (                            & dummy = ( & ( epmo * ( ( v0 ( i + 1 , j , k ) - v0 ( i , j , k )) * dxhi ( i + 1 ) & + ( u0 ( i + 1 , j , k ) - u0 ( i + 1 , jm , k )) * dyi ) & - emmo * ( ( v0 ( i , j , k ) - v0 ( i - 1 , j , k )) * dxhi ( i ) & + ( u0 ( i , j , k ) - u0 ( i , jm , k )) * dyi ) & ) * dxfi ( i ) & ! = d/dx( Km*(dv/dx + du/dy) ) + & ( tekm ( i , j , k ) * ( v0 ( i , jp , k ) - v0 ( i , j , k )) & - tekm ( i , jm , k ) * ( v0 ( i , j , k ) - v0 ( i , jm , k )) ) * 2. * dy2i & ! = d/dy( 2*Km*(dv/dy) ) + & ( eomp * ( ( v0 ( i , j , kp ) - v0 ( i , j , k )) * dzhi ( kp ) & + ( w0 ( i , j , kp ) - w0 ( i , jm , kp )) * dyi ) & - eomm * ( ( v0 ( i , j , k ) - v0 ( i , j , km )) * dzhi ( k ) & + ( w0 ( i , j , k ) - w0 ( i , jm , k )) * dyi ) & ) * dzfi ( k ) ) ! = d/dz( Km*(dv/dz + dw/dy) ) tsgsmy1 ( i , j , k ) = ( tsgsmy1 ( i , j , k ) * ( tstatsdumpp - tsamplep ) + dummy * v0 ( i , j , k ) * tsamplep ) * tstatsdumppi ! update average tsgsmy1  = <v*d/dxj(2*nu*S2j)> tsgsmy2 ( i , j , k ) = ( tsgsmy2 ( i , j , k ) * ( tstatsdumpp - tsamplep ) + dummy * tsamplep ) * tstatsdumppi ! update average tsgsmy2  = <d/dxj(2*nu*S2j)> ! z-direction emom = ( dzf ( km ) * ( tekm ( i , j , k ) * dxf ( i - 1 ) + tekm ( i - 1 , j , k ) * dxf ( i ) ) * dxhi ( i ) + & dzf ( k ) * ( tekm ( i , j , km ) * dxf ( i - 1 ) + tekm ( i - 1 , j , km ) * dxf ( i ) ) * dxhi ( i ) ) * dzhiq ( k ) eomm = ( dzf ( km ) * ( tekm ( i , j , k ) + tekm ( i , jm , k ) ) + & dzf ( k ) * ( tekm ( i , j , km ) + tekm ( i , jm , km ) ) ) * dzhiq ( k ) eopm = ( dzf ( km ) * ( tekm ( i , j , k ) + tekm ( i , jp , k ) ) + & dzf ( k ) * ( tekm ( i , j , km ) + tekm ( i , jp , km ) ) ) * dzhiq ( k ) epom = ( dzf ( km ) * ( tekm ( i , j , k ) * dxf ( i + 1 ) + tekm ( i + 1 , j , k ) * dxf ( i ) ) * dxhi ( i + 1 ) + & dzf ( k ) * ( tekm ( i , j , km ) * dxf ( i + 1 ) + tekm ( i + 1 , j , km ) * dxf ( i ) ) * dxhi ( i + 1 ) ) * dzhiq ( k ) !        dummy = w0(i,j,k) * (                                         & dummy = ( & ( epom * ( ( w0 ( i + 1 , j , k ) - w0 ( i , j , k )) * dxhi ( i + 1 ) & + ( u0 ( i + 1 , j , k ) - u0 ( i + 1 , j , km )) * dzhi ( k ) ) & - emom * ( ( w0 ( i , j , k ) - w0 ( i - 1 , j , k )) * dxhi ( i ) & + ( u0 ( i , j , k ) - u0 ( i , j , km )) * dzhi ( k ) ) & ) * dxfi ( i ) & + & ( eopm * ( ( w0 ( i , jp , k ) - w0 ( i , j , k )) * dyi & + ( v0 ( i , jp , k ) - v0 ( i , jp , km )) * dzhi ( k ) ) & - eomm * ( ( w0 ( i , j , k ) - w0 ( i , jm , k )) * dyi & + ( v0 ( i , j , k ) - v0 ( i , j , km )) * dzhi ( k ) ) & ) * dyi & + & ( tekm ( i , j , k ) * ( w0 ( i , j , kp ) - w0 ( i , j , k )) * dzfi ( k ) & - tekm ( i , j , km ) * ( w0 ( i , j , k ) - w0 ( i , j , km )) * dzfi ( km ) ) * 2. & * dzhi ( k )) tsgsmz1 ( i , j , k ) = ( tsgsmz1 ( i , j , k ) * ( tstatsdumpp - tsamplep ) + dummy * w0 ( i , j , k ) * tsamplep ) * tstatsdumppi ! update average tsgsmz1 = <w*d/dxj(2*nu*S3j)> tsgsmz2 ( i , j , k ) = ( tsgsmz2 ( i , j , k ) * ( tstatsdumpp - tsamplep ) + dummy * tsamplep ) * tstatsdumppi ! update average tsgsmz2 = <d/dxj(2*nu*S3j)> end do end do end do end subroutine tkestats","tags":"","url":"proc/tkestats.html"},{"title":"initmpi – uDALES","text":"public  subroutine initmpi() Uses decomp_2d proc~~initmpi~~UsesGraph proc~initmpi initmpi decomp_2d decomp_2d proc~initmpi->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~initmpi~~CallsGraph proc~initmpi initmpi mpi_comm_rank mpi_comm_rank proc~initmpi->mpi_comm_rank mpi_comm_size mpi_comm_size proc~initmpi->mpi_comm_size mpi_init mpi_init proc~initmpi->mpi_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~initmpi~~CalledByGraph proc~initmpi initmpi program~dalesurban DALESURBAN program~dalesurban->proc~initmpi Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine initmpi use decomp_2d , only : nrank , nproc implicit none ! integer dims(1) ! logical periods(1) ! integer periods2(1) call MPI_INIT ( mpierr ) MY_REAL = MPI_DOUBLE_PRECISION !MPI_REAL8 should be the same.. comm3d = MPI_COMM_WORLD call MPI_COMM_RANK ( MPI_COMM_WORLD , nrank , mpierr ) call MPI_COMM_SIZE ( MPI_COMM_WORLD , nproc , mpierr ) myid = nrank nprocs = nproc write ( cmyid , '(i3.3)' ) myid ! ! Specify the # procs in each direction. ! ! specifying a 0 means that MPI will try to find a useful # procs in ! ! the corresponding  direction, ! ! ! specifying 1 means only 1 processor in this direction, meaning that ! ! we have in fact a grid of (at most) 2 dimensions left. This is used ! ! when we want the array index range in 1 particular direction to be ! ! present on all processors in the grid ! !     dims(1) = 0 ! ! ! ! directions 1 and 2 are chosen periodic ! ! !     periods(1) = .true. ! ! Soares 20080115 !     periods2(1) = 1 ! ! ! find suitable # procs in each direction ! !     call MPI_DIMS_CREATE( nprocs, 1, dims, mpierr ) ! ! ! create the Cartesian communicator, denoted by the integer comm3d ! !     ! BUG - Thijs, Harm !     !call MPI_CART_CREATE(MPI_COMM_WORLD, 1, dims, periods,.false., & !     !                    comm3d, ierr ) ! !     call MPI_CART_CREATE(MPI_COMM_WORLD, 1, dims, periods,.true., & !                         comm3d, mpierr ) ! ! ! Soares 20080115 ! !     call MPI_CART_CREATE(MPI_COMM_WORLD, 1, dims, periods2,1, & ! !                         comm3d, mpierr ) ! ! ! Get my processor number in this communicator ! !     call MPI_COMM_RANK( comm3d, myid, mpierr ) ! ! ! ! when applying boundary conditions, we need to know which processors ! ! are neighbours in all 3 directions ! ! ! ! these are determined with the aid of the MPI routine MPI_CART_SHIFT, ! !     call MPI_CART_SHIFT( comm3d, 0,  1, nbrbottom, nbrtop,   mpierr ) ! ! ! determine some useful MPI datatypes for sending/receiving data ! !      write(cmyid,'(i3.3)') myid ! ! if(myid==0)then !   CPU_program0 = MPI_Wtime() ! end if ! !     write(*,*)'nprocs = ', nprocs end subroutine initmpi","tags":"","url":"proc/initmpi.html"},{"title":"starttimer – uDALES","text":"public  subroutine starttimer() Arguments None Calls proc~~starttimer~~CallsGraph proc~starttimer starttimer mpi_wtime mpi_wtime proc~starttimer->mpi_wtime Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~starttimer~~CalledByGraph proc~starttimer starttimer program~dalesurban DALESURBAN program~dalesurban->proc~starttimer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine starttimer if ( myid == 0 ) then CPU_program0 = MPI_Wtime () end if end subroutine starttimer","tags":"","url":"proc/starttimer.html"},{"title":"exitmpi – uDALES","text":"public  subroutine exitmpi() Uses decomp_2d proc~~exitmpi~~UsesGraph proc~exitmpi exitmpi decomp_2d decomp_2d proc~exitmpi->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~exitmpi~~CallsGraph proc~exitmpi exitmpi decomp_2d_finalize decomp_2d_finalize proc~exitmpi->decomp_2d_finalize mpi_finalize mpi_finalize proc~exitmpi->mpi_finalize mpi_wtime mpi_wtime proc~exitmpi->mpi_wtime Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~exitmpi~~CalledByGraph proc~exitmpi exitmpi proc~exitmodules exitmodules proc~exitmodules->proc~exitmpi program~dalesurban DALESURBAN program~dalesurban->proc~exitmpi Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine exitmpi use decomp_2d implicit none if ( myid == 0 ) then CPU_program = MPI_Wtime () - CPU_program0 write ( 6 , * ) 'TOTAL CPU time = ' , CPU_program end if !call MPI_Comm_free( comm3d, mpierr ) !call MPI_FINALIZE(mpierr) call decomp_2d_finalize call MPI_FINALIZE ( mpierr ) end subroutine exitmpi","tags":"","url":"proc/exitmpi.html"},{"title":"barrou – uDALES","text":"public  subroutine barrou() Arguments None Calls proc~~barrou~~CallsGraph proc~barrou barrou mpi_barrier mpi_barrier proc~barrou->mpi_barrier Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine barrou () implicit none call MPI_BARRIER ( comm3d , mpierr ) return end subroutine barrou","tags":"","url":"proc/barrou.html"},{"title":"excis – uDALES","text":"public  subroutine excis(a, sx, ex, sy, ey, sz, ez, ih, jh) Arguments Type Intent Optional Attributes Name real :: a (sx-ih:ex+ih,sy-jh:ey+jh,sz:ez) integer :: sx integer :: ex integer :: sy integer :: ey integer :: sz integer :: ez integer :: ih integer :: jh Calls proc~~excis~~CallsGraph proc~excis excis mpi_isend mpi_isend proc~excis->mpi_isend mpi_recv mpi_recv proc~excis->mpi_recv mpi_wait mpi_wait proc~excis->mpi_wait Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine excis ( a , sx , ex , sy , ey , sz , ez , ih , jh ) implicit none integer sx , ex , sy , ey , sz , ez , ih , jh real a ( sx - ih : ex + ih , sy - jh : ey + jh , sz : ez ) integer status ( MPI_STATUS_SIZE ) integer ii , i , j , k integer reqe , reqw integer ewsize real , allocatable , dimension (:) :: sende , recve real , allocatable , dimension (:) :: sendw , recvw !   Calculate buffer size ewsize = ih * ( ey - sy + 1 + 2 * jh ) * ( ez - sz + 1 ) !   Allocate send / receive buffers allocate ( sende ( ewsize ), sendw ( ewsize )) allocate ( recve ( ewsize ), recvw ( ewsize )) if ( nprocx . gt . 1 ) then !   Send east/west ii = 0 do i = 1 , ih do k = sz , ez do j = sy - jh , ey + jh ii = ii + 1 sende ( ii ) = a ( ex - i + 1 , j , k ) sendw ( ii ) = a ( sx + i - 1 , j , k ) enddo enddo enddo call MPI_ISEND ( sende , ewsize , MY_REAL , nbreast , 6 , comm3d , reqe , mpierr ) call MPI_ISEND ( sendw , ewsize , MY_REAL , nbrwest , 7 , comm3d , reqw , mpierr ) !   Receive west/east call MPI_RECV ( recvw , ewsize , MY_REAL , nbrwest , 6 , comm3d , status , mpierr ) call MPI_RECV ( recve , ewsize , MY_REAL , nbreast , 7 , comm3d , status , mpierr ) ii = 0 do i = 1 , ih do k = sz , ez do j = sy - jh , ey + jh ii = ii + 1 a ( sx - i , j , k ) = recvw ( ii ) a ( ex + i , j , k ) = recve ( ii ) enddo enddo enddo else ! Single processor, make sure the field is periodic do i = 1 , ih do k = sz , ez do j = sy - jh , ey + jh a ( sx - i , j , k ) = a ( ex - i + 1 , j , k ) a ( ex + i , j , k ) = a ( sx + i - 1 , j , k ) enddo enddo enddo endif if ( nprocx . gt . 1 ) then call MPI_WAIT ( reqe , status , mpierr ) call MPI_WAIT ( reqw , status , mpierr ) endif deallocate ( sende , sendw ) deallocate ( recve , recvw ) return end subroutine excis","tags":"","url":"proc/excis.html"},{"title":"excjs – uDALES","text":"public  subroutine excjs(a, sx, ex, sy, ey, sz, ez, ih, jh) Arguments Type Intent Optional Attributes Name real :: a (sx-ih:ex+ih,sy-jh:ey+jh,sz:ez) integer :: sx integer :: ex integer :: sy integer :: ey integer :: sz integer :: ez integer :: ih integer :: jh Calls proc~~excjs~~CallsGraph proc~excjs excjs mpi_isend mpi_isend proc~excjs->mpi_isend mpi_recv mpi_recv proc~excjs->mpi_recv mpi_wait mpi_wait proc~excjs->mpi_wait Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~excjs~~CalledByGraph proc~excjs excjs proc~readinletfile readinletfile proc~readinletfile->proc~excjs proc~inletgen inletgen proc~inletgen->proc~readinletfile proc~inletgennotemp inletgennotemp proc~inletgennotemp->proc~readinletfile proc~readinitfiles readinitfiles proc~readinitfiles->proc~readinletfile program~dalesurban DALESURBAN program~dalesurban->proc~readinitfiles Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine excjs ( a , sx , ex , sy , ey , sz , ez , ih , jh ) implicit none integer sx , ex , sy , ey , sz , ez , ih , jh real a ( sx - ih : ex + ih , sy - jh : ey + jh , sz : ez ) integer status ( MPI_STATUS_SIZE ) integer ii , i , j , k integer reqn , reqs integer nssize real , allocatable , dimension (:) :: sendn , recvn real , allocatable , dimension (:) :: sends , recvs !   Calculate buffer size nssize = jh * ( ex - sx + 1 + 2 * ih ) * ( ez - sz + 1 ) !   Allocate send / receive buffers allocate ( sendn ( nssize ), sends ( nssize )) allocate ( recvn ( nssize ), recvs ( nssize )) if ( nprocy . gt . 1 ) then !   Send north/south ii = 0 do j = 1 , jh do k = sz , ez do i = sx - ih , ex + ih ii = ii + 1 sendn ( ii ) = a ( i , ey - j + 1 , k ) sends ( ii ) = a ( i , sy + j - 1 , k ) enddo enddo enddo call MPI_ISEND ( sendn , nssize , MY_REAL , nbrnorth , 4 , comm3d , reqn , mpierr ) call MPI_ISEND ( sends , nssize , MY_REAL , nbrsouth , 5 , comm3d , reqs , mpierr ) !   Receive south/north call MPI_RECV ( recvs , nssize , MY_REAL , nbrsouth , 4 , comm3d , status , mpierr ) call MPI_RECV ( recvn , nssize , MY_REAL , nbrnorth , 5 , comm3d , status , mpierr ) ii = 0 do j = 1 , jh do k = sz , ez do i = sx - ih , ex + ih ii = ii + 1 a ( i , sy - j , k ) = recvs ( ii ) a ( i , ey + j , k ) = recvn ( ii ) enddo enddo enddo else ! Single processor, make sure the field is periodic do j = 1 , jh do k = sz , ez do i = sx - ih , ex + ih a ( i , sy - j , k ) = a ( i , ey - j + 1 , k ) a ( i , ey + j , k ) = a ( i , sy + j - 1 , k ) enddo enddo enddo endif if ( nprocy . gt . 1 ) then call MPI_WAIT ( reqn , status , mpierr ) call MPI_WAIT ( reqs , status , mpierr ) endif deallocate ( sendn , sends ) deallocate ( recvn , recvs ) return end subroutine excjs","tags":"","url":"proc/excjs.html"},{"title":"slabsum – uDALES","text":"public  subroutine slabsum(aver, ks, kf, var, ib, ie, jb, je, kb, ke, ibs, ies, jbs, jes, kbs, kes) Arguments Type Intent Optional Attributes Name real :: aver (ks:kf) integer :: ks integer :: kf real :: var (ib:ie,jb:je,kb:ke) integer :: ib integer :: ie integer :: jb integer :: je integer :: kb integer :: ke integer :: ibs integer :: ies integer :: jbs integer :: jes integer :: kbs integer :: kes Calls proc~~slabsum~~CallsGraph proc~slabsum slabsum mpi_allreduce mpi_allreduce proc~slabsum->mpi_allreduce Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~slabsum~~CalledByGraph proc~slabsum slabsum proc~inletgen inletgen proc~inletgen->proc~slabsum proc~inletgennotemp inletgennotemp proc~inletgennotemp->proc~slabsum proc~readinitfiles readinitfiles proc~readinitfiles->proc~slabsum program~dalesurban DALESURBAN program~dalesurban->proc~readinitfiles Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine slabsum ( aver , ks , kf , var , ib , ie , jb , je , kb , ke , ibs , ies , jbs , jes , kbs , kes ) implicit none integer :: ks , kf integer :: ib , ie , jb , je , kb , ke , ibs , ies , jbs , jes , kbs , kes real :: aver ( ks : kf ) real :: var ( ib : ie , jb : je , kb : ke ) real :: averl ( ks : kf ) real :: avers ( ks : kf ) integer :: k averl = 0. avers = 0. do k = kbs , kes averl ( k ) = sum ( var ( ibs : ies , jbs : jes , k )) enddo call MPI_ALLREDUCE ( averl , avers , kf - ks + 1 , MY_REAL , & MPI_SUM , comm3d , mpierr ) aver = aver + avers return end subroutine slabsum","tags":"","url":"proc/slabsum.html"},{"title":"avexy_ibm – uDALES","text":"public  subroutine avexy_ibm(aver, var, ib, ie, jb, je, kb, ke, ih, jh, kh, II, IIs, lnan) Arguments Type Intent Optional Attributes Name real :: aver (kb:ke+kh) real :: var (ib:ie,jb:je,kb:ke+kh) integer :: ib integer :: ie integer :: jb integer :: je integer :: kb integer :: ke integer :: ih integer :: jh integer :: kh integer :: II (ib:ie,jb:je,kb:ke+kh) integer :: IIs (kb:ke+kh) logical :: lnan Calls proc~~avexy_ibm~~CallsGraph proc~avexy_ibm avexy_ibm mpi_allreduce mpi_allreduce proc~avexy_ibm->mpi_allreduce Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~avexy_ibm~~CalledByGraph proc~avexy_ibm avexy_ibm proc~bcpup bcpup proc~bcpup->proc~avexy_ibm proc~diagfld diagfld proc~diagfld->proc~avexy_ibm proc~fluidvolume fluidvolume proc~fluidvolume->proc~avexy_ibm proc~masscorr masscorr proc~masscorr->proc~avexy_ibm proc~readinitfiles readinitfiles proc~readinitfiles->proc~avexy_ibm proc~thermodynamics thermodynamics proc~readinitfiles->proc~thermodynamics proc~statsdump statsdump proc~statsdump->proc~avexy_ibm proc~tkestatsdump tkestatsdump proc~statsdump->proc~tkestatsdump proc~thermodynamics->proc~avexy_ibm proc~thermodynamics->proc~diagfld proc~tkestatsdump->proc~avexy_ibm proc~calcfluidvolumes calcfluidvolumes proc~calcfluidvolumes->proc~fluidvolume program~dalesurban DALESURBAN program~dalesurban->proc~masscorr program~dalesurban->proc~readinitfiles program~dalesurban->proc~statsdump program~dalesurban->proc~thermodynamics program~dalesurban->proc~calcfluidvolumes Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine avexy_ibm ( aver , var , ib , ie , jb , je , kb , ke , ih , jh , kh , II , IIs , lnan ) implicit none integer :: ib , ie , jb , je , kb , ke , ih , jh , kh real :: aver ( kb : ke + kh ) real :: var ( ib : ie , jb : je , kb : ke + kh ) integer :: II ( ib : ie , jb : je , kb : ke + kh ) integer :: IIs ( kb : ke + kh ) integer :: IId ( kb : ke + kh ) real :: averl ( kb : ke + kh ) real :: avers ( kb : ke + kh ) integer :: k logical :: lnan averl = 0. avers = 0. do k = kb , ke + kh averl ( k ) = sum ( var ( ib : ie , jb : je , k ) * II ( ib : ie , jb : je , k )) enddo IId = IIs ! tg3315 22.03.19 - if not calculating stats and all blocks on lowest layer... ! should not be necessary but value at kb is used in modthermo so reasonable value must ! be assigned. Potentially should leave as before and only account for in modthermo... if ((. not . lnan ) . and . ( IId ( kb ) == 0 )) then averl ( kb ) = sum ( var ( ib : ie , jb : je , kb )) IId ( kb ) = IId ( ke ) end if call MPI_ALLREDUCE ( averl , avers , ke + kh - kb + 1 , MY_REAL , & MPI_SUM , comm3d , mpierr ) where ( IId == 0 ) aver = - 99 9. elsewhere aver = avers / IId endwhere return end subroutine avexy_ibm","tags":"","url":"proc/avexy_ibm.html"},{"title":"slabsumi – uDALES","text":"public  subroutine slabsumi(aver, iis, iif, var, ib, ie, jb, je, kb, ke, ibs, ies, jbs, jes, kbs, kes) Arguments Type Intent Optional Attributes Name real :: aver (iis:iif) integer :: iis integer :: iif real :: var (ib:ie,jb:je,kb:ke) integer :: ib integer :: ie integer :: jb integer :: je integer :: kb integer :: ke integer :: ibs integer :: ies integer :: jbs integer :: jes integer :: kbs integer :: kes Calls proc~~slabsumi~~CallsGraph proc~slabsumi slabsumi mpi_allreduce mpi_allreduce proc~slabsumi->mpi_allreduce Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine slabsumi ( aver , iis , iif , var , ib , ie , jb , je , kb , ke , ibs , ies , jbs , jes , kbs , kes ) implicit none integer :: iis , iif integer :: ib , ie , jb , je , kb , ke , ibs , ies , jbs , jes , kbs , kes real :: aver ( iis : iif ) real :: var ( ib : ie , jb : je , kb : ke ) real :: averl ( iis : iif ) real :: avers ( iis : iif ) integer :: i averl = 0. avers = 0. do i = ibs , ies averl ( i ) = sum ( var ( i , jbs : jes , kbs : kes )) enddo call MPI_ALLREDUCE ( averl , avers , iif - iis + 1 , MY_REAL , & MPI_SUM , comm3d , mpierr ) aver = aver + avers return end subroutine slabsumi","tags":"","url":"proc/slabsumi.html"},{"title":"avey_ibm – uDALES","text":"public  subroutine avey_ibm(aver, var, ib, ie, jb, je, kb, ke, II, IIt) Arguments Type Intent Optional Attributes Name real :: aver (ib:ie,kb:ke) real :: var (ib:ie,jb:je,kb:ke) integer :: ib integer :: ie integer :: jb integer :: je integer :: kb integer :: ke integer :: II (ib:ie,jb:je,kb:ke) integer :: IIt (ib:ie,kb:ke) Calls proc~~avey_ibm~~CallsGraph proc~avey_ibm avey_ibm mpi_allreduce mpi_allreduce proc~avey_ibm->mpi_allreduce Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~avey_ibm~~CalledByGraph proc~avey_ibm avey_ibm proc~statsdump statsdump proc~statsdump->proc~avey_ibm program~dalesurban DALESURBAN program~dalesurban->proc~statsdump Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine avey_ibm ( aver , var , ib , ie , jb , je , kb , ke , II , IIt ) implicit none integer :: ib , ie , jb , je , kb , ke real :: aver ( ib : ie , kb : ke ) real :: avero ( ib : ie , kb : ke ) real :: var ( ib : ie , jb : je , kb : ke ) integer :: II ( ib : ie , jb : je , kb : ke ) integer :: IIt ( ib : ie , kb : ke ) logical :: lytdump , lnan avero = 0. aver = 0. avero = sum ( var ( ib : ie , jb : je , kb : ke ) * II ( ib : ie , jb : je , kb : ke ), DIM = 2 ) call MPI_ALLREDUCE ( avero ( ib : ie , kb : ke ), aver ( ib : ie , kb : ke ), ( ke - kb + 1 ) * ( ie - ib + 1 ), MY_REAL , MPI_SUM , comm3d , mpierr ) where ( IIt == 0 ) aver = - 99 9. elsewhere aver = aver / IIt endwhere end subroutine avey_ibm","tags":"","url":"proc/avey_ibm.html"},{"title":"sumy_ibm – uDALES","text":"public  subroutine sumy_ibm(sumy, var, ib, ie, jb, je, kb, ke, II) Arguments Type Intent Optional Attributes Name real :: sumy (ib:ie,kb:ke) real :: var (ib:ie,jb:je,kb:ke) integer :: ib integer :: ie integer :: jb integer :: je integer :: kb integer :: ke integer :: II (ib:ie,jb:je,kb:ke) Calls proc~~sumy_ibm~~CallsGraph proc~sumy_ibm sumy_ibm mpi_allreduce mpi_allreduce proc~sumy_ibm->mpi_allreduce Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~sumy_ibm~~CalledByGraph proc~sumy_ibm sumy_ibm proc~masscorr masscorr proc~masscorr->proc~sumy_ibm proc~uoutletarea uoutletarea proc~uoutletarea->proc~sumy_ibm proc~calcfluidvolumes calcfluidvolumes proc~calcfluidvolumes->proc~uoutletarea program~dalesurban DALESURBAN program~dalesurban->proc~masscorr program~dalesurban->proc~calcfluidvolumes Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine sumy_ibm ( sumy , var , ib , ie , jb , je , kb , ke , II ) ! This routine sums up a variable over the y direction, ! only including the fluid cells. implicit none integer :: ib , ie , jb , je , kb , ke real :: sumy ( ib : ie , kb : ke ) real :: sumproc ( ib : ie , kb : ke ) real :: var ( ib : ie , jb : je , kb : ke ) integer :: II ( ib : ie , jb : je , kb : ke ) sumproc = 0. sumy = 0. sumproc = sum ( var ( ib : ie , jb : je , kb : ke ) * II ( ib : ie , jb : je , kb : ke ), DIM = 2 ) call MPI_ALLREDUCE ( sumproc ( ib : ie , kb : ke ), sumy ( ib : ie , kb : ke ), ( ke - kb + 1 ) * ( ie - ib + 1 ), MY_REAL , MPI_SUM , comm3d , mpierr ) end subroutine sumy_ibm","tags":"","url":"proc/sumy_ibm.html"},{"title":"sumx_ibm – uDALES","text":"public  subroutine sumx_ibm(sumx, var, ib, ie, jb, je, kb, ke, II) Arguments Type Intent Optional Attributes Name real :: sumx (jb:je,kb:ke) real :: var (ib:ie,jb:je,kb:ke) integer :: ib integer :: ie integer :: jb integer :: je integer :: kb integer :: ke integer :: II (ib:ie,jb:je,kb:ke) Calls proc~~sumx_ibm~~CallsGraph proc~sumx_ibm sumx_ibm mpi_allreduce mpi_allreduce proc~sumx_ibm->mpi_allreduce Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~sumx_ibm~~CalledByGraph proc~sumx_ibm sumx_ibm proc~voutletarea voutletarea proc~voutletarea->proc~sumx_ibm proc~calcfluidvolumes calcfluidvolumes proc~calcfluidvolumes->proc~voutletarea program~dalesurban DALESURBAN program~dalesurban->proc~calcfluidvolumes Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine sumx_ibm ( sumx , var , ib , ie , jb , je , kb , ke , II ) ! This routine sums up a variable over the x direction, ! only including the fluid cells. implicit none integer :: ib , ie , jb , je , kb , ke real :: sumx ( jb : je , kb : ke ) real :: sumproc ( jb : je , kb : ke ) real :: var ( ib : ie , jb : je , kb : ke ) integer :: II ( ib : ie , jb : je , kb : ke ) sumproc = 0. sumx = 0. sumproc = sum ( var ( ib : ie , jb : je , kb : ke ) * II ( ib : ie , jb : je , kb : ke ), DIM = 1 ) call MPI_ALLREDUCE ( sumproc ( jb : je , kb : ke ), sumx ( jb : je , kb : ke ), ( ke - kb + 1 ) * ( je - jb + 1 ), MY_REAL , MPI_SUM , comm3d , mpierr ) end subroutine sumx_ibm","tags":"","url":"proc/sumx_ibm.html"},{"title":"initthermodynamics – uDALES","text":"public  subroutine initthermodynamics() Uses modglobal proc~~initthermodynamics~~UsesGraph proc~initthermodynamics initthermodynamics module~modglobal modglobal proc~initthermodynamics->module~modglobal Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~initthermodynamics~~CalledByGraph proc~initthermodynamics initthermodynamics program~dalesurban DALESURBAN program~dalesurban->proc~initthermodynamics Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine initthermodynamics use modglobal , only : kb , ke , kh , ib , ie , jb , je implicit none allocate ( th0av ( kb : ke + kh )) allocate ( thv0 ( ib : ie , jb : je , kb : ke + kh )) th0av = 0. end subroutine initthermodynamics","tags":"","url":"proc/initthermodynamics.html"},{"title":"thermodynamics – uDALES","text":"public  subroutine thermodynamics() Uses modfields modmpi modglobal proc~~thermodynamics~~UsesGraph proc~thermodynamics thermodynamics module~modfields modfields proc~thermodynamics->module~modfields module~modglobal modglobal proc~thermodynamics->module~modglobal module~modmpi modmpi proc~thermodynamics->module~modmpi decomp_2d decomp_2d module~modfields->decomp_2d mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~thermodynamics~~CallsGraph proc~thermodynamics thermodynamics proc~avexy_ibm avexy_ibm proc~thermodynamics->proc~avexy_ibm proc~calc_halflev calc_halflev proc~thermodynamics->proc~calc_halflev proc~calthv calthv proc~thermodynamics->proc~calthv proc~diagfld diagfld proc~thermodynamics->proc~diagfld proc~thermo thermo proc~thermodynamics->proc~thermo mpi_allreduce mpi_allreduce proc~avexy_ibm->mpi_allreduce proc~diagfld->proc~avexy_ibm proc~fromztop fromztop proc~diagfld->proc~fromztop Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~thermodynamics~~CalledByGraph proc~thermodynamics thermodynamics proc~readinitfiles readinitfiles proc~readinitfiles->proc~thermodynamics program~dalesurban DALESURBAN program~dalesurban->proc~thermodynamics program~dalesurban->proc~readinitfiles Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine thermodynamics use modglobal , only : lmoist , timee , kb , ke , kh , ib , ih , ie , jb , jh , je , rlv , cp , rslabs , rd , rv , libm , eps1 use modfields , only : thl0 , thl0h , qt0 , qt0h , ql0 , ql0h , presf , presh , exnf , exnh , thvh , thv0h , qt0av , ql0av , thvf , rhof , IIc , IIw , IIcs , IIws use modmpi , only : slabsum , avexy_ibm , myid !ILS13 added variables behind \"exnh\" implicit none integer :: k if ( timee == 0 ) call diagfld if ( lmoist ) then call thermo ( thl0 , qt0 , ql0 , presf , exnf ) end if call diagfld call calc_halflev !calculate halflevel values of qt0 and thl0 if ( lmoist ) then call thermo ( thl0h , qt0h , ql0h , presh , exnh ) end if call calthv !ILS13 introduced from DALES4.0   13.05.2015 thvh = 0. !    call slabsum(thvh,kb,ke+kh,thv0h(:,:,kb:ke+kh),ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) !redefine halflevel thv using calculated thv !    thvh = thvh/rslabs call avexy_ibm ( thvh ( kb : ke + kh ), thv0h ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIw ( ib : ie , jb : je , kb : ke + kh ), IIws ( kb : ke + kh ),. false .) !    if (libm) then !      call avexy_ibm(thvh(kb:ke),thv0h(ib:ie,jb:je,kb:ke),ib,ie,jb,je,kb,ke,IIw(ib:ie,jb:je,kb:ke),IIws(kb:ke)) !    else !      call slabsum(thvh,kb,ke+kh,thv0h(:,:,kb:ke+kh),ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) !     !redefine halflevel thv using calculated thv !     thvh = thvh/rslabs !    end if thvh ( kb ) = th0av ( kb ) * ( 1 + ( rv / rd - 1 ) * qt0av ( kb ) - rv / rd * ql0av ( kb )) ! override first level if ( abs ( thvh ( kb + 1 )) < eps1 ) then thvh ( kb + 1 ) = th0av ( kb + 1 ) * ( 1 + ( rv / rd - 1 ) * qt0av ( kb + 1 ) - rv / rd * ql0av ( kb + 1 )) ! override second level if all blocks at kb end if !    where (thvh==0) !override slabs completely covered by blocks !      thvh = th0av(kb)*(1+(rv/rd-1)*qt0av(kb)-rv/rd*ql0av(kb)) !    endwhere do k = kb , ke + kh !    thv0(ib+ih:ie,jb+jh:je,k) = (thl0(ib+ih:ie,jb+ih:je,k)+rlv*ql0(ib+ih:ie,jb+ih:je,k)/(cp*exnf(k)))*(1+(rv/rd-1)*qt0(ib+ih:ie,jb+ih:je,k)-rv/rd*ql0(ib+ih:ie,jb+ih:je,k)) thv0 ( ib : ie , jb : je , k ) = ( thl0 ( ib : ie , jb : je , k ) + rlv * ql0 ( ib : ie , jb : je , k ) / ( cp * exnf ( k ))) * ( 1 + ( rv / rd - 1 ) * qt0 ( ib : ie , jb : je , k ) - rv / rd * ql0 ( ib : ie , jb : je , k )) enddo thvf = 0.0 !write(*,*) \"thv0\",thv0 !    call slabsum(thvf,kb,ke+kh,thv0,ib,ie+ih,jb,je+jh,kb,ke+kh,ib+ih,ie,jb+ih,je,kb,ke+kh) !    call slabsum(thvf,kb,ke+kh,thv0,ib,ie,jb,je,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) call avexy_ibm ( thvf ( kb : ke + kh ), thv0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) !    write(*,*) 'IIc(2,2,:), myid' , IIc(12,2,:), myid !    where (thvf==0) !override slabs completely covered by blocks !      thvf = th0av(kb)*(1+(rv/rd-1)*qt0av(kb)-rv/rd*ql0av(kb)) !    endwhere !    thvf = thvf/rslabs !write(*,*) \"thvf\",thvf !write(*,*) \"exnf\",exnf !    do k=1,k1 !      rhof(k) = presf(k)/(rd*thvf(k)*exnf(k)) !    end do end subroutine thermodynamics","tags":"","url":"proc/thermodynamics.html"},{"title":"exitthermodynamics – uDALES","text":"public  subroutine exitthermodynamics() Arguments None Called by proc~~exitthermodynamics~~CalledByGraph proc~exitthermodynamics exitthermodynamics proc~exitmodules exitmodules proc~exitmodules->proc~exitthermodynamics Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine exitthermodynamics implicit none deallocate ( th0av ) end subroutine exitthermodynamics","tags":"","url":"proc/exitthermodynamics.html"},{"title":"calthv – uDALES","text":"public  subroutine calthv() Uses modfields modsurfdata modglobal proc~~calthv~~UsesGraph proc~calthv calthv module~modfields modfields proc~calthv->module~modfields module~modglobal modglobal proc~calthv->module~modglobal module~modsurfdata modsurfdata proc~calthv->module~modsurfdata decomp_2d decomp_2d module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~calthv~~CalledByGraph proc~calthv calthv proc~thermodynamics thermodynamics proc~thermodynamics->proc~calthv proc~readinitfiles readinitfiles proc~readinitfiles->proc~thermodynamics program~dalesurban DALESURBAN program~dalesurban->proc~thermodynamics program~dalesurban->proc~readinitfiles Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine calthv use modglobal , only : lmoist , ib , ie , jb , je , kb , ke , kh , zf , zh , dzh , rlv , rd , rv , cp , eps1 use modfields , only : thl0 , thl0h , ql0 , ql0h , qt0 , qt0h , sv0 , exnf , exnh , thv0h , dthvdz use modsurfdata , only : dthldz , dqtdz implicit none integer i , j , k real qs real c1 , c2 , dq , dth , dthv , temp real a_dry , b_dry , a_moist , b_moist , c_liquid , epsilon , eps_I , chi_sat , chi real del_thv_sat , del_thv_dry dthvdz = 0.0 if ( lmoist ) then do k = kb , ke + kh do j = jb , je do i = ib , ie thv0h ( i , j , k ) = ( thl0h ( i , j , k ) + rlv * ql0h ( i , j , k ) / ( cp * exnh ( k ))) & * ( 1 + ( rv / rd - 1 ) * qt0h ( i , j , k ) - rv / rd * ql0h ( i , j , k )) end do end do end do do k = kb + 1 , ke do j = jb , je do i = ib , ie ! !         default thv jump computed unsaturated ! epsilon = rd / rv eps_I = 1 / epsilon - 1. !cstep approx 0.608 a_dry = 1. + eps_I * qt0 ( i , j , k ) b_dry = eps_I * thl0 ( i , j , k ) dth = thl0 ( i , j , k + 1 ) - thl0 ( i , j , k - 1 ) dq = qt0 ( i , j , k + 1 ) - qt0 ( i , j , k - 1 ) del_thv_dry = a_dry * dth + b_dry * dq dthv = del_thv_dry if ( ql0 ( i , j , k ) > 0 ) then !include moist thermodynamics temp = thl0 ( i , j , k ) * exnf ( k ) + ( rlv / cp ) * ql0 ( i , j , k ) qs = qt0 ( i , j , k ) - ql0 ( i , j , k ) a_moist = ( 1. - qt0 ( i , j , k ) + qs / epsilon * ( 1. + rlv / ( rv * temp ))) & / ( 1. + rlv ** 2 * qs / ( cp * rv * temp ** 2 )) b_moist = a_moist * rlv / cp - temp c_liquid = a_dry * rlv / cp - thl0 ( i , j , k ) / epsilon del_thv_sat = a_moist * dth + b_moist * dq chi = 2 * chi_half * ( zf ( k ) - zf ( k - 1 )) / ( dzh ( k ) + dzh ( k + 1 )) chi_sat = c_liquid * ql0 ( i , j , k ) / ( del_thv_dry - del_thv_sat ) if ( chi < chi_sat ) then !mixed parcel is saturated dthv = del_thv_sat end if end if dthvdz ( i , j , k ) = dthv / ( dzh ( k + 1 ) + dzh ( k )) end do end do end do do j = jb , je do i = ib , ie dthvdz ( i , j , kb ) = 0. end do end do else !      thv0h = thl0h thv0h = thl0h (:,:, kb : ke + kh ) do k = kb + 1 , ke do j = jb , je do i = ib , ie dthvdz ( i , j , k ) = ( thl0 ( i , j , k + 1 ) - thl0 ( i , j , k - 1 )) / ( dzh ( k + 1 ) + dzh ( k )) end do end do end do do j = jb , je do i = ib , ie dthvdz ( i , j , kb ) = 0. end do end do end if !CvH remove WHERE !where (abs(dthvdz)<eps1) !  dthvdz = sign(eps1,dthvdz) !end where do k = kb , ke do j = jb , je do i = ib , ie if ( abs ( dthvdz ( i , j , k )) < eps1 ) then dthvdz ( i , j , k ) = sign ( eps1 , dthvdz ( i , j , k )) end if end do end do end do end subroutine calthv","tags":"","url":"proc/calthv.html"},{"title":"diagfld – uDALES","text":"public  subroutine diagfld() Uses modfields modsurfdata modmpi modglobal proc~~diagfld~~UsesGraph proc~diagfld diagfld module~modfields modfields proc~diagfld->module~modfields module~modglobal modglobal proc~diagfld->module~modglobal module~modmpi modmpi proc~diagfld->module~modmpi module~modsurfdata modsurfdata proc~diagfld->module~modsurfdata decomp_2d decomp_2d module~modfields->decomp_2d mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~diagfld~~CallsGraph proc~diagfld diagfld proc~avexy_ibm avexy_ibm proc~diagfld->proc~avexy_ibm proc~fromztop fromztop proc~diagfld->proc~fromztop mpi_allreduce mpi_allreduce proc~avexy_ibm->mpi_allreduce Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~diagfld~~CalledByGraph proc~diagfld diagfld proc~thermodynamics thermodynamics proc~thermodynamics->proc~diagfld proc~readinitfiles readinitfiles proc~readinitfiles->proc~thermodynamics program~dalesurban DALESURBAN program~dalesurban->proc~thermodynamics program~dalesurban->proc~readinitfiles Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine diagfld use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , khc , nsv , zh , zf , rslabs , grav , rlv , cp , rd , rv , pref0 use modfields , only : u0 , v0 , thl0 , qt0 , ql0 , sv0 , u0av , v0av , thl0av , qt0av , ql0av , sv0av , & presf , presh , exnf , exnh , rhof , thvf , IIc , IIcs , IIu , IIus , IIv , IIvs use modsurfdata , only : thls , ps use modmpi , only : slabsum , myid , avexy_ibm implicit none real tv integer k , n !!********************************************************* !!  1.0   calculate average profiles of u,v,thl,qt and ql * !!        assuming hydrostatic equilibrium                * !!********************************************************* ! initialise local MPI arrays u0av = 0.0 v0av = 0.0 thl0av = 0.0 th0av = 0.0 qt0av = 0.0 ql0av = 0.0 sv0av = 0. !CvH changed momentum array dimensions to same value as scalars! !  call slabsum(u0av  ,kb,ke+kh,u0  ,ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) !    call slabsum(u0av  ,kb,ke+kh,u0(:,:,kb:ke+kh)  ,ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) call avexy_ibm ( u0av ( kb : ke + kh ), u0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIu ( ib : ie , jb : je , kb : ke + kh ), IIus ( kb : ke + kh ),. false .) !  call slabsum(v0av  ,kb,ke+kh,v0  ,ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) !    call slabsum(v0av  ,kb,ke+kh,v0(:,:,kb:ke+kh)  ,ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) call avexy_ibm ( v0av ( kb : ke + kh ), v0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIv ( ib : ie , jb : je , kb : ke + kh ), IIvs ( kb : ke + kh ),. false .) !  call slabsum(thl0av,kb,ke+kh,thl0,ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) !    call slabsum(thl0av,kb,ke+kh,thl0(:,:,kb:ke+kh),ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) call avexy_ibm ( thl0av ( kb : ke + kh ), thl0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) !write(*,*) 'thl0av(kb), thl0av(kb+1)', thl0av(kb), thl0av(kb+1) !if (IIbl == 0) then ! as lEB applies blocks to kb and masking matrices average this to zero !  thl0av(kb) = thl0av(kb+1) !end if !  call slabsum(qt0av ,kb,ke+kh,qt0 ,ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) !    call slabsum(qt0av ,kb,ke+kh,qt0(:,:,kb:ke+kh) ,ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) call avexy_ibm ( qt0av ( kb : ke + kh ), qt0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) !    call slabsum(ql0av ,kb,ke+kh,ql0 ,ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) call avexy_ibm ( ql0av ( kb : ke + kh ), ql0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) exnf = 1 - grav * zf / ( cp * thls ) exnh = 1 - grav * zh / ( cp * thls ) th0av = thl0av + ( rlv / cp ) * ql0av / exnf !write(*,*) 'thl0av',thl0av !write(*,*) 'th0av',th0av do n = 1 , nsv !       call slabsum(sv0av(kb,n),kb,ke+kh,sv0(ib-ih,jb-jh,kb,n),ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) call avexy_ibm ( sv0av ( kb : ke + khc , n ), sv0 ( ib : ie , jb : je , kb : ke + khc , n ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + khc ), IIcs ( kb : ke + khc ),. false .) end do !    sv0av = sv0av/rslabs !*********************************************************** !  2.0   calculate average profile of pressure at full and * !        half levels, assuming hydrostatic equilibrium.    * !*********************************************************** !    2.1 Use first guess of theta, then recalculate theta call fromztop exnf = ( presf / pref0 ) ** ( rd / cp ) th0av = thl0av + ( rlv / cp ) * ql0av / exnf !    2.2 Use new updated value of theta for determination of pressure call fromztop !*********************************************************** !  3.0   Construct density profiles and exner function     * !       for further use in the program                     * !*********************************************************** !    3.1 determine exner exnh ( kb ) = ( ps / pref0 ) ** ( rd / cp ) exnf ( kb ) = ( presf ( kb ) / pref0 ) ** ( rd / cp ) do k = kb + 1 , ke + kh exnf ( k ) = ( presf ( k ) / pref0 ) ** ( rd / cp ) exnh ( k ) = ( presh ( k ) / pref0 ) ** ( rd / cp ) end do thvf ( kb ) = th0av ( kb ) * exnf ( kb ) * ( 1 + ( rv / rd - 1 ) * qt0av ( kb ) - rv / rd * ql0av ( kb )) rhof ( kb ) = presf ( kb ) / ( rd * thvf ( kb )) !    3.2 determine rho do k = kb + 1 , ke !+kh    ? !   write(*,*) \"exnf(k)\",exnf(k) !   write(*,*) \"th0av(k)\",th0av(k) !   write(*,*) \"qt0av(k)\",qt0av(k) !   write(*,*) \"ql0av(k)\",ql0av(k) thvf ( k ) = th0av ( k ) * exnf ( k ) * ( 1. + ( rv / rd - 1 ) * qt0av ( k ) - rv / rd * ql0av ( k )) rhof ( k ) = presf ( k ) / ( rd * thvf ( k )) end do return end subroutine diagfld","tags":"","url":"proc/diagfld.html"},{"title":"fromztop – uDALES","text":"public  subroutine fromztop() Uses modfields modsurfdata modglobal proc~~fromztop~~UsesGraph proc~fromztop fromztop module~modfields modfields proc~fromztop->module~modfields module~modglobal modglobal proc~fromztop->module~modglobal module~modsurfdata modsurfdata proc~fromztop->module~modsurfdata decomp_2d decomp_2d module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~fromztop~~CalledByGraph proc~fromztop fromztop proc~diagfld diagfld proc~diagfld->proc~fromztop proc~thermodynamics thermodynamics proc~thermodynamics->proc~diagfld proc~readinitfiles readinitfiles proc~readinitfiles->proc~thermodynamics program~dalesurban DALESURBAN program~dalesurban->proc~thermodynamics program~dalesurban->proc~readinitfiles Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine fromztop use modglobal , only : kmax , kb , ke , kh , dzf , dzh , rv , rd , cp , tmelt , zf , grav , pref0 , lEB use modfields , only : qt0av , ql0av , presf , presh , thvh , thvf , IIcs use modsurfdata , only : ps , thvs implicit none integer k real rdocp real , allocatable , dimension (:) :: thetah , qth , qlh allocate ( thetah ( kb : ke + kh ), qth ( kb : ke + kh ), qlh ( kb : ke + kh )) rdocp = rd / cp !************************************************** !    1.0 Determine theta and qt at half levels    * !************************************************** do k = kb + 1 , ke + kh thetah ( k ) = ( th0av ( k ) * dzf ( k - 1 ) + th0av ( k - 1 ) * dzf ( k )) / ( 2 * dzh ( k )) qth ( k ) = ( qt0av ( k ) * dzf ( k - 1 ) + qt0av ( k - 1 ) * dzf ( k )) / ( 2 * dzh ( k )) qlh ( k ) = ( ql0av ( k ) * dzf ( k - 1 ) + ql0av ( k - 1 ) * dzf ( k )) / ( 2 * dzh ( k )) end do !************************************************** !     2.1  calculate pressures at full levels     * !          assuming hydrostatic equilibrium       * !************************************************** !     1: lowest level: use thvs thvh ( kb ) = thvs presf ( kb ) = ps ** rdocp - & grav * ( pref0 ** rdocp ) * zf ( kb ) / ( cp * thvh ( kb )) presf ( kb ) = presf ( kb ) ** ( 1. / rdocp ) !     2: higher levels do k = kb + 1 , ke + kh thvh ( k ) = thetah ( k ) * ( 1 + ( rv / rd - 1 ) * qth ( k ) - rv / rd * qlh ( k )) presf ( k ) = presf ( k - 1 ) ** rdocp - grav * ( pref0 ** rdocp ) * dzh ( k ) / ( cp * thvh ( k )) presf ( k ) = presf ( k ) ** ( 1. / rdocp ) end do !************************************************** !     2.2   calculate pressures at half levels    * !           assuming hydrostatic equilibrium      * !************************************************** presh ( kb ) = ps thvf ( kb ) = th0av ( kb ) * ( 1 + ( rv / rd - 1 ) * qt0av ( kb ) - rv / rd * ql0av ( kb )) do k = kb + 1 , ke + kh thvf ( k ) = th0av ( k ) * ( 1 + ( rv / rd - 1 ) * qt0av ( k ) - rv / rd * ql0av ( k )) presh ( k ) = presh ( k - 1 ) ** rdocp - grav * ( pref0 ** rdocp ) * dzf ( k - 1 ) / ( cp * thvf ( k - 1 )) presh ( k ) = presh ( k ) ** ( 1. / rdocp ) end do deallocate ( thetah , qth , qlh ) return end subroutine fromztop","tags":"","url":"proc/fromztop.html"},{"title":"thermo – uDALES","text":"public  subroutine thermo(thl, qt, ql, pressure, exner) Uses modsurfdata modglobal proc~~thermo~~UsesGraph proc~thermo thermo module~modglobal modglobal proc~thermo->module~modglobal module~modsurfdata modsurfdata proc~thermo->module~modsurfdata Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(in) :: thl (ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh) real, intent(in) :: qt (ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh) real, intent(out) :: ql (ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) real, intent(in) :: pressure (kb:ke+kh) real, intent(in) :: exner (kb:ke+kh) Called by proc~~thermo~~CalledByGraph proc~thermo thermo proc~thermodynamics thermodynamics proc~thermodynamics->proc~thermo proc~readinitfiles readinitfiles proc~readinitfiles->proc~thermodynamics program~dalesurban DALESURBAN program~dalesurban->proc~thermodynamics program~dalesurban->proc~readinitfiles Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine thermo ( thl , qt , ql , pressure , exner ) !  use modglobal, only : ih,jh,i1,j1,k1,es0,at,bt,rd,rv,rlv,cp,tmelt use modglobal , only : ih , jh , ib , ie , jb , je , kb , ke , kh , es0 , at , bt , rd , rv , rlv , cp , tmelt use modsurfdata , only : thls implicit none integer i , j , k real tl , es , qs , qsl , b1 !  real, intent(in)  :: qt(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh),thl(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh),exner(kb:ke+kh),pressure(kb:ke+kh) real , intent ( in ) :: qt ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ), thl ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ), exner ( kb : ke + kh ), pressure ( kb : ke + kh ) real , intent ( out ) :: ql ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ) real :: Tnr , qsatur , Tnr_old integer :: niter , nitert if ( lqlnr ) then !mc      calculation of T with Newton-Raphson method !mc      first guess is Tnr=tl !mc nitert = 0 do k = kb , ke + kh do j = jb , je do i = ib , ie tl = thl ( i , j , k ) * exner ( k ) Tnr = tl Tnr_old = 0. do while ( abs ( Tnr - Tnr_old ) / Tnr > 1e-5 ) niter = niter + 1 Tnr_old = Tnr es = es0 * exp ( at * ( Tnr - tmelt ) / ( Tnr - bt )) qsatur = rd / rv * es / ( pressure ( k ) - ( 1 - rd / rv ) * es ) Tnr = Tnr - ( Tnr + ( rlv / cp ) * qsatur - tl - & ( rlv / cp ) * qt ( i , j , k )) / ( 1 + ( rlv ** 2 * qsatur ) / & ( rv * cp * Tnr ** 2 )) end do nitert = max ( nitert , niter ) niter = 0 ql ( i , j , k ) = dim ( qt ( i , j , k ) - qsatur , 0. ) end do end do end do else do k = kb , ke + kh do j = jb , je do i = ib , ie tl = thl ( i , j , k ) * exner ( k ) es = es0 * exp ( at * ( tl - tmelt ) / ( tl - bt )) qsl = rd / rv * es / ( pressure ( k ) - ( 1 - rd / rv ) * es ) b1 = rlv ** 2 / ( tl ** 2 * cp * rv ) qs = qsl * ( 1. + b1 * qt ( i , j , k )) / ( 1. + b1 * qsl ) ql ( i , j , k ) = dim ( qt ( i , j , k ) - qs , 0. ) end do end do end do end if return end subroutine thermo","tags":"","url":"proc/thermo.html"},{"title":"calc_halflev – uDALES","text":"public  subroutine calc_halflev() Uses modfields modsurfdata modglobal proc~~calc_halflev~~UsesGraph proc~calc_halflev calc_halflev module~modfields modfields proc~calc_halflev->module~modfields module~modglobal modglobal proc~calc_halflev->module~modglobal module~modsurfdata modsurfdata proc~calc_halflev->module~modsurfdata decomp_2d decomp_2d module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~calc_halflev~~CalledByGraph proc~calc_halflev calc_halflev proc~readinitfiles readinitfiles proc~readinitfiles->proc~calc_halflev proc~thermodynamics thermodynamics proc~readinitfiles->proc~thermodynamics proc~thermodynamics->proc~calc_halflev program~dalesurban DALESURBAN program~dalesurban->proc~readinitfiles program~dalesurban->proc~thermodynamics Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine calc_halflev use modglobal , only : ib , ie , jb , je , kb , ke , kh , dzf , dzh , iadv_thl , iadv_qt , iadv_kappa use modfields , only : thl0 , thl0h , qt0 , qt0h use modsurfdata , only : qts , thls implicit none integer :: i , j , k !      do  k=kb+1,ke+kh do k = kb , ke + kh do j = jb , je do i = ib , ie thl0h ( i , j , k ) = ( thl0 ( i , j , k ) * dzf ( k - 1 ) + thl0 ( i , j , k - 1 ) * dzf ( k )) / ( 2 * dzh ( k )) end do end do end do thl0h ( ib : ie , jb : je , kb ) = thls !      do  k=kb+1,ke+kh do k = kb , ke + kh do j = jb , je do i = ib , ie qt0h ( i , j , k ) = ( qt0 ( i , j , k ) * dzf ( k - 1 ) + qt0 ( i , j , k - 1 ) * dzf ( k )) / ( 2 * dzh ( k )) end do end do end do qt0h ( ib : ie , jb : je , kb ) = qts end subroutine calc_halflev","tags":"","url":"proc/calc_halflev.html"},{"title":"matinv3 – uDALES","text":"public pure function matinv3(A) result(B) Arguments Type Intent Optional Attributes Name real, intent(in) :: A (3,3) Return Value real, (3,3)","tags":"","url":"proc/matinv3.html"},{"title":"matinv4 – uDALES","text":"public pure function matinv4(A) result(B) Arguments Type Intent Optional Attributes Name real, intent(in) :: A (4,4) Return Value real, (4,4) Called by proc~~matinv4~~CalledByGraph proc~matinv4 matinv4 proc~eb EB proc~eb->proc~matinv4 proc~initeb initEB proc~initeb->proc~matinv4 program~dalesurban DALESURBAN program~dalesurban->proc~eb program~dalesurban->proc~initeb Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/matinv4.html"},{"title":"gaussji – uDALES","text":"public  function gaussji(c, d, n) result(a) Arguments Type Intent Optional Attributes Name real, intent(in) :: c (n,n) real, intent(in) :: d (n,n) integer :: n Return Value real, (n,n) Called by proc~~gaussji~~CalledByGraph proc~gaussji gaussji proc~eb EB proc~eb->proc~gaussji proc~initeb initEB proc~initeb->proc~gaussji program~dalesurban DALESURBAN program~dalesurban->proc~eb program~dalesurban->proc~initeb Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function gaussji ( c , d , n ) result ( a ) !Linear equation solution by Gauss-Jordan elimination, used to find inverse of matrix c. !possibly slow for large \"c\" (LAPACK better?) !c needs to be square and have dimension n !c(1:n,1:n) is an input matrix stored in an array of physical dimensions n by n. !d(1:n,1:n) is an input matrix containing the n by n identity matrix. !On  output, a(1:n,1:n) (and b(1:n,1:n)) are the inverse of c !Parameter: NMAX is  the  largest  anticipated  value  of n. integer :: n real , intent ( in ) :: c ( n , n ) !WILL BE OVERWRITTEN!! real , intent ( in ) :: d ( n , n ) real :: a ( n , n ), b ( n , n ) integer , parameter :: NMAX = 50 integer :: m , i , icol , irow , j , k , l , ll , indxc ( NMAX ), indxr ( NMAX ), ipiv ( NMAX ) !The integer arrays ipiv, indxr, and indxc are  used for bookkeeping  on the pivoting. REAL :: big , dum , pivinv a = c b = d m = n do j = 1 , n ipiv ( j ) = 0 end do do i = 1 , n !This  is  the  main  loop  over  the  columns  to  be  reduced. big = 0. do j = 1 , n !This  is  the  outer  loop  of  the  search  for  a  pivot  element. if ( ipiv ( j ) . ne . 1 ) then do k = 1 , n if ( ipiv ( k ) . eq . 0 ) then if ( abs ( a ( j , k )) . ge . big ) then big = abs ( a ( j , k )) irow = j icol = k endif !else if (ipiv(k).gt.1) then !pause 'singular matrix in gaussj' end if end do end if end do ipiv ( icol ) = ipiv ( icol ) + 1 !We  now  have  the  pivot  element,  so  we  interchange  rows,  if  needed,  to  put  the  pivot !element  on  the  diagonal.  The  columns  are  not  physically  interchanged,  only  relabeled: !indxc(i), the column of the ith pivot element, is the ith column that is reduced, while !indxr(i) is  the  row in  which  that  pivot  element  was  originally  located.  If !indxr(i) /= indxc(i) there  is  an  implied  column  interchange.  With  this  form  of  bookkeeping,  the !solution b's  will  end  up  in  the  correct  order,  and  the  inverse  matrix  will  be  scrambled by  columns if ( irow . ne . icol ) then do l = 1 , n dum = a ( irow , l ) a ( irow , l ) = a ( icol , l ) a ( icol , l ) = dum end do do l = 1 , m dum = b ( irow , l ) b ( irow , l ) = b ( icol , l ) b ( icol , l ) = dum enddo endif !We are now ready to divide the pivot row by the pivot element, located at irow and icol. indxr ( i ) = irow indxc ( i ) = icol !if (a(icol,icol).eq.0.) pause 'singular matrix in gaussj' pivinv = 1. / a ( icol , icol ) a ( icol , icol ) = 1. do l = 1 , n a ( icol , l ) = a ( icol , l ) * pivinv end do do l = 1 , m b ( icol , l ) = b ( icol , l ) * pivinv end do do ll = 1 , n !Next,  we  reduce  the  rows, except for the  pivot  one, of course. if ( ll . ne . icol ) then dum = a ( ll , icol ) a ( ll , icol ) = 0. do l = 1 , n a ( ll , l ) = a ( ll , l ) - a ( icol , l ) * dum end do do l = 1 , m b ( ll , l ) = b ( ll , l ) - b ( icol , l ) * dum end do end if end do end do !This is the end of the main loop over columns of the reduction. do l = n , 1 , - 1 !It  only  remains  to  unscramble  the  solution  in  view !of  the  column  interchanges.  We  do  this  by  in- !terchanging pairs of columns in the reverse order !that the permutation was built  up. if ( indxr ( l ) . ne . indxc ( l )) then do k = 1 , n dum = a ( k , indxr ( l )) a ( k , indxr ( l )) = a ( k , indxc ( l )) a ( k , indxc ( l )) = dum end do end if end do return !And  we  are  done. end function gaussji","tags":"","url":"proc/gaussji.html"},{"title":"intqH – uDALES","text":"public  subroutine intqH() Uses modmpi initfac modglobal proc~~intqh~~UsesGraph proc~intqh intqH module~initfac initfac proc~intqh->module~initfac module~modglobal modglobal proc~intqh->module~modglobal module~modmpi modmpi proc~intqh->module~modmpi module~initfac->module~modglobal module~initfac->module~modmpi mpi mpi module~initfac->mpi netcdf netcdf module~initfac->netcdf module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~intqh~~CallsGraph proc~intqh intqH mpi_allreduce mpi_allreduce proc~intqh->mpi_allreduce Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~intqh~~CalledByGraph proc~intqh intqH proc~eb EB proc~eb->proc~intqh program~dalesurban DALESURBAN program~dalesurban->proc~eb Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine intqH !time integration of heat and latent heat from facets use modglobal , only : nfcts , dt , rk3step , lEB use initfac , only : faccth , fachfsum , fachf , fachfi , facef , facefi , facefsum use modmpi , only : nprocs , myid , comm3d , mpierr , mpi_sum , my_real real :: dummy integer :: n if (. not . lEB ) return if ( rk3step . eq . 3 ) then !sum over all processors since a facet can be split onto more than one processor fachfsum = 0. facefsum = 0. call MPI_ALLREDUCE ( fachf ( 1 : nfcts ), fachfsum ( 1 : nfcts ), nfcts , MY_REAL , MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( facef ( 1 : nfcts ), facefsum ( 1 : nfcts ), nfcts , MY_REAL , MPI_SUM , comm3d , mpierr ) if ( myid == 0 ) then !time summation of total facet heatlux (will be divided by dtEB in EB to get time mean flux) do n = 1 , nfcts fachfi ( n ) = fachfi ( n ) + dt * fachfsum ( n ) !sum up the fluxes over time facefi ( n ) = facefi ( n ) + dt * facefsum ( n ) end do end if end if fachf = 0. fachfsum = 0. facefsum = 0. facef = 0. end subroutine intqH","tags":"","url":"proc/intqh.html"},{"title":"initEB – uDALES","text":"public  subroutine initEB() Uses modmpi initfac modstat_nc modglobal proc~~initeb~~UsesGraph proc~initeb initEB module~initfac initfac proc~initeb->module~initfac module~modglobal modglobal proc~initeb->module~modglobal module~modmpi modmpi proc~initeb->module~modmpi module~modstat_nc modstat_nc proc~initeb->module~modstat_nc module~initfac->module~modglobal module~initfac->module~modmpi mpi mpi module~initfac->mpi netcdf netcdf module~initfac->netcdf module~modmpi->mpi module~modstat_nc->module~modmpi module~modstat_nc->netcdf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~initeb~~CallsGraph proc~initeb initEB proc~define_nc define_nc proc~initeb->proc~define_nc proc~gaussji gaussji proc~initeb->proc~gaussji proc~matinv4 matinv4 proc~initeb->proc~matinv4 proc~ncinfo ncinfo proc~initeb->proc~ncinfo proc~open_nc open_nc proc~initeb->proc~open_nc proc~writestat_dims_nc writestat_dims_nc proc~initeb->proc~writestat_dims_nc nf90_def_var nf90_def_var proc~define_nc->nf90_def_var nf90_enddef nf90_enddef proc~define_nc->nf90_enddef nf90_inq_dimid nf90_inq_dimid proc~define_nc->nf90_inq_dimid nf90_inq_varid nf90_inq_varid proc~define_nc->nf90_inq_varid nf90_put_att nf90_put_att proc~define_nc->nf90_put_att nf90_redef nf90_redef proc~define_nc->nf90_redef proc~nchandle_error nchandle_error proc~define_nc->proc~nchandle_error nf90_create nf90_create proc~open_nc->nf90_create nf90_def_dim nf90_def_dim proc~open_nc->nf90_def_dim proc~open_nc->nf90_def_var proc~open_nc->nf90_enddef nf90_get_var nf90_get_var proc~open_nc->nf90_get_var proc~open_nc->nf90_inq_dimid proc~open_nc->nf90_inq_varid nf90_inquire nf90_inquire proc~open_nc->nf90_inquire nf90_inquire_dimension nf90_inquire_dimension proc~open_nc->nf90_inquire_dimension nf90_open nf90_open proc~open_nc->nf90_open proc~open_nc->nf90_put_att nf90_sync nf90_sync proc~open_nc->nf90_sync proc~writestat_dims_nc->nf90_inq_varid proc~writestat_dims_nc->nf90_inquire_dimension nf90_put_var nf90_put_var proc~writestat_dims_nc->nf90_put_var nf90_strerror nf90_strerror proc~nchandle_error->nf90_strerror Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~initeb~~CalledByGraph proc~initeb initEB program~dalesurban DALESURBAN program~dalesurban->proc~initeb Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine initEB !initialise everything necessary to calculate the energy balance use modglobal , only : AM , BM , CM , DM , EM , FM , GM , HM , IDM , inAM , bb , w , dumv , Tdash , bldT , nfcts , nfaclyrs use initfac , only : facd , faccp , faclam , fackappa , netsw , facem , fachf , facef , fachfi , facT , facLWin , facefi , facwsoil , facf , facets , facTdash , facqsat , facf , fachurel use modmpi , only : myid , comm3d , mpierr , MY_REAL , nprocs , cmyid use modstat_nc , only : open_nc , define_nc , ncinfo , writestat_dims_nc integer :: i , j , k , l , m , n real :: dum if (. not . lEB ) return allocate ( AM ( 1 : nfaclyrs + 1 , 1 : nfaclyrs + 1 )) allocate ( inAM ( 1 : nfaclyrs + 1 , 1 : nfaclyrs + 1 )) allocate ( CM ( 1 : nfaclyrs + 1 , 1 : nfaclyrs + 1 )) allocate ( bb ( 1 : nfaclyrs + 1 )) allocate ( BM ( 1 : nfaclyrs + 1 , 1 : nfaclyrs + 1 )) allocate ( DM ( 1 : nfaclyrs + 1 , 1 : nfaclyrs + 1 )) allocate ( EM ( 1 : nfaclyrs + 1 , 1 : nfaclyrs + 1 )) allocate ( FM ( 1 : nfaclyrs + 1 , 1 : nfaclyrs + 1 )) allocate ( GM ( 1 : nfaclyrs + 1 , 1 : nfaclyrs + 1 )) allocate ( HM ( 1 : nfaclyrs + 1 , 1 : nfaclyrs + 1 )) allocate ( IDM ( 1 : nfaclyrs + 1 , 1 : nfaclyrs + 1 )) allocate ( w ( 1 : nfaclyrs + 1 )) allocate ( dumv ( 1 : nfaclyrs + 1 )) allocate ( Tdash ( 1 : nfaclyrs + 1 )) BM = 0. ; DM = 0. ; EM = 0. ; FM = 0. ; GM = 0. ; HM = 0. ; w = 0. ; dumv = 0. ; Tdash = 0. ; AM = 0. ; inAM = 0. ; CM = 0. ; IDM = 0. ; bb = 0. do j = 1 , nfaclyrs + 1 IDM ( j , j ) = 1.0 end do !Fortran is column major, i.e. left dimensions should be iterated first ! e.g.  (1,1)->(2,1)->(3,1)->(1,2)->... since they are next to each other on memory !first index moves \"up and down\" second \"left and right\" (as always) m = 1 ; !position along columns do j = 2 , nfaclyrs + 1 AM ( j , m ) = 0.5 AM ( j , m + 1 ) = 0.5 m = m + 1 end do AM ( 1 , 1 ) = 1.0 if ( nfaclyrs == 3 ) then inAM = matinv4 ( AM ) !!alternatively !inAM=matinv3(AM) !!or else inAM = gaussji ( AM , IDM , nfaclyrs + 1 ) end if ! write facet temperatures to facT.xxx.nc, and energies to facEB.xxx.nc if ( lwriteEBfiles ) then Tname ( 6 : 8 ) = cexpnr EBname ( 7 : 9 ) = cexpnr allocate ( ncstatT ( nstatT , 4 )) call ncinfo ( tncstatT ( 1 ,:), 't' , 'Time' , 's' , 'time' ) call ncinfo ( ncstatT ( 1 ,:), 'T' , 'Temperature' , 'K' , 'flt' ) call ncinfo ( ncstatT ( 2 ,:), 'dTdz' , 'Temperature gradient' , 'K/m' , 'flt' ) allocate ( ncstatEB ( nstatEB , 4 )) call ncinfo ( tncstatEB ( 1 ,:), 't' , 'Time' , 's' , 'time' ) call ncinfo ( ncstatEB ( 1 ,:), 'netsw' , 'Net shortwave' , 'W/m&#94;2' , 'ft' ) call ncinfo ( ncstatEB ( 2 ,:), 'LWin' , 'Incoming longwave' , 'W/m&#94;2' , 'ft' ) call ncinfo ( ncstatEB ( 3 ,:), 'LWout' , 'Outgoing longwave' , 'W/m&#94;2' , 'ft' ) call ncinfo ( ncstatEB ( 4 ,:), 'hf' , 'Sensible heat' , 'W/m&#94;2' , 'ft' ) call ncinfo ( ncstatEB ( 5 ,:), 'ef' , 'Latent heat' , 'W/m&#94;2' , 'ft' ) call ncinfo ( ncstatEB ( 6 ,:), 'WGR' , 'Water content' , '?' , 'ft' ) if ( myid == 0 ) then call open_nc ( Tname , ncidT , nrecT , nfcts = nfcts , nlyrs = nfaclyrs + 1 ) call open_nc ( EBname , ncidEB , nrecEB , nfcts = nfcts ) if ( nrecT == 0 ) then call define_nc ( ncidT , 1 , tncstatT ) call writestat_dims_nc ( ncidT ) end if if ( nrecEB == 0 ) then call define_nc ( ncidEB , 1 , tncstatEB ) call writestat_dims_nc ( ncidEB ) end if call define_nc ( ncidT , nstatT , ncstatT ) call define_nc ( ncidEB , nstatEB , ncstatEB ) endif !myid==0 end if end subroutine initEB","tags":"","url":"proc/initeb.html"},{"title":"calclw – uDALES","text":"public  subroutine calclw() Uses initfac modglobal proc~~calclw~~UsesGraph proc~calclw calclw module~initfac initfac proc~calclw->module~initfac module~modglobal modglobal proc~calclw->module~modglobal module~initfac->module~modglobal module~modmpi modmpi module~initfac->module~modmpi mpi mpi module~initfac->mpi netcdf netcdf module~initfac->netcdf module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~calclw~~CalledByGraph proc~calclw calclw proc~eb EB proc~eb->proc~calclw program~dalesurban DALESURBAN program~dalesurban->proc~eb Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine calclw !calculate the longwave exchange between facets use modglobal , only : nfcts , boltz , skyLW , nnz use initfac , only : facem , vf , svf , faca , facT , facLWin , facets , vfsparse , ivfsparse , jvfsparse integer :: n , m , i , j real :: ltemp = 0. if ( lvfsparse ) then facLWin = svf * skyLW * facem do n = 1 , nnz i = ivfsparse ( n ) j = jvfsparse ( n ) facLWin ( i ) = facLWin ( i ) + vfsparse ( n ) * facem ( i ) * facem ( j ) * boltz * facT ( j , 1 ) ** 4 end do else do n = 1 , nfcts !if (facets(n) < -100) cycle ltemp = 0. do m = 1 , nfcts !for n, sum over all other m facets !ltemp = ltemp + vf(m, n)*faca(m)/faca(n)*facem(m)*boltz*facT(m, 1)**4 ![W/m2] ltemp = ltemp + vf ( n , m ) * facem ( m ) * boltz * facT ( m , 1 ) ** 4 ![W/m2] end do facLWin ( n ) = ( ltemp + svf ( n ) * skyLW ) * facem ( n ) end do end if end subroutine calclw","tags":"","url":"proc/calclw.html"},{"title":"updateGR – uDALES","text":"public  subroutine updateGR() Uses initfac modglobal proc~~updategr~~UsesGraph proc~updategr updateGR module~initfac initfac proc~updategr->module~initfac module~modglobal modglobal proc~updategr->module~modglobal module~initfac->module~modglobal module~modmpi modmpi module~initfac->module~modmpi mpi mpi module~initfac->mpi netcdf netcdf module~initfac->netcdf module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~updategr~~CallsGraph proc~updategr updateGR proc~qsat qsat proc~updategr->proc~qsat Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~updategr~~CalledByGraph proc~updategr updateGR proc~eb EB proc~eb->proc~updategr program~dalesurban DALESURBAN program~dalesurban->proc~eb Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine updateGR !updates soil and vegetation resistance to evaporation !updates soil moisture ! ! based on ERA40 surface scheme ! van den Hurk 2000 ! plants ! E = max(0,vegetation% * rhoa * (qa-qsat(TGR)) * 1/(rc+ra)) !no dew!! ! rc=rsmin/LAI*f1(K)*f2(WGS)*f3(D)*f4(T) ! ra,qa,qsat ! f3(D) is 1 for small plants ! bare soil ! E = max(0,(1-vegetation%) * rhoa * (qa-qsat(TGR)*hu) * (1/(rs+ra)) use modglobal , only : nfcts , rlv , rlvi , rhoa , cp , wfc , wwilt , wsoil , rsmin , GRLAI , tEB , rsmax , lconstW use initfac , only : netSW , faccth , fachurel , faclGR , facwsoil , facf , facef , facT , facefi , facqsat , facd , faca , qsat integer :: n real :: vfraction = 0.8 !fraction of GR covered in vegetation, should be made into a proper model parameter (-> modglobal) real :: dum do n = 1 , nfcts if ( faclGR ( n )) then !facefi is actually the accumulated moisture flux, has to be converted to energy flux to calculate temperature !yet actually the moisture flux is needed for water budget, i.e. currently many operations cancel each other e.g. X*Lv/Lv !facefi is the sum over all gridcells of a facet, thus has to be averaged by dividing by number of cells in that facet !units of facefi are kgW/kgA*m/s facefi ( n ) = facefi ( n ) / tEB / faca ( n ) * rhoa * rlv !mean heat flux since last EB calculation (time average) if (. not . lconstW ) then !remove water from soil facwsoil ( n ) = max ( facwsoil ( n ) + facefi ( n ) * tEB * rlvi / facd ( n , 1 ), 0. ) !ils13, careful this assumes water only being present in the first layer!!! end if !update canopy resistance used in wf_gr fachurel ( n ) = max ( min ( 1.0 , 0.5 * ( 1.0 - cos ( 3.14159 * facwsoil ( n ) / wfc ))), 0. ) !relative humidity above soil facf ( n , 1 ) = 1. / min ( 1.0 , ( 0.004 * netSW ( n ) + 0.05 ) / ( 0.81 * ( 0.004 * netSW ( n ) + 1 ))) !f1 facf ( n , 2 ) = 1. / min ( max ( 0.001 , ( facwsoil ( n ) - wwilt ) / ( wfc - wwilt )), 1.0 ) !f2 !f3 drops out because it is for high vegetation only facf ( n , 3 ) = 1. / max (( 1 - 0.0016 * ( 298 - facT ( n , 1 )) ** 2 ), 0.001 ) !f4 !store resistance for plants facf ( n , 4 ) = min ( rsmin / GRLAI * facf ( n , 1 ) * facf ( n , 2 ) * facf ( n , 3 ), rsmax ) !store resistance for soil facf ( n , 5 ) = min ( rsmin * facf ( n , 2 ), rsmax ) dum = facT ( n , 1 ) facqsat ( n ) = qsat ( dum ) end if end do end subroutine updateGR","tags":"","url":"proc/updategr.html"},{"title":"EB – uDALES","text":"public  subroutine EB() Uses modmpi initfac modstat_nc modglobal proc~~eb~~UsesGraph proc~eb EB module~initfac initfac proc~eb->module~initfac module~modglobal modglobal proc~eb->module~modglobal module~modmpi modmpi proc~eb->module~modmpi module~modstat_nc modstat_nc proc~eb->module~modstat_nc module~initfac->module~modglobal module~initfac->module~modmpi mpi mpi module~initfac->mpi netcdf netcdf module~initfac->netcdf module~modmpi->mpi module~modstat_nc->module~modmpi module~modstat_nc->netcdf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~eb~~CallsGraph proc~eb EB interface~writestat_nc writestat_nc proc~eb->interface~writestat_nc mpi_bcast mpi_bcast proc~eb->mpi_bcast proc~calclw calclw proc~eb->proc~calclw proc~gaussji gaussji proc~eb->proc~gaussji proc~intqh intqH proc~eb->proc~intqh proc~matinv4 matinv4 proc~eb->proc~matinv4 proc~updategr updateGR proc~eb->proc~updategr proc~writestat_1d_nc writestat_1D_nc proc~eb->proc~writestat_1d_nc proc~writestat_2d_nc writestat_2D_nc proc~eb->proc~writestat_2d_nc interface~writestat_nc->proc~writestat_1d_nc interface~writestat_nc->proc~writestat_2d_nc proc~writestat_3d_nc writestat_3D_nc interface~writestat_nc->proc~writestat_3d_nc proc~writestat_3d_short_nc writestat_3D_short_nc interface~writestat_nc->proc~writestat_3d_short_nc proc~writestat_time_nc writestat_time_nc interface~writestat_nc->proc~writestat_time_nc mpi_allreduce mpi_allreduce proc~intqh->mpi_allreduce proc~qsat qsat proc~updategr->proc~qsat nf90_inq_varid nf90_inq_varid proc~writestat_1d_nc->nf90_inq_varid nf90_put_var nf90_put_var proc~writestat_1d_nc->nf90_put_var nf90_sync nf90_sync proc~writestat_1d_nc->nf90_sync proc~writestat_2d_nc->nf90_inq_varid proc~writestat_2d_nc->nf90_put_var proc~writestat_2d_nc->nf90_sync proc~writestat_3d_nc->nf90_inq_varid proc~writestat_3d_nc->nf90_put_var proc~writestat_3d_nc->nf90_sync proc~writestat_3d_short_nc->nf90_inq_varid proc~writestat_3d_short_nc->nf90_put_var proc~writestat_3d_short_nc->nf90_sync proc~writestat_time_nc->nf90_inq_varid proc~writestat_time_nc->nf90_put_var proc~writestat_time_nc->nf90_sync Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~eb~~CalledByGraph proc~eb EB program~dalesurban DALESURBAN program~dalesurban->proc~eb Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine EB !calculates the energy balance for every facet use modglobal , only : nfcts , boltz , tEB , AM , BM , CM , DM , EM , FM , GM , HM , inAM , bb , w , dumv , Tdash , timee , dtEB , tnextEB , rk3step , rhoa , cp , lEB , ntrun , lwriteEBfiles , nfaclyrs use initfac , only : faclam , faccp , netsw , facem , fachf , facef , fachfi , facT , facLWin , faca , facefi , facf , facets , facTdash , facqsat , facwsoil , facf , fachurel , facd , fackappa use modmpi , only : myid , comm3d , mpierr , MY_REAL , nprocs , cmyid use modstat_nc , only : writestat_nc , writestat_1D_nc , writestat_2D_nc real :: ca = 0. , cb = 0. , cc = 0. , cd = 0. , ce = 0. , cf = 0. real :: ab = 0. integer :: l , n , m , i , j character ( 19 ) name if (. not . ( lEB )) return !calculate latent heat flux from vegetation and soil call intqH !calculate energy balance, update facet temperature and soil moisture if (( rk3step . eq . 3 ) . and . ( timee . ge . tnextEB )) then if ( myid . eq . 0 ) then tEB = timee - tEB !time since last calculation of energy balance !write (*, *) \"doing EB, time since last EB:\", tEB !calculate time mean, facet area mean latent heat flux and update green roof !ILS13 02.05.18 ABOUT updateGR: convert latent heatflux E properly should be done before temperature calculatation. BUT the rest of updateGR should be done after! !update green roof call updateGR !get longwave fluxes for all facets call calclw !get time mean, facet area mean sensible heat flux do n = 1 , nfcts fachfi ( n ) = fachfi ( n ) / tEB / faca ( n ) * rhoa * cp !mean heat flux since last EB calculation (time average) !since fachf is the sum over all cells making up a facet we need to divide by the number of cells, assuming a given density to convert to W/m2 end do !solve the system: !see Suter 2018 !A * T'= bb + B * T,   where T' = dT/dz !C * d/dtT + D d/dtT'= e * T' ! !-> T(n+1)=(F-G*dt)&#94;-1*(F*T+w*dt) !where F=(C + D*A&#94;-1*B), G=(E*A&#94;-1*B), w=(E*A&#94;-1*bb) do n = 1 , nfcts if ( facets ( n ) < - 100 ) cycle !calculate wallflux and update surface temperature !! define time dependent fluxes ab = boltz * facem ( n ) * ( facT ( n , 1 ) ** 3 ) / faclam ( n , 1 ) ! ab*T is the Stefan-Boltzman law bb ( 1 ) = - ( netsw ( n ) + facLWin ( n ) + fachfi ( n ) + facefi ( n )) / faclam ( n , 1 ) !net surface flux !!define the matrices to solve wall heat flux !! CREATE MATRICES BASED ON WALL PROPERTIES i = 1 ; m = 0 ; !position along columns, placeholder for layerindex since only 3 layers implemented (initfac.f90) do j = 1 , nfaclyrs m = j !!CARE!!! ONLY 3 LAYERS ARE CURRENTLY BEING READ FROM INPUT FILES. PROPERTIES OF LAYER 3 ARE USED FOR SUBSEQUENT LAYERS!!! ca = 1. / facd ( n , m ) BM ( j + 1 , i ) =- ca BM ( j + 1 , i + 1 ) = ca EM ( j , i ) =- faclam ( n , m ) EM ( j , i + 1 ) = faclam ( n , m + 1 ) cb = faccp ( n , m ) * facd ( n , m ) / 2. CM ( j , i ) = cb CM ( j , i + 1 ) = cb ca = faccp ( n , m ) * facd ( n , m ) ** 2 / 1 2. DM ( j , i ) = ca DM ( j , i + 1 ) =- ca i = i + 1 end do CM ( nfaclyrs + 1 , nfaclyrs + 1 ) = 1. BM ( 1 , 1 ) = ab w = matmul ( EM , matmul ( inAM , bb )) * tEB !easier than loop and sum HM = matmul ( inAM , BM ) FM = CM + matmul ( DM , HM ) GM = matmul ( EM , HM ) HM = FM - GM * tEB if ( nfaclyrs == 3 ) then GM = matinv4 ( HM ) else GM = gaussji ( HM , IDM , nfaclyrs + 1 ) end if !instead of inverting matrix HM and multiplying by GM (=HM&#94;-1) it would be waster to do a  left matrix division HM\\x is faster than (HM&#94;-1)*x dumv = matmul ( GM , ( matmul ( FM , facT ( n ,:)) + w )) facT ( n , :) = dumv !calculate Temperature gradient dT/dz=>Tdash so we can output it !ground heat flux = lambda dT/dz w = matmul ( BM , dumv ) facTdash ( n , :) = matmul ( inAM , ( bb + w )) !end if end do if ( lwriteEBfiles ) then if ( myid == 0 ) then allocate ( varsT ( nfcts , nfaclyrs + 1 , nstatT )) varsT (:,:, 1 ) = facT ( 1 : nfcts , 1 : nfaclyrs + 1 ) varsT (:,:, 2 ) = facTdash ( 1 : nfcts , 1 : nfaclyrs + 1 ) call writestat_nc ( ncidT , 1 , tncstatT ,( / timee / ), nrecT ,. true .) call writestat_2D_nc ( ncidT , nstatT , ncstatT , varsT , nrecT , nfcts , nfaclyrs + 1 ) deallocate ( varsT ) allocate ( varsEB ( nfcts , nstatEB )) varsEB (:, 1 ) = netsw ( 1 : nfcts ) varsEB (:, 2 ) = facLWin ( 1 : nfcts ) varsEB (:, 3 ) = boltz * facem ( 1 : nfcts ) * facT ( 1 : nfcts , 1 ) ** 4 varsEB (:, 4 ) = fachfi ( 1 : nfcts ) varsEB (:, 5 ) = facefi ( 1 : nfcts ) varsEB (:, 6 ) = facwsoil ( 1 : nfcts ) ! add longwave out call writestat_nc ( ncidEB , 1 , tncstatEB ,( / timee / ), nrecEB ,. true .) call writestat_1D_nc ( ncidEB , nstatEB , ncstatEB , varsEB , nrecEB , nfcts ) deallocate ( varsEB ) end if !myid end if tEB = timee !set time of last calculation of energy balance to current time tnextEB = NINT (( timee + dtEB )) * 1.0 !rounded to nearest integer  (e.g. if current time is 10.013s and dtEb=10s, then the next energy balance will be calculated at t>=20s) !write (*, *) \"time, time next EB\", timee, tnextEB do n = 1 , nfcts fachfi ( n ) = 0. facefi ( n ) = 0. end do end if !myid==0 !write (*, *) \"bcasting facT\" call MPI_BCAST ( facT ( 0 : nfcts , 1 : nfaclyrs + 1 ), ( nfaclyrs + 1 ) * ( nfcts + 1 ), MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( tnextEB , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( facqsat ( 0 : nfcts ), nfcts + 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( facf ( 0 : nfcts , 1 : 5 ), ( nfcts + 1 ) * 5 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( fachurel ( 0 : nfcts ), nfcts + 1 , MY_REAL , 0 , comm3d , mpierr ) !call MPI_BCAST(facwsoil(0:nfcts), nfcts + 1, MY_REAL, 0, comm3d, mpierr) end if !time>tnextEB end subroutine EB","tags":"","url":"proc/eb.html"},{"title":"initstatsdump – uDALES","text":"public  subroutine initstatsdump() Uses modmpi decomp_2d modstat_nc modglobal modfields proc~~initstatsdump~~UsesGraph proc~initstatsdump initstatsdump decomp_2d decomp_2d proc~initstatsdump->decomp_2d module~modfields modfields proc~initstatsdump->module~modfields module~modglobal modglobal proc~initstatsdump->module~modglobal module~modmpi modmpi proc~initstatsdump->module~modmpi module~modstat_nc modstat_nc proc~initstatsdump->module~modstat_nc module~modfields->decomp_2d mpi mpi module~modmpi->mpi module~modstat_nc->module~modmpi netcdf netcdf module~modstat_nc->netcdf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~initstatsdump~~CallsGraph proc~initstatsdump initstatsdump mpi_bcast mpi_bcast proc~initstatsdump->mpi_bcast proc~define_nc define_nc proc~initstatsdump->proc~define_nc proc~ncinfo ncinfo proc~initstatsdump->proc~ncinfo proc~open_nc open_nc proc~initstatsdump->proc~open_nc proc~writestat_dims_nc writestat_dims_nc proc~initstatsdump->proc~writestat_dims_nc zend zend proc~initstatsdump->zend zstart zstart proc~initstatsdump->zstart nf90_def_var nf90_def_var proc~define_nc->nf90_def_var nf90_enddef nf90_enddef proc~define_nc->nf90_enddef nf90_inq_dimid nf90_inq_dimid proc~define_nc->nf90_inq_dimid nf90_inq_varid nf90_inq_varid proc~define_nc->nf90_inq_varid nf90_put_att nf90_put_att proc~define_nc->nf90_put_att nf90_redef nf90_redef proc~define_nc->nf90_redef proc~nchandle_error nchandle_error proc~define_nc->proc~nchandle_error nf90_create nf90_create proc~open_nc->nf90_create nf90_def_dim nf90_def_dim proc~open_nc->nf90_def_dim proc~open_nc->nf90_def_var proc~open_nc->nf90_enddef nf90_get_var nf90_get_var proc~open_nc->nf90_get_var proc~open_nc->nf90_inq_dimid proc~open_nc->nf90_inq_varid nf90_inquire nf90_inquire proc~open_nc->nf90_inquire nf90_inquire_dimension nf90_inquire_dimension proc~open_nc->nf90_inquire_dimension nf90_open nf90_open proc~open_nc->nf90_open proc~open_nc->nf90_put_att nf90_sync nf90_sync proc~open_nc->nf90_sync proc~writestat_dims_nc->nf90_inq_varid proc~writestat_dims_nc->nf90_inquire_dimension nf90_put_var nf90_put_var proc~writestat_dims_nc->nf90_put_var nf90_strerror nf90_strerror proc~nchandle_error->nf90_strerror Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~initstatsdump~~CalledByGraph proc~initstatsdump initstatsdump program~dalesurban DALESURBAN program~dalesurban->proc~initstatsdump Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Namelists Namelist NAMSTATSDUMP Variables Name Type Default Description lydump logical .false. tsample real None klow integer None khigh integer None tstatsdump real None lytdump logical .false. ltkedump logical .false. lxydump logical .false. lxytdump logical .false. ltdump logical .false. ltreedump logical .false. lmintdump logical .false. Source Code subroutine initstatsdump use modmpi , only : my_real , mpierr , comm3d , mpi_logical , mpi_integer , mpi_character , cmyid , cmyidx , cmyidy use modglobal , only : imax , jmax , kmax , cexpnr , ifnamopt , fname_options , ib , ie , jb , je , kb , ke , ladaptive , btime ,& nsv , lkslicedump , lislicedump , ljslicedump , ltreedump , ib , ie , islice , islicerank , isliceloc , jslice , jslicerank , jsliceloc use modstat_nc , only : open_nc , define_nc , ncinfo , writestat_dims_nc use modfields , only : ncstaty , ncstatyt , ncstattke , ncstatxy , ncstatkslice , ncstatislice , ncstatjslice , ncstatxyt , ncstatt , ncstattr , ncstatmint use decomp_2d , only : zstart , zend implicit none integer :: ierr namelist / NAMSTATSDUMP / & lydump , tsample , klow , khigh , tstatsdump , lytdump , ltkedump , lxydump , lxytdump , ltdump , ltreedump , lmintdump ! maybe removed; NAMSTATSDUMP is not in use anymore allocate ( ncstaty ( nstaty , 4 )) allocate ( ncstatyt ( nstatyt , 4 )) allocate ( ncstattke ( nstattke , 4 )) allocate ( ncstatxy ( nstatxy , 4 )) allocate ( ncstatkslice ( nstatkslice , 4 )) allocate ( ncstatislice ( nstatislice , 4 )) allocate ( ncstatjslice ( nstatjslice , 4 )) allocate ( ncstatxyt ( nstatxyt , 4 )) allocate ( ncstatt ( nstatt , 4 )) allocate ( ncstattr ( nstattr , 4 )) allocate ( ncstatmint ( nstatmint , 4 )) klow = kb khigh = ke if ( myid == 0 ) then open ( ifnamopt , file = fname_options , status = 'old' , iostat = ierr ) read ( ifnamopt , NAMSTATSDUMP , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions NAMSTATSDUMP' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif !write(6 ,NAMSTATSDUMP) close ( ifnamopt ) end if call MPI_BCAST ( klow , 1 , MPI_INTEGER , 0 , comm3d , ierr ) !have to do this? just want nc for first CPU call MPI_BCAST ( khigh , 1 , MPI_INTEGER , 0 , comm3d , ierr ) call MPI_BCAST ( nstatt , 1 , MPI_INTEGER , 0 , comm3d , ierr ) call MPI_BCAST ( nstatmint , 1 , MPI_INTEGER , 0 , comm3d , ierr ) ! call MPI_BCAST(nstaty      ,1,MPI_INTEGER,0,comm3d,ierr) call MPI_BCAST ( ncstatyt , 80 , MPI_CHARACTER , 0 , comm3d , mpierr ) call MPI_BCAST ( ncstaty , 80 , MPI_CHARACTER , 0 , comm3d , mpierr ) call MPI_BCAST ( ncstattke , 80 , MPI_CHARACTER , 0 , comm3d , mpierr ) call MPI_BCAST ( ncstatxy , 80 , MPI_CHARACTER , 0 , comm3d , mpierr ) call MPI_BCAST ( ncstatxyt , 80 , MPI_CHARACTER , 0 , comm3d , mpierr ) call MPI_BCAST ( ncstatt , 80 , MPI_CHARACTER , 0 , comm3d , mpierr ) call MPI_BCAST ( ncstatmint , 80 , MPI_CHARACTER , 0 , comm3d , mpierr ) !call MPI_BCAST(ltdump      ,1,MPI_LOGICAL,0,comm3d,ierr)      ! maybe removed; unnecessary broadcast; this variable already broadcasted in modstartup !call MPI_BCAST(ltreedump   ,1,MPI_LOGICAL,0,comm3d,ierr)      ! maybe removed; unnecessary broadcast; this variable already broadcasted in modstartup call MPI_BCAST ( lmintdump , 1 , MPI_LOGICAL , 0 , comm3d , ierr ) !> Generate y-averaged NetCDF: ydump.xxx.nc if ( lydump ) then yname ( 7 : 9 ) = cexpnr call ncinfo ( tncstaty ( 1 ,:), 'time' , 'Time' , 's' , 'time' ) call ncinfo ( ncstaty ( 1 ,:), 'uy' , 'Streamwise velocity' , 'm/s' , 'm0tt' ) call ncinfo ( ncstaty ( 2 ,:), 'vy' , 'Spanwise velocity' , 'm/s' , 't0tt' ) call ncinfo ( ncstaty ( 3 ,:), 'wy' , 'Vertical velocity' , 'm/s' , 't0mt' ) call ncinfo ( ncstaty ( 4 ,:), 'thly' , 'Temperature' , 'K' , 't0tt' ) call ncinfo ( ncstaty ( 5 ,:), 'qty' , 'Moisture' , 'kg/kg' , 't0tt' ) call ncinfo ( ncstaty ( 6 ,:), 'sca1y' , 'Scalar field 1' , 'kg/m&#94;3' , 't0tt' ) call ncinfo ( ncstaty ( 7 ,:), 'sca2y' , 'Scalar field 2' , 'kg/m&#94;3' , 't0tt' ) call ncinfo ( ncstaty ( 8 ,:), 'sca3y' , 'Scalar field 3' , 'kg/m&#94;3' , 't0tt' ) call ncinfo ( ncstaty ( 9 ,:), 'upwpy' , 'Turbulent mom. flux' , 'm&#94;2/s&#94;2' , 'm0mt' ) call ncinfo ( ncstaty ( 10 ,:), 'wpthlpy' , 'Turbulent heat flux' , 'K m/s' , 't0mt' ) call ncinfo ( ncstaty ( 11 ,:), 'usgsy' , 'SGS mom. flux' , 'm&#94;2/s&#94;2' , 'm0mt' ) call ncinfo ( ncstaty ( 12 ,:), 'thlsgsy' , 'SGS heat flux' , 'K m/s' , 't0mt' ) call ncinfo ( ncstaty ( 13 ,:), 'uwyik' , 'Advective mom. flux' , 'm&#94;2/s&#94;2' , 'm0mt' ) call ncinfo ( ncstaty ( 14 ,:), 'wthlyk' , 'Advective heat flux' , 'K m/s' , 't0mt' ) if ( myid == 0 ) then call open_nc ( yname , ncidy , nrecy , n1 = imax , n3 = khigh - klow + 1 ) if ( nrecy == 0 ) then call define_nc ( ncidy , 1 , tncstaty ) call writestat_dims_nc ( ncidy ) end if call define_nc ( ncidy , nstaty , ncstaty ) endif !myid==0 endif !> Generate time and y averaged NetCDF: ytdump.xxx.nc if ( lytdump ) then ytname ( 8 : 10 ) = cexpnr call ncinfo ( tncstatyt ( 1 ,:), 'time' , 'Sampling time' , 's' , 'time' ) call ncinfo ( ncstatyt ( 1 ,:), 'uyt' , 'Streamwise velocity' , 'm/s' , 'm0tt' ) call ncinfo ( ncstatyt ( 2 ,:), 'vyt' , 'Spanwise velocity' , 'm/s' , 't0tt' ) call ncinfo ( ncstatyt ( 3 ,:), 'wyt' , 'Vertical velocity' , 'm/s' , 't0mt' ) call ncinfo ( ncstatyt ( 4 ,:), 'thlyt' , 'Temperature' , 'K' , 't0tt' ) call ncinfo ( ncstatyt ( 5 ,:), 'qtyt' , 'Moisture' , 'kg/kg' , 't0tt' ) call ncinfo ( ncstatyt ( 6 ,:), 'sca1yt' , 'Scalar field 1' , 'kg/m&#94;3' , 't0tt' ) call ncinfo ( ncstatyt ( 7 ,:), 'sca2yt' , 'Scalar field 2' , 'kg/m&#94;3' , 't0tt' ) call ncinfo ( ncstatyt ( 8 ,:), 'sca3yt' , 'Scalar field 3' , 'kg/m&#94;3' , 't0tt' ) call ncinfo ( ncstatyt ( 9 ,:), 'upwpyt' , 'Turbulent mom. flux' , 'm&#94;2/s&#94;2' , 'm0mt' ) call ncinfo ( ncstatyt ( 10 ,:), 'wpthlpyt' , 'Turbulent heat flux' , 'K m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 11 ,:), 'wpqtpyt' , 'Turbulent moisture flux' , 'kg/kg m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 12 ,:), 'wpsca1tpyt' , 'Turbulent scalar flux' , 'M m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 13 ,:), 'wpsca2tpyt' , 'Turbulent scalar flux' , 'M m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 14 ,:), 'wpsca3tpyt' , 'Turbulent scalar flux' , 'M m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 15 ,:), 'uwyt' , 'Kinematic mom. flux' , 'm&#94;2/s&#94;2' , 'm0mt' ) call ncinfo ( ncstatyt ( 16 ,:), 'wthlyt' , 'Kinematic heat flux' , 'K m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 17 ,:), 'wqtyt' , 'Kinematic moisture flux' , 'K m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 18 ,:), 'wsca1yt' , 'Kinematic scalar flux' , 'K m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 19 ,:), 'wsca2yt' , 'Kinematic scalar flux' , 'K m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 20 ,:), 'wsca3yt' , 'Kinematic scalar flux' , 'K m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 21 ,:), 'upupyt' , 'mom. variance' , 'm&#94;2/s&#94;2' , 't0tt' ) call ncinfo ( ncstatyt ( 22 ,:), 'wpwpyt' , 'mom. variance' , 'm&#94;2/s&#94;2' , 't0tt' ) call ncinfo ( ncstatyt ( 23 ,:), 'thlpthlpyt' , 'temp. variance' , 'K&#94;2' , 't0tt' ) call ncinfo ( ncstatyt ( 24 ,:), 'qtpqtpyt' , 'moisture. variance' , 'kg&#94;2/kg&#94;2' , 't0tt' ) call ncinfo ( ncstatyt ( 25 ,:), 'sca1tpsca1pyt' , 'scalar. variance' , 'M&#94;2' , 't0tt' ) call ncinfo ( ncstatyt ( 26 ,:), 'sca2tpsca2pyt' , 'scalar. variance' , 'M&#94;2' , 't0tt' ) call ncinfo ( ncstatyt ( 27 ,:), 'sca3tpsca3pyt' , 'scalar. variance' , 'M&#94;2' , 't0tt' ) call ncinfo ( ncstatyt ( 28 ,:), 'usgsyt' , 'SGS mom. flux' , 'm&#94;2/s&#94;2' , 'm0mt' ) call ncinfo ( ncstatyt ( 29 ,:), 'wsgsyt' , 'SGS mom. flux' , 'm&#94;2/s&#94;2' , 't0mt' ) call ncinfo ( ncstatyt ( 30 ,:), 'thlsgsyt' , 'SGS heat flux' , 'K m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 31 ,:), 'qtsgsyt' , 'SGS moisture flux' , 'kg/kg m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 32 ,:), 'sca1sgsyt' , 'SGS scalar flux' , 'M m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 33 ,:), 'sca2sgsyt' , 'SGS scalar flux' , 'M m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 34 ,:), 'sca3sgsyt' , 'SGS scalar flux' , 'M m/s' , 't0mt' ) if ( myid == 0 ) then call open_nc ( ytname , ncidyt , nrecyt , n1 = imax , n3 = khigh - klow + 1 ) if ( nrecyt == 0 ) then call define_nc ( ncidyt , 1 , tncstatyt ) call writestat_dims_nc ( ncidyt ) end if call define_nc ( ncidyt , nstatyt , ncstatyt ) endif !myid==0 endif !> Generate y and x averaged NetCDF: xydump.xxx.nc if ( lxydump ) then xyname ( 8 : 10 ) = cexpnr call ncinfo ( tncstatxy ( 1 ,:), 'time' , 'Time' , 's' , 'time' ) call ncinfo ( ncstatxy ( 1 ,:), 'uxy' , 'Streamwise velocity' , 'm/s' , 'tt' ) call ncinfo ( ncstatxy ( 2 ,:), 'vxy' , 'Spanwise velocity' , 'm/s' , 'tt' ) call ncinfo ( ncstatxy ( 3 ,:), 'wxy' , 'Vertical velocity' , 'm/s' , 'mt' ) call ncinfo ( ncstatxy ( 4 ,:), 'thlxy' , 'Temperature' , 'K' , 'tt' ) call ncinfo ( ncstatxy ( 5 ,:), 'qtxy' , 'Moisture' , 'kg/kg' , 'tt' ) call ncinfo ( ncstatxy ( 6 ,:), 'pxy' , 'Pressure' , 'm&#94;2/s&#94;2' , 'tt' ) call ncinfo ( ncstatxy ( 7 ,:), 'upwpxy' , 'Mom. flux' , 'm&#94;2/s&#94;2' , 'mt' ) call ncinfo ( ncstatxy ( 8 ,:), 'wpthlpxy' , 'Heat flux' , 'Km/s' , 'mt' ) call ncinfo ( ncstatxy ( 9 ,:), 'vpwpxy' , 'Mom. flux' , 'Km/s' , 'mt' ) call ncinfo ( ncstatxy ( 10 ,:), 'usgsxy' , 'SGS mom. flux' , 'm&#94;2/s&#94;2' , 'mt' ) call ncinfo ( ncstatxy ( 11 ,:), 'thlsgsxy' , 'SGS heat flux' , 'Km/s' , 'mt' ) call ncinfo ( ncstatxy ( 12 ,:), 'vsgsxy' , 'SGS mom. flux' , 'm&#94;2/s&#94;2' , 'mt' ) call ncinfo ( ncstatxy ( 13 ,:), 'uwxyik' , 'Advective mom. flux' , 'm&#94;2/s&#94;2' , 'mt' ) call ncinfo ( ncstatxy ( 14 ,:), 'wthlxy' , 'Advective heat flux' , 'K m/s' , 'mt' ) call ncinfo ( ncstatxy ( 15 ,:), 'vwxy' , 'Advective mom. flux' , 'm&#94;2/s&#94;2' , 'mt' ) if ( myid == 0 ) then call open_nc ( xyname , ncidxy , nrecxy , n3 = khigh - klow + 1 ) if ( nrecxy == 0 ) then call define_nc ( ncidxy , 1 , tncstatxy ) call writestat_dims_nc ( ncidxy ) end if call define_nc ( ncidxy , nstatxy , ncstatxy ) end if end if !> Generate time, y and x averaged NetCDF: xytdump.xxx.nc if ( lxytdump ) then xytname ( 9 : 11 ) = cexpnr call ncinfo ( tncstatxyt ( 1 ,:), 'time' , 'Time' , 's' , 'time' ) call ncinfo ( ncstatxyt ( 1 ,:), 'uxyt' , 'Streamwise velocity' , 'm/s' , 'tt' ) call ncinfo ( ncstatxyt ( 2 ,:), 'vxyt' , 'Spanwise velocity' , 'm/s' , 'tt' ) call ncinfo ( ncstatxyt ( 3 ,:), 'wxyt' , 'Vertical velocity' , 'm/s' , 'mt' ) call ncinfo ( ncstatxyt ( 4 ,:), 'thlxyt' , 'Temperature' , 'K' , 'tt' ) call ncinfo ( ncstatxyt ( 5 ,:), 'qtxyt' , 'Moisture' , 'kg/kg' , 'tt' ) call ncinfo ( ncstatxyt ( 6 ,:), 'pxyt' , 'Pressure' , 'm&#94;2/s&#94;2' , 'tt' ) call ncinfo ( ncstatxyt ( 7 ,:), 'upwpxyt' , 'Turbulent mom. flux' , 'm&#94;2/s&#94;2' , 'mt' ) call ncinfo ( ncstatxyt ( 8 ,:), 'wpthlpxyt' , 'Turbulent heat flux' , 'K m/s' , 'mt' ) call ncinfo ( ncstatxyt ( 9 ,:), 'vpwpxyt' , 'Turbulent mom. flux' , 'm&#94;2/s&#94;2' , 'mt' ) call ncinfo ( ncstatxyt ( 10 ,:), 'upvpxyt' , 'Turbulent mom. flux' , 'm&#94;2/s&#94;2' , 'mt' ) call ncinfo ( ncstatxyt ( 11 ,:), 'uwxyt' , 'Kinematic mom. flux' , 'm&#94;2/s&#94;2' , 'mt' ) call ncinfo ( ncstatxyt ( 12 ,:), 'wthlxyt' , 'Kinematic heat flux' , 'K m/s' , 'mt' ) call ncinfo ( ncstatxyt ( 13 ,:), 'uvxyt' , 'Kinematic mom. flux' , 'm&#94;2/s&#94;2' , 'mt' ) call ncinfo ( ncstatxyt ( 14 ,:), 'vwxyt' , 'Kinematic mom. flux' , 'm&#94;2/s&#94;2' , 'mt' ) call ncinfo ( ncstatxyt ( 15 ,:), 'wwxyt' , 'Kinematic mom. flux' , 'm&#94;2/s&#94;2' , 'mt' ) call ncinfo ( ncstatxyt ( 16 ,:), 'usgsxyt' , 'SGS mom. flux' , 'm&#94;2/s&#94;2' , 'mt' ) call ncinfo ( ncstatxyt ( 17 ,:), 'thlsgsxyt' , 'SGS heat flux' , 'K m/s' , 'mt' ) call ncinfo ( ncstatxyt ( 18 ,:), 'vsgsxyt' , 'SGS mom. flux' , 'K m/s' , 'mt' ) call ncinfo ( ncstatxyt ( 19 ,:), 'thlpthlptxy' , 'Temp. variance' , 'K&#94;2' , 'tt' ) call ncinfo ( ncstatxyt ( 20 ,:), 'upuptxyc' , 'u variance' , 'm&#94;2/s&#94;2' , 'tt' ) call ncinfo ( ncstatxyt ( 21 ,:), 'vpvptxyc' , 'v variance' , 'm&#94;2/s&#94;2' , 'tt' ) call ncinfo ( ncstatxyt ( 22 ,:), 'wpwptxyc' , 'w variance' , 'm&#94;2/s&#94;2' , 'tt' ) call ncinfo ( ncstatxyt ( 23 ,:), 'tketxyc' , 'tke' , 'm&#94;2/s&#94;2' , 'tt' ) if ( myid == 0 ) then call open_nc ( xytname , ncidxyt , nrecxyt , n3 = khigh - klow + 1 ) if ( nrecxyt == 0 ) then call define_nc ( ncidxyt , 1 , tncstatxyt ) call writestat_dims_nc ( ncidxyt ) end if call define_nc ( ncidxyt , nstatxyt , ncstatxyt ) end if end if !> Generate time averaged NetCDF: tdump.xxx.nc if ( ltdump ) then tname ( 7 : 9 ) = cmyidx tname ( 11 : 13 ) = cmyidy tname ( 15 : 17 ) = cexpnr call ncinfo ( tncstatt ( 1 ,:), 'time' , 'Time' , 's' , 'time' ) call ncinfo ( ncstatt ( 1 ,:), 'ut' , 'Streamwise velocity' , 'm/s' , 'mttt' ) call ncinfo ( ncstatt ( 2 ,:), 'vt' , 'Spanwise velocity' , 'm/s' , 'tmtt' ) call ncinfo ( ncstatt ( 3 ,:), 'wt' , 'Vertical velocity' , 'm/s' , 'ttmt' ) call ncinfo ( ncstatt ( 4 ,:), 'thlt' , 'Temperature' , 'K' , 'tttt' ) call ncinfo ( ncstatt ( 5 ,:), 'qtt' , 'Moisture' , 'kg/kg' , 'tttt' ) call ncinfo ( ncstatt ( 6 ,:), 'pt' , 'Pressure' , 'm&#94;2/s&#94;2' , 'tttt' ) call ncinfo ( ncstatt ( 7 ,:), 'sca1t' , 'Concentration field 1' , 'g/m&#94;3' , 'tttt' ) call ncinfo ( ncstatt ( 8 ,:), 'sca2t' , 'Concentration field 2' , 'g/m&#94;3' , 'tttt' ) call ncinfo ( ncstatt ( 9 ,:), 'sca3t' , 'Concentration field 3' , 'g/m&#94;3' , 'tttt' ) call ncinfo ( ncstatt ( 10 ,:), 'sca4t' , 'Concentration field 4' , 'g/m&#94;3' , 'tttt' ) call ncinfo ( ncstatt ( 11 ,:), 'PSS' , 'PSS defect' , 'gm/s' , 'tttt' ) call ncinfo ( ncstatt ( 12 ,:), 'upwpt' , 'Turbulent momentum flux' , 'm&#94;2/s&#94;2' , 'mtmt' ) call ncinfo ( ncstatt ( 13 ,:), 'vpwpt' , 'Turbulent momentum flux' , 'm&#94;2/s&#94;2' , 'tmmt' ) call ncinfo ( ncstatt ( 14 ,:), 'upvpt' , 'Turbulent momentum flux' , 'm&#94;2/s&#94;2' , 'mmtt' ) call ncinfo ( ncstatt ( 15 ,:), 'wpthlpt' , 'Turbulent heat flux' , 'K m/s' , 'ttmt' ) call ncinfo ( ncstatt ( 16 ,:), 'wpsca1pt' , 'Turbulent flux 1' , 'gm/s' , 'ttmt' ) call ncinfo ( ncstatt ( 17 ,:), 'wpsca2pt' , 'Turbulent flux 2' , 'gm/s' , 'ttmt' ) call ncinfo ( ncstatt ( 18 ,:), 'wpsca3pt' , 'Turbulent flux 3' , 'gm/s' , 'ttmt' ) call ncinfo ( ncstatt ( 19 ,:), 'wpsca4pt' , 'Turbulent flux 4' , 'gm/s' , 'ttmt' ) call ncinfo ( ncstatt ( 20 ,:), 'thlpthlpt' , 'Temperature variance' , 'K&#94;2' , 'tttt' ) call ncinfo ( ncstatt ( 21 ,:), 'upuptc' , 'u variance' , 'm&#94;2/s&#94;2' , 'tttt' ) call ncinfo ( ncstatt ( 22 ,:), 'vpvptc' , 'v variance' , 'm&#94;2/s&#94;2' , 'tttt' ) call ncinfo ( ncstatt ( 23 ,:), 'wpwptc' , 'w variance' , 'm&#94;2/s&#94;2' , 'tttt' ) call ncinfo ( ncstatt ( 24 ,:), 'tketc' , 'TKE' , 'm&#94;2/s&#94;2' , 'tttt' ) call ncinfo ( ncstatt ( 25 ,:), 'sca1psca1pt' , 'Concentration variance 1' , 'g&#94;2/m&#94;6' , 'tttt' ) call ncinfo ( ncstatt ( 26 ,:), 'sca2psca2pt' , 'Concentration variance 2' , 'g&#94;2/m&#94;6' , 'tttt' ) call ncinfo ( ncstatt ( 27 ,:), 'sca3psca3pt' , 'Concentration variance 3' , 'g&#94;2/m&#94;6' , 'tttt' ) call ncinfo ( ncstatt ( 28 ,:), 'sca4psca4pt' , 'Concentration variance 4' , 'g&#94;2/m&#94;6' , 'tttt' ) call ncinfo ( ncstatt ( 29 ,:), 'sv1sgs' , 'SGS flux 1' , 'gm/s' , 'ttmt' ) call ncinfo ( ncstatt ( 30 ,:), 'sv2sgs' , 'SGS flux 2' , 'gm/s' , 'ttmt' ) call ncinfo ( ncstatt ( 31 ,:), 'sv3sgs' , 'SGS flux 3' , 'gm/s' , 'ttmt' ) call ncinfo ( ncstatt ( 32 ,:), 'sv4sgs' , 'SGS flux 4' , 'gm/s' , 'ttmt' ) ! call ncinfo(ncstatt(33,:),'sca1t_max','Max concentration field 1'   ,'g/m&#94;3'  ,'tttt'  ) ! call ncinfo(ncstatt(34,:),'sca2t_max','Max concentration field 2'   ,'g/m&#94;3'  ,'tttt'  ) ! call ncinfo(ncstatt(35,:),'sca3t_max','Max concentration field 3'   ,'g/m&#94;3'  ,'tttt'  ) ! call ncinfo(ncstatt(36,:),'sca4t_max','Max concentration field 4'   ,'g/m&#94;3'  ,'tttt'  ) !      if (myid==0) then call open_nc ( tname , ncidt , nrect , n1 = imax , n2 = jmax , n3 = khigh - klow + 1 ) if ( nrect == 0 ) then call define_nc ( ncidt , 1 , tncstatt ) call writestat_dims_nc ( ncidt ) end if call define_nc ( ncidt , nstatt , ncstatt ) !      end if end if if ( lmintdump ) then mintname ( 10 : 12 ) = cmyidx mintname ( 14 : 16 ) = cmyidy mintname ( 18 : 20 ) = cexpnr call ncinfo ( tncstatmint ( 1 ,:), 'time' , 'Time' , 's' , 'time' ) call ncinfo ( ncstatmint ( 1 ,:), 'ut' , 'Streamwise velocity' , 'm/s' , 'mttt' ) call ncinfo ( ncstatmint ( 2 ,:), 'vt' , 'Spanwise velocity' , 'm/s' , 'tmtt' ) call ncinfo ( ncstatmint ( 3 ,:), 'wt' , 'Vertical velocity' , 'm/s' , 'ttmt' ) call ncinfo ( ncstatmint ( 4 ,:), 'thlt' , 'Temperature' , 'K' , 'tttt' ) call ncinfo ( ncstatmint ( 5 ,:), 'qtt' , 'Moisture' , 'kg/kg' , 'tttt' ) call ncinfo ( ncstatmint ( 6 ,:), 'pt' , 'Pressure' , 'm&#94;2/s&#94;2' , 'tttt' ) !      if (myid==0) then call open_nc ( mintname , ncidmint , nrecmint , n1 = imax , n2 = jmax , n3 = khigh - klow + 1 ) if ( nrecmint == 0 ) then call define_nc ( ncidmint , 1 , tncstatmint ) call writestat_dims_nc ( ncidmint ) end if call define_nc ( ncidmint , nstatmint , ncstatmint ) !      end if end if !> Generate time averaged NetCDF: treedump.xxx.nc if ( ltreedump ) then trname ( 10 : 12 ) = cmyidx trname ( 14 : 16 ) = cmyidy trname ( 18 : 20 ) = cexpnr call ncinfo ( tncstattr ( 1 ,:), 'time' , 'Time' , 's' , 'time' ) call ncinfo ( ncstattr ( 1 ,:), 'tr_u' , 'Drag in x' , 'm/s&#94;2' , 'tttt' ) call ncinfo ( ncstattr ( 2 ,:), 'tr_v' , 'Drag in y' , 'm/s&#94;2' , 'tttt' ) call ncinfo ( ncstattr ( 3 ,:), 'tr_w' , 'Drag in z' , 'm/s&#94;2' , 'ttmt' ) call ncinfo ( ncstattr ( 4 ,:), 'tr_thl' , 'Temp source/ sink' , 'K/s' , 'tttt' ) call ncinfo ( ncstattr ( 5 ,:), 'tr_qt' , 'Moisture source sink' , '1/s' , 'tttt' ) call ncinfo ( ncstattr ( 6 ,:), 'tr_qtR' , 'Moisture source sink' , '1/s' , 'tttt' ) call ncinfo ( ncstattr ( 7 ,:), 'tr_qtA' , 'Moisture source sink' , '1/s' , 'tttt' ) call ncinfo ( ncstattr ( 8 ,:), 'tr_sv1' , 'Scalar source sink' , 'kg/m&#94;3s' , 'tttt' ) call ncinfo ( ncstattr ( 9 ,:), 'tr_sv2' , 'Scalar source sink' , 'kg/m&#94;3s' , 'tttt' ) call ncinfo ( ncstattr ( 10 ,:), 'tr_omega' , 'Decoupling factor' , '-' , 'tttt' ) !      if (myid==0) then call open_nc ( trname , ncidtr , nrectr , n1 = imax , n2 = jmax , n3 = khigh - klow + 1 ) if ( nrectr == 0 ) then call define_nc ( ncidtr , 1 , tncstattr ) call writestat_dims_nc ( ncidtr ) end if call define_nc ( ncidtr , nstattr , ncstattr ) !      end if end if !> Generate time, y and x averaged NetCDF for tke budget: tkedump.xxx.nc if ( ltkedump ) then tkename ( 9 : 11 ) = cexpnr call ncinfo ( tncstattke ( 1 ,:), 'time' , 'Time' , 's' , 'time' ) call ncinfo ( ncstattke ( 1 ,:), 'p_b' , 'p_bant production or consumption term' , 'm&#94;2/s&#94;3' , 'tt' ) call ncinfo ( ncstattke ( 2 ,:), 't_p' , 'total viscous transport (?)' , 'm&#94;2/s&#94;3' , 'tt' ) call ncinfo ( ncstattke ( 3 ,:), 'adv' , 'Advection by mean wind' , 'm&#94;2/s&#94;3' , 'tt' ) call ncinfo ( ncstattke ( 4 ,:), 't_t' , 'Total turb???' , 'm&#94;2/s&#94;3' , 'tt' ) call ncinfo ( ncstattke ( 5 ,:), 't_sgs' , 'total SGS  term' , 'm&#94;2/s&#94;3' , 'tt' ) call ncinfo ( ncstattke ( 6 ,:), 'p_t' , 'Shear production term' , 'm&#94;2/s&#94;3' , 'tt' ) call ncinfo ( ncstattke ( 7 ,:), 't_v' , 'Resolved viscous dissipation term' , 'm&#94;2/s&#94;3' , 'tt' ) call ncinfo ( ncstattke ( 8 ,:), 'd_sgs' , 'SGS dissipation term' , 'm&#94;2/s&#94;3' , 'tt' ) if ( myid == 0 ) then call open_nc ( tkename , ncidtke , nrectke , n3 = khigh - klow + 1 ) if ( nrectke == 0 ) then call define_nc ( ncidtke , 1 , tncstattke ) call writestat_dims_nc ( ncidtke ) end if call define_nc ( ncidtke , nstattke , ncstattke ) endif !myid==0 endif !> Generate sliced NetCDF: slicedump.xxx.xxx.nc if ( lkslicedump ) then kslicename ( 12 : 14 ) = cmyidx kslicename ( 16 : 18 ) = cmyidy kslicename ( 20 : 22 ) = cexpnr call ncinfo ( tncstatkslice ( 1 ,:), 'time' , 'Time' , 's' , 'time' ) call ncinfo ( ncstatkslice ( 1 ,:), 'u_kslice' , 'Streamwise velocity at kslice' , '-' , 'mt0t' ) call ncinfo ( ncstatkslice ( 2 ,:), 'v_kslice' , 'Spanwise velocity at kslice' , '-' , 'tm0t' ) call ncinfo ( ncstatkslice ( 3 ,:), 'w_kslice' , 'Vertical velocity at kslice' , '-' , 'tt0t' ) call ncinfo ( ncstatkslice ( 4 ,:), 'thl_kslice' , 'Potential temperature at kslice' , '-' , 'tt0t' ) call ncinfo ( ncstatkslice ( 5 ,:), 'qt_kslice' , 'Specific humidity at kslice' , '-' , 'tt0t' ) call open_nc ( kslicename , ncidkslice , nreckslice , n1 = imax , n2 = jmax ) if ( nreckslice == 0 ) then call define_nc ( ncidkslice , 1 , tncstatkslice ) call writestat_dims_nc ( ncidkslice ) end if call define_nc ( ncidkslice , nstatkslice , ncstatkslice ) end if if ( lislicedump ) then islicename ( 12 : 14 ) = cmyidx islicename ( 16 : 18 ) = cmyidy islicename ( 20 : 22 ) = cexpnr call ncinfo ( tncstatislice ( 1 ,:), 'time' , 'Time' , 's' , 'time' ) call ncinfo ( ncstatislice ( 1 ,:), 'u_islice' , 'Streamwise velocity at islice' , '-' , '0ttt' ) call ncinfo ( ncstatislice ( 2 ,:), 'v_islice' , 'Spanwise velocity at islice' , '-' , '0mtt' ) call ncinfo ( ncstatislice ( 3 ,:), 'w_islice' , 'Vertical velocity at islice' , '-' , '0tmt' ) call ncinfo ( ncstatislice ( 4 ,:), 'thl_islice' , 'Potential temperature at islice' , '-' , '0ttt' ) call ncinfo ( ncstatislice ( 5 ,:), 'qt_islice' , 'Specific humidity at islice' , '-' , '0ttt' ) if (( islice >= zstart ( 1 )) . and . ( islice <= zend ( 1 ))) then islicerank = . true . isliceloc = islice - zstart ( 1 ) + 1 else islicerank = . false . end if if ( islicerank ) then call open_nc ( islicename , ncidislice , nrecislice , n2 = jmax , n3 = khigh - klow + 1 ) if ( nrecislice == 0 ) then call define_nc ( ncidislice , 1 , tncstatislice ) call writestat_dims_nc ( ncidislice ) end if call define_nc ( ncidislice , nstatislice , ncstatislice ) end if end if if ( ljslicedump ) then jslicename ( 12 : 14 ) = cmyidx jslicename ( 16 : 18 ) = cmyidy jslicename ( 20 : 22 ) = cexpnr call ncinfo ( tncstatjslice ( 1 ,:), 'time' , 'Time' , 's' , 'time' ) call ncinfo ( ncstatjslice ( 1 ,:), 'u_jslice' , 'Streamwise velocity at jslice' , '-' , 'm0tt' ) call ncinfo ( ncstatjslice ( 2 ,:), 'v_jslice' , 'Spanwise velocity at jslice' , '-' , 't0tt' ) call ncinfo ( ncstatjslice ( 3 ,:), 'w_jslice' , 'Vertical velocity at jslice' , '-' , 't0mt' ) call ncinfo ( ncstatjslice ( 4 ,:), 'thl_jslice' , 'Potential temperature at jslice' , '-' , 't0tt' ) call ncinfo ( ncstatjslice ( 5 ,:), 'qt_jslice' , 'Specific humidity at jslice' , '-' , 't0tt' ) if (( jslice >= zstart ( 2 )) . and . ( jslice <= zend ( 2 ))) then jslicerank = . true . jsliceloc = jslice - zstart ( 2 ) + 1 else jslicerank = . false . end if if ( jslicerank ) then call open_nc ( jslicename , ncidjslice , nrecjslice , n1 = imax , n3 = khigh - klow + 1 ) if ( nrecjslice == 0 ) then call define_nc ( ncidjslice , 1 , tncstatjslice ) call writestat_dims_nc ( ncidjslice ) end if call define_nc ( ncidjslice , nstatjslice , ncstatjslice ) end if end if !> Set times to zero so works for warm starts... could have issues with warmstarts here... tsamplep = 0. tstatsdumpp = 0. end subroutine initstatsdump","tags":"","url":"proc/initstatsdump.html"},{"title":"statsdump – uDALES","text":"public  subroutine statsdump() Uses modmpi modstatistics modsurfdata modfields modstat_nc modsubgrid modglobal proc~~statsdump~~UsesGraph proc~statsdump statsdump module~modfields modfields proc~statsdump->module~modfields module~modglobal modglobal proc~statsdump->module~modglobal module~modmpi modmpi proc~statsdump->module~modmpi module~modstat_nc modstat_nc proc~statsdump->module~modstat_nc module~modstatistics modstatistics proc~statsdump->module~modstatistics module~modsubgrid modsubgrid proc~statsdump->module~modsubgrid module~modsurfdata modsurfdata proc~statsdump->module~modsurfdata decomp_2d decomp_2d module~modfields->decomp_2d mpi mpi module~modmpi->mpi module~modstat_nc->module~modmpi netcdf netcdf module~modstat_nc->netcdf module~modstatistics->module~modglobal module~modstatistics->module~modmpi module~modsubgriddata modsubgriddata module~modsubgrid->module~modsubgriddata module~modsubgrid->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~statsdump~~CallsGraph proc~statsdump statsdump interface~writestat_nc writestat_nc proc~statsdump->interface~writestat_nc proc~avexy_ibm avexy_ibm proc~statsdump->proc~avexy_ibm proc~avey_ibm avey_ibm proc~statsdump->proc~avey_ibm proc~tkestatsdump tkestatsdump proc~statsdump->proc~tkestatsdump proc~writestat_1d_nc writestat_1D_nc proc~statsdump->proc~writestat_1d_nc interface~writestat_nc->proc~writestat_1d_nc proc~writestat_2d_nc writestat_2D_nc interface~writestat_nc->proc~writestat_2d_nc proc~writestat_3d_nc writestat_3D_nc interface~writestat_nc->proc~writestat_3d_nc proc~writestat_3d_short_nc writestat_3D_short_nc interface~writestat_nc->proc~writestat_3d_short_nc proc~writestat_time_nc writestat_time_nc interface~writestat_nc->proc~writestat_time_nc mpi_allreduce mpi_allreduce proc~avexy_ibm->mpi_allreduce proc~avey_ibm->mpi_allreduce proc~tkestatsdump->proc~avexy_ibm exchange_halo_z exchange_halo_z proc~tkestatsdump->exchange_halo_z nf90_inq_varid nf90_inq_varid proc~writestat_1d_nc->nf90_inq_varid nf90_put_var nf90_put_var proc~writestat_1d_nc->nf90_put_var nf90_sync nf90_sync proc~writestat_1d_nc->nf90_sync proc~writestat_2d_nc->nf90_inq_varid proc~writestat_2d_nc->nf90_put_var proc~writestat_2d_nc->nf90_sync proc~writestat_3d_nc->nf90_inq_varid proc~writestat_3d_nc->nf90_put_var proc~writestat_3d_nc->nf90_sync proc~writestat_3d_short_nc->nf90_inq_varid proc~writestat_3d_short_nc->nf90_put_var proc~writestat_3d_short_nc->nf90_sync proc~writestat_time_nc->nf90_inq_varid proc~writestat_time_nc->nf90_put_var proc~writestat_time_nc->nf90_sync Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~statsdump~~CalledByGraph proc~statsdump statsdump program~dalesurban DALESURBAN program~dalesurban->proc~statsdump Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine statsdump use modfields , only : um , up , vm , wm , svm , qtm , thlm , pres0 , ncstaty , ncstatxy , ncstatyt , ncstattke , ncstatmint ,& ncstatkslice , ncstatislice , ncstatjslice , t_t , t_v , t_p , t_sgs , d_sgs , p_b , p_t , adv ,& IIc , IIu , IIv , IIw , IIuw , IIvw , IIct , IIwt , IIut , IIvt , IIuwt , IIuv ,& IIcs , IIws , IIus , IIvs , IIuws , IIvws , IIuvs ,& vyt , uyt , wyt , thlyt , qtyt ,& sca1yt , sca2yt , sca3yt , thlsgsyt , qtsgsyt , sv1sgsyt , sv2sgsyt , sv3sgsyt , usgsyt , wsgsyt ,& usgsxyt , thlsgsxyt , vsgsxyt , uwtik , vwtjk , uvtij , utik , wtik , wtjk , vtjk , utij , vtij ,& wthltk , wqttk , thlthlt , qtqtt , sv1sv1t , sv2sv2t , sv3sv3t , sv4sv4t , wmt , thltk , qttk , thlt , uxyt , vxyt , wxyt , thlxyt ,& ncstatxyt , qtxyt , pxyt , ncstatt , uutc , vvtc , wwtc , utc , vtc , wtc ,& umt , vmt , sv1t , sv2t , sv3t , sv4t , sv1tk , sv2tk , sv3tk , sv4tk , wsv1tk , wsv2tk , wsv3tk , wsv4tk ,& sv1sgst , sv2sgst , sv3sgst , sv4sgst , qtt , pt , PSSt ,& !,sv1max,sv2max,sv3max,sv4max ncstattr , tr_u , tr_ut , tr_v , tr_vt , tr_w , tr_wt , tr_thl , tr_thlt , tr_qt , tr_qtR ,& tr_qtA , tr_qtt , tr_qtRt , tr_qtAt , tr_sv , tr_sv1t , PSSt , tr_sv2t , tr_omega , tr_omegat use modglobal , only : ib , ie , ih , ihc , xf , xh , jb , je , jhc , jgb , jge , dy , dyi , jh , ke , kb , kh , khc , rk3step ,& timee , cexpnr , tsample , tstatsdump , tstatstart , jtot , imax , jmax , dzf ,& ltempeq , zh , dxf , dzf , dzh2i , lprofforc , lscasrcl ,& lkslicedump , lislicedump , ljslicedump , lchem , dzhi , dzfi , dzhiq , dxhi , lmoist , nsv ,& k1 , JNO2 , lchem , kslice , islice , jslice , isliceloc , jsliceloc , islicerank , jslicerank ,& ltreedump !  use modsubgriddata,   only : ekm,sbshr use modstat_nc , only : writestat_nc , writestat_1D_nc use modmpi , only : myid , cmyid , my_real , mpi_sum , avey_ibm , mpierr ,& comm3d , avexy_ibm , nprocs use modsurfdata , only : thls use modsubgrid , only : ekh , ekm use modstatistics , only : genstats , tkestats implicit none !> Create fields to be used in statistics ! interpolated fields !  real, dimension(ib:ie,jb:je,kb:ke)     :: umc !  real, dimension(ib:ie,jb:je,kb:ke)     :: vmc !  real, dimension(ib:ie,jb:je,kb:ke)     :: wmc ! real, dimension(ib:ie,jb:je,kb:ke+kh)     :: thlk ! real, dimension(ib:ie,jb:je,kb:ke+kh)     :: qtk ! real, dimension(ib:ie,jb:je,kb:ke+kh)     :: uik ! real, dimension(ib:ie,jb:je,kb:ke+kh)     :: wik ! real, dimension(ib:ie,jb:je,kb:ke+kh)     :: vjk ! real, dimension(ib:ie,jb:je,kb:ke+kh)     :: wjk ! real, dimension(ib:ie,jb:je,kb:ke+kh)     :: uij ! real, dimension(ib:ie,jb:je,kb:ke+kh)     :: vij ! real, dimension(ib:ie,jb:je,kb:ke+kh)     :: uc ! real, dimension(ib:ie,jb:je,kb:ke+kh)     :: vc ! real, dimension(ib:ie,jb:je,kb:ke+kh)     :: wc real , allocatable :: thlk (:,:,:) real , allocatable :: qtk (:,:,:) real , allocatable :: uik (:,:,:) real , allocatable :: wik (:,:,:) real , allocatable :: vjk (:,:,:) real , allocatable :: wjk (:,:,:) real , allocatable :: uij (:,:,:) real , allocatable :: vij (:,:,:) real , allocatable :: uc (:,:,:) real , allocatable :: vc (:,:,:) real , allocatable :: wc (:,:,:) ! SGS fluxes ! real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh)     :: thlsgs ! real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh)     :: qtsgs ! real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh)     :: usgs ! real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh)     :: vsgs ! real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh)     :: wsgs real , allocatable :: thlsgs (:,:,:) real , allocatable :: qtsgs (:,:,:) real , allocatable :: usgs (:,:,:) real , allocatable :: vsgs (:,:,:) real , allocatable :: wsgs (:,:,:) ! t-averaged fields ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: sv1k ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: sv2k ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: sv3k ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: sv4k ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: wpsv1p ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: wpsv2p ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: wpsv3p ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: wpsv4p ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: sv1sgs ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: sv2sgs ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: sv3sgs ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: sv4sgs real , allocatable :: sv1k (:,:,:) real , allocatable :: sv2k (:,:,:) real , allocatable :: sv3k (:,:,:) real , allocatable :: sv4k (:,:,:) real , allocatable :: sv1sgs (:,:,:) real , allocatable :: sv2sgs (:,:,:) real , allocatable :: sv3sgs (:,:,:) real , allocatable :: sv4sgs (:,:,:) real , allocatable :: wpsv1p (:,:,:) real , allocatable :: wpsv2p (:,:,:) real , allocatable :: wpsv3p (:,:,:) real , allocatable :: wpsv4p (:,:,:) real , allocatable :: sv1psv1pt (:,:,:) real , allocatable :: sv2psv2pt (:,:,:) real , allocatable :: sv3psv3pt (:,:,:) real , allocatable :: sv4psv4pt (:,:,:) real , allocatable :: PSS (:,:,:) ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: upwptik ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: vpwptjk ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: upvptij ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: wpthlptk ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: thlpthlpt ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: upuptc ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: vpvptc ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: wpwptc ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: tketc real , allocatable :: upwptik (:,:,:) real , allocatable :: vpwptjk (:,:,:) real , allocatable :: upvptij (:,:,:) real , allocatable :: wpthlptk (:,:,:) real , allocatable :: thlpthlpt (:,:,:) real , allocatable :: upuptc (:,:,:) real , allocatable :: vpvptc (:,:,:) real , allocatable :: wpwptc (:,:,:) real , allocatable :: tketc (:,:,:) ! y-averaged fields real , dimension ( ib : ie , kb : ke ) :: uy real , dimension ( ib : ie , kb : ke ) :: vy real , dimension ( ib : ie , kb : ke ) :: wy real , dimension ( ib : ie , kb : ke ) :: thly real , dimension ( ib : ie , kb : ke ) :: qty real , dimension ( ib : ie , kb : ke ) :: sca1y real , dimension ( ib : ie , kb : ke ) :: sca2y real , dimension ( ib : ie , kb : ke ) :: sca3y real , dimension ( ib : ie , kb : ke ) :: usgsy real , dimension ( ib : ie , kb : ke ) :: wsgsy real , dimension ( ib : ie , kb : ke ) :: thlsgsy real , dimension ( ib : ie , kb : ke ) :: qtsgsy real , dimension ( ib : ie , kb : ke ) :: sv1sgsy real , dimension ( ib : ie , kb : ke ) :: sv2sgsy real , dimension ( ib : ie , kb : ke ) :: sv3sgsy real , dimension ( ib : ie , kb : ke ) :: uwyik real , dimension ( ib : ie , kb : ke ) :: wthlyk real , dimension ( ib : ie , kb : ke ) :: wqtyk ! real, dimension(ib:ie,kb:ke)                 :: wsv1yk ! real, dimension(ib:ie,kb:ke)                 :: wsv2yk real , dimension ( ib : ie , kb : ke ) :: wyik real , dimension ( ib : ie , kb : ke ) :: uyik real , dimension ( ib : ie , kb : ke ) :: thlyk real , dimension ( ib : ie , kb : ke ) :: upwpyik real , dimension ( ib : ie , kb : ke ) :: wpthlpyk ! ty-averaged fluxes real , dimension ( ib : ie , kb : ke ) :: upwptyik real , dimension ( ib : ie , kb : ke ) :: wpthlptyk real , dimension ( ib : ie , kb : ke ) :: wpqtptyk real , dimension ( ib : ie , kb : ke ) :: wpsv1ptyk real , dimension ( ib : ie , kb : ke ) :: wpsv2ptyk real , dimension ( ib : ie , kb : ke ) :: wpsv3ptyk real , dimension ( ib : ie , kb : ke ) :: upuptyc real , dimension ( ib : ie , kb : ke ) :: vpvptyc real , dimension ( ib : ie , kb : ke ) :: wpwptyc real , dimension ( ib : ie , kb : ke ) :: qtpqtpty real , dimension ( ib : ie , kb : ke ) :: thlpthlpty real , dimension ( ib : ie , kb : ke ) :: sv1psv1pty real , dimension ( ib : ie , kb : ke ) :: sv2psv2pty real , dimension ( ib : ie , kb : ke ) :: sv3psv3pty real , dimension ( ib : ie , kb : ke ) :: uwtyik real , dimension ( ib : ie , kb : ke ) :: wthltyk real , dimension ( ib : ie , kb : ke ) :: wqttyk real , dimension ( ib : ie , kb : ke ) :: wsv1tyk real , dimension ( ib : ie , kb : ke ) :: wsv2tyk real , dimension ( ib : ie , kb : ke ) :: wsv3tyk ! xy-averaged fields real , dimension ( kb : ke + kh ) :: uxy real , dimension ( kb : ke + kh ) :: vxy real , dimension ( kb : ke + kh ) :: wxy real , dimension ( kb : ke + kh ) :: thlxy real , dimension ( kb : ke + kh ) :: qtxy real , dimension ( kb : ke + kh ) :: pxy real , dimension ( kb : ke + kh ) :: usgsxy real , dimension ( kb : ke + kh ) :: thlsgsxy real , dimension ( kb : ke + kh ) :: vsgsxy real , dimension ( kb : ke + kh ) :: sca1xy real , dimension ( kb : ke + kh ) :: uwxyik real , dimension ( kb : ke + kh ) :: vwxyjk real , dimension ( kb : ke + kh ) :: wthlxyk real , dimension ( kb : ke + kh ) :: thlxyk real , dimension ( kb : ke + kh ) :: wxyik real , dimension ( kb : ke + kh ) :: uxyik real , dimension ( kb : ke + kh ) :: vxyjk real , dimension ( kb : ke + kh ) :: wxyjk real , dimension ( kb : ke + kh ) :: upwpxyik real , dimension ( kb : ke + kh ) :: wpthlpxyk real , dimension ( kb : ke + kh ) :: vpwpxyjk ! txy-averaged fields real , dimension ( kb : ke + kh ) :: upwptxyik real , dimension ( kb : ke + kh ) :: wpthlptxyk real , dimension ( kb : ke + kh ) :: thlpthlptxy real , dimension ( kb : ke + kh ) :: upuptxyc real , dimension ( kb : ke + kh ) :: vpvptxyc real , dimension ( kb : ke + kh ) :: wpwptxyc real , dimension ( kb : ke + kh ) :: tketxyc real , dimension ( kb : ke + kh ) :: vpwptxyjk real , dimension ( kb : ke + kh ) :: upvptxyij real , dimension ( kb : ke + kh ) :: uwtxyik real , dimension ( kb : ke + kh ) :: wthltxyk real , dimension ( kb : ke + kh ) :: vwtxyjk real , dimension ( kb : ke + kh ) :: wwtxyk real , dimension ( kb : ke + kh ) :: uvtxyij real , allocatable :: field (:,:), varsy (:,:,:), varsyt (:,:,:), varstke (:,:), varsxy (:,:),& varkslice (:,:,:), varislice (:,:,:), varjslice (:,:,:), varsxyt (:,:), varst (:,:,:,:), varstr (:,:,:,:), varsmint (:,:,:,:) real :: tstatsdumppi , emom integer :: i , j , k , ip , im , jp , jm , kp , km integer :: writecounter = 1 integer :: reclength if ( timee < tstatstart ) return if (. not .( lytdump . or . lydump . or . lxydump . or . lxytdump . or . ltdump . or . lmintdump & . or . lkslicedump . or . lislicedump . or . ljslicedump )) return allocate ( thlk ( ib : ie , jb : je , kb : ke + kh )) allocate ( qtk ( ib : ie , jb : je , kb : ke + kh )) allocate ( uik ( ib : ie , jb : je , kb : ke + kh )) allocate ( wik ( ib : ie , jb : je , kb : ke + kh )) allocate ( vjk ( ib : ie , jb : je , kb : ke + kh )) allocate ( wjk ( ib : ie , jb : je , kb : ke + kh )) allocate ( uij ( ib : ie , jb : je , kb : ke + kh )) allocate ( vij ( ib : ie , jb : je , kb : ke + kh )) allocate ( uc ( ib : ie , jb : je , kb : ke + kh )) allocate ( vc ( ib : ie , jb : je , kb : ke + kh )) allocate ( wc ( ib : ie , jb : je , kb : ke + kh )) allocate ( thlsgs ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( qtsgs ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( usgs ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( vsgs ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( wsgs ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( sv1k ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv2k ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv3k ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv4k ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv1sgs ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv2sgs ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv3sgs ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv4sgs ( ib : ie , jb : je , kb : ke + kh )) allocate ( wpsv1p ( ib : ie , jb : je , kb : ke + kh )) allocate ( wpsv2p ( ib : ie , jb : je , kb : ke + kh )) allocate ( wpsv3p ( ib : ie , jb : je , kb : ke + kh )) allocate ( wpsv4p ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv1psv1pt ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv2psv2pt ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv3psv3pt ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv4psv4pt ( ib : ie , jb : je , kb : ke + kh )) allocate ( PSS ( ib : ie , jb : je , kb : ke + kh )) allocate ( upwptik ( ib : ie , jb : je , kb : ke + kh )) allocate ( vpwptjk ( ib : ie , jb : je , kb : ke + kh )) allocate ( upvptij ( ib : ie , jb : je , kb : ke + kh )) allocate ( wpthlptk ( ib : ie , jb : je , kb : ke + kh )) allocate ( thlpthlpt ( ib : ie , jb : je , kb : ke + kh )) allocate ( upuptc ( ib : ie , jb : je , kb : ke + kh )) allocate ( vpvptc ( ib : ie , jb : je , kb : ke + kh )) allocate ( wpwptc ( ib : ie , jb : je , kb : ke + kh )) allocate ( tketc ( ib : ie , jb : je , kb : ke + kh )) ! thlk=0.;qtk=0.;uik=0.;wik=0.;vjk=0.;wjk=0.;uij=0.;vij=0.;uc=0.;vc=0.;wc=0.;thlsgs=0.;qtsgs=0.;usgs=0.;vsgs=0.;wsgs=0.;sv1k=0.;sv2k=0.;sv3k=0.;sv4k=0.;sv1sgs=0.;sv2sgs=0.;sv3sgs=0.;sv4sgs=0.;wpsv1p=0.;wpsv2p=0. ! wpsv3p=0.;wpsv4p=0.;sv1psv1pt=0.;sv2psv2pt=0.;sv3psv3pt=0.;sv4psv4pt=0.;PSS=0.;upwptik=0.;vpwptjk=0.;upvptij=0.;wpthlptk=0.;thlpthlpt=0.;upuptc=0.;vpvptc=0.;wpwptc=0.;tketc=0. ! upwptyik=0.;wpthlptyk=0.;wpqtptyk=0.;wpsv1ptyk=0.;wpsv2ptyk=0.;wpsv3ptyk=0.;uwtyik=0.;wthltyk=0.;wqttyk=0.;wsv1tyk=0.;wsv2tyk=0.;wsv3tyk=0.;upuptyc=0.;wpwptyc=0.;thlpthlpty=0. ! qtpqtpty=0.;sv1psv1pty=0.;sv2psv2pty=0.;sv3psv3pty=0. if (. not . rk3step == 3 ) return if ( tsamplep > tsample ) then if ( lytdump . or . lydump . or . lxydump . or . lxytdump . or . ltdump . or . lmintdump ) then ! wpthlptyk=0.;wpqtptyk=0.;wpsv1ptyk=0.;wpsv2ptyk=0. tstatsdumppi = 1. / tstatsdumpp !> Perform required interpolations for flux calculations !  tg3315 for non-equidistant x and z-grids this needs to change do k = kb , ke + kh do j = jb , je do i = ib , ie uik ( i , j , k ) = 0.5 * dzhi ( k ) * ( um ( i , j , k ) * dzf ( k - 1 ) + um ( i , j , k - 1 ) * dzf ( k )) wik ( i , j , k ) = 0.5 * dxhi ( i ) * ( wm ( i , j , k ) * dxf ( i - 1 ) + wm ( i - 1 , j , k ) * dxf ( i )) vjk ( i , j , k ) = 0.5 * dzhi ( k ) * ( vm ( i , j , k ) * dzf ( k - 1 ) + vm ( i , j , k - 1 ) * dzf ( k )) wjk ( i , j , k ) = 0.5 * ( wm ( i , j , k ) + wm ( i , j - 1 , k )) uij ( i , j , k ) = 0.5 * ( um ( i , j , k ) + um ( i , j - 1 , k )) vij ( i , j , k ) = 0.5 * dxhi ( i ) * ( vm ( i , j , k ) * dxf ( i - 1 ) + vm ( i - 1 , j , k ) * dxf ( i )) uc ( i , j , k ) = 0.5 * dxhi ( i ) * ( um ( i , j , k ) * dxf ( i - 1 ) + um ( i - 1 , j , k ) * dxf ( i )) vc ( i , j , k ) = 0.5 * ( vm ( i , j , k ) + vm ( i , j - 1 , k )) wc ( i , j , k ) = 0.5 * ( wm ( i , j , k + 1 ) + wm ( i , j , k ) ) ! SGS fluxes ! interps ekm to cell corner (uw) emom = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) * dxf ( i - 1 ) + ekm ( i - 1 , j , k ) * dxf ( i ) ) + & dzf ( k ) * ( ekm ( i , j , k - 1 ) * dxf ( i - 1 ) + ekm ( i - 1 , j , k - 1 ) * dxf ( i ) ) ) * dxhi ( i ) * dzhiq ( k ) usgs ( i , j , k ) = emom * ( ( um ( i , j , k ) - um ( i , j , k - 1 )) * dzhi ( k ) & + ( wm ( i , j , k ) - wm ( i - 1 , j , k )) * dxhi ( i )) ! interps ekm to cell corner (vw) emom = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) + ekm ( i , j - 1 , k ) ) + & dzf ( k ) * ( ekm ( i , j , k - 1 ) + ekm ( i , j - 1 , k - 1 ) ) ) * dzhiq ( k ) vsgs ( i , j , k ) = emom * ( ( vm ( i , j , k ) - vm ( i , j , k - 1 )) * dzhi ( k ) & + ( wm ( i , j , k ) - wm ( i , j - 1 , k )) * dyi ) end do end do end do do k = kb , ke do j = jb , je do i = ib , ie wsgs ( i , j , k ) = ( ekm ( i , j , k ) * ( wm ( i , j , k + 1 ) - wm ( i , j , k )) * dzfi ( k ) & - ekm ( i , j , k - 1 ) * ( wm ( i , j , k ) - wm ( i , j , k - 1 )) * dzfi ( k - 1 ) ) * 2. & * dzhi ( k ) ! tg3315 check this end do end do end do if ( ltempeq ) then do k = kb , ke + kh do j = jb , je do i = ib , ie thlk ( i , j , k ) = 0.5 * dzhi ( k ) * ( thlm ( i , j , k ) * dzf ( k - 1 ) + thlm ( i , j , k - 1 ) * dzf ( k )) end do end do end do do k = kb , ke !> SGS fluxes thlsgs (:,:, k ) = 0.5 * ( dzf ( k - 1 ) * ekh (:,:, k ) + dzf ( k ) * ekh (:,:, k - 1 )) & * ( thlm (:,:, k ) - thlm (:,:, k - 1 )) * dzh2i ( k ) end do end if if ( lmoist ) then do k = kb , ke + kh do j = jb , je do i = ib , ie qtk ( i , j , k ) = 0.5 * dzhi ( k ) * ( qtm ( i , j , k ) * dzf ( k - 1 ) + qtm ( i , j , k - 1 ) * dzf ( k )) end do end do end do do k = kb , ke !> SGS fluxes qtsgs (:,:, k ) = 0.5 * ( dzf ( k - 1 ) * ekh (:,:, k ) + dzf ( k ) * ekh (:,:, k - 1 )) & * ( qtm (:,:, k ) - qtm (:,:, k - 1 )) * dzh2i ( k ) end do end if if ( nsv > 0 ) then do k = kb , ke do j = jb , je do i = ib , ie sv1k ( i , j , k ) = 0.5 * dzhi ( k ) * ( svm ( i , j , k , 1 ) * dzf ( k - 1 ) + svm ( i , j , k - 1 , 1 ) * dzf ( k )) end do end do end do do k = kb , ke sv1sgs ( ib : ie , jb : je , k ) = 0.5 * ( dzf ( k - 1 ) * ekh ( ib : ie , jb : je , k ) + dzf ( k ) * ekh ( ib : ie , jb : je , k - 1 )) & * ( svm ( ib : ie , jb : je , k , 1 ) - svm ( ib : ie , jb : je , k - 1 , 1 )) * dzh2i ( k ) end do end if if ( nsv > 1 ) then do k = kb , ke + kh do j = jb , je do i = ib , ie sv2k ( i , j , k ) = 0.5 * dzhi ( k ) * ( svm ( i , j , k , 2 ) * dzf ( k - 1 ) + svm ( i , j , k - 1 , 2 ) * dzf ( k )) end do end do end do do k = kb , ke sv2sgs ( ib : ie , jb : je , k ) = 0.5 * ( dzf ( k - 1 ) * ekh ( ib : ie , jb : je , k ) + dzf ( k ) * ekh ( ib : ie , jb : je , k - 1 )) & * ( svm ( ib : ie , jb : je , k , 2 ) - svm ( ib : ie , jb : je , k - 1 , 2 )) * dzh2i ( k ) end do end if if ( nsv > 2 ) then do k = kb , ke + kh do j = jb , je do i = ib , ie sv3k ( i , j , k ) = 0.5 * dzhi ( k ) * ( svm ( i , j , k , 3 ) * dzf ( k - 1 ) + svm ( i , j , k - 1 , 3 ) * dzf ( k )) end do end do end do do k = kb , ke sv3sgs ( ib : ie , jb : je , k ) = 0.5 * ( dzf ( k - 1 ) * ekh ( ib : ie , jb : je , k ) + dzf ( k ) * ekh ( ib : ie , jb : je , k - 1 )) & * ( svm ( ib : ie , jb : je , k , 3 ) - svm ( ib : ie , jb : je , k - 1 , 3 )) * dzh2i ( k ) end do end if if ( nsv > 3 ) then do k = kb , ke + kh do j = jb , je do i = ib , ie sv4k ( i , j , k ) = 0.5 * dzhi ( k ) * ( svm ( i , j , k , 4 ) * dzf ( k - 1 ) + svm ( i , j , k - 1 , 4 ) * dzf ( k )) end do end do end do do k = kb , ke sv4sgs ( ib : ie , jb : je , k ) = 0.5 * ( dzf ( k - 1 ) * ekh ( ib : ie , jb : je , k ) + dzf ( k ) * ekh ( ib : ie , jb : je , k - 1 )) & * ( svm ( ib : ie , jb : je , k , 4 ) - svm ( ib : ie , jb : je , k - 1 , 4 )) * dzh2i ( k ) end do end if if (( nsv > 2 ) . and . ( lchem . eqv . . true .)) then do k = kb , ke do j = jb , je do i = ib , ie if (( ABS ( svm ( i , j , k , 2 )) . gt . 1.e-40 ) . and . ( IIc ( i , j , k ) == 1 )) then PSS ( i , j , k ) = ( ( ( k1 * ( svm ( i , j , k , 1 ) / 3 0. ) * ( svm ( i , j , k , 3 ) / 4 8. )) / ( JNO2 * ( svm ( i , j , k , 2 ) / 4 6. )) ) - 1 ) * 100 end if end do end do end do end if !!>> CALCS FOR INST. STATS !> Note: More computationally efficient to spatially average mean quantities first & !        for time dependant stats, hence the .or.s. Assuming homogeneity in y. !> Average in y-direction if ( lydump . or . lytdump ) then uy = 0. ; vy = 0. ; wy = 0. ; uwyik = 0. ; usgsy = 0. ; wsgsy = 0. ; thly = 0. ; wthlyk = 0. ; thlsgsy = 0. qty = 0. ; wqtyk = 0. ; qtsgsy = 0. ; sca1y = 0. ; sv1sgsy = 0. ; sv2sgsy = 0. ; sca2y = 0. ; sca3y = 0. ; sv3sgsy = 0. call avey_ibm ( uy , um ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIu ( ib : ie , jb : je , kb : ke ), IIut ( ib : ie , kb : ke )) call avey_ibm ( vy , vm ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIv ( ib : ie , jb : je , kb : ke ), IIvt ( ib : ie , kb : ke )) call avey_ibm ( wy , wm ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( uwyik , uik ( ib : ie , jb : je , kb : ke ) * wik ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIuw ( ib : ie , jb : je , kb : ke ), IIuwt ( ib : ie , kb : ke )) call avey_ibm ( usgsy , usgs ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIuw ( ib : ie , jb : je , kb : ke ), IIuwt ( ib : ie , kb : ke )) call avey_ibm ( wsgsy , wsgs ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) if ( ltempeq ) then call avey_ibm ( thly , thlm ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke ), IIct ( ib : ie , kb : ke )) call avey_ibm ( wthlyk , wm ( ib : ie , jb : je , kb : ke ) * thlk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( thlsgsy , thlsgs ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) end if if ( lmoist ) then call avey_ibm ( qty , qtm ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke ), IIct ( ib : ie , kb : ke )) call avey_ibm ( wqtyk , wm ( ib : ie , jb : je , kb : ke ) * qtk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( qtsgsy , qtsgs ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) end if if ( nsv > 0 ) then call avey_ibm ( sca1y , svm ( ib : ie , jb : je , kb : ke , 1 ), ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke ), IIct ( ib : ie , kb : ke )) ! call avey_ibm(wsv1yk,wm(ib:ie,jb:je,kb:ke)*sv1k(ib:ie,jb:je,kb:ke),ib,ie,jb,je,kb,ke,IIw(ib:ie,jb:je,kb:ke),IIwt(ib:ie,kb:ke)) call avey_ibm ( sv1sgsy , sv1sgs ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) end if if ( nsv > 1 ) then call avey_ibm ( sca2y , svm ( ib : ie , jb : je , kb : ke , 2 ), ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke ), IIct ( ib : ie , kb : ke )) ! call avey_ibm(wsv2yk,wm(ib:ie,jb:je,kb:ke)*sv2k(ib:ie,jb:je,kb:ke),ib,ie,jb,je,kb,ke,IIw(ib:ie,jb:je,kb:ke),IIwt(ib:ie,kb:ke)) call avey_ibm ( sv2sgsy , sv2sgs ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) end if if ( nsv > 2 ) then call avey_ibm ( sca3y , svm ( ib : ie , jb : je , kb : ke , 3 ), ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke ), IIct ( ib : ie , kb : ke )) call avey_ibm ( sv3sgsy , sv3sgs ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) end if end if ! lydump .or. lytdump if ( lydump ) then uwyik = 0. ; wthlyk = 0. ; uyik = 0. ; wyik = 0. ; thlyk = 0. ; wpthlpyk = 0. call avey_ibm ( uwyik , uik ( ib : ie , jb : je , kb : ke ) * wik ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIuw ( ib : ie , jb : je , kb : ke ), IIuwt ( ib : ie , kb : ke )) call avey_ibm ( uyik , uik ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIuw ( ib : ie , jb : je , kb : ke ), IIuwt ( ib : ie , kb : ke )) call avey_ibm ( wyik , wik ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIuw ( ib : ie , jb : je , kb : ke ), IIuwt ( ib : ie , kb : ke )) if ( ltempeq ) then call avey_ibm ( wthlyk , wm ( ib : ie , jb : je , kb : ke ) * thlk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( thlyk , thlk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) end if upwpyik = uwyik - uyik * wyik if ( ltempeq ) then wpthlpyk = wthlyk - wy * thlyk where ( IIwt == 0 ) wpthlpyk = - 99 9.0 endwhere end if where ( IIuwt == 0 ) upwpyik = - 99 9.0 endwhere end if ! lydump !> tg3315 10.07.18 - in any case where averaging spatially can assume homogeneity and therefore average !  spatially first? Perhaps not due to UCL...? Would save space but goes against triple decomposition !  definition !> Average in x and y-direction if ( lxydump . or . lxytdump ) then uxy = 0. ; vxy = 0. ; wxy = 0. ; thlxy = 0. ; qtxy = 0. ; pxy = 0. ; usgsxy = 0. ; thlsgsxy = 0. ; sca1xy = 0. ; vsgsxy = 0. !> Spatial averages of mean quantities call avexy_ibm ( uxy ( kb : ke + kh ), um ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIu ( ib : ie , jb : je , kb : ke + kh ), IIus ( kb : ke + kh ),. false .) call avexy_ibm ( vxy ( kb : ke + kh ), vm ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIv ( ib : ie , jb : je , kb : ke + kh ), IIvs ( kb : ke + kh ),. false .) call avexy_ibm ( wxy ( kb : ke + kh ), wm ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIw ( ib : ie , jb : je , kb : ke + kh ), IIws ( kb : ke + kh ),. false .) if ( ltempeq ) then call avexy_ibm ( thlxy ( kb : ke + kh ), thlm ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) call avexy_ibm ( thlsgsxy ( kb : ke + kh ), thlsgs ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIw ( ib : ie , jb : je , kb : ke + kh ), IIws ( kb : ke + kh ),. false .) end if if ( lmoist ) then call avexy_ibm ( qtxy ( kb : ke + kh ), qtm ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) end if call avexy_ibm ( pxy ( kb : ke + kh ), pres0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) call avexy_ibm ( usgsxy ( kb : ke + kh ), usgs ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIuw ( ib : ie , jb : je , kb : ke + kh ), IIuws ( kb : ke + kh ),. false .) call avexy_ibm ( vsgsxy ( kb : ke + kh ), vsgs ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIvw ( ib : ie , jb : je , kb : ke + kh ), IIvws ( kb : ke + kh ),. false .) end if ! lxydump .or. lxytdump if ( lxydump ) then uwxyik = 0. ; vwxyjk = 0. ; uxyik = 0. ; wxyik = 0. ; vxyjk = 0. ; wxyjk = 0. ; wthlxyk = 0. ; thlxyk = 0. ; wpthlpxyk = 0. call avexy_ibm ( uwxyik ( kb : ke + kh ), uik ( ib : ie , jb : je , kb : ke + kh ) * wik ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIuw ( ib : ie , jb : je , kb : ke + kh ), IIuws ( kb : ke + kh ),. true .) call avexy_ibm ( vwxyjk ( kb : ke + kh ), vjk ( ib : ie , jb : je , kb : ke + kh ) * wjk ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIvw ( ib : ie , jb : je , kb : ke + kh ), IIvws ( kb : ke + kh ),. true .) call avexy_ibm ( uxyik ( kb : ke + kh ), uik ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIuw ( ib : ie , jb : je , kb : ke + kh ), IIuws ( kb : ke + kh ),. true .) call avexy_ibm ( wxyik ( kb : ke + kh ), wik ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIuw ( ib : ie , jb : je , kb : ke + kh ), IIuws ( kb : ke + kh ),. true .) call avexy_ibm ( wxyjk ( kb : ke + kh ), wjk ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIvw ( ib : ie , jb : je , kb : ke + kh ), IIvws ( kb : ke + kh ),. true .) call avexy_ibm ( vxyjk ( kb : ke + kh ), vjk ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIvw ( ib : ie , jb : je , kb : ke + kh ), IIvws ( kb : ke + kh ),. true .) if ( ltempeq ) then call avexy_ibm ( wthlxyk ( kb : ke + kh ), wm ( ib : ie , jb : je , kb : ke + kh ) * thlk ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIw ( ib : ie , jb : je , kb : ke + kh ), IIws ( kb : ke + kh ),. true .) call avexy_ibm ( thlxyk ( kb : ke + kh ), thlk ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIw ( ib : ie , jb : je , kb : ke + kh ), IIws ( kb : ke + kh ),. true .) end if upwpxyik = uwxyik - uxyik * wxyik vpwpxyjk = vwxyjk - vxyjk * wxyjk if ( ltempeq ) then wpthlpxyk = wthlxyk - wxy * thlxyk end if end if ! lxydump !!>> CALCS FOR TIME DEPENDANT (AVERAGED) STATS !> Average 1-D fields in time if ( lxytdump ) then uxyt ( kb : ke + kh ) = ( uxyt ( kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + uxy ( kb : ke + kh ) * tsamplep ) * tstatsdumppi vxyt ( kb : ke + kh ) = ( vxyt ( kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + vxy ( kb : ke + kh ) * tsamplep ) * tstatsdumppi wxyt ( kb : ke + kh ) = ( wxyt ( kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + wxy ( kb : ke + kh ) * tsamplep ) * tstatsdumppi qtxyt ( kb : ke + kh ) = ( qtxyt ( kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + qtxy ( kb : ke + kh ) * tsamplep ) * tstatsdumppi pxyt ( kb : ke + kh ) = ( pxyt ( kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + pxy ( kb : ke + kh ) * tsamplep ) * tstatsdumppi usgsxyt ( kb : ke + kh ) = ( usgsxyt ( kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + usgsxy ( kb : ke + kh ) * tsamplep ) * tstatsdumppi vsgsxyt ( kb : ke + kh ) = ( vsgsxyt ( kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + vsgsxy ( kb : ke + kh ) * tsamplep ) * tstatsdumppi if ( ltempeq ) then thlsgsxyt ( kb : ke + kh ) = ( thlsgsxyt ( kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + thlsgsxy ( kb : ke + kh ) * tsamplep ) * tstatsdumppi thlxyt ( kb : ke + kh ) = ( thlxyt ( kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + thlxy ( kb : ke + kh ) * tsamplep ) * tstatsdumppi end if end if ! lxytdump !> Average 2-D fields in time if ( lytdump ) then if ( myid == 0 ) then vyt ( ib : ie , kb : ke ) = ( vyt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + vy ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi uyt ( ib : ie , kb : ke ) = ( uyt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + uy ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi wyt ( ib : ie , kb : ke ) = ( wyt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + wy ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi usgsyt ( ib : ie , kb : ke ) = ( usgsyt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + usgsy ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi wsgsyt ( ib : ie , kb : ke ) = ( wsgsyt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + wsgsy ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi if ( ltempeq ) then thlyt ( ib : ie , kb : ke ) = ( thlyt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + thly ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi thlsgsyt ( ib : ie , kb : ke ) = ( thlsgsyt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + thlsgsy ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi end if if ( lmoist ) then qtyt ( ib : ie , kb : ke ) = ( qtyt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + qty ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi qtsgsyt ( ib : ie , kb : ke ) = ( qtsgsyt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + qtsgsy ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi end if if ( nsv > 0 ) then sca1yt ( ib : ie , kb : ke ) = ( sca1yt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + sca1y ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi sv1sgsyt ( ib : ie , kb : ke ) = ( sv1sgsyt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + sv1sgsy ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi end if if ( nsv > 1 ) then sca2yt ( ib : ie , kb : ke ) = ( sca2yt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + sca2y ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi sv2sgsyt ( ib : ie , kb : ke ) = ( sv2sgsyt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + sv2sgsy ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi end if if ( nsv > 2 ) then sca3yt ( ib : ie , kb : ke ) = ( sca3yt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + sca3y ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi sv3sgsyt ( ib : ie , kb : ke ) = ( sv3sgsyt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + sv3sgsy ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi end if end if ! myid end if !lytdump ! Average 3-D fields in time ! tg3315 may be possible to do less calculations by splitting up ! some calcs not necessary for xyt or yt... if ( lxytdump . or . lytdump . or . ltdump . or . lmintdump ) then uwtik (:,:, kb : ke + kh ) = ( uwtik (:,:, kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + wik (:,:, kb : ke + kh ) * uik (:,:, kb : ke + kh ) * tsamplep ) * tstatsdumppi vwtjk (:,:, kb : ke + kh ) = ( vwtjk (:,:, kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + wjk (:,:, kb : ke + kh ) * vjk (:,:, kb : ke + kh ) * tsamplep ) * tstatsdumppi uvtij (:,:, kb : ke + kh ) = ( uvtij (:,:, kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + uij (:,:, kb : ke + kh ) * vij (:,:, kb : ke + kh ) * tsamplep ) * tstatsdumppi uutc ( ib : ie , jb : je , kb : ke + kh ) = ( uutc ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + uc ( ib : ie , jb : je , kb : ke + kh ) * uc ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi vvtc ( ib : ie , jb : je , kb : ke + kh ) = ( vvtc ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + vc ( ib : ie , jb : je , kb : ke + kh ) * vc ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi wwtc ( ib : ie , jb : je , kb : ke + kh ) = ( wwtc ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + wc ( ib : ie , jb : je , kb : ke + kh ) * wc ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi utik (:,:, kb : ke + kh ) = ( utik (:,:, kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + uik (:,:, kb : ke + kh ) * tsamplep ) * tstatsdumppi wtik (:,:, kb : ke + kh ) = ( wtik (:,:, kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + wik (:,:, kb : ke + kh ) * tsamplep ) * tstatsdumppi vtjk (:,:, kb : ke + kh ) = ( vtjk (:,:, kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + vjk (:,:, kb : ke + kh ) * tsamplep ) * tstatsdumppi wtjk (:,:, kb : ke + kh ) = ( wtjk (:,:, kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + wjk (:,:, kb : ke + kh ) * tsamplep ) * tstatsdumppi utij (:,:, kb : ke + kh ) = ( utij (:,:, kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + uij (:,:, kb : ke + kh ) * tsamplep ) * tstatsdumppi vtij (:,:, kb : ke + kh ) = ( vtij (:,:, kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + vij (:,:, kb : ke + kh ) * tsamplep ) * tstatsdumppi umt ( ib : ie , jb : je , kb : ke + kh ) = ( umt ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + um ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi vmt ( ib : ie , jb : je , kb : ke + kh ) = ( vmt ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + vm ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi wmt ( ib : ie , jb : je , kb : ke + kh ) = ( wmt ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + wm ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi utc ( ib : ie , jb : je , kb : ke + kh ) = ( utc ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + uc ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi vtc ( ib : ie , jb : je , kb : ke + kh ) = ( vtc ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + vc ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi wtc ( ib : ie , jb : je , kb : ke + kh ) = ( wtc ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + wc ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi pt ( ib : ie , jb : je , kb : ke + kh ) = ( pt ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + pres0 ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi if ( ltempeq ) then wthltk ( ib : ie , jb : je , kb : ke + kh ) = ( wthltk ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + thlk ( ib : ie , jb : je , kb : ke + kh ) * wm ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi thlthlt ( ib : ie , jb : je , kb : ke + kh ) = ( thlthlt ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + thlm ( ib : ie , jb : je , kb : ke + kh ) * thlm ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi thltk ( ib : ie , jb : je , kb : ke + kh ) = ( thltk ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + thlk ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi thlt ( ib : ie , jb : je , kb : ke + kh ) = ( thlt ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + thlm ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi end if if ( lmoist ) then wqttk ( ib : ie , jb : je , kb : ke + kh ) = ( wqttk ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + qtk ( ib : ie , jb : je , kb : ke + kh ) * wm ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi qtqtt ( ib : ie , jb : je , kb : ke + kh ) = ( qtqtt ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + qtm ( ib : ie , jb : je , kb : ke + kh ) * qtm ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi qttk ( ib : ie , jb : je , kb : ke + kh ) = ( qttk ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + qtk ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi qtt ( ib : ie , jb : je , kb : ke + kh ) = ( qtt ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + qtm ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi end if if ( nsv > 0 ) then sv1t ( ib : ie , jb : je , kb : ke + kh ) = ( sv1t ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + svm ( ib : ie , jb : je , kb : ke + kh , 1 ) * tsamplep ) * tstatsdumppi sv1tk ( ib : ie , jb : je , kb : ke + kh ) = ( sv1tk ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + sv1k ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi wsv1tk ( ib : ie , jb : je , kb : ke + kh ) = ( wsv1tk ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + wm ( ib : ie , jb : je , kb : ke + kh ) * sv1k ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi sv1sgst ( ib : ie , jb : je , kb : ke + kh ) = ( sv1sgst ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + sv1sgs ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi sv1sv1t ( ib : ie , jb : je , kb : ke + kh ) = ( sv1sv1t ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + svm ( ib : ie , jb : je , kb : ke + kh , 1 ) * svm ( ib : ie , jb : je , kb : ke + kh , 1 ) * tsamplep ) * tstatsdumppi ! sv1max(ib:ie,jb:je,kb:ke) = max(sv1max(ib:ie,jb:je,kb:ke),svm(ib:ie,jb:je,kb:ke,1)) end if if (( lchem . eqv . . true .) . and . ( nsv > 2 )) then PSSt ( ib : ie , jb : je , kb : ke + kh ) = ( PSSt ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + PSS ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi end if if ( nsv > 1 ) then sv2t ( ib : ie , jb : je , kb : ke + kh ) = ( sv2t ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + svm ( ib : ie , jb : je , kb : ke + kh , 2 ) * tsamplep ) * tstatsdumppi sv2tk ( ib : ie , jb : je , kb : ke + kh ) = ( sv2tk ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + sv2k ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi wsv2tk ( ib : ie , jb : je , kb : ke + kh ) = ( wsv2tk ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + wm ( ib : ie , jb : je , kb : ke + kh ) * sv2k ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi sv2sgst ( ib : ie , jb : je , kb : ke + kh ) = ( sv2sgst ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + sv2sgs ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi sv2sv2t ( ib : ie , jb : je , kb : ke + kh ) = ( sv2sv2t ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + svm ( ib : ie , jb : je , kb : ke + kh , 2 ) * svm ( ib : ie , jb : je , kb : ke + kh , 2 ) * tsamplep ) * tstatsdumppi ! sv2max(ib:ie,jb:je,kb:ke) = max(sv2max(ib:ie,jb:je,kb:ke),svm(ib:ie,jb:je,kb:ke,2)) end if if ( nsv > 2 ) then sv3t ( ib : ie , jb : je , kb : ke + kh ) = ( sv3t ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + svm ( ib : ie , jb : je , kb : ke + kh , 3 ) * tsamplep ) * tstatsdumppi sv3tk ( ib : ie , jb : je , kb : ke + kh ) = ( sv3tk ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + sv3k ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi wsv3tk ( ib : ie , jb : je , kb : ke + kh ) = ( wsv3tk ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + wm ( ib : ie , jb : je , kb : ke + kh ) * sv3k ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi sv3sgst ( ib : ie , jb : je , kb : ke + kh ) = ( sv3sgst ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + sv3sgs ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi sv3sv3t ( ib : ie , jb : je , kb : ke + kh ) = ( sv3sv3t ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + svm ( ib : ie , jb : je , kb : ke + kh , 3 ) * svm ( ib : ie , jb : je , kb : ke + kh , 3 ) * tsamplep ) * tstatsdumppi ! sv3max(ib:ie,jb:je,kb:ke) = max(sv3max(ib:ie,jb:je,kb:ke),svm(ib:ie,jb:je,kb:ke,3)) end if if ( nsv > 3 ) then sv4t ( ib : ie , jb : je , kb : ke + kh ) = ( sv4t ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + svm ( ib : ie , jb : je , kb : ke + kh , 4 ) * tsamplep ) * tstatsdumppi sv4tk ( ib : ie , jb : je , kb : ke + kh ) = ( sv4tk ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + sv4k ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi wsv4tk ( ib : ie , jb : je , kb : ke + kh ) = ( wsv4tk ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + wm ( ib : ie , jb : je , kb : ke + kh ) * sv4k ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi sv4sgst ( ib : ie , jb : je , kb : ke + kh ) = ( sv4sgst ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + sv4sgs ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi sv4sv4t ( ib : ie , jb : je , kb : ke + kh ) = ( sv4sv4t ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + svm ( ib : ie , jb : je , kb : ke + kh , 4 ) * svm ( ib : ie , jb : je , kb : ke + kh , 4 ) * tsamplep ) * tstatsdumppi ! sv4max(ib:ie,jb:je,kb:ke) = max(sv4max(ib:ie,jb:je,kb:ke),svm(ib:ie,jb:je,kb:ke,4)) end if end if !lxytdump .or. lytdump .or. ltdump ! Other 3-D fields specifically for tdump !if (ltdump) then ! bss116 already calculated above ! wmt(ib:ie,jb:je,kb:ke+kh) = (wmt(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + wm(ib:ie,jb:je,kb:ke+kh)*tsamplep)*tstatsdumppi ! sv1t(ib:ie,jb:je,kb:ke+kh) = (sv1t(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + svm(ib:ie,jb:je,kb:ke+kh,1)*tsamplep)*tstatsdumppi ! sv2t(ib:ie,jb:je,kb:ke+kh) = (sv2t(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + svm(ib:ie,jb:je,kb:ke+kh,2)*tsamplep)*tstatsdumppi ! sv3t(ib:ie,jb:je,kb:ke+kh) = (sv3t(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + svm(ib:ie,jb:je,kb:ke+kh,3)*tsamplep)*tstatsdumppi ! ! sv4t(ib:ie,jb:je,kb:ke+kh) = (sv4t(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + svm(ib:ie,jb:je,kb:ke+kh,4)*tsamplep)*tstatsdumppi ! sv1tk(ib:ie,jb:je,kb:ke+kh) = (sv1tk(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + sv1k(ib:ie,jb:je,kb:ke+kh)*tsamplep)*tstatsdumppi ! sv2tk(ib:ie,jb:je,kb:ke+kh) = (sv2tk(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + sv2k(ib:ie,jb:je,kb:ke+kh)*tsamplep)*tstatsdumppi ! sv3tk(ib:ie,jb:je,kb:ke+kh) = (sv3tk(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + sv3k(ib:ie,jb:je,kb:ke+kh)*tsamplep)*tstatsdumppi ! sv4tk(ib:ie,jb:je,kb:ke+kh) = (sv4tk(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + sv4k(ib:ie,jb:je,kb:ke+kh)*tsamplep)*tstatsdumppi ! wsv1tk(ib:ie,jb:je,kb:ke+kh) = (wsv1tk(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + wm(ib:ie,jb:je,kb:ke+kh)*sv1k(ib:ie,jb:je,kb:ke+kh)*tsamplep)*tstatsdumppi ! wsv2tk(ib:ie,jb:je,kb:ke+kh) = (wsv2tk(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + wm(ib:ie,jb:je,kb:ke+kh)*sv2k(ib:ie,jb:je,kb:ke+kh)*tsamplep)*tstatsdumppi ! wsv3tk(ib:ie,jb:je,kb:ke+kh) = (wsv3tk(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + wm(ib:ie,jb:je,kb:ke+kh)*sv3k(ib:ie,jb:je,kb:ke+kh)*tsamplep)*tstatsdumppi ! wsv4tk(ib:ie,jb:je,kb:ke+kh) = (wsv4tk(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + wm(ib:ie,jb:je,kb:ke+kh)*sv4k(ib:ie,jb:je,kb:ke+kh)*tsamplep)*tstatsdumppi ! sv1sgst(ib:ie,jb:je,kb:ke+kh) = (sv1sgst(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + sv1sgs(ib:ie,jb:je,kb:ke+kh)*tsamplep)*tstatsdumppi ! sv2sgst(ib:ie,jb:je,kb:ke+kh) = (sv2sgst(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + sv2sgs(ib:ie,jb:je,kb:ke+kh)*tsamplep)*tstatsdumppi ! sv3sgst(ib:ie,jb:je,kb:ke+kh) = (sv3sgst(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + sv3sgs(ib:ie,jb:je,kb:ke+kh)*tsamplep)*tstatsdumppi ! sv4sgst(ib:ie,jb:je,kb:ke+kh) = (sv4sgst(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + sv4sgs(ib:ie,jb:je,kb:ke+kh)*tsamplep)*tstatsdumppi !end if ! ltdump if ( ltreedump ) then tr_ut ( ib : ie , jb : je , kb : ke ) = ( tr_ut ( ib : ie , jb : je , kb : ke ) * ( tstatsdumpp - tsamplep ) + tr_u ( ib : ie , jb : je , kb : ke ) * tsamplep ) * tstatsdumppi tr_vt ( ib : ie , jb : je , kb : ke ) = ( tr_vt ( ib : ie , jb : je , kb : ke ) * ( tstatsdumpp - tsamplep ) + tr_v ( ib : ie , jb : je , kb : ke ) * tsamplep ) * tstatsdumppi tr_wt ( ib : ie , jb : je , kb : ke ) = ( tr_wt ( ib : ie , jb : je , kb : ke ) * ( tstatsdumpp - tsamplep ) + tr_w ( ib : ie , jb : je , kb : ke ) * tsamplep ) * tstatsdumppi if ( ltempeq ) then tr_thlt ( ib : ie , jb : je , kb : ke ) = ( tr_thlt ( ib : ie , jb : je , kb : ke ) * ( tstatsdumpp - tsamplep ) + tr_thl ( ib : ie , jb : je , kb : ke ) * tsamplep ) * tstatsdumppi end if if ( lmoist ) then tr_qtt ( ib : ie , jb : je , kb : ke ) = ( tr_qtt ( ib : ie , jb : je , kb : ke ) * ( tstatsdumpp - tsamplep ) + tr_qt ( ib : ie , jb : je , kb : ke ) * tsamplep ) * tstatsdumppi tr_qtRt ( ib : ie , jb : je , kb : ke ) = ( tr_qtRt ( ib : ie , jb : je , kb : ke ) * ( tstatsdumpp - tsamplep ) + tr_qtR ( ib : ie , jb : je , kb : ke ) * tsamplep ) * tstatsdumppi tr_qtAt ( ib : ie , jb : je , kb : ke ) = ( tr_qtAt ( ib : ie , jb : je , kb : ke ) * ( tstatsdumpp - tsamplep ) + tr_qtA ( ib : ie , jb : je , kb : ke ) * tsamplep ) * tstatsdumppi tr_omegat ( ib : ie , jb : je , kb : ke ) = ( tr_omegat ( ib : ie , jb : je , kb : ke ) * ( tstatsdumpp - tsamplep ) + tr_omega ( ib : ie , jb : je , kb : ke ) * tsamplep ) * tstatsdumppi end if if ( nsv > 0 ) then tr_sv1t ( ib : ie , jb : je , kb : ke ) = ( tr_sv1t ( ib : ie , jb : je , kb : ke ) * ( tstatsdumpp - tsamplep ) + tr_sv ( ib : ie , jb : je , kb : ke , 1 ) * tsamplep ) * tstatsdumppi tr_sv2t ( ib : ie , jb : je , kb : ke ) = ( tr_sv2t ( ib : ie , jb : je , kb : ke ) * ( tstatsdumpp - tsamplep ) + tr_sv ( ib : ie , jb : je , kb : ke , 2 ) * tsamplep ) * tstatsdumppi end if end if !      where (IIuwt==0) !        upwpyik    = -999 !        upwpytik   = -999 !      endwhere end if ! lytdump .or. lydump .or. lxydump .or. lxytdump .or. ltdump .or. lmintdump ! Write y-averaged statistics every tsample if ( lydump ) then if ( myid == 0 ) then allocate ( field ( ib : ie , kb : ke )) allocate ( varsy ( imax , khigh - klow + 1 , nstaty )) varsy = 0. varsy (:,:, 1 ) = uy ( ib : ie , kb : ke ) varsy (:,:, 2 ) = vy ( ib : ie , kb : ke ) varsy (:,:, 3 ) = wy ( ib : ie , kb : ke ) varsy (:,:, 4 ) = thly ( ib : ie , kb : ke ) varsy (:,:, 5 ) = qty ( ib : ie , kb : ke ) varsy (:,:, 6 ) = sca1y ( ib : ie , kb : ke ) varsy (:,:, 7 ) = sca2y ( ib : ie , kb : ke ) varsy (:,:, 8 ) = sca3y ( ib : ie , kb : ke ) varsy (:,:, 9 ) = upwpyik ( ib : ie , kb : ke ) varsy (:,:, 10 ) = wpthlpyk ( ib : ie , kb : ke ) varsy (:,:, 11 ) = usgsy ( ib : ie , kb : ke ) varsy (:,:, 12 ) = thlsgsy ( ib : ie , kb : ke ) varsy (:,:, 13 ) = uwyik ( ib : ie , kb : ke ) varsy (:,:, 14 ) = wthlyk ( ib : ie , kb : ke ) call writestat_nc ( ncidy , 1 , tncstaty ,( / timee / ), nrecy ,. true .) call writestat_nc ( ncidy , nstaty , ncstaty , varsy , nrecy , imax , khigh - klow + 1 ) deallocate ( field , varsy ) endif !myid endif !lydump ! Write xy-averaged statistics every tsample if ( lxydump ) then if ( myid == 0 ) then call writestat_nc ( ncidxy , 1 , tncstatxy ,( / timee / ), nrecxy ,. true .) allocate ( varsxy ( khigh - klow + 1 , nstatxy )) varsxy (:, 1 ) = uxy ( kb : ke ) varsxy (:, 2 ) = vxy ( kb : ke ) varsxy (:, 3 ) = wxy ( kb : ke ) varsxy (:, 4 ) = thlxy ( kb : ke ) varsxy (:, 5 ) = qtxy ( kb : ke ) varsxy (:, 6 ) = pxy ( kb : ke ) varsxy (:, 7 ) = upwpxyik ( kb : ke ) varsxy (:, 8 ) = wpthlpxyk ( kb : ke ) varsxy (:, 9 ) = vpwpxyjk ( kb : ke ) varsxy (:, 10 ) = usgsxy ( kb : ke ) varsxy (:, 11 ) = thlsgsxy ( kb : ke ) !wdthldtc(kb:ke) varsxy (:, 12 ) = vsgsxy ( kb : ke ) varsxy (:, 13 ) = uwxyik ( kb : ke ) varsxy (:, 14 ) = wthlxyk ( kb : ke ) varsxy (:, 15 ) = vwxyjk ( kb : ke ) call writestat_1D_nc ( ncidxy , nstatxy , ncstatxy , varsxy , nrecxy , khigh - klow + 1 ) end if !myid end if !lxydump if ( lkslicedump ) then allocate ( varkslice ( imax , jmax , nstatkslice )) call writestat_nc ( ncidkslice , 1 , tncstatkslice ,( / timee / ), nreckslice ,. true .) varkslice (:,:, 1 ) = um ( ib : ie , jb : je , kslice ) varkslice (:,:, 2 ) = vm ( ib : ie , jb : je , kslice ) varkslice (:,:, 3 ) = 0.5 * ( wm ( ib : ie , jb : je , kslice ) + wm ( ib : ie , jb : je , kslice + 1 )) ! assumes equidistant varkslice (:,:, 4 ) = thlm ( ib : ie , jb : je , kslice ) varkslice (:,:, 5 ) = qtm ( ib : ie , jb : je , kslice ) call writestat_nc ( ncidkslice , nstatkslice , ncstatkslice , varkslice , nreckslice , imax , jmax ) endif if ( lislicedump ) then if ( islicerank ) then allocate ( varislice ( jmax , khigh - klow + 1 , nstatislice )) call writestat_nc ( ncidislice , 1 , tncstatislice ,( / timee / ), nrecislice ,. true .) varislice (:,:, 1 ) = 0.5 * ( um ( isliceloc , jb : je , kb : ke ) + um ( isliceloc + 1 , jb : je , kb : ke )) varislice (:,:, 2 ) = vm ( isliceloc , jb : je , kb : ke ) varislice (:,:, 3 ) = wm ( isliceloc , jb : je , kb : ke ) varislice (:,:, 4 ) = thlm ( isliceloc , jb : je , kb : ke ) varislice (:,:, 5 ) = qtm ( isliceloc , jb : je , kb : ke ) call writestat_nc ( ncidislice , nstatislice , ncstatislice , varislice , nrecislice , jmax , khigh - klow + 1 ) endif endif if ( ljslicedump ) then if ( jslicerank ) then allocate ( varjslice ( imax , khigh - klow + 1 , nstatjslice )) call writestat_nc ( ncidjslice , 1 , tncstatjslice ,( / timee / ), nrecjslice ,. true .) varjslice (:,:, 1 ) = um ( ib : ie , jsliceloc , kb : ke ) varjslice (:,:, 2 ) = 0.5 * ( vm ( ib : ie , jsliceloc , kb : ke ) + vm ( ib : ie , jsliceloc + 1 , kb : ke )) varjslice (:,:, 3 ) = wm ( ib : ie , jsliceloc , kb : ke ) varjslice (:,:, 4 ) = thlm ( ib : ie , jsliceloc , kb : ke ) varjslice (:,:, 5 ) = qtm ( ib : ie , jsliceloc , kb : ke ) call writestat_nc ( ncidjslice , nstatjslice , ncstatjslice , varjslice , nrecjslice , imax , khigh - klow + 1 ) endif endif if ( ltkedump ) then !call genstats(tsamplep,tstatsdumpp,umc,vmc,wmc) endif tsamplep = dt else !timestatsdumpp < tsample tsamplep = tsamplep + dt endif if ( tstatsdumpp > tstatsdump ) then ! Final calculations and write xyt-averaged statistics every tsample if ( lxytdump ) then wthltxyk = 0. ; uwtxyik = 0. ; vwtxyjk = 0. ; wwtxyk = 0. ; uvtxyij = 0. ; wpthlptxyk = 0. ; upwptxyik = 0. ; vpwptxyjk = 0. ; upvptxyij = 0. ; thlpthlptxy = 0. ; upuptxyc = 0. ; vpvptxyc = 0. ; wpwptxyc = 0. ; tketxyc = 0. !> Advective flux if ( ltempeq ) then call avexy_ibm ( wthltxyk ( kb : ke + kh ), wmt ( ib : ie , jb : je , kb : ke + kh ) * thltk ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIw ( ib : ie , jb : je , kb : ke + kh ), IIws ( kb : ke + kh ),. false .) end if call avexy_ibm ( uwtxyik ( kb : ke + kh ), utik ( ib : ie , jb : je , kb : ke + kh ) * wtik ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIuw ( ib : ie , jb : je , kb : ke + kh ), IIuws ( kb : ke + kh ),. false .) call avexy_ibm ( vwtxyjk ( kb : ke + kh ), vtjk ( ib : ie , jb : je , kb : ke + kh ) * wtjk ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIvw ( ib : ie , jb : je , kb : ke + kh ), IIvws ( kb : ke + kh ),. false .) call avexy_ibm ( wwtxyk ( kb : ke + kh ), wmt ( ib : ie , jb : je , kb : ke + kh ) * wmt ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIw ( ib : ie , jb : je , kb : ke + kh ), IIws ( kb : ke + kh ),. false .) call avexy_ibm ( uvtxyij ( kb : ke + kh ), utij ( ib : ie , jb : je , kb : ke + kh ) * vtij ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIuv ( ib : ie , jb : je , kb : ke + kh ), IIuvs ( kb : ke + kh ),. false .) !> Turbulent fluxes if ( ltempeq ) then call avexy_ibm ( wpthlptxyk ( kb : ke + kh ), wthltk ( ib : ie , jb : je , kb : ke + kh ) - wmt ( ib : ie , jb : je , kb : ke + kh ) * thltk ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIw ( ib : ie , jb : je , kb : ke + kh ), IIws ( kb : ke + kh ),. false .) end if call avexy_ibm ( upwptxyik ( kb : ke + kh ), uwtik ( ib : ie , jb : je , kb : ke + kh ) - utik ( ib : ie , jb : je , kb : ke + kh ) * wtik ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIuw ( ib : ie , jb : je , kb : ke + kh ), IIuws ( kb : ke + kh ),. false .) call avexy_ibm ( vpwptxyjk ( kb : ke + kh ), vwtjk ( ib : ie , jb : je , kb : ke + kh ) - vtjk ( ib : ie , jb : je , kb : ke + kh ) * wtjk ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIvw ( ib : ie , jb : je , kb : ke + kh ), IIvws ( kb : ke + kh ),. false .) call avexy_ibm ( upvptxyij ( kb : ke + kh ), uvtij ( ib : ie , jb : je , kb : ke + kh ) - utij ( ib : ie , jb : je , kb : ke + kh ) * vtij ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIuv ( ib : ie , jb : je , kb : ke + kh ), IIuvs ( kb : ke + kh ),. false .) !> Variances and TKE if ( ltempeq ) then call avexy_ibm ( thlpthlptxy ( kb : ke + kh ), thlthlt ( ib : ie , jb : je , kb : ke + kh ) - thlt ( ib : ie , jb : je , kb : ke + kh ) * thlt ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) end if call avexy_ibm ( upuptxyc ( kb : ke + kh ), uutc ( ib : ie , jb : je , kb : ke + kh ) - utc ( ib : ie , jb : je , kb : ke + kh ) * utc ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) call avexy_ibm ( vpvptxyc ( kb : ke + kh ), vvtc ( ib : ie , jb : je , kb : ke + kh ) - vtc ( ib : ie , jb : je , kb : ke + kh ) * vtc ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) call avexy_ibm ( wpwptxyc ( kb : ke + kh ), wwtc ( ib : ie , jb : je , kb : ke + kh ) - wtc ( ib : ie , jb : je , kb : ke + kh ) * wtc ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) call avexy_ibm ( tketxyc ( kb : ke + kh ), 0.5 * (( wwtc ( ib : ie , jb : je , kb : ke + kh ) - wtc ( ib : ie , jb : je , kb : ke + kh ) * wtc ( ib : ie , jb : je , kb : ke + kh )) + ( vvtc ( ib : ie , jb : je , kb : ke + kh ) - vtc ( ib : ie , jb : je , kb : ke + kh ) * vtc ( ib : ie , jb : je , kb : ke + kh )) + ( uutc ( ib : ie , jb : je , kb : ke + kh ) - utc ( ib : ie , jb : je , kb : ke + kh ) * utc ( ib : ie , jb : je , kb : ke + kh ))), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) if ( myid == 0 ) then call writestat_nc ( ncidxyt , 1 , tncstatxyt ,( / timee / ), nrecxyt ,. true .) allocate ( varsxyt ( khigh - klow + 1 , nstatxyt )) varsxyt (:, 1 ) = uxyt ( kb : ke ) varsxyt (:, 2 ) = vxyt ( kb : ke ) varsxyt (:, 3 ) = wxyt ( kb : ke ) varsxyt (:, 4 ) = thlxyt ( kb : ke ) varsxyt (:, 5 ) = qtxyt ( kb : ke ) varsxyt (:, 6 ) = pxyt ( kb : ke ) varsxyt (:, 7 ) = upwptxyik ( kb : ke ) varsxyt (:, 8 ) = wpthlptxyk ( kb : ke ) varsxyt (:, 9 ) = vpwptxyjk ( kb : ke ) varsxyt (:, 10 ) = upvptxyij ( kb : ke ) varsxyt (:, 11 ) = uwtxyik ( kb : ke ) varsxyt (:, 12 ) = wthltxyk ( kb : ke ) !wdthldtc(kb:ke) varsxyt (:, 13 ) = uvtxyij ( kb : ke ) varsxyt (:, 14 ) = vwtxyjk ( kb : ke ) varsxyt (:, 15 ) = wwtxyk ( kb : ke ) varsxyt (:, 16 ) = usgsxyt ( kb : ke ) !wdthldtw(kb:ke) varsxyt (:, 17 ) = thlsgsxyt ( kb : ke ) varsxyt (:, 18 ) = vsgsxyt ( kb : ke ) varsxyt (:, 19 ) = thlpthlptxy ( kb : ke ) varsxyt (:, 20 ) = upuptxyc ( kb : ke ) varsxyt (:, 21 ) = vpvptxyc ( kb : ke ) varsxyt (:, 22 ) = wpwptxyc ( kb : ke ) varsxyt (:, 23 ) = tketxyc ( kb : ke ) call writestat_1D_nc ( ncidxyt , nstatxyt , ncstatxyt , varsxyt , nrecxyt , khigh - klow + 1 ) end if !myid end if !lxytdump ! Final calculations and write yt-averaged statistics every tsample if ( lytdump ) then !    call MPI_BCAST(sca1yt ,(ke+kh-(kb-kh))*(ie+ih-(ib-ih)),MY_REAL   ,7,comm3d,mpierr) ! Turbulent flux call avey_ibm ( upwptyik , uwtik ( ib : ie , jb : je , kb : ke ) - utik ( ib : ie , jb : je , kb : ke ) * wtik ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIuw ( ib : ie , jb : je , kb : ke ), IIuwt ( ib : ie , kb : ke )) call avey_ibm ( uwtyik , utik ( ib : ie , jb : je , kb : ke ) * wtik ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIuw ( ib : ie , jb : je , kb : ke ), IIuwt ( ib : ie , kb : ke )) call avey_ibm ( upuptyc , uutc ( ib : ie , jb : je , kb : ke ) - utc ( ib : ie , jb : je , kb : ke ) * utc ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke ), IIct ( ib : ie , kb : ke )) call avey_ibm ( vpvptyc , vvtc ( ib : ie , jb : je , kb : ke ) - vtc ( ib : ie , jb : je , kb : ke ) * vtc ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke ), IIct ( ib : ie , kb : ke )) call avey_ibm ( wpwptyc , wwtc ( ib : ie , jb : je , kb : ke ) - wtc ( ib : ie , jb : je , kb : ke ) * wtc ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke ), IIct ( ib : ie , kb : ke )) if ( ltempeq ) then call avey_ibm ( wpthlptyk , wthltk ( ib : ie , jb : je , kb : ke ) - wmt ( ib : ie , jb : je , kb : ke ) * thltk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( wthltyk , wmt ( ib : ie , jb : je , kb : ke ) * thltk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( thlpthlpty , thlthlt ( ib : ie , jb : je , kb : ke ) - thlt ( ib : ie , jb : je , kb : ke ) * thlt ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke ), IIct ( ib : ie , kb : ke )) end if if ( lmoist ) then call avey_ibm ( wpqtptyk , wqttk ( ib : ie , jb : je , kb : ke ) - wmt ( ib : ie , jb : je , kb : ke ) * qttk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( wqttyk , wmt ( ib : ie , jb : je , kb : ke ) * qttk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( qtpqtpty , qtqtt ( ib : ie , jb : je , kb : ke ) - qtt ( ib : ie , jb : je , kb : ke ) * qtt ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke ), IIct ( ib : ie , kb : ke )) end if if ( nsv > 0 ) then call avey_ibm ( wpsv1ptyk , wsv1tk ( ib : ie , jb : je , kb : ke ) - wmt ( ib : ie , jb : je , kb : ke ) * sv1tk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( wsv1tyk , wmt ( ib : ie , jb : je , kb : ke ) * sv1tk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( sv1psv1pty , sv1sv1t ( ib : ie , jb : je , kb : ke ) - sv1t ( ib : ie , jb : je , kb : ke ) * sv1t ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke ), IIct ( ib : ie , kb : ke )) end if if ( nsv > 1 ) then call avey_ibm ( wpsv2ptyk , wsv2tk ( ib : ie , jb : je , kb : ke ) - wmt ( ib : ie , jb : je , kb : ke ) * sv2tk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( wsv2tyk , wmt ( ib : ie , jb : je , kb : ke ) * sv2tk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( sv2psv2pty , sv2sv2t ( ib : ie , jb : je , kb : ke ) - sv2t ( ib : ie , jb : je , kb : ke ) * sv2t ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke ), IIct ( ib : ie , kb : ke )) end if if ( nsv > 2 ) then call avey_ibm ( wpsv3ptyk , wsv3tk ( ib : ie , jb : je , kb : ke ) - wmt ( ib : ie , jb : je , kb : ke ) * sv3tk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( wsv3tyk , wmt ( ib : ie , jb : je , kb : ke ) * sv3tk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( sv3psv3pty , sv3sv3t ( ib : ie , jb : je , kb : ke ) - sv3t ( ib : ie , jb : je , kb : ke ) * sv3t ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke ), IIct ( ib : ie , kb : ke )) end if if ( myid == 0 ) then allocate ( varsyt ( imax , khigh - klow + 1 , nstatyt )) varsyt = 0. call writestat_nc ( ncidyt , 1 , tncstatyt ,( / timee / ), nrecyt ,. true .) varsyt (:,:, 1 ) = uyt ( ib : ie , kb : ke ) varsyt (:,:, 2 ) = vyt ( ib : ie , kb : ke ) varsyt (:,:, 3 ) = wyt ( ib : ie , kb : ke ) varsyt (:,:, 4 ) = thlyt ( ib : ie , kb : ke ) varsyt (:,:, 5 ) = qtyt ( ib : ie , kb : ke ) varsyt (:,:, 6 ) = sca1yt ( ib : ie , kb : ke ) varsyt (:,:, 7 ) = sca2yt ( ib : ie , kb : ke ) varsyt (:,:, 8 ) = sca3yt ( ib : ie , kb : ke ) varsyt (:,:, 9 ) = upwptyik ( ib : ie , kb : ke ) varsyt (:,:, 10 ) = wpthlptyk ( ib : ie , kb : ke ) varsyt (:,:, 11 ) = wpqtptyk ( ib : ie , kb : ke ) varsyt (:,:, 12 ) = wpsv1ptyk ( ib : ie , kb : ke ) varsyt (:,:, 13 ) = wpsv2ptyk ( ib : ie , kb : ke ) varsyt (:,:, 14 ) = wpsv3ptyk ( ib : ie , kb : ke ) varsyt (:,:, 15 ) = uwtyik ( ib : ie , kb : ke ) varsyt (:,:, 16 ) = wthltyk ( ib : ie , kb : ke ) varsyt (:,:, 17 ) = wqttyk ( ib : ie , kb : ke ) varsyt (:,:, 18 ) = wsv1tyk ( ib : ie , kb : ke ) varsyt (:,:, 19 ) = wsv2tyk ( ib : ie , kb : ke ) varsyt (:,:, 20 ) = wsv3tyk ( ib : ie , kb : ke ) varsyt (:,:, 21 ) = upuptyc ( ib : ie , kb : ke ) varsyt (:,:, 22 ) = wpwptyc ( ib : ie , kb : ke ) varsyt (:,:, 23 ) = thlpthlpty ( ib : ie , kb : ke ) varsyt (:,:, 24 ) = qtpqtpty ( ib : ie , kb : ke ) varsyt (:,:, 25 ) = sv1psv1pty ( ib : ie , kb : ke ) varsyt (:,:, 26 ) = sv2psv2pty ( ib : ie , kb : ke ) varsyt (:,:, 27 ) = sv3psv3pty ( ib : ie , kb : ke ) varsyt (:,:, 28 ) = usgsyt ( ib : ie , kb : ke ) varsyt (:,:, 29 ) = wsgsyt ( ib : ie , kb : ke ) varsyt (:,:, 30 ) = thlsgsyt ( ib : ie , kb : ke ) varsyt (:,:, 31 ) = qtsgsyt ( ib : ie , kb : ke ) varsyt (:,:, 32 ) = sv1sgsyt ( ib : ie , kb : ke ) varsyt (:,:, 33 ) = sv2sgsyt ( ib : ie , kb : ke ) varsyt (:,:, 34 ) = sv3sgsyt ( ib : ie , kb : ke ) call writestat_nc ( ncidyt , nstatyt , ncstatyt , varsyt , nrecyt , imax , khigh - klow + 1 ) end if !myid end if !lytdump ! Final calculations and write t-averaged statistics every tsample if ( ltdump ) then ! wpsv1p = wsv1tk - wmt*sv1tk ! wpsv2p = wsv2tk - wmt*sv2tk ! wpsv3p = wsv3tk - wmt*sv3tk ! wpsv4p = wsv4tk - wmt*sv4tk wpthlptk = 0. ; thlpthlpt = 0. !> Turbulent fluxes upwptik = uwtik - utik * wtik vpwptjk = vwtjk - vtjk * wtjk upvptij = uvtij - utij * vtij if ( ltempeq ) then wpthlptk = wthltk - wmt * thltk end if if ( nsv > 0 ) then wpsv1p = wsv1tk - wmt * sv1tk end if if ( nsv > 1 ) then wpsv2p = wsv2tk - wmt * sv2tk end if if ( nsv > 2 ) then wpsv3p = wsv3tk - wmt * sv3tk end if if ( nsv > 3 ) then wpsv4p = wsv4tk - wmt * sv4tk end if !> Variances and TKE if ( ltempeq ) then thlpthlpt = thlthlt - thlt * thlt end if upuptc = uutc - utc * utc vpvptc = vvtc - vtc * vtc wpwptc = wwtc - wtc * wtc tketc = 0.5 * ( upuptc + vpvptc + wpwptc ) if ( nsv > 0 ) then sv1psv1pt = sv1sv1t - sv1t * sv1t end if if ( nsv > 1 ) then sv2psv2pt = sv2sv2t - sv2t * sv2t end if if ( nsv > 2 ) then sv3psv3pt = sv3sv3t - sv3t * sv3t end if if ( nsv > 3 ) then sv4psv4pt = sv4sv4t - sv4t * sv4t end if !      if (myid == 0) then allocate ( varst ( imax , jmax , khigh - klow + 1 , nstatt )) call writestat_nc ( ncidt , 1 , tncstatt ,( / timee / ), nrect ,. true .) varst (:,:,:, 1 ) = umt ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 2 ) = vmt ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 3 ) = wmt ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 4 ) = thlt ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 5 ) = qtt ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 6 ) = pt ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 7 ) = sv1t ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 8 ) = sv2t ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 9 ) = sv3t ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 10 ) = sv4t ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 11 ) = PSSt ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 12 ) = upwptik ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 13 ) = vpwptjk ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 14 ) = upvptij ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 15 ) = wpthlptk ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 16 ) = wpsv1p ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 17 ) = wpsv2p ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 18 ) = wpsv3p ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 19 ) = wpsv4p ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 20 ) = thlpthlpt ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 21 ) = upuptc ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 22 ) = vpvptc ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 23 ) = wpwptc ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 24 ) = tketc ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 25 ) = sv1psv1pt ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 26 ) = sv2psv2pt ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 27 ) = sv3psv3pt ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 28 ) = sv4psv4pt ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 29 ) = sv1sgst ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 30 ) = sv2sgst ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 31 ) = sv3sgst ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 32 ) = sv4sgst ( ib : ie , jb : je , kb : ke ) ! varst(:,:,:,33) = sv1max(ib:ie,jb:je,kb:ke) ! varst(:,:,:,34) = sv2max(ib:ie,jb:je,kb:ke) ! varst(:,:,:,35) = sv3max(ib:ie,jb:je,kb:ke) ! varst(:,:,:,36) = sv4max(ib:ie,jb:je,kb:ke) call writestat_nc ( ncidt , nstatt , ncstatt , varst , nrect , imax , jmax , khigh - klow + 1 ) !        end if !myid deallocate ( varst ) end if !ltdump if ( lmintdump ) then !      if (myid == 0) then allocate ( varsmint ( imax , jmax , khigh - klow + 1 , nstatmint )) call writestat_nc ( ncidmint , 1 , tncstatmint ,( / timee / ), nrecmint ,. true .) varsmint (:,:,:, 1 ) = umt ( ib : ie , jb : je , kb : ke ) varsmint (:,:,:, 2 ) = vmt ( ib : ie , jb : je , kb : ke ) varsmint (:,:,:, 3 ) = wmt ( ib : ie , jb : je , kb : ke ) varsmint (:,:,:, 4 ) = thlt ( ib : ie , jb : je , kb : ke ) varsmint (:,:,:, 5 ) = qtt ( ib : ie , jb : je , kb : ke ) varsmint (:,:,:, 6 ) = pt ( ib : ie , jb : je , kb : ke ) call writestat_nc ( ncidmint , nstatmint , ncstatmint , varsmint , nrecmint , imax , jmax , khigh - klow + 1 ) !        end if !myid deallocate ( varsmint ) end if !lmintdump ! Final calculations and write t-averaged statistics for the trees if ( ltreedump ) then !        if (myid == 0) then allocate ( varstr ( imax , jmax , khigh - klow + 1 , nstattr )) call writestat_nc ( ncidtr , 1 , tncstattr ,( / timee / ), nrectr ,. true .) varstr (:,:,:, 1 ) = tr_ut ( ib : ie , jb : je , kb : ke ) varstr (:,:,:, 2 ) = tr_vt ( ib : ie , jb : je , kb : ke ) varstr (:,:,:, 3 ) = tr_wt ( ib : ie , jb : je , kb : ke ) varstr (:,:,:, 4 ) = tr_thlt ( ib : ie , jb : je , kb : ke ) varstr (:,:,:, 5 ) = tr_qtt ( ib : ie , jb : je , kb : ke ) varstr (:,:,:, 6 ) = tr_qtRt ( ib : ie , jb : je , kb : ke ) varstr (:,:,:, 7 ) = tr_qtAt ( ib : ie , jb : je , kb : ke ) varstr (:,:,:, 8 ) = tr_sv1t ( ib : ie , jb : je , kb : ke ) varstr (:,:,:, 9 ) = tr_sv2t ( ib : ie , jb : je , kb : ke ) varstr (:,:,:, 10 ) = tr_omegat ( ib : ie , jb : je , kb : ke ) call writestat_nc ( ncidtr , nstattr , ncstattr , varstr , nrectr , imax , jmax , khigh - klow + 1 ) !        end if !myid deallocate ( varstr ) end if !ltdump if ( ltkedump ) then call tkestatsdump if ( myid == 0 ) then call writestat_nc ( ncidtke , 1 , tncstattke ,( / timee / ), nrectke ,. true .) allocate ( varstke ( khigh - klow + 1 , nstattke )) varstke (:, 1 ) = p_b ( kb : ke + kh ) varstke (:, 2 ) = t_p ( kb : ke + kh ) varstke (:, 3 ) = adv ( kb : ke + kh ) varstke (:, 4 ) = t_t ( kb : ke + kh ) varstke (:, 5 ) = t_sgs ( kb : ke + kh ) varstke (:, 6 ) = p_t ( kb : ke + kh ) varstke (:, 7 ) = t_v ( kb : ke + kh ) varstke (:, 8 ) = d_sgs ( kb : ke + kh ) call writestat_1D_nc ( ncidtke , nstattke , ncstattke , varstke , nrectke , khigh - klow + 1 ) end if !myid endif !ltkedump tstatsdumpp = dt else !tstatsdumpp < tstatsdump tstatsdumpp = tstatsdumpp + dt endif deallocate ( thlk , qtk , uik , wik , vjk , wjk , uij , vij , uc , vc , wc ) deallocate ( thlsgs , qtsgs , usgs , vsgs , wsgs ) deallocate ( sv1k , sv2k , sv3k , sv4k , sv1sgs , sv2sgs , sv3sgs , sv4sgs , PSS , wpsv1p , wpsv2p , wpsv3p , wpsv4p , sv1psv1pt , sv2psv2pt , sv3psv3pt , sv4psv4pt ) deallocate ( upwptik , vpwptjk , upvptij , wpthlptk , thlpthlpt , upuptc , vpvptc , wpwptc , tketc ) end subroutine statsdump","tags":"","url":"proc/statsdump.html"},{"title":"tkestatsdump – uDALES","text":"private  subroutine tkestatsdump() Uses modmpi modsurfdata modfields decomp_2d modsubgrid modglobal proc~~tkestatsdump~~UsesGraph proc~tkestatsdump tkestatsdump decomp_2d decomp_2d proc~tkestatsdump->decomp_2d module~modfields modfields proc~tkestatsdump->module~modfields module~modglobal modglobal proc~tkestatsdump->module~modglobal module~modmpi modmpi proc~tkestatsdump->module~modmpi module~modsubgrid modsubgrid proc~tkestatsdump->module~modsubgrid module~modsurfdata modsurfdata proc~tkestatsdump->module~modsurfdata module~modfields->decomp_2d mpi mpi module~modmpi->mpi module~modsubgriddata modsubgriddata module~modsubgrid->module~modsubgriddata module~modsubgrid->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~tkestatsdump~~CallsGraph proc~tkestatsdump tkestatsdump exchange_halo_z exchange_halo_z proc~tkestatsdump->exchange_halo_z proc~avexy_ibm avexy_ibm proc~tkestatsdump->proc~avexy_ibm mpi_allreduce mpi_allreduce proc~avexy_ibm->mpi_allreduce Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~tkestatsdump~~CalledByGraph proc~tkestatsdump tkestatsdump proc~statsdump statsdump proc~statsdump->proc~tkestatsdump program~dalesurban DALESURBAN program~dalesurban->proc~statsdump Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine tkestatsdump use modfields , only : u0 , v0 , w0 , thl0 , uav , vav , wav , uuav , vvav , wwav , uvav , uwav , vwav , thlav , thlthlav , pres0 , thluav , thlvav , thlwav ,& upupav , vpvpav , wpwpav , thlpthlpav , upvpav , upwpav , vpwpav , thlpupav , thlpvpav , thlpwpav , presav ,& strain2av , disssgsav , t_vav , tvmx , tvmy , tvmz , tsgsmx1 , tsgsmx2 , tsgsmy1 , tsgsmy2 , tsgsmz1 , t_sgsav , nusgsav ,& tpm , t_pav , ttmx , ttmy , ttmz , t_tav , p_bav , d_sgsav , p_tav , tkeadv , tsgsmz1 , tsgsmz2 , t_t , t_v , t_p , t_sgs , d_sgs ,& p_b , p_t , adv , IIc , IIcs use modglobal , only : ib , ie , ih , jb , je , jgb , jge , dy , jh , ke , kb , kh , rk3step , timee , cexpnr , tsample , tstatsdump , jtot , imax , dzf ,& dzf , dzfi , dzhi , dxf , dxfi , dyi , dxhi , dy2i , grav , numol , ierank , jerank use modmpi , only : myid , cmyid , my_real , mpi_sum , avey_ibm , mpierr , comm3d , excjs , avexy_ibm use modsurfdata , only : thls use modsubgrid , only : ekh use decomp_2d , only : exchange_halo_z implicit none real , dimension ( ib : ie , jb : je , kb : ke ) :: disssgsfl ! average subgrid visc. * average rate of strain squared : 2*<nu_t>*<Sij>*<Sij> real , dimension ( ib : ie , jb : je , kb : ke ) :: dissresav ! average resolved dissipation: 2*nu*<Sij'*Sij'> = 2*nu*( <Sij*Sij> - <Sij>*<Sij> ) real , dimension ( ib : ie , jb : je , kb : ke ) :: tke ! tke = 0.5*<ui'ui'> real , dimension ( ib : ie , jb : je , kb : ke ) :: mke ! = <ui>d/dxj(<ui><uj>) + <ui>d/dxj(<ui'uj'>) = <ui>d/dxj(<ui*uj>) real , dimension ( ib - 1 : ie + 1 , jb - 1 : je + 1 , kb : ke ) :: dummyx real , dimension ( ib - 1 : ie + 1 , jb - 1 : je + 1 , kb : ke ) :: dummyy real , dimension ( ib : ie , jb : je , kb : ke + 1 ) :: dummyz integer i , j , k , ip , im , jp , jm , kp , km real strainav2 real dummy ! Tvav = (Tvm - <ui>*d/dxj(<Sij>)  ) + 2*nu*<Sij'Sij'> ! Tvm = Tvmx + Tvmy + Tvmz -> therefore: subtraction, then interpolation, ! then addition of 2*nu*<Sij'Sij'> do k = kb , ke km = k - 1 kp = k + 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie im = i - 1 ip = i + 1 !            t_vav(i,j,k) =  0.5*( (tvmx(i,j,k) - (                      & dummyx ( i , j , k ) = ( & ( numol * ( uav ( i + 1 , j , k ) - uav ( i , j , k )) * dxfi ( i ) & - numol * ( uav ( i , j , k ) - uav ( i - 1 , j , k )) * dxfi ( i - 1 ) ) * 2. * dxhi ( i ) & + & ( numol * ( ( uav ( i , jp , k ) - uav ( i , j , k )) * dyi & + ( vav ( i , jp , k ) - vav ( i - 1 , jp , k )) * dxhi ( i )) & - numol * ( ( uav ( i , j , k ) - uav ( i , jm , k )) * dyi & + ( vav ( i , j , k ) - vav ( i - 1 , j , k )) * dxhi ( i )) & ) * dyi & + & ( numol * ( ( uav ( i , j , kp ) - uav ( i , j , k )) * dzhi ( kp ) & + ( wav ( i , j , kp ) - wav ( i - 1 , j , kp )) * dxhi ( i )) & - numol * ( ( uav ( i , j , k ) - uav ( i , j , km )) * dzhi ( k ) & + ( wav ( i , j , k ) - wav ( i - 1 , j , k )) * dxhi ( i )) & ) * dzfi ( k ) ) ! y-direction dummyy ( i , j , k ) = ( & ( numol * ( ( vav ( i + 1 , j , k ) - vav ( i , j , k )) * dxhi ( i + 1 ) & + ( uav ( i + 1 , j , k ) - uav ( i + 1 , jm , k )) * dyi ) & - numol * ( ( vav ( i , j , k ) - vav ( i - 1 , j , k )) * dxhi ( i ) & + ( uav ( i , j , k ) - uav ( i , jm , k )) * dyi ) & ) * dxfi ( i ) & ! = d/dx( Km*(dv/dx + du/dy) ) + & ( numol * ( vav ( i , jp , k ) - vav ( i , j , k )) & - numol * ( vav ( i , j , k ) - vav ( i , jm , k )) ) * 2. * dy2i & ! =d/dy( 2*Km*(dv/dy) ) + & ( numol * ( ( vav ( i , j , kp ) - vav ( i , j , k )) * dzhi ( kp ) & + ( wav ( i , j , kp ) - wav ( i , jm , kp )) * dyi ) & - numol * ( ( vav ( i , j , k ) - vav ( i , j , km )) * dzhi ( k ) & + ( wav ( i , j , k ) - wav ( i , jm , k )) * dyi ) & ) * dzfi ( k ) ) ! = d/dz( Km*(dv/dz + dw/dy) ) ! z-direction dummyz ( i , j , k ) = ( & ( numol * ( ( wav ( i + 1 , j , k ) - wav ( i , j , k )) * dxhi ( i + 1 ) & + ( uav ( i + 1 , j , k ) - uav ( i + 1 , j , km )) * dzhi ( k ) ) & - numol * ( ( wav ( i , j , k ) - wav ( i - 1 , j , k )) * dxhi ( i ) & + ( uav ( i , j , k ) - uav ( i , j , km )) * dzhi ( k ) ) & ) * dxfi ( i ) & + & ( numol * ( ( wav ( i , jp , k ) - wav ( i , j , k )) * dyi & + ( vav ( i , jp , k ) - vav ( i , jp , km )) * dzhi ( k ) ) & - numol * ( ( wav ( i , j , k ) - wav ( i , jm , k )) * dyi & + ( vav ( i , j , k ) - vav ( i , j , km )) * dzhi ( k ) ) & ) * dyi & + & ( numol * ( wav ( i , j , kp ) - wav ( i , j , k )) * dzfi ( k ) & - numol * ( wav ( i , j , k ) - wav ( i , j , km )) * dzfi ( km ) ) * 2. & * dzhi ( k )) strainav2 = ( & (( uav ( ip , j , k ) - uav ( i , j , k )) * dxfi ( i ) ) ** 2 + & (( vav ( i , jp , k ) - vav ( i , j , k )) * dyi ) ** 2 + & (( wav ( i , j , kp ) - wav ( i , j , k )) * dzfi ( k ) ) ** 2 ) strainav2 = strainav2 + 0.125 * ( & (( wav ( i , j , kp ) - wav ( im , j , kp )) * dxhi ( i ) + & ( uav ( i , j , kp ) - uav ( i , j , k )) * dzhi ( kp ) ) ** 2 + & (( wav ( i , j , k ) - wav ( im , j , k )) * dxhi ( i ) + & ( uav ( i , j , k ) - uav ( i , j , km )) * dzhi ( k ) ) ** 2 + & (( wav ( ip , j , k ) - wav ( i , j , k )) * dxhi ( ip ) + & ( uav ( ip , j , k ) - uav ( ip , j , km )) * dzhi ( k ) ) ** 2 + & (( wav ( ip , j , kp ) - wav ( i , j , kp )) * dxhi ( ip ) + & ( uav ( ip , j , kp ) - uav ( ip , j , k )) * dzhi ( kp ) ) ** 2 ) strainav2 = strainav2 + 0.125 * ( & (( uav ( i , jp , k ) - uav ( i , j , k )) * dyi + & ( vav ( i , jp , k ) - vav ( im , jp , k )) * dxhi ( i ) ) ** 2 + & (( uav ( i , j , k ) - uav ( i , jm , k )) * dyi + & ( vav ( i , j , k ) - vav ( im , j , k )) * dxhi ( i ) ) ** 2 + & (( uav ( ip , j , k ) - uav ( ip , jm , k )) * dyi + & ( vav ( ip , j , k ) - vav ( i , j , k )) * dxhi ( ip ) ) ** 2 + & (( uav ( ip , jp , k ) - uav ( ip , j , k )) * dyi + & ( vav ( ip , jp , k ) - vav ( i , jp , k )) * dxhi ( ip ) ) ** 2 ) strainav2 = strainav2 + 0.125 * ( & (( vav ( i , j , kp ) - vav ( i , j , k )) * dzhi ( kp ) + & ( wav ( i , j , kp ) - wav ( i , jm , kp )) * dyi ) ** 2 + & (( vav ( i , j , k ) - vav ( i , j , km )) * dzhi ( k ) + & ( wav ( i , j , k ) - wav ( i , jm , k )) * dyi ) ** 2 + & (( vav ( i , jp , k ) - vav ( i , jp , km )) * dzhi ( k ) + & ( wav ( i , jp , k ) - wav ( i , j , k )) * dyi ) ** 2 + & (( vav ( i , jp , kp ) - vav ( i , jp , k )) * dzhi ( kp ) + & ( wav ( i , jp , kp ) - wav ( i , j , kp )) * dyi ) ** 2 ) dissresav ( i , j , k ) = 2. * numol * ( strain2av ( i , j , k ) - strainav2 ) !resolved dissipation end do end do end do ! call excjs( tvmy   , ib,ie,jb,je,kb,ke,0,1)   ! jb-1 is not used ! call excjs( tsgsmy1, ib,ie,jb,je,kb,ke,0,1)   ! jb-1 is not used ! call excjs( tsgsmy2, ib,ie,jb,je,kb,ke,0,1)   ! jb-1 is not used ! call excjs( dummyy,  ib,ie,jb,je,kb,ke,0,1)   ! jb-1 is not used ! call excjs( ttmy   , ib,ie,jb,je,kb,ke,0,1)   ! jb-1 is not used call exchange_halo_z ( tvmx , opt_zlevel = ( / ih , jh , 0 / )) call exchange_halo_z ( tsgsmx1 , opt_zlevel = ( / ih , jh , 0 / )) call exchange_halo_z ( tsgsmx2 , opt_zlevel = ( / ih , jh , 0 / )) call exchange_halo_z ( dummyx , opt_zlevel = ( / ih , jh , 0 / )) call exchange_halo_z ( ttmx , opt_zlevel = ( / ih , jh , 0 / )) call exchange_halo_z ( tvmy , opt_zlevel = ( / ih , jh , 0 / )) call exchange_halo_z ( tsgsmy1 , opt_zlevel = ( / ih , jh , 0 / )) call exchange_halo_z ( tsgsmy2 , opt_zlevel = ( / ih , jh , 0 / )) call exchange_halo_z ( dummyy , opt_zlevel = ( / ih , jh , 0 / )) call exchange_halo_z ( ttmy , opt_zlevel = ( / ih , jh , 0 / )) ! BC's if ( ierank ) then tvmx ( ie + 1 ,:,:) = tvmx ( ie ,:,:) tsgsmx1 ( ie + 1 ,:,:) = tsgsmx1 ( ie ,:,:) tsgsmx2 ( ie + 1 ,:,:) = tsgsmx2 ( ie ,:,:) dummyx ( ie + 1 ,:,:) = dummyx ( ie ,:,:) ttmx ( ie + 1 ,:,:) = ttmx ( ie ,:,:) end if if ( jerank ) then tvmy (:, je + 1 ,:) = tvmy (:, je ,:) tsgsmy1 (:, je + 1 ,:) = tsgsmy1 (:, je ,:) tsgsmy2 (:, je + 1 ,:) = tsgsmy2 (:, je ,:) dummyy (:, je + 1 ,:) = dummyy (:, je ,:) ttmy (:, je + 1 ,:) = ttmy (:, je ,:) end if tvmz (:,:, ke + 1 ) = tvmz (:,:, ke ) tsgsmz1 (:,:, ke + 1 ) = tsgsmz1 (:,:, ke ) tsgsmz2 (:,:, ke + 1 ) = tsgsmz2 (:,:, ke ) dummyz (:,:, ke + 1 ) = dummyz (:,:, ke ) ttmz (:,:, ke + 1 ) = ttmz (:,:, ke ) do k = kb , ke km = k - 1 kp = k + 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie im = i - 1 ip = i + 1 ! Total viscous dissipation t_vav ( i , j , k ) = 0.5 * ( ( tvmx ( i , j , k ) - dummyx ( i , j , k ) * uav ( i , j , k )) + & ( tvmx ( ip , j , k ) - dummyx ( ip , j , k ) * uav ( ip , j , k ))) & + 0.5 * ( ( tvmy ( i , j , k ) - dummyy ( i , j , k ) * vav ( i , j , k )) + & ( tvmy ( i , jp , k ) - dummyy ( i , jp , k ) * vav ( i , jp , k ))) & + 0.5 * ( ( tvmz ( i , j , k ) - dummyz ( i , j , k ) * wav ( i , j , k )) + & ( tvmz ( i , j , kp ) - dummyz ( i , j , kp ) * wav ( i , j , kp ))) & + dissresav ( i , j , k ) ! d/dxj(2*nu*<ui'Sij'>) = <u_i*d/dxj(2*nu*Sij')> +2*nu*<Sij'Sij'> !      Now the same for subgrid stress !      <d/dxj(2*u_i'*nu_t*Sij)'> = <u_i'*d/dxj(2*nu_t*Sij)'> + <(2*nu_t*Sij)'*Sij'> !                                = <u_i*d/dxj(2*nu_t*Sij)> - !                                  <u_i>*<d/dxj(2*nu_t*Sij)>   + <2*nu_t*Sij*Sij> - !                                  <(2*nu_t*Sij)>*<Sij> !                                = <u_i*d/dxj(2*nu_t*Sij)> - !                                  <u_i>*<d/dxj(2*nu_t*Sij)>   + <2*nu_t*Sij*Sij> - !                                  2*<nu_t>*<Sij>*<Sij> - 2*<nu_t'*Sij'>*<Sij> !--------------------------------------- !Total subgrid TKE !--------------------------------------- ! Mean SGS dissipation disssgsfl ( i , j , k ) = 2. * nusgsav ( i , j , k ) * strainav2 ! = 2*<nu_sgs>*<sij>*<sij> ! TKE tke ( i , j , k ) = 0.5 * ( 0.5 * ( upupav ( ip , j , k ) + upupav ( i , j , k )) + & 0.5 * ( vpvpav ( i , jp , k ) + vpvpav ( i , j , k )) + & 0.5 * ( wpwpav ( i , j , kp ) + wpwpav ( i , j , k ))) ! total SGS t_sgsav ( i , j , k ) = 0.5 * ( ( tsgsmx1 ( i , j , k ) - uav ( i , j , k ) * tsgsmx2 ( i , j , k )) + & ( tsgsmx1 ( ip , j , k ) - uav ( ip , j , k ) * tsgsmx2 ( ip , j , k ))) & + & ! = <2*nu_t*SijSij> - <2*nu_t*Sij>*<Sij> 0.5 * ( ( tsgsmy1 ( i , j , k ) - vav ( i , j , k ) * tsgsmy2 ( i , j , k )) + & ( tsgsmy1 ( i , jp , k ) - vav ( i , jp , k ) * tsgsmy2 ( i , jp , k ))) & + & ! = <2*nu_t*SijSij> - <2*nu_t*Sij>*<Sij> 0.5 * ( ( tsgsmz1 ( i , j , k ) - vav ( i , j , k ) * tsgsmz2 ( i , j , k )) + & ( tsgsmz1 ( i , j , kp ) - vav ( i , j , kp ) * tsgsmz2 ( i , j , kp ))) & + disssgsav ( i , j , k ) - disssgsfl ( i , j , k ) ! -2*<nu_t'Sij'>*<Sij>  should still be added! ! SGS dissipation d_sgsav ( i , j , k ) = - disssgsav ( i , j , k ) + disssgsfl ( i , j , k ) ! +2*<nu_t'Sij'>*<Sij>  should still be added! (is compensated with above) !--------------------------------------- !Total pressure TKE !--------------------------------------- ! Pressure correlation term ! - <uj'*dp'/dxj> = - <uj*dp/dxj> + <uj>*d<p>/dxj t_pav ( i , j , k ) = tpm ( i , j , k ) + & 0.5 * ( uav ( i , j , k ) * ( presav ( i , j , k ) - presav ( i - 1 , j , k )) * dxhi ( i ) + & uav ( i + 1 , j , k ) * ( presav ( i + 1 , j , k ) - presav ( i , j , k )) * dxhi ( i + 1 )) & + & 0.5 * ( vav ( i , j , k ) * ( presav ( i , j , k ) - presav ( i , j - 1 , k )) * dyi + & vav ( i , j + 1 , k ) * ( presav ( i , j + 1 , k ) - presav ( i , j , k )) * dyi ) & + & 0.5 * ( wav ( i , j , k ) * ( presav ( i , j , k ) - presav ( i , j , k - 1 )) * dzhi ( k ) + & wav ( i , j , k + 1 ) * ( presav ( i , j , k + 1 ) - presav ( i , j , k )) * dzhi ( k + 1 )) ! - d/dxj(<0.5*ui'ui'uj'>) = -<uj'd/dxj(<0.5*ui'ui'>) + <ui'uj'><Sij> !                             = -<uj*d/dxj(0.5*ui'ui')> + <uj>*d/dxj(<0.5*ui'ui'> + !                             <ui'uj'><Sij>) !            ttav(i,j,k)   = ttm(i,j,k) - !--------------------------------------- !Total advection TKE !--------------------------------------- !            <advection term N.S. times ui> = MKE + A - Pshear - Tt !            Tt = -<ui'd/dxj(ui'uj')> = -<d/dxj(0.5*ui'ui'uj')> = A + MKE - Pshear - Total !Pshear =Ptav = -<ui'uj'>d/dxj(<Sij>) = -<ui'uj'>d<ui>/dxj ! mechanical or shear production p_tav ( i , j , k ) = - ( & 0.5 * ( upupav ( i , j , k ) + upupav ( ip , j , k )) * ( uav ( ip , j , k ) - uav ( i , j , k )) * dxfi ( i ) + & ! <u'u'>*d<u>/dx 0.25 * ( upvpav ( i , j , k ) * ( uav ( i , j , k ) - uav ( i , jm , k ) ) * dyi + & upvpav ( i , jp , k ) * ( uav ( i , jp , k ) - uav ( i , j , k ) ) * dyi + & upvpav ( ip , j , k ) * ( uav ( ip , j , k ) - uav ( ip , jm , k ) ) * dyi + & upvpav ( ip , jp , k ) * ( uav ( ip , jp , k ) - uav ( ip , j , k ) ) * dyi ) + & ! <u'v'>*d<u>/dy 0.25 * ( upwpav ( i , j , k ) * ( uav ( i , j , k ) - uav ( i , j , km )) * dzhi ( k ) + & upwpav ( i , j , kp ) * ( uav ( i , j , kp ) - uav ( i , j , k )) * dzhi ( kp ) + & upwpav ( ip , j , k ) * ( uav ( ip , j , k ) - uav ( ip , j , km )) * dzhi ( k ) + & upwpav ( ip , j , kp ) * ( uav ( ip , j , kp ) - uav ( ip , j , k )) * dzhi ( kp )) + & ! <u'w'>*d<u>/dz 0.25 * ( upvpav ( i , j , k ) * ( vav ( i , j , k ) - vav ( im , j , k )) * dxhi ( i ) + & upvpav ( ip , j , k ) * ( vav ( ip , j , k ) - vav ( i , j , k )) * dxhi ( ip ) + & upvpav ( i , jp , k ) * ( vav ( i , jp , k ) - vav ( im , jp , k )) * dxhi ( i ) + & upvpav ( ip , jp , k ) * ( vav ( ip , jp , k ) - vav ( i , jp , k )) * dxhi ( ip )) + & ! <u'v'>*d<v>/dx 0.5 * ( vpvpav ( i , j , k ) + vpvpav ( i , jp , k )) * ( vav ( i , jp , k ) - vav ( i , j , k )) * dyi + & ! <v'v'>*d<v>/dy 0.5 * ( vpvpav ( i , j , k ) + vpvpav ( i , jp , k )) * ( vav ( i , jp , k ) - vav ( i , j , k )) * dyi + & ! <v'v'>*d<v>/dy 0.25 * ( vpwpav ( i , j , k ) * ( vav ( i , j , k ) - vav ( i , j , km )) * dzhi ( k ) + & vpwpav ( i , j , kp ) * ( vav ( i , j , kp ) - vav ( i , j , k )) * dzhi ( kp ) + & vpwpav ( i , jp , k ) * ( vav ( i , jp , k ) - vav ( i , jp , km )) * dzhi ( k ) + & vpwpav ( i , jp , kp ) * ( vav ( i , jp , kp ) - vav ( i , jp , k )) * dzhi ( kp )) + & ! <v'w'>*d<v>/dz 0.25 * ( upwpav ( i , j , k ) * ( wav ( i , j , k ) - wav ( im , j , k )) * dxhi ( i ) + & upwpav ( ip , j , k ) * ( wav ( ip , j , k ) - wav ( i , j , k )) * dxhi ( ip ) + & upwpav ( i , j , kp ) * ( wav ( i , j , kp ) - wav ( im , j , kp )) * dxhi ( i ) + & upwpav ( ip , j , kp ) * ( wav ( ip , j , kp ) - wav ( i , j , kp )) * dxhi ( ip )) + & ! <u'w'>*d<w>/dx 0.25 * ( vpwpav ( i , j , k ) * ( wav ( i , j , k ) - wav ( i , jm , k ) ) * dyi + & vpwpav ( i , jp , k ) * ( wav ( i , jp , k ) - wav ( i , j , k ) ) * dyi + & vpwpav ( ip , j , k ) * ( wav ( i , j , kp ) - wav ( i , jm , kp ) ) * dyi + & vpwpav ( ip , jp , k ) * ( wav ( i , jp , kp ) - wav ( i , j , kp ) ) * dyi ) + & ! <v'w'>*d<w>/dy 0.5 * ( wpwpav ( i , j , k ) + wpwpav ( i , j , kp )) * ( wav ( i , j , kp ) - wav ( i , j , k )) * dzfi ( k ) ) ! <w'w'>*d<w>/dz ! Mean kinetic energy term (expected to be small). mke ( i , j , k ) = 0.5 * ( uav ( ip , j , k ) + uav ( i , j , k )) * ( uuav ( ip , j , k ) - uuav ( i , j , k )) * dxfi ( i ) + & !<u>*d<uu>/dx 0.5 * ( uav ( i , j , k ) * ( uvav ( i , jp , k ) - uvav ( i , j , k )) * dyi + & ! <u>*d<uv>/dy uav ( ip , j , k ) * ( uvav ( ip , jp , k ) - uvav ( ip , j , k )) * dyi ) + & 0.5 * ( uav ( i , j , k ) * ( uwav ( i , j , kp ) - uwav ( i , j , k )) * dzfi ( k ) + & ! <u>*d<uw>/dz uav ( ip , j , k ) * ( uwav ( ip , j , kp ) - uwav ( ip , j , k )) * dzfi ( k )) + & 0.5 * ( vav ( i , j , k ) * ( uvav ( ip , j , k ) - uvav ( i , j , k )) * dxfi ( i ) + & ! <v>*d<uv>/dx vav ( i , jp , k ) * ( uvav ( ip , jp , k ) - uvav ( i , jp , k )) * dxfi ( i )) + & 0.5 * ( vav ( i , jp , k ) + vav ( i , j , k )) * ( vvav ( i , jp , k ) - vvav ( i , j , k )) * dyi + & ! <v>*d<vv>/dy 0.5 * ( vav ( i , j , k ) * ( vwav ( i , j , kp ) - vwav ( i , j , k )) * dzfi ( k ) + & ! <v>*d<vw>/dz vav ( i , jp , k ) * ( vwav ( i , jp , kp ) - vwav ( i , jp , k )) * dzfi ( k )) + & 0.5 * ( wav ( i , j , k ) * ( uwav ( ip , j , k ) - uwav ( i , j , k )) * dxfi ( i ) + & ! <w>*d<uw>/dx wav ( i , j , kp ) * ( uwav ( ip , j , kp ) - uwav ( i , j , kp )) * dxfi ( i )) + & 0.5 * ( wav ( i , j , k ) * ( vwav ( i , jp , k ) - vwav ( i , j , k )) * dyi + & ! <w>*d<vw>/dy wav ( i , j , kp ) * ( vwav ( i , jp , kp ) - vwav ( i , j , kp )) * dyi ) + & 0.5 * ( wav ( i , j , kp ) + wav ( i , j , k )) * ( wwav ( i , j , kp ) - wwav ( i , j , k )) * dzfi ( k ) ! <w>*d<ww>/dz ! Advection of TKE tkeadv ( i , j , k ) = 0.5 * ( uav ( i , j , k ) * ( tke ( i , j , k ) - tke ( im , j , k )) * dxhi ( i ) + & ! <u>*de/dx uav ( ip , j , k ) * ( tke ( ip , j , k ) - tke ( i , j , k )) * dxhi ( ip )) + & ! 0.5 * ( vav ( i , j , k ) * ( tke ( i , j , k ) - tke ( i , jm , k )) * dyi + & ! <v>*de/dy vav ( i , jp , k ) * ( tke ( i , jp , k ) - tke ( i , j , k )) * dyi ) + & 0.5 * ( wav ( i , j , k ) * ( tke ( i , j , k ) - tke ( i , j , km )) * dzhi ( k ) + & ! <w>*de/dz wav ( i , j , kp ) * ( tke ( i , j , kp ) - tke ( i , j , k )) * dzhi ( kp )) ! <advection term N.S. times ui> = MKE + A - Pshear - Tt ! Tt = -<ui'd/dxj(ui'uj')> = -<d/dxj(0.5*ui'ui'uj')> = A      +    MKE   - ! Pshear  -   Total !                                                    = tkeadv +    mke   - !                                                    p_tav   -   ttm !        t_tav(i,j,k)   = tkeadv(i,j,k) + mke(i,j,k) - p_tav(i,j,k) - ttm(i,j,k) t_tav ( i , j , k ) = tkeadv ( i , j , k ) + mke ( i , j , k ) - p_tav ( i , j , k ) & - 0.5 * ( ttmx ( i , j , k ) + ttmx ( ip , j , k )) & - 0.5 * ( ttmy ( i , j , k ) + ttmy ( i , jp , k )) & - 0.5 * ( ttmz ( i , j , k ) + ttmz ( i , j , kp )) p_bav ( i , j , k ) = ( grav / thls ) * 0.5 * ( thlpwpav ( i , j , k ) + thlpwpav ( i , j , kp )) !use of thls here...???? end do end do end do ! need updating tg3315 call avexy_ibm ( p_b ( kb : ke + kh ), p_bav (:,:, kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc , IIcs ,. true .) call avexy_ibm ( t_p ( kb : ke + kh ), t_pav (:,:, kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc , IIcs ,. true .) call avexy_ibm ( adv ( kb : ke + kh ), tkeadv (:,:, kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc , IIcs ,. true .) call avexy_ibm ( t_t ( kb : ke + kh ), t_tav (:,:, kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc , IIcs ,. true .) call avexy_ibm ( t_sgs ( kb : ke + kh ), t_sgsav (:,:, kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc , IIcs ,. true .) call avexy_ibm ( p_t ( kb : ke + kh ), p_tav (:,:, kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc , IIcs ,. true .) call avexy_ibm ( d_sgs ( kb : ke + kh ), d_sgsav (:,:, kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc , IIcs ,. true .) call avexy_ibm ( t_v ( kb : ke + kh ), t_vav (:,:, kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc , IIcs ,. true .) end subroutine tkestatsdump","tags":"","url":"proc/tkestatsdump.html"},{"title":"exitstatsdump – uDALES","text":"public  subroutine exitstatsdump() Uses modglobal modstat_nc proc~~exitstatsdump~~UsesGraph proc~exitstatsdump exitstatsdump module~modglobal modglobal proc~exitstatsdump->module~modglobal module~modstat_nc modstat_nc proc~exitstatsdump->module~modstat_nc module~modmpi modmpi module~modstat_nc->module~modmpi netcdf netcdf module~modstat_nc->netcdf mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~exitstatsdump~~CalledByGraph proc~exitstatsdump exitstatsdump program~dalesurban DALESURBAN program~dalesurban->proc~exitstatsdump Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine exitstatsdump use modstat_nc , only : exitstat_nc use modglobal , only : ltdump implicit none !       if (lydump) then !         call exitstat_nc(ncid) !       endif ! will doing this ruin the averaging? ... try tg3315 !       if (lytdump) then !         call exitstat_nc(ncidt) !       endif !      if (ltkedump) then !        call exitstat_nc(ncidtke) !      endif !       if (ltdump) then !         call exitstat_nc(ncidt) !       endif end subroutine exitstatsdump","tags":"","url":"proc/exitstatsdump.html"},{"title":"initfielddump – uDALES","text":"public  subroutine initfielddump() Uses modmpi modpois modstat_nc modglobal modibm modfields proc~~initfielddump~~UsesGraph proc~initfielddump initfielddump modpois modpois proc~initfielddump->modpois module~modfields modfields proc~initfielddump->module~modfields module~modglobal modglobal proc~initfielddump->module~modglobal module~modibm modibm proc~initfielddump->module~modibm module~modmpi modmpi proc~initfielddump->module~modmpi module~modstat_nc modstat_nc proc~initfielddump->module~modstat_nc decomp_2d decomp_2d module~modfields->decomp_2d module~modibmdata modibmdata module~modibm->module~modibmdata mpi mpi module~modibm->mpi module~modmpi->mpi module~modstat_nc->module~modmpi netcdf netcdf module~modstat_nc->netcdf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~initfielddump~~CallsGraph proc~initfielddump initfielddump mpi_bcast mpi_bcast proc~initfielddump->mpi_bcast proc~define_nc define_nc proc~initfielddump->proc~define_nc proc~ncinfo ncinfo proc~initfielddump->proc~ncinfo proc~open_nc open_nc proc~initfielddump->proc~open_nc proc~writestat_dims_nc writestat_dims_nc proc~initfielddump->proc~writestat_dims_nc nf90_def_var nf90_def_var proc~define_nc->nf90_def_var nf90_enddef nf90_enddef proc~define_nc->nf90_enddef nf90_inq_dimid nf90_inq_dimid proc~define_nc->nf90_inq_dimid nf90_inq_varid nf90_inq_varid proc~define_nc->nf90_inq_varid nf90_put_att nf90_put_att proc~define_nc->nf90_put_att nf90_redef nf90_redef proc~define_nc->nf90_redef proc~nchandle_error nchandle_error proc~define_nc->proc~nchandle_error nf90_create nf90_create proc~open_nc->nf90_create nf90_def_dim nf90_def_dim proc~open_nc->nf90_def_dim proc~open_nc->nf90_def_var proc~open_nc->nf90_enddef nf90_get_var nf90_get_var proc~open_nc->nf90_get_var proc~open_nc->nf90_inq_dimid proc~open_nc->nf90_inq_varid nf90_inquire nf90_inquire proc~open_nc->nf90_inquire nf90_inquire_dimension nf90_inquire_dimension proc~open_nc->nf90_inquire_dimension nf90_open nf90_open proc~open_nc->nf90_open proc~open_nc->nf90_put_att nf90_sync nf90_sync proc~open_nc->nf90_sync proc~writestat_dims_nc->nf90_inq_varid proc~writestat_dims_nc->nf90_inquire_dimension nf90_put_var nf90_put_var proc~writestat_dims_nc->nf90_put_var nf90_strerror nf90_strerror proc~nchandle_error->nf90_strerror Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~initfielddump~~CalledByGraph proc~initfielddump initfielddump program~dalesurban DALESURBAN program~dalesurban->proc~initfielddump Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine initfielddump use modmpi , only : myid , my_real , mpierr , comm3d , mpi_logical , mpi_integer , cmyidx , cmyidy , mpi_character use modglobal , only : imax , jmax , kmax , imax1 , jmax1 , kmax1 , imax2 , jmax2 , kmax2 , cexpnr , ifnamopt , fname_options , dtmax , kb , ke , ladaptive , dt_lim , btime , nsv , fieldvars , ib , ie , jb , je , kb , ke , ih , jh , lfielddump , ktot , kh use modstat_nc , only : open_nc , define_nc , ncinfo , writestat_dims_nc use modfields , only : u0 , v0 , w0 , thl0 , sv0 , ql0 , qt0 , pres0 , div , dudx , dvdy , dwdz , ru , rv , rw , tau_x , tau_y , tau_z , thl_flux use modpois , only : p , pup , pvp , pwp , rhs , dpupdx , dpvpdy , dpwpdz , xyzrt , Fxy , Fxyz use modibm , only : mask_u , mask_v , mask_w , mask_c implicit none integer :: ierr , n !type(domainptr), dimension(nvar) :: pfields nvar = ( LEN ( trim ( fieldvars )) + 1 ) / 3 if ( nvar == 0 ) then lfielddump = . false . print * , 'empty fieldvars therefore lfielddump = .false. and no instantaneous fields outputted' return else allocate ( ncname ( nvar , 4 )) end if lhalos = . false . if ( lhalos ) then ilow = ib - ih ihigh = ie + ih jlow = jb - jh jhigh = je + jh klow = kb - kh khigh = ke + kh else ilow = ib ihigh = ie jlow = jb jhigh = je klow = kb khigh = ke end if !ils13 13.08.18: why is this broadcast, doesn't every processor do it anyway? call MPI_BCAST ( klow , 1 , MPI_INTEGER , 0 , comm3d , ierr ) call MPI_BCAST ( khigh , 1 , MPI_INTEGER , 0 , comm3d , ierr ) call MPI_BCAST ( lfielddump , 1 , MPI_LOGICAL , 0 , comm3d , ierr ) call MPI_BCAST ( ldiracc , 1 , MPI_LOGICAL , 0 , comm3d , ierr ) call MPI_BCAST ( lbinary , 1 , MPI_LOGICAL , 0 , comm3d , ierr ) call MPI_BCAST ( ncname , 80 , MPI_CHARACTER , 0 , comm3d , mpierr ) call MPI_BCAST ( nvar , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) !    dt_lim = min(dt_lim,tnext) if (. not .( lfielddump )) return fname ( 11 : 13 ) = cmyidx fname ( 15 : 17 ) = cmyidy fname ( 19 : 21 ) = cexpnr call ncinfo ( tncname ( 1 ,:), 'time' , 'Time' , 's' , 'time' ) ! tg3315 reads in fields specified by fieldvars if ( lhalos ) then do n = 1 , nvar select case ( fieldvars ( 3 * n - 2 : 3 * n - 1 )) case ( 'u0' ) call ncinfo ( ncname ( n ,:), 'u' , 'West-East velocity' , 'm/s' , 'mttt' ) pfields ( n )% point => u0 ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ) case ( 'v0' ) call ncinfo ( ncname ( n ,:), 'v' , 'South-North velocity' , 'm/s' , 'tmtt' ) pfields ( n )% point => v0 ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ) case ( 'w0' ) call ncinfo ( ncname ( n ,:), 'w' , 'Vertical velocity' , 'm/s' , 'ttmt' ) pfields ( n )% point => w0 ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ) case ( 'th' ) call ncinfo ( ncname ( n ,:), 'thl' , 'Liquid water potential temperature' , 'K' , 'tttt' ) pfields ( n )% point => thl0 ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ) case ( 'ql' ) call ncinfo ( ncname ( n ,:), 'ql' , 'Liquid water mixing ratio' , '1e-5kg/kg' , 'tttt' ) pfields ( n )% point => ql0 ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ) case ( 'qt' ) call ncinfo ( ncname ( n ,:), 'qt' , 'Total water mixing ratio' , '1e-5kg/kg' , 'tttt' ) pfields ( n )% point => qt0 ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ) case ( 's1' ) call ncinfo ( ncname ( n ,:), 'sca1' , 'scalar 1' , 'M' , 'tttt' ) pfields ( n )% point => sv0 ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke , 1 ) case ( 's2' ) call ncinfo ( ncname ( n ,:), 'sca2' , 'scalar 2' , 'M' , 'tttt' ) pfields ( n )% point => sv0 ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke , 2 ) case ( 's3' ) call ncinfo ( ncname ( n ,:), 'sca3' , 'scalar 3' , 'M' , 'tttt' ) pfields ( n )% point => sv0 ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke , 3 ) case ( 's4' ) call ncinfo ( ncname ( n ,:), 'sca4' , 'scalar 4' , 'M' , 'tttt' ) pfields ( n )% point => sv0 ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke , 4 ) case ( 's5' ) call ncinfo ( ncname ( n ,:), 'sca5' , 'scalar 5' , 'M' , 'tttt' ) pfields ( n )% point => sv0 ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke , 5 ) case ( 'p0' ) call ncinfo ( ncname ( n ,:), 'pres' , 'pressure field' , 'M' , 'tttt' ) pfields ( n )% point => pres0 ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ) ! case('pd') !   call ncinfo(ncname( n,:),'p','pressure correction','M','tttt') !   pfields(n)%point => p(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh) ! case('pu') !   call ncinfo(ncname( n,:),'pup','predicted u','M','mttt') !   pfields(n)%point => pup(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh) ! case('pv') !   call ncinfo(ncname( n,:),'pvp','predicted v','M','tmtt') !   pfields(n)%point => pvp(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh) ! case('pw') !   call ncinfo(ncname( n,:),'pwp','predicted w','M','ttmt') !   pfields(n)%point => pwp(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh) ! case('du') !   call ncinfo(ncname( n,:),'dpupdx','','M','tttt') !   pfields(n)%point => dpupdx(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh) ! case('dv') !   call ncinfo(ncname( n,:),'dpvpdy','','M','tttt') !   pfields(n)%point => dpvpdy(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh) ! case('dw') !   call ncinfo(ncname( n,:),'dpwpdz','','M','tttt') !   pfields(n)%point => dpwpdz(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh) ! case default !   call ncinfo(ncname( n,:),'u','West-East velocity','m/s','mttt') !   pfields(n)%point => u0(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh) end select end do else do n = 1 , nvar select case ( fieldvars ( 3 * n - 2 : 3 * n - 1 )) case ( 'u0' ) call ncinfo ( ncname ( n ,:), 'u' , 'West-East velocity' , 'm/s' , 'mttt' ) pfields ( n )% point => u0 ( ib : ie , jb : je , kb : ke ) case ( 'v0' ) call ncinfo ( ncname ( n ,:), 'v' , 'South-North velocity' , 'm/s' , 'tmtt' ) pfields ( n )% point => v0 ( ib : ie , jb : je , kb : ke ) case ( 'w0' ) call ncinfo ( ncname ( n ,:), 'w' , 'Vertical velocity' , 'm/s' , 'ttmt' ) pfields ( n )% point => w0 ( ib : ie , jb : je , kb : ke ) case ( 'th' ) call ncinfo ( ncname ( n ,:), 'thl' , 'Liquid water potential temperature' , 'K' , 'tttt' ) pfields ( n )% point => thl0 ( ib : ie , jb : je , kb : ke ) case ( 'ql' ) call ncinfo ( ncname ( n ,:), 'ql' , 'Liquid water mixing ratio' , '1e-5kg/kg' , 'tttt' ) pfields ( n )% point => ql0 ( ib : ie , jb : je , kb : ke ) case ( 'qt' ) call ncinfo ( ncname ( n ,:), 'qt' , 'Total water mixing ratio' , '1e-5kg/kg' , 'tttt' ) pfields ( n )% point => qt0 ( ib : ie , jb : je , kb : ke ) case ( 's1' ) call ncinfo ( ncname ( n ,:), 'sca1' , 'scalar 1' , 'M' , 'tttt' ) pfields ( n )% point => sv0 ( ib : ie , jb : je , kb : ke , 1 ) case ( 's2' ) call ncinfo ( ncname ( n ,:), 'sca2' , 'scalar 2' , 'M' , 'tttt' ) pfields ( n )% point => sv0 ( ib : ie , jb : je , kb : ke , 2 ) case ( 's3' ) call ncinfo ( ncname ( n ,:), 'sca3' , 'scalar 3' , 'M' , 'tttt' ) pfields ( n )% point => sv0 ( ib : ie , jb : je , kb : ke , 3 ) case ( 's4' ) call ncinfo ( ncname ( n ,:), 'sca4' , 'scalar 4' , 'M' , 'tttt' ) pfields ( n )% point => sv0 ( ib : ie , jb : je , kb : ke , 4 ) case ( 's5' ) call ncinfo ( ncname ( n ,:), 'sca5' , 'scalar 5' , 'M' , 'tttt' ) pfields ( n )% point => sv0 ( ib : ie , jb : je , kb : ke , 5 ) case ( 'p0' ) call ncinfo ( ncname ( n ,:), 'pres' , 'pressure field' , 'M' , 'tttt' ) pfields ( n )% point => pres0 ( ib : ie , jb : je , kb : ke ) case ( 'tx' ) call ncinfo ( ncname ( n ,:), 'tau_x' , 'stress x' , 'M' , 'mttt' ) pfields ( n )% point => tau_x ( ib : ie , jb : je , kb : ke ) case ( 'ty' ) call ncinfo ( ncname ( n ,:), 'tau_y' , 'stress y' , 'M' , 'tmtt' ) pfields ( n )% point => tau_y ( ib : ie , jb : je , kb : ke ) case ( 'tz' ) call ncinfo ( ncname ( n ,:), 'tau_z' , 'stress z' , 'M' , 'ttmt' ) pfields ( n )% point => tau_z ( ib : ie , jb : je , kb : ke ) case ( 'hf' ) call ncinfo ( ncname ( n ,:), 'thl_flux' , 'heat flux' , 'M' , 'tttt' ) pfields ( n )% point => thl_flux ( ib : ie , jb : je , kb : ke ) case ( 'mu' ) call ncinfo ( ncname ( n ,:), 'mask_u' , 'mask u' , 'M' , 'mttt' ) pfields ( n )% point => mask_u ( ib : ie , jb : je , kb : ke ) case ( 'mv' ) call ncinfo ( ncname ( n ,:), 'mask_v' , 'mask v' , 'M' , 'tmtt' ) pfields ( n )% point => mask_v ( ib : ie , jb : je , kb : ke ) case ( 'mw' ) call ncinfo ( ncname ( n ,:), 'mask_w' , 'mask w' , 'M' , 'ttmt' ) pfields ( n )% point => mask_w ( ib : ie , jb : je , kb : ke ) case ( 'mc' ) call ncinfo ( ncname ( n ,:), 'mask_c' , 'mask c' , 'M' , 'tttt' ) pfields ( n )% point => mask_c ( ib : ie , jb : je , kb : ke ) ! case('pd') !   call ncinfo(ncname( n,:),'p','pressure correction','M','tttt') !   pfields(n)%point => p(ib:ie,jb:je,kb:ke) ! case('pu') !   call ncinfo(ncname( n,:),'pup','predicted u','M','mttt') !   pfields(n)%point => pup(ib:ie,jb:je,kb:ke) ! case('pv') !   call ncinfo(ncname( n,:),'pvp','predicted v','M','tmtt') !   pfields(n)%point => pvp(ib:ie,jb:je,kb:ke) ! case('pw') !   call ncinfo(ncname( n,:),'pwp','predicted w','M','ttmt') !   pfields(n)%point => pwp(ib:ie,jb:je,kb:ke) ! case('rs') !   call ncinfo(ncname( n,:),'rhs','rhs of poisson equation','M','tttt') !   pfields(n)%point => rhs(ib:ie,jb:je,kb:ke) ! case('du') !   call ncinfo(ncname( n,:),'dpupdx','','M','tttt') !   pfields(n)%point => dpupdx(ib:ie,jb:je,kb:ke) ! case('dv') !   call ncinfo(ncname( n,:),'dpvpdy','','M','tttt') !   pfields(n)%point => dpvpdy(ib:ie,jb:je,kb:ke) ! case('dw') !   call ncinfo(ncname( n,:),'dpwpdz','','M','tttt') !   pfields(n)%point => dpwpdz(ib:ie,jb:je,kb:ke) case ( 'di' ) call ncinfo ( ncname ( n ,:), 'div' , 'Divergence after pressure correction' , 'M' , 'tttt' ) pfields ( n )% point => div ( ib : ie , jb : je , kb : ke ) ! case('ft') !   call ncinfo(ncname( n,:),'ft','Fourier transformed data in x and y','M','tttt') !   pfields(n)%point => Fxy(ib:ie,jb:je,kb:ke) ! case('ge') !   call ncinfo(ncname( n,:),'ge','Fourier transformed data in x and y and done GE in z','M','tttt') !   pfields(n)%point => Fxyz(ib:ie,jb:je,kb:ke) ! case('ux') !   call ncinfo(ncname( n,:),'dudx','','M','tttt') !   pfields(n)%point => dudx(ib:ie,jb:je,kb:ke) ! case('vy') !   call ncinfo(ncname( n,:),'dvdy','','M','tttt') !   pfields(n)%point => dvdy(ib:ie,jb:je,kb:ke) ! case('wz') !   call ncinfo(ncname( n,:),'dwdz','','M','tttt') !   pfields(n)%point => dwdz(ib:ie,jb:je,kb:ke) ! case('up') !   call ncinfo(ncname( n,:),'up','','M','tttt') !   pfields(n)%point => ru(ib:ie,jb:je,kb:ke) ! case('vp') !   call ncinfo(ncname( n,:),'vp','','M','tttt') !   pfields(n)%point => rv(ib:ie,jb:je,kb:ke) ! case('wp') !   call ncinfo(ncname( n,:),'wp','','M','tttt') !   pfields(n)%point => rw(ib:ie,jb:je,kb:ke) ! case('rt') !   call ncinfo(ncname( n,:),'xyzrt','Wavenumbers','M','tttt') !   pfields(n)%point => xyzrt(1:sp%zsz(1),1:sp%zsz(2),1:ktot) case default call ncinfo ( ncname ( n ,:), 'u' , 'West-East velocity' , 'm/s' , 'mttt' ) pfields ( n )% point => u0 ( ib : ie , jb : je , kb : ke ) end select end do end if !call ncinfo(ncname( n,:),'u','West-East velocity','m/s','mttt') !call open_nc( fname, ncid, nrec, n1=imax+2, n2=jmax+2, n3=khigh-klow+1) call open_nc ( fname , ncid , nrec , n1 = ihigh - ilow + 1 , n2 = jhigh - jlow + 1 , n3 = khigh - klow + 1 ) if ( nrec == 0 ) then call define_nc ( ncid , 1 , tncname ) call writestat_dims_nc ( ncid ) end if call define_nc ( ncid , nvar , ncname ) !call open_nc( fname, ncid, nrec, n1=imax+2, n2=jmax+2, n3=khigh-klow+1) call open_nc ( fname , ncid , nrec , n1 = ihigh - ilow + 1 , n2 = jhigh - jlow + 1 , n3 = khigh - klow + 1 ) if ( nrec == 0 ) then call define_nc ( ncid , 1 , tncname ) call writestat_dims_nc ( ncid ) end if call define_nc ( ncid , nvar , ncname ) !   ! X-pencil ! !   fname1(11:13) = cmyidx !   fname1(15:17) = cmyidy !   fname1(19:21) = cexpnr !   call ncinfo(tncname1(1,:),'time','Time','s','time') !   call ncinfo(ncname1(1,:),'u','West-East velocity','m/s','mttt') ! !   !write(*,*) \"done defining pfields\" ! !   call open_nc( fname1, ncid1, nrec, n1=imax1+2, n2=jmax1+2, n3=kmax1+2) ! !   if (nrec==0) then !     call define_nc( ncid1, 1, tncname1) !     call writestat_dims_nc(ncid1) !   end if !   call define_nc( ncid1, nvar, ncname1) !   call open_nc( fname1, ncid1, nrec, n1=imax1+2, n2=jmax1+2, n3=kmax1+2) !   ! call open_nc( fname, ncid, nrec, n1=imax+2, n2=jmax+2, n3=khigh-klow+1)  !if want to print ghostcells !   if (nrec==0) then !     call define_nc( ncid1, 1, tncname1) !     call writestat_dims_nc(ncid1) !  end if !  call define_nc( ncid1, nvar, ncname1) ! ! !  ! Y-pencil ! !  fname2(11:13) = cmyidx !  fname2(15:17) = cmyidy !  fname2(19:21) = cexpnr !  call ncinfo(tncname2(1,:),'time','Time','s','time') !  call ncinfo(ncname2( 1,:),'u','West-East velocity','m/s','mttt') ! !  call open_nc( fname2, ncid2, nrec, n1=imax2+2, n2=jmax2+2, n3=kmax2+2) !  if (nrec==0) then !    call define_nc( ncid2, 1, tncname2) !    call writestat_dims_nc(ncid2) !  end if !  call define_nc( ncid2, nvar, ncname2) !  call open_nc( fname2, ncid2, nrec, n1=imax2+2, n2=jmax2+2, n3=kmax2+2) !  ! call open_nc( fname, ncid, nrec, n1=imax+2, n2=jmax+2, n3=khigh-klow+1)  !if want to print ghostcells !  if (nrec==0) then !    call define_nc( ncid2, 1, tncname2) !    call writestat_dims_nc(ncid2) ! end if ! call define_nc( ncid2, nvar, ncname2) end subroutine initfielddump","tags":"","url":"proc/initfielddump.html"},{"title":"fielddump – uDALES","text":"public  subroutine fielddump() Uses modmpi modsurfdata modfields modstat_nc modglobal proc~~fielddump~~UsesGraph proc~fielddump fielddump module~modfields modfields proc~fielddump->module~modfields module~modglobal modglobal proc~fielddump->module~modglobal module~modmpi modmpi proc~fielddump->module~modmpi module~modstat_nc modstat_nc proc~fielddump->module~modstat_nc module~modsurfdata modsurfdata proc~fielddump->module~modsurfdata decomp_2d decomp_2d module~modfields->decomp_2d mpi mpi module~modmpi->mpi module~modstat_nc->module~modmpi netcdf netcdf module~modstat_nc->netcdf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~fielddump~~CallsGraph proc~fielddump fielddump interface~writestat_nc writestat_nc proc~fielddump->interface~writestat_nc proc~writestat_1d_nc writestat_1D_nc interface~writestat_nc->proc~writestat_1d_nc proc~writestat_2d_nc writestat_2D_nc interface~writestat_nc->proc~writestat_2d_nc proc~writestat_3d_nc writestat_3D_nc interface~writestat_nc->proc~writestat_3d_nc proc~writestat_3d_short_nc writestat_3D_short_nc interface~writestat_nc->proc~writestat_3d_short_nc proc~writestat_time_nc writestat_time_nc interface~writestat_nc->proc~writestat_time_nc nf90_inq_varid nf90_inq_varid proc~writestat_1d_nc->nf90_inq_varid nf90_put_var nf90_put_var proc~writestat_1d_nc->nf90_put_var nf90_sync nf90_sync proc~writestat_1d_nc->nf90_sync proc~writestat_2d_nc->nf90_inq_varid proc~writestat_2d_nc->nf90_put_var proc~writestat_2d_nc->nf90_sync proc~writestat_3d_nc->nf90_inq_varid proc~writestat_3d_nc->nf90_put_var proc~writestat_3d_nc->nf90_sync proc~writestat_3d_short_nc->nf90_inq_varid proc~writestat_3d_short_nc->nf90_put_var proc~writestat_3d_short_nc->nf90_sync proc~writestat_time_nc->nf90_inq_varid proc~writestat_time_nc->nf90_put_var proc~writestat_time_nc->nf90_sync Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~fielddump~~CalledByGraph proc~fielddump fielddump program~dalesurban DALESURBAN program~dalesurban->proc~fielddump Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine fielddump use modfields , only : u0 , v0 , w0 , thl0 , qt0 , ql0 , sv0 , pres0 , u01 , u02 , u0h , um , div , dudx , dvdy , dwdz , tau_x !ILS13 21.04.2015 changed to u0 from um  etc use modsurfdata , only : thls , qts , thvs use modglobal , only : ib , ie , ih , jb , je , jh , ke , kb , kh , rk3step , timee , dt_lim , cexpnr , ifoutput , imax , jmax ,& tfielddump , tnextfielddump , nsv , lfielddump , ktot , fieldvars , imax1 , jmax1 , kmax1 , imax2 , jmax2 , kmax2 , rk3step , dyi , dxfi , dzhi !use modmpi,    only : myid,cmyid !use modsubgriddata, only : ekm,sbshr use modstat_nc , only : writestat_nc use modmpi , only : myid , cmyid implicit none real , allocatable :: vars (:,:,:,:), vars1 (:,:,:,:), vars2 (:,:,:,:) integer i , j , k , n integer :: writecounter = 1 if (. not . (( timee >= tnextfielddump ) . or . ( rk3step == 0 ))) return if (. not . lfielddump ) return if ( rk3step /= 3 . and . rk3step /= 0 ) return do k = kb , ke do j = jb , je do i = ib , ie dudx ( i , j , k ) = ( u0 ( i + 1 , j , k ) - u0 ( i , j , k ) ) * dxfi ( i ) dvdy ( i , j , k ) = ( v0 ( i , j + 1 , k ) - v0 ( i , j , k ) ) * dyi dwdz ( i , j , k ) = ( w0 ( i , j , k + 1 ) - w0 ( i , j , k ) ) * dzhi ( k ) div ( i , j , k ) = ( u0 ( i + 1 , j , k ) - u0 ( i , j , k ) ) * dxfi ( i ) + & ( v0 ( i , j + 1 , k ) - v0 ( i , j , k ) ) * dyi + & ( w0 ( i , j , k + 1 ) - w0 ( i , j , k ) ) * dzhi ( k ) end do end do end do if ( rk3step == 3 ) tnextfielddump = tnextfielddump + tfielddump if ( lhalos ) then allocate ( vars ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh , nvar )); vars = 0 ; do n = 1 , nvar vars ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh , n ) = pfields ( n )% point end do else allocate ( vars ( ib : ie , jb : je , kb : ke , nvar )); vars = 0 ; do n = 1 , nvar vars ( ib : ie , jb : je , kb : ke , n ) = pfields ( n )% point end do end if call writestat_nc ( ncid , 1 , tncname ,( / timee / ), nrec ,. true .) !call writestat_nc(ncid,nvar,ncname,vars,nrec,imax+2,jmax+2,khigh-klow+1) call writestat_nc ( ncid , nvar , ncname , vars , nrec , ihigh - ilow + 1 , jhigh - jlow + 1 , khigh - klow + 1 ) deallocate ( vars ) end subroutine fielddump","tags":"","url":"proc/fielddump.html"},{"title":"exitfielddump – uDALES","text":"public  subroutine exitfielddump() Uses modstat_nc modglobal proc~~exitfielddump~~UsesGraph proc~exitfielddump exitfielddump module~modglobal modglobal proc~exitfielddump->module~modglobal module~modstat_nc modstat_nc proc~exitfielddump->module~modstat_nc module~modmpi modmpi module~modstat_nc->module~modmpi netcdf netcdf module~modstat_nc->netcdf mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~exitfielddump~~CallsGraph proc~exitfielddump exitfielddump proc~exitstat_nc exitstat_nc proc~exitfielddump->proc~exitstat_nc nf90_close nf90_close proc~exitstat_nc->nf90_close proc~nchandle_error nchandle_error proc~exitstat_nc->proc~nchandle_error nf90_strerror nf90_strerror proc~nchandle_error->nf90_strerror Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~exitfielddump~~CalledByGraph proc~exitfielddump exitfielddump program~dalesurban DALESURBAN program~dalesurban->proc~exitfielddump Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine exitfielddump use modglobal , only : lfielddump use modstat_nc , only : exitstat_nc implicit none if ( lfielddump ) call exitstat_nc ( ncid ) end subroutine exitfielddump","tags":"","url":"proc/exitfielddump.html"},{"title":"initboundary – uDALES","text":"public  subroutine initboundary() Uses modinletdata modglobal proc~~initboundary~~UsesGraph proc~initboundary initboundary module~modglobal modglobal proc~initboundary->module~modglobal module~modinletdata modinletdata proc~initboundary->module~modinletdata Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~initboundary~~CalledByGraph proc~initboundary initboundary program~dalesurban DALESURBAN program~dalesurban->proc~initboundary Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine initboundary use modglobal , only : ib , kb , ke , kh , kmax , pi , zf , iplane use modinletdata , only : irecy implicit none real :: zspb , zspt integer :: k allocate ( tsc ( kb : ke + kh )) ! Sponge layer if ( ksp == - 1 ) then !      ksp  = min(3*kmax/4,kmax - 15) ksp = ( kb - 1 ) + max ( min ( 3 * kmax / 4 , kmax - 15 ), 1 ) end if zspb = zf ( ksp ) zspt = zf ( ke ) tsc ( kb : ksp - 1 ) = 0.0 do k = ksp , ke tsc ( k ) = rnu0 * sin ( 0.5 * pi * ( zf ( k ) - zspb ) / ( zspt - zspb )) ** 2 end do tsc ( ke + 1 ) = tsc ( ke ) irecy = ib + iplane end subroutine initboundary","tags":"","url":"proc/initboundary.html"},{"title":"halos – uDALES","text":"public  subroutine halos() Uses modfields decomp_2d modglobal proc~~halos~~UsesGraph proc~halos halos decomp_2d decomp_2d proc~halos->decomp_2d module~modfields modfields proc~halos->module~modfields module~modglobal modglobal proc~halos->module~modglobal module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~halos~~CallsGraph proc~halos halos exchange_halo_z exchange_halo_z proc~halos->exchange_halo_z proc~xm_periodic xm_periodic proc~halos->proc~xm_periodic proc~xq_periodic xq_periodic proc~halos->proc~xq_periodic proc~xs_periodic xs_periodic proc~halos->proc~xs_periodic proc~xt_periodic xT_periodic proc~halos->proc~xt_periodic proc~ym_periodic ym_periodic proc~halos->proc~ym_periodic proc~yq_periodic yq_periodic proc~halos->proc~yq_periodic proc~ys_periodic ys_periodic proc~halos->proc~ys_periodic proc~yt_periodic yT_periodic proc~halos->proc~yt_periodic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~halos~~CalledByGraph proc~halos halos proc~readinitfiles readinitfiles proc~readinitfiles->proc~halos program~dalesurban DALESURBAN program~dalesurban->proc~halos program~dalesurban->proc~readinitfiles Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine halos use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , ihc , jhc , khc , nsv , & BCxm , BCym , BCxT , BCyT , BCxq , BCyq , BCxs , BCys , & BCxm_periodic , BCxT_periodic , BCxq_periodic , BCxs_periodic , & BCym_periodic , BCyT_periodic , BCyq_periodic , BCys_periodic , & ibrank , ierank , jbrank , jerank use modfields , only : u0 , v0 , w0 , um , vm , wm , thl0 , thlm , qt0 , qtm , sv0 , svm , thl0c use decomp_2d , only : exchange_halo_z implicit none integer i , k , n call exchange_halo_z ( u0 ) call exchange_halo_z ( v0 ) call exchange_halo_z ( w0 ) call exchange_halo_z ( um ) call exchange_halo_z ( vm ) call exchange_halo_z ( wm ) call exchange_halo_z ( thl0 ) call exchange_halo_z ( thlm ) call exchange_halo_z ( thl0c , opt_zlevel = ( / ihc , jhc , khc / )) call exchange_halo_z ( qt0 ) call exchange_halo_z ( qtm ) do n = 1 , nsv call exchange_halo_z ( sv0 (:, :, :, n ), opt_zlevel = ( / ihc , jhc , khc / )) call exchange_halo_z ( svm (:, :, :, n ), opt_zlevel = ( / ihc , jhc , khc / )) enddo if ( ibrank . and . ierank ) then ! not parallelized in x if ( BCxm == BCxm_periodic ) call xm_periodic if ( BCxT == BCxT_periodic ) call xT_periodic if ( BCxq == BCxq_periodic ) call xq_periodic if ( BCxs == BCxs_periodic ) call xs_periodic end if if ( jbrank . and . jerank ) then ! not parallelized in x if ( BCym == BCym_periodic ) call ym_periodic if ( BCyT == BCyT_periodic ) call yT_periodic if ( BCyq == BCyq_periodic ) call yq_periodic if ( BCys == BCys_periodic ) call ys_periodic end if end subroutine halos","tags":"","url":"proc/halos.html"},{"title":"boundary – uDALES","text":"public  subroutine boundary() Uses modmpi modsubgriddata modsurfdata decomp_2d moddriver modinletdata modglobal modfields proc~~boundary~~UsesGraph proc~boundary boundary decomp_2d decomp_2d proc~boundary->decomp_2d module~moddriver moddriver proc~boundary->module~moddriver module~modfields modfields proc~boundary->module~modfields module~modglobal modglobal proc~boundary->module~modglobal module~modinletdata modinletdata proc~boundary->module~modinletdata module~modmpi modmpi proc~boundary->module~modmpi module~modsubgriddata modsubgriddata proc~boundary->module~modsubgriddata module~modsurfdata modsurfdata proc~boundary->module~modsurfdata module~moddriver->module~modinletdata module~modfields->decomp_2d mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~boundary~~CallsGraph proc~boundary boundary proc~driverchunkread driverchunkread proc~boundary->proc~driverchunkread proc~drivergen drivergen proc~boundary->proc~drivergen proc~fluxtop fluxtop proc~boundary->proc~fluxtop proc~fluxtopscal fluxtopscal proc~boundary->proc~fluxtopscal proc~valuetop valuetop proc~boundary->proc~valuetop proc~valuetopscal valuetopscal proc~boundary->proc~valuetopscal proc~xmi_driver xmi_driver proc~boundary->proc~xmi_driver proc~xmi_profile xmi_profile proc~boundary->proc~xmi_profile proc~xmo_convective xmo_convective proc~boundary->proc~xmo_convective proc~xqi_driver xqi_driver proc~boundary->proc~xqi_driver proc~xqi_profile xqi_profile proc~boundary->proc~xqi_profile proc~xqo_convective xqo_convective proc~boundary->proc~xqo_convective proc~xsi_custom xsi_custom proc~boundary->proc~xsi_custom proc~xsi_driver xsi_driver proc~boundary->proc~xsi_driver proc~xsi_profile xsi_profile proc~boundary->proc~xsi_profile proc~xso_convective xso_convective proc~boundary->proc~xso_convective proc~xti_driver xTi_driver proc~boundary->proc~xti_driver proc~xti_profile xTi_profile proc~boundary->proc~xti_profile proc~xto_convective xTo_convective proc~boundary->proc~xto_convective proc~ymi_profile ymi_profile proc~boundary->proc~ymi_profile proc~ymo_convective ymo_convective proc~boundary->proc~ymo_convective proc~yqi_profile yqi_profile proc~boundary->proc~yqi_profile proc~yqo_convective yqo_convective proc~boundary->proc~yqo_convective proc~ysi_profile ysi_profile proc~boundary->proc~ysi_profile proc~yso_convective yso_convective proc~boundary->proc~yso_convective proc~yti_profile yTi_profile proc~boundary->proc~yti_profile proc~yto_convective yTo_convective proc~boundary->proc~yto_convective proc~readdriverfile_chunk readdriverfile_chunk proc~driverchunkread->proc~readdriverfile_chunk proc~writedriverfile writedriverfile proc~drivergen->proc~writedriverfile zstart zstart proc~xsi_custom->zstart Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~boundary~~CalledByGraph proc~boundary boundary program~dalesurban DALESURBAN program~dalesurban->proc~boundary Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine boundary use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , ihc , jhc , khc , dzf , zh , nsv , & ltempeq , lmoist , luvolflowr , luoutflowr , & BCxm , BCym , BCxT , BCyT , BCxq , BCyq , BCxs , BCys , BCtopm , BCtopT , BCtopq , BCtops , & BCtopm_freeslip , BCtopm_noslip , BCtopm_pressure , & BCtopT_flux , BCtopT_value , BCtopq_flux , BCtopq_value , BCtops_flux , BCtops_value , & BCxm_periodic , BCxm_profile , BCxm_driver , & BCxT_periodic , BCxT_profile , BCxT_driver , & BCxq_periodic , BCxq_profile , BCxq_driver , & BCxs_periodic , BCxs_profile , BCxs_driver , BCxs_custom , & BCym_periodic , BCym_profile , BCyT_periodic , BCyT_profile , & BCyq_periodic , BCyq_profile , BCys_periodic , & ibrank , ierank , jbrank , jerank , e12min , idriver , & Uinf , Vinf , & rk3step , lchunkread use modfields , only : u0 , v0 , w0 , um , vm , wm , thl0 , thlm , qt0 , qtm , e120 , e12m , sv0 , svm , u0av , v0av , uouttot , vouttot , thl0c use modsubgriddata , only : ekh , ekm , loneeqn use modsurfdata , only : thl_top , qt_top , sv_top , wttop , wqtop , wsvtop use modmpi , only : myid , slabsum , avey_ibm use moddriver , only : drivergen , driverchunkread use modinletdata , only : ubulk , vbulk , iangle use decomp_2d , only : exchange_halo_z implicit none real , dimension ( kb : ke ) :: uaverage , vaverage real , dimension ( ib : ie , kb : ke ) :: uavey integer i , k , n ! if not using massflowrate need to set outflow velocity if ( luoutflowr ) then ! do nothing - calculated in modforces elseif (. not . luvolflowr ) then !ubulk = sum(u0av)/(ke-kb+1) do k = kb , ke uaverage ( k ) = u0av ( k ) * dzf ( k ) end do do k = kb , ke vaverage ( k ) = v0av ( k ) * dzf ( k ) end do ! need a method to know if we have all blocks at lowest cell kb ! assuming this for now (hence kb+1) uouttot = sum ( uaverage ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb + 1 )) vouttot = sum ( vaverage ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb + 1 )) else uouttot = ubulk vouttot = vbulk end if ! Bottom BC - many ways of enforcing this but this is simplest ! Other variables handled by bottom wm (:, :, kb ) = 0. w0 (:, :, kb ) = 0. !! Top ! Momentum select case ( BCtopm ) case ( BCtopm_freeslip ) !free-slip = zero-flux call fluxtop ( um , ekm , 0.0 ) call fluxtop ( u0 , ekm , 0.0 ) call fluxtop ( vm , ekm , 0.0 ) call fluxtop ( v0 , ekm , 0.0 ) w0 (:, :, ke + 1 ) = 0.0 wm (:, :, ke + 1 ) = 0.0 if ( loneeqn ) then e120 (:, :, ke + 1 ) = e12min e12m (:, :, ke + 1 ) = e12min end if case ( BCtopm_noslip ) !no-slip = fixed velocity at wall call valuetop ( um , Uinf ) call valuetop ( u0 , Uinf ) call valuetop ( vm , Vinf ) call valuetop ( v0 , Vinf ) w0 (:, :, ke + 1 ) = 0.0 wm (:, :, ke + 1 ) = 0.0 case ( BCtopm_pressure ) call fluxtop ( um , ekm , 0.0 ) call fluxtop ( u0 , ekm , 0.0 ) call fluxtop ( vm , ekm , 0.0 ) call fluxtop ( v0 , ekm , 0.0 ) if ( loneeqn ) then e120 (:, :, ke + 1 ) = e12min e12m (:, :, ke + 1 ) = e12min end if ! w considered in modpois case default write ( 0 , * ) \"ERROR: top boundary type for velocity undefined\" stop 1 end select ! Temperature select case ( BCtopT ) case ( BCtopT_flux ) call fluxtop ( thlm , ekh , wttop ) call fluxtop ( thl0 , ekh , wttop ) do n = 1 , khc thl0c (:,:, ke + n ) = thl0c (:,:, ke + n - 1 ) end do case ( BCtopT_value ) call valuetop ( thlm , thl_top ) call valuetop ( thl0 , thl_top ) case default write ( 0 , * ) \"ERROR: top boundary type for temperature undefined\" stop 1 end select ! Moisture select case ( BCtopq ) case ( BCtopq_flux ) call fluxtop ( qtm , ekh , wqtop ) call fluxtop ( qt0 , ekh , wqtop ) case ( BCtopq_value ) call valuetop ( qtm , qt_top ) call valuetop ( qt0 , qt_top ) case default write ( 0 , * ) \"ERROR: top boundary type for moisture undefined\" stop 1 end select ! Scalars select case ( BCtops ) case ( BCtops_flux ) call fluxtopscal ( wsvtop ) call fluxtopscal ( wsvtop ) case ( BCtops_value ) call valuetopscal ( sv_top ) call valuetopscal ( sv_top ) case default write ( 0 , * ) \"ERROR: top boundary type for scalars undefined\" stop 1 end select if ( idriver == 1 ) call drivergen ! Should be moved elsewhere, as not related to boundary conditions. ! x inlet if ( ibrank ) then ! set inlet ! Momentum select case ( BCxm ) case ( BCxm_periodic ) ! Handled in halos case ( BCxm_profile ) !uouttot = cos(iangle)*ubulk call xmi_profile case ( BCxm_driver ) !uouttot = ubulk ! does this hold for all forcings of precursor simulations? tg3315 if ( rk3step == 0 . or . rk3step == 3 ) then if ( lchunkread ) call driverchunkread call drivergen ! think this should be done at the start of an rk3 loop? end if call xmi_driver case default write ( 0 , * ) \"ERROR: lateral boundary type for veloctiy in x-direction undefined\" stop 1 end select ! Temperature if ( ltempeq ) then select case ( BCxT ) case ( BCxT_periodic ) ! periodic ! Handled in halos case ( BCxT_profile ) ! profile call xTi_profile case ( BCxT_driver ) call xTi_driver case default write ( 0 , * ) \"ERROR: lateral boundary type for temperature in x-direction undefined\" stop 1 end select end if ! Moisture if ( lmoist ) then select case ( BCxq ) case ( BCxq_periodic ) ! Handled in halos case ( BCxq_profile ) call xqi_profile case ( BCxq_driver ) call xqi_driver case default write ( 0 , * ) \"ERROR: lateral boundary type for humidity in x-direction undefined\" stop 1 end select end if ! Scalars if ( nsv > 0 ) then select case ( BCxs ) case ( BCxs_periodic ) ! Handled in halos case ( BCxs_profile ) call xsi_profile case ( BCxs_driver ) call xsi_driver case ( BCxs_custom ) call xsi_custom case default write ( 0 , * ) \"ERROR: lateral boundary type for scalars in x-direction undefined\" stop 1 end select end if end if !ibrank if ( jbrank ) then ! set y inlet ! Momentum select case ( BCym ) case ( BCym_periodic ) ! Handled in halos case ( BCym_profile ) call ymi_profile case default write ( 0 , * ) \"ERROR: lateral boundary type for veloctiy in y-direction undefined\" stop 1 end select ! Temperature if ( ltempeq ) then select case ( BCyT ) case ( BCyT_periodic ) ! Handled in halos case ( BCyT_profile ) call yTi_profile case default write ( 0 , * ) \"ERROR: lateral boundary type for temperature in y-direction undefined\" stop 1 end select end if ! Moisture if ( lmoist ) then select case ( BCyq ) case ( BCyq_periodic ) ! Handled in halos case ( BCyq_profile ) call yqi_profile case default write ( 0 , * ) \"ERROR: lateral boundary type for humidity in y-direction undefined\" stop 1 end select end if if ( nsv > 0 ) then !scalars select case ( BCys ) case ( 1 ) ! Handled in halos case ( 2 ) call ysi_profile case default write ( 0 , * ) \"ERROR: lateral boundary type for scalars in y-direction undefined\" stop 1 end select end if end if !jbrank !> Outlet ! Currently only outflow boundary conditions are convective if ( ierank ) then if ( BCxm . ne . BCxm_periodic ) call xmo_convective if (( BCxT . ne . BCxT_periodic ) . and . ltempeq ) call xTo_convective if (( BCxq . ne . BCxq_periodic ) . and . lmoist ) call xqo_convective if (( BCxs . ne . BCxs_periodic ) . and . nsv > 0 ) call xso_convective end if if ( jerank ) then if ( BCym . ne . BCym_periodic ) call ymo_convective if (( BCyT . ne . BCyT_periodic ) . and . ltempeq ) call yTo_convective if (( BCyq . ne . BCyq_periodic ) . and . lmoist ) call yqo_convective if (( BCys . ne . BCys_periodic ) . and . nsv > 0 ) call yso_convective end if end subroutine boundary","tags":"","url":"proc/boundary.html"},{"title":"closurebc – uDALES","text":"public  subroutine closurebc() Uses decomp_2d modsubgriddata modglobal proc~~closurebc~~UsesGraph proc~closurebc closurebc decomp_2d decomp_2d proc~closurebc->decomp_2d module~modglobal modglobal proc~closurebc->module~modglobal module~modsubgriddata modsubgriddata proc~closurebc->module~modsubgriddata Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~closurebc~~CallsGraph proc~closurebc closurebc exchange_halo_z exchange_halo_z proc~closurebc->exchange_halo_z Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~closurebc~~CalledByGraph proc~closurebc closurebc proc~closure closure proc~closure->proc~closurebc proc~subgrid subgrid proc~subgrid->proc~closure program~dalesurban DALESURBAN program~dalesurban->proc~subgrid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine closurebc use modsubgriddata , only : ekm , ekh use modglobal , only : ib , ie , jb , je , kb , ke , ih , jh , kh , numol , prandtlmoli , & ibrank , ierank , jbrank , jerank , BCtopm , BCxm , BCym , & BCtopm_freeslip , BCtopm_noslip , BCtopm_pressure , & BCxm_periodic , BCym_periodic use decomp_2d , only : exchange_halo_z integer i , j call exchange_halo_z ( ekm ) call exchange_halo_z ( ekh ) ! Top and bottom if (( BCtopm . eq . BCtopm_freeslip ) . or . ( BCtopm . eq . BCtopm_pressure )) then do j = jb - 1 , je + 1 do i = ib - 1 , ie + 1 ekm ( i , j , ke + 1 ) = ekm ( i , j , ke ) ! zero-gradient top wall ekh ( i , j , ke + 1 ) = ekh ( i , j , ke ) ! zero-gradient top wall ekm ( i , j , kb - 1 ) = 2. * numol - ekm ( i , j , kb ) ! no-slip lower wall ekh ( i , j , kb - 1 ) = ( 2. * numol * prandtlmoli ) - ekh ( i , j , kb ) ! no-slip lower wall end do end do else if ( BCtopm . eq . BCtopm_noslip ) then do j = jb - 1 , je + 1 do i = ib - 1 , ie + 1 ekm ( i , j , ke + 1 ) = 2. * numol - ekm ( i , j , ke ) ! no-slip top wall ekh ( i , j , ke + 1 ) = ( 2. * numol * prandtlmoli ) - ekh ( i , j , ke ) ! no-slip top wall ekm ( i , j , kb - 1 ) = 2. * numol - ekm ( i , j , kb ) ! no-slip lower wall ekh ( i , j , kb - 1 ) = ( 2. * numol * prandtlmoli ) - ekh ( i , j , kb ) ! no-slip lower wall end do end do end if if ( BCxm . ne . BCxm_periodic ) then ! inflow/outflow if ( ibrank ) then ekm ( ib - 1 , :, :) = ekm ( ib , :, :) ekh ( ib - 1 , :, :) = ekh ( ib , :, :) end if if ( ierank ) then ekm ( ie + 1 , :, :) = ekm ( ie , :, :) ekh ( ie + 1 , :, :) = ekh ( ie , :, :) end if else ! periodic if ( ibrank . and . ierank ) then ekm ( ib - 1 , :, :) = ekm ( ie , :, :) ekm ( ie + 1 , :, :) = ekm ( ib , :, :) ekh ( ib - 1 , :, :) = ekh ( ie , :, :) ekh ( ie + 1 , :, :) = ekh ( ib , :, :) end if end if if ( BCym . ne . BCym_periodic ) then ! inflow/outflow if ( jbrank ) then ekm (:, jb - 1 ,:) = ekm (:, jb ,:) ekh (:, jb - 1 ,:) = ekh (:, jb ,:) end if if ( jerank ) then ekm (:, je + 1 ,:) = ekm (:, je ,:) ekh (:, je + 1 ,:) = ekh (:, je ,:) end if else ! periodic if ( jbrank . and . jerank ) then ekm (:, jb - 1 , :) = ekm (:, je , :) ekm (:, je + 1 , :) = ekm (:, jb , :) ekh (:, jb - 1 , :) = ekh (:, je , :) ekh (:, je + 1 , :) = ekh (:, jb , :) end if end if end subroutine closurebc","tags":"","url":"proc/closurebc.html"},{"title":"xm_periodic – uDALES","text":"public  subroutine xm_periodic() Uses modfields modmpi modsubgriddata modglobal proc~~xm_periodic~~UsesGraph proc~xm_periodic xm_periodic module~modfields modfields proc~xm_periodic->module~modfields module~modglobal modglobal proc~xm_periodic->module~modglobal module~modmpi modmpi proc~xm_periodic->module~modmpi module~modsubgriddata modsubgriddata proc~xm_periodic->module~modsubgriddata decomp_2d decomp_2d module~modfields->decomp_2d mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~xm_periodic~~CalledByGraph proc~xm_periodic xm_periodic proc~halos halos proc~halos->proc~xm_periodic proc~readinitfiles readinitfiles proc~readinitfiles->proc~halos program~dalesurban DALESURBAN program~dalesurban->proc~halos program~dalesurban->proc~readinitfiles Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine xm_periodic use modglobal , only : ib , ie , ih use modfields , only : u0 , um , v0 , vm , w0 , wm , e120 , e12m use modsubgriddata , only : loneeqn , lsmagorinsky use modmpi , only : excis integer n , m do m = 1 , ih u0 ( ib - m , :, :) = u0 ( ie + 1 - m , :, :) u0 ( ie + m , :, :) = u0 ( ib - 1 + m , :, :) v0 ( ib - m , :, :) = v0 ( ie + 1 - m , :, :) v0 ( ie + m , :, :) = v0 ( ib - 1 + m , :, :) w0 ( ib - m , :, :) = w0 ( ie + 1 - m , :, :) w0 ( ie + m , :, :) = w0 ( ib - 1 + m , :, :) um ( ib - m , :, :) = um ( ie + 1 - m , :, :) um ( ie + m , :, :) = um ( ib - 1 + m , :, :) vm ( ib - m , :, :) = vm ( ie + 1 - m , :, :) vm ( ie + m , :, :) = vm ( ib - 1 + m , :, :) wm ( ib - m , :, :) = wm ( ie + 1 - m , :, :) wm ( ie + m , :, :) = wm ( ib - 1 + m , :, :) end do if ( loneeqn ) then e120 ( ib - m , :, :) = e120 ( ie + 1 - m , :, :) e120 ( ie + m , :, :) = e120 ( ib - 1 + m , :, :) e12m ( ib - m , :, :) = e12m ( ie + 1 - m , :, :) e12m ( ie + m , :, :) = e12m ( ib - 1 + m , :, :) end if return end subroutine xm_periodic","tags":"","url":"proc/xm_periodic.html"},{"title":"xT_periodic – uDALES","text":"public  subroutine xT_periodic() Uses modfields modglobal proc~~xt_periodic~~UsesGraph proc~xt_periodic xT_periodic module~modfields modfields proc~xt_periodic->module~modfields module~modglobal modglobal proc~xt_periodic->module~modglobal decomp_2d decomp_2d module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~xt_periodic~~CalledByGraph proc~xt_periodic xT_periodic proc~halos halos proc~halos->proc~xt_periodic proc~readinitfiles readinitfiles proc~readinitfiles->proc~halos program~dalesurban DALESURBAN program~dalesurban->proc~halos program~dalesurban->proc~readinitfiles Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine xT_periodic use modglobal , only : ib , ie , ih , ihc use modfields , only : thl0 , thlm , thl0c integer m do m = 1 , ih thl0 ( ib - m , :, :) = thl0 ( ie + 1 - m , :, :) thl0 ( ie + m , :, :) = thl0 ( ib - 1 + m , :, :) thlm ( ib - m , :, :) = thlm ( ie + 1 - m , :, :) thlm ( ie + m , :, :) = thlm ( ib - 1 + m , :, :) end do do m = 1 , ihc thl0c ( ib - m , :, :) = thl0c ( ie + 1 - m , :, :) thl0c ( ie + m , :, :) = thl0c ( ib - 1 + m , :, :) end do return end subroutine xT_periodic","tags":"","url":"proc/xt_periodic.html"},{"title":"xq_periodic – uDALES","text":"public  subroutine xq_periodic() Uses modfields modglobal proc~~xq_periodic~~UsesGraph proc~xq_periodic xq_periodic module~modfields modfields proc~xq_periodic->module~modfields module~modglobal modglobal proc~xq_periodic->module~modglobal decomp_2d decomp_2d module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~xq_periodic~~CalledByGraph proc~xq_periodic xq_periodic proc~halos halos proc~halos->proc~xq_periodic proc~readinitfiles readinitfiles proc~readinitfiles->proc~halos program~dalesurban DALESURBAN program~dalesurban->proc~halos program~dalesurban->proc~readinitfiles Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine xq_periodic use modglobal , only : ib , ie , ih use modfields , only : qt0 , qtm integer m do m = 1 , ih qt0 ( ib - m , :, :) = qt0 ( ie + 1 - m , :, :) qt0 ( ie + m , :, :) = qt0 ( ib - 1 + m , :, :) qtm ( ib - m , :, :) = qtm ( ie + 1 - m , :, :) qtm ( ie + m , :, :) = qtm ( ib - 1 + m , :, :) end do return end subroutine xq_periodic","tags":"","url":"proc/xq_periodic.html"},{"title":"xs_periodic – uDALES","text":"public  subroutine xs_periodic() Uses modfields modglobal proc~~xs_periodic~~UsesGraph proc~xs_periodic xs_periodic module~modfields modfields proc~xs_periodic->module~modfields module~modglobal modglobal proc~xs_periodic->module~modglobal decomp_2d decomp_2d module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~xs_periodic~~CalledByGraph proc~xs_periodic xs_periodic proc~halos halos proc~halos->proc~xs_periodic proc~readinitfiles readinitfiles proc~readinitfiles->proc~halos program~dalesurban DALESURBAN program~dalesurban->proc~halos program~dalesurban->proc~readinitfiles Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine xs_periodic use modglobal , only : ib , ie , ihc use modfields , only : sv0 , svm integer m , n do m = 1 , ihc sv0 ( ib - m , :, :, :) = sv0 ( ie + 1 - m , :, :, :) sv0 ( ie + m , :, :, :) = sv0 ( ib - 1 + m , :, :, :) svm ( ib - m , :, :, :) = svm ( ie + 1 - m , :, :, :) svm ( ie + m , :, :, :) = svm ( ib - 1 + m , :, :, :) end do return end subroutine xs_periodic","tags":"","url":"proc/xs_periodic.html"},{"title":"ym_periodic – uDALES","text":"public  subroutine ym_periodic() Uses modfields modmpi modsubgriddata modglobal proc~~ym_periodic~~UsesGraph proc~ym_periodic ym_periodic module~modfields modfields proc~ym_periodic->module~modfields module~modglobal modglobal proc~ym_periodic->module~modglobal module~modmpi modmpi proc~ym_periodic->module~modmpi module~modsubgriddata modsubgriddata proc~ym_periodic->module~modsubgriddata decomp_2d decomp_2d module~modfields->decomp_2d mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~ym_periodic~~CalledByGraph proc~ym_periodic ym_periodic proc~halos halos proc~halos->proc~ym_periodic proc~readinitfiles readinitfiles proc~readinitfiles->proc~halos program~dalesurban DALESURBAN program~dalesurban->proc~halos program~dalesurban->proc~readinitfiles Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine ym_periodic use modglobal , only : ib , ie , jb , je , ih , jh , kb , ke , kh , jmax use modfields , only : u0 , um , v0 , vm , w0 , wm , e120 , e12m , shear use modsubgriddata , only : loneeqn , lsmagorinsky use modmpi , only : excjs integer n , m do m = 1 , ih u0 (:, jb - m , :) = u0 (:, je + 1 - m , :) u0 (:, je + m , :) = u0 (:, jb - 1 + m , :) v0 (:, jb - m , :) = v0 (:, je + 1 - m , :) v0 (:, je + m , :) = v0 (:, jb - 1 + m , :) w0 (:, jb - m , :) = w0 (:, je + 1 - m , :) w0 (:, je + m , :) = w0 (:, jb - 1 + m , :) um (:, jb - m , :) = um (:, je + 1 - m , :) um (:, je + m , :) = um (:, jb - 1 + m , :) vm (:, jb - m , :) = vm (:, je + 1 - m , :) vm (:, je + m , :) = vm (:, jb - 1 + m , :) wm (:, jb - m , :) = wm (:, je + 1 - m , :) wm (:, je + m , :) = wm (:, jb - 1 + m , :) end do if ( loneeqn ) then e120 (:, jb - m , :) = e120 (:, je + 1 - m , :) e120 (:, je + m , :) = e120 (:, jb - 1 + m , :) e12m (:, jb - m , :) = e12m (:, je + 1 - m , :) e12m (:, je + m , :) = e12m (:, jb - 1 + m , :) end if return end subroutine ym_periodic","tags":"","url":"proc/ym_periodic.html"},{"title":"yT_periodic – uDALES","text":"public  subroutine yT_periodic() Uses modfields modmpi modglobal proc~~yt_periodic~~UsesGraph proc~yt_periodic yT_periodic module~modfields modfields proc~yt_periodic->module~modfields module~modglobal modglobal proc~yt_periodic->module~modglobal module~modmpi modmpi proc~yt_periodic->module~modmpi decomp_2d decomp_2d module~modfields->decomp_2d mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~yt_periodic~~CalledByGraph proc~yt_periodic yT_periodic proc~halos halos proc~halos->proc~yt_periodic proc~readinitfiles readinitfiles proc~readinitfiles->proc~halos program~dalesurban DALESURBAN program~dalesurban->proc~halos program~dalesurban->proc~readinitfiles Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine yT_periodic use modglobal , only : jb , je , jh , jhc use modfields , only : thl0 , thlm , thl0c use modmpi , only : excjs , myid , nprocs integer m do m = 1 , jh thl0 (:, jb - m , :) = thl0 (:, je + 1 - m , :) thl0 (:, je + m , :) = thl0 (:, jb - 1 + m , :) thlm (:, jb - m , :) = thlm (:, je + 1 - m , :) thlm (:, je + m , :) = thlm (:, jb - 1 + m , :) end do do m = 1 , jhc thl0c (:, jb - m , :) = thl0c (:, je + 1 - m , :) thl0c (:, je + m , :) = thl0c (:, jb - 1 + m , :) end do return end subroutine yT_periodic","tags":"","url":"proc/yt_periodic.html"},{"title":"yq_periodic – uDALES","text":"public  subroutine yq_periodic() Uses modfields modglobal proc~~yq_periodic~~UsesGraph proc~yq_periodic yq_periodic module~modfields modfields proc~yq_periodic->module~modfields module~modglobal modglobal proc~yq_periodic->module~modglobal decomp_2d decomp_2d module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~yq_periodic~~CalledByGraph proc~yq_periodic yq_periodic proc~halos halos proc~halos->proc~yq_periodic proc~readinitfiles readinitfiles proc~readinitfiles->proc~halos program~dalesurban DALESURBAN program~dalesurban->proc~halos program~dalesurban->proc~readinitfiles Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine yq_periodic use modglobal , only : jb , je , jh use modfields , only : qt0 , qtm integer m do m = 1 , jh qt0 (:, jb - m , :) = qt0 (:, je + 1 - m , :) qt0 (:, je + m , :) = qt0 (:, jb - 1 + m , :) qtm (:, jb - m , :) = qtm (:, je + 1 - m , :) qtm (:, je + m , :) = qtm (:, jb - 1 + m , :) end do return end subroutine yq_periodic","tags":"","url":"proc/yq_periodic.html"},{"title":"ys_periodic – uDALES","text":"public  subroutine ys_periodic() Uses modfields modglobal proc~~ys_periodic~~UsesGraph proc~ys_periodic ys_periodic module~modfields modfields proc~ys_periodic->module~modfields module~modglobal modglobal proc~ys_periodic->module~modglobal decomp_2d decomp_2d module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~ys_periodic~~CalledByGraph proc~ys_periodic ys_periodic proc~halos halos proc~halos->proc~ys_periodic proc~readinitfiles readinitfiles proc~readinitfiles->proc~halos program~dalesurban DALESURBAN program~dalesurban->proc~halos program~dalesurban->proc~readinitfiles Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine ys_periodic use modglobal , only : jb , je , jhc , nsv use modfields , only : sv0 , svm integer n , m do n = 1 , nsv do m = 1 , jhc sv0 (:, jb - m , :, :) = sv0 (:, je + 1 - m , :, :) sv0 (:, je + m , :, :) = sv0 (:, jb - 1 + m , :, :) svm (:, jb - m , :, :) = svm (:, je + 1 - m , :, :) svm (:, je + m , :, :) = svm (:, jb - 1 + m , :, :) end do end do return end subroutine ys_periodic","tags":"","url":"proc/ys_periodic.html"},{"title":"xmi_profile – uDALES","text":"private  subroutine xmi_profile() Uses modfields modsubgriddata modglobal proc~~xmi_profile~~UsesGraph proc~xmi_profile xmi_profile module~modfields modfields proc~xmi_profile->module~modfields module~modglobal modglobal proc~xmi_profile->module~modglobal module~modsubgriddata modsubgriddata proc~xmi_profile->module~modsubgriddata decomp_2d decomp_2d module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~xmi_profile~~CalledByGraph proc~xmi_profile xmi_profile proc~boundary boundary proc~boundary->proc~xmi_profile program~dalesurban DALESURBAN program~dalesurban->proc~boundary Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine xmi_profile use modglobal , only : ib , ie , jb , je , kb , ke use modfields , only : u0 , um , v0 , vm , w0 , wm , e120 , e12m , uprof , vprof , e12prof use modsubgriddata , only : loneeqn integer j , k do j = jb - 1 , je + 1 do k = kb , ke + 1 u0 ( ib , j , k ) = uprof ( k ) um ( ib , j , k ) = uprof ( k ) u0 ( ib - 1 , j , k ) = 2 * u0 ( ib , j , k ) - u0 ( ib + 1 , j , k ) ! (u(ib+1)+u(ib-1))/2 = u(ib) um ( ib - 1 , j , k ) = 2 * um ( ib , j , k ) - um ( ib + 1 , j , k ) ! (u(ib+1)+u(ib-1))/2 = u(ib) v0 ( ib - 1 , j , k ) = 2 * vprof ( k ) - v0 ( ib , j , k ) ! (v(ib)+v(ib-1))/2 = vprof vm ( ib - 1 , j , k ) = 2 * vprof ( k ) - vm ( ib , j , k ) ! (v(ib)+v(ib-1))/2 = vprof w0 ( ib - 1 , j , k ) = - w0 ( ib , j , k ) wm ( ib - 1 , j , k ) = - wm ( ib , j , k ) end do end do if ( loneeqn ) then do j = jb - 1 , je + 1 do k = kb , ke + 1 e120 ( ib - 1 , j , k ) = 2 * e12prof ( k ) - e120 ( ib , j , k ) ! (e12(ib)+e12(ib-1))/2=e12prof e12m ( ib - 1 , j , k ) = 2 * e12prof ( k ) - e12m ( ib , j , k ) ! (e12(ib)+e12(ib-1))/2=e12prof end do end do end if end subroutine xmi_profile","tags":"","url":"proc/xmi_profile.html"},{"title":"xmi_driver – uDALES","text":"private  subroutine xmi_driver() Uses modfields modinletdata modsubgriddata modglobal proc~~xmi_driver~~UsesGraph proc~xmi_driver xmi_driver module~modfields modfields proc~xmi_driver->module~modfields module~modglobal modglobal proc~xmi_driver->module~modglobal module~modinletdata modinletdata proc~xmi_driver->module~modinletdata module~modsubgriddata modsubgriddata proc~xmi_driver->module~modsubgriddata decomp_2d decomp_2d module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~xmi_driver~~CalledByGraph proc~xmi_driver xmi_driver proc~boundary boundary proc~boundary->proc~xmi_driver program~dalesurban DALESURBAN program~dalesurban->proc~boundary Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine xmi_driver use modglobal , only : ib , ie , jb , je , kb , ke use modinletdata , only : u0driver , umdriver , v0driver , vmdriver , w0driver , wmdriver use modfields , only : u0 , um , v0 , vm , w0 , wm , e120 , e12m , e12prof use modsubgriddata , only : loneeqn integer j , k do j = jb - 1 , je + 1 do k = kb , ke !tg3315 removed +1 following above... u0 ( ib , j , k ) = u0driver ( j , k ) !max(0.,u0driver(j,k)) um ( ib , j , k ) = umdriver ( j , k ) !max(0.,umdriver(j,k)) u0 ( ib - 1 , j , k ) = u0driver ( j , k ) !max(0.,u0driver(j,k)) um ( ib - 1 , j , k ) = umdriver ( j , k ) !max(0.,umdriver(j,k)) ! u0(ib-1,j,k)= 2*u0(ib, j, k) - u0(ib + 1, j, k) ! (u(ib+1)+u(ib-1))/2 = u(ib) ! um(ib-1,j,k)= 2*um(ib, j, k) - um(ib + 1, j, k) ! (u(ib+1)+u(ib-1))/2 = u(ib) !v0(ib,j,k)   = v0driver(j,k) !max(0.,v0driver(j,k)) !vm(ib,j,k)   = vmdriver(j,k) !max(0.,vmdriver(j,k)) v0 ( ib - 1 , j , k ) = v0driver ( j , k ) !max(0.,v0driver(j,k)) vm ( ib - 1 , j , k ) = vmdriver ( j , k ) !max(0.,vmdriver(j,k)) end do do k = kb , ke + 1 !w0(ib,j,k)   = w0driver(j,k) !max(0.,w0driver(j,k)) !wm(ib,j,k)   = wmdriver(j,k) !max(0.,wmdriver(j,k)) w0 ( ib - 1 , j , k ) = w0driver ( j , k ) !max(0.,w0driver(j,k)) wm ( ib - 1 , j , k ) = wmdriver ( j , k ) !max(0.,wmdriver(j,k)) end do end do if ( loneeqn ) then do j = jb - 1 , je + 1 do k = kb , ke + 1 ! to be changed in the future: e12 should be taken from recycle plane! !e120(ib-1,j,k) = e120driver(j,k)      ! extrapolate e12 from interior !e12m(ib-1,j,k) = e12mdriver(j,k)      ! extrapolate e12 from interior e120 ( ib - 1 , j , k ) = e120 ( ib , j , k ) ! (e12(ib)+e12(ib-1))/2=e12prof e12m ( ib - 1 , j , k ) = e12m ( ib , j , k ) ! (e12(ib)+e12(ib-1))/2=e12prof end do end do end if end subroutine xmi_driver","tags":"","url":"proc/xmi_driver.html"},{"title":"xTi_profile – uDALES","text":"private  subroutine xTi_profile() Uses modfields modglobal proc~~xti_profile~~UsesGraph proc~xti_profile xTi_profile module~modfields modfields proc~xti_profile->module~modfields module~modglobal modglobal proc~xti_profile->module~modglobal decomp_2d decomp_2d module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~xti_profile~~CalledByGraph proc~xti_profile xTi_profile proc~boundary boundary proc~boundary->proc~xti_profile program~dalesurban DALESURBAN program~dalesurban->proc~boundary Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine xTi_profile use modglobal , only : ib , ie , jb , je , kb , ke use modfields , only : thl0 , thlm , thlprof integer j , k ! set ghost cell ! do j = jb - 1, je + 1 !   do k = kb, ke + 1 !     thl0(ib - 1, j, k) = 2*thlprof(k) - thl0(ib, j, k) !     thlm(ib - 1, j, k) = 2*thlprof(k) - thlm(ib, j, k) !   end do ! end do do j = jb - 1 , je + 1 do k = kb , ke + 1 thl0 ( ib - 1 , j , k ) = thlprof ( k ) thlm ( ib - 1 , j , k ) = thlprof ( k ) end do end do ! set first internal cell as well do j = jb - 1 , je + 1 do k = kb , ke thl0 ( ib , j , k ) = thlprof ( k ) thlm ( ib , j , k ) = thlprof ( k ) end do end do end subroutine xTi_profile","tags":"","url":"proc/xti_profile.html"},{"title":"xTi_driver – uDALES","text":"private  subroutine xTi_driver() Uses modfields modinletdata modglobal proc~~xti_driver~~UsesGraph proc~xti_driver xTi_driver module~modfields modfields proc~xti_driver->module~modfields module~modglobal modglobal proc~xti_driver->module~modglobal module~modinletdata modinletdata proc~xti_driver->module~modinletdata decomp_2d decomp_2d module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~xti_driver~~CalledByGraph proc~xti_driver xTi_driver proc~boundary boundary proc~boundary->proc~xti_driver program~dalesurban DALESURBAN program~dalesurban->proc~boundary Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine xTi_driver use modglobal , only : ib , ie , jb , je , kb , ke use modinletdata , only : thl0driver , thlmdriver use modfields , only : thl0 , thlm integer j , k do j = jb - 1 , je + 1 do k = kb , ke + 1 thl0 ( ib - 1 , j , k ) = thl0driver ( j , k ) thlm ( ib - 1 , j , k ) = thlmdriver ( j , k ) end do end do end subroutine xTi_driver","tags":"","url":"proc/xti_driver.html"},{"title":"xqi_profile – uDALES","text":"private  subroutine xqi_profile() Uses modfields modglobal proc~~xqi_profile~~UsesGraph proc~xqi_profile xqi_profile module~modfields modfields proc~xqi_profile->module~modfields module~modglobal modglobal proc~xqi_profile->module~modglobal decomp_2d decomp_2d module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~xqi_profile~~CalledByGraph proc~xqi_profile xqi_profile proc~boundary boundary proc~boundary->proc~xqi_profile program~dalesurban DALESURBAN program~dalesurban->proc~boundary Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine xqi_profile use modglobal , only : ib , ie , jb , je , kb , ke use modfields , only : qt0 , qtm , qtprof integer j , k do j = jb - 1 , je + 1 do k = kb , ke + 1 qt0 ( ib - 1 , j , k ) = 2 * qtprof ( k ) - qt0 ( ib , j , k ) qtm ( ib - 1 , j , k ) = 2 * qtprof ( k ) - qtm ( ib , j , k ) end do end do end subroutine xqi_profile","tags":"","url":"proc/xqi_profile.html"},{"title":"xqi_driver – uDALES","text":"private  subroutine xqi_driver() Uses modfields modinletdata modglobal proc~~xqi_driver~~UsesGraph proc~xqi_driver xqi_driver module~modfields modfields proc~xqi_driver->module~modfields module~modglobal modglobal proc~xqi_driver->module~modglobal module~modinletdata modinletdata proc~xqi_driver->module~modinletdata decomp_2d decomp_2d module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~xqi_driver~~CalledByGraph proc~xqi_driver xqi_driver proc~boundary boundary proc~boundary->proc~xqi_driver program~dalesurban DALESURBAN program~dalesurban->proc~boundary Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine xqi_driver use modglobal , only : ib , ie , jb , je , kb , ke use modinletdata , only : qt0driver , qtmdriver use modfields , only : qt0 , qtm integer j , k do j = jb - 1 , je + 1 do k = kb , ke + 1 qt0 ( ib - 1 , j , k ) = qt0driver ( j , k ) qtm ( ib - 1 , j , k ) = qtmdriver ( j , k ) end do end do end subroutine xqi_driver","tags":"","url":"proc/xqi_driver.html"},{"title":"xsi_profile – uDALES","text":"private  subroutine xsi_profile() Uses modfields modglobal proc~~xsi_profile~~UsesGraph proc~xsi_profile xsi_profile module~modfields modfields proc~xsi_profile->module~modfields module~modglobal modglobal proc~xsi_profile->module~modglobal decomp_2d decomp_2d module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~xsi_profile~~CalledByGraph proc~xsi_profile xsi_profile proc~boundary boundary proc~boundary->proc~xsi_profile program~dalesurban DALESURBAN program~dalesurban->proc~boundary Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine xsi_profile use modglobal , only : ib , ie , jb , je , kb , ke , nsv , ihc use modfields , only : sv0 , svm , svprof integer j , k , n , m do j = jb , je do k = kb , ke + 1 do n = 1 , nsv do m = 1 , ihc sv0 ( ib - m , j , k , n ) = 2 * svprof ( k , n ) - sv0 ( ib - m + 1 , j , k , n ) svm ( ib - m , j , k , n ) = 2 * svprof ( k , n ) - svm ( ib - m + 1 , j , k , n ) end do end do end do end do end subroutine xsi_profile","tags":"","url":"proc/xsi_profile.html"},{"title":"xsi_custom – uDALES","text":"private  subroutine xsi_custom() Uses modfields decomp_2d modglobal proc~~xsi_custom~~UsesGraph proc~xsi_custom xsi_custom decomp_2d decomp_2d proc~xsi_custom->decomp_2d module~modfields modfields proc~xsi_custom->module~modfields module~modglobal modglobal proc~xsi_custom->module~modglobal module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~xsi_custom~~CallsGraph proc~xsi_custom xsi_custom zstart zstart proc~xsi_custom->zstart Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~xsi_custom~~CalledByGraph proc~xsi_custom xsi_custom proc~boundary boundary proc~boundary->proc~xsi_custom program~dalesurban DALESURBAN program~dalesurban->proc~boundary Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine xsi_custom use modglobal , only : ib , ie , jb , je , jtot , kb , ke , nsv , ihc use modfields , only : sv0 , svm , svprof use decomp_2d , only : zstart integer j , k , n , m do j = jb , je if ( j + zstart ( 2 ) - 1 == jtot / 2 ) then do k = kb , ke + 1 do n = 1 , nsv do m = 1 , ihc sv0 ( ib - m , j - 1 : j + 1 , k , n ) = 2 * svprof ( k , n ) - sv0 ( ib - m + 1 , j - 1 : j + 1 , k , n ) svm ( ib - m , j - 1 : j + 1 , k , n ) = 2 * svprof ( k , n ) - svm ( ib - m + 1 , j - 1 : j + 1 , k , n ) end do end do end do end if end do end subroutine xsi_custom","tags":"","url":"proc/xsi_custom.html"},{"title":"xsi_driver – uDALES","text":"private  subroutine xsi_driver() Uses modfields modinletdata modglobal proc~~xsi_driver~~UsesGraph proc~xsi_driver xsi_driver module~modfields modfields proc~xsi_driver->module~modfields module~modglobal modglobal proc~xsi_driver->module~modglobal module~modinletdata modinletdata proc~xsi_driver->module~modinletdata decomp_2d decomp_2d module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~xsi_driver~~CalledByGraph proc~xsi_driver xsi_driver proc~boundary boundary proc~boundary->proc~xsi_driver program~dalesurban DALESURBAN program~dalesurban->proc~boundary Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine xsi_driver use modglobal , only : ib , ie , ihc , jb , je , jhc , kb , ke , khc , nsv use modinletdata , only : sv0driver , svmdriver use modfields , only : sv0 , svm integer j , k , n , m do j = jb - 1 , je + 1 do k = kb , ke + 1 do n = 1 , nsv do m = 1 , ihc sv0 ( ib - m , j , k , n ) = sv0driver ( j , k , n ) svm ( ib - m , j , k , n ) = svmdriver ( j , k , n ) end do end do end do end do end subroutine xsi_driver","tags":"","url":"proc/xsi_driver.html"},{"title":"xmo_convective – uDALES","text":"private  subroutine xmo_convective() Uses modfields modsubgriddata modglobal proc~~xmo_convective~~UsesGraph proc~xmo_convective xmo_convective module~modfields modfields proc~xmo_convective->module~modfields module~modglobal modglobal proc~xmo_convective->module~modglobal module~modsubgriddata modsubgriddata proc~xmo_convective->module~modsubgriddata decomp_2d decomp_2d module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~xmo_convective~~CalledByGraph proc~xmo_convective xmo_convective proc~boundary boundary proc~boundary->proc~xmo_convective program~dalesurban DALESURBAN program~dalesurban->proc~boundary Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine xmo_convective use modglobal , only : ie , dxi , rk3step , dt use modfields , only : u0 , um , v0 , vm , w0 , wm , e120 , e12m , uouttot use modsubgriddata , only : loneeqn real rk3coef rk3coef = dt / ( 4. - dble ( rk3step )) v0 ( ie + 1 , :, :) = v0 ( ie + 1 , :, :) - ( v0 ( ie + 1 , :, :) - v0 ( ie , :, :)) * dxi * rk3coef * uouttot w0 ( ie + 1 , :, :) = w0 ( ie + 1 , :, :) - ( w0 ( ie + 1 , :, :) - w0 ( ie , :, :)) * dxi * rk3coef * uouttot vm ( ie + 1 , :, :) = vm ( ie + 1 , :, :) - ( vm ( ie + 1 , :, :) - vm ( ie , :, :)) * dxi * rk3coef * uouttot wm ( ie + 1 , :, :) = wm ( ie + 1 , :, :) - ( wm ( ie + 1 , :, :) - wm ( ie , :, :)) * dxi * rk3coef * uouttot if ( loneeqn ) then e120 ( ie + 1 , :, :) = e120 ( ie , :, :) - ( e120 ( ie + 1 , :, :) - e120 ( ie , :, :)) * dxi * rk3coef * uouttot e12m ( ie + 1 , :, :) = e12m ( ie , :, :) - ( e12m ( ie + 1 , :, :) - e12m ( ie , :, :)) * dxi * rk3coef * uouttot end if end subroutine xmo_convective","tags":"","url":"proc/xmo_convective.html"},{"title":"xmo_Neumann – uDALES","text":"private  subroutine xmo_Neumann() Uses modfields modsubgriddata modglobal proc~~xmo_neumann~~UsesGraph proc~xmo_neumann xmo_Neumann module~modfields modfields proc~xmo_neumann->module~modfields module~modglobal modglobal proc~xmo_neumann->module~modglobal module~modsubgriddata modsubgriddata proc~xmo_neumann->module~modsubgriddata decomp_2d decomp_2d module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Source Code subroutine xmo_Neumann use modglobal , only : ie use modfields , only : u0 , um , v0 , vm , w0 , wm , e120 , e12m use modsubgriddata , only : loneeqn v0 ( ie + 1 , :, :) = v0 ( ie , :, :) w0 ( ie + 1 , :, :) = w0 ( ie , :, :) vm ( ie + 1 , :, :) = vm ( ie , :, :) wm ( ie + 1 , :, :) = wm ( ie , :, :) if ( loneeqn ) then e120 ( ie + 1 , :, :) = e120 ( ie , :, :) e12m ( ie + 1 , :, :) = e12m ( ie , :, :) end if end subroutine xmo_Neumann","tags":"","url":"proc/xmo_neumann.html"},{"title":"xTo_convective – uDALES","text":"private  subroutine xTo_convective() Uses modfields modglobal proc~~xto_convective~~UsesGraph proc~xto_convective xTo_convective module~modfields modfields proc~xto_convective->module~modfields module~modglobal modglobal proc~xto_convective->module~modglobal decomp_2d decomp_2d module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~xto_convective~~CalledByGraph proc~xto_convective xTo_convective proc~boundary boundary proc~boundary->proc~xto_convective program~dalesurban DALESURBAN program~dalesurban->proc~boundary Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine xTo_convective use modglobal , only : ie , dxi , rk3step , dt use modfields , only : thl0 , thlm , uouttot real rk3coef rk3coef = dt / ( 4. - dble ( rk3step )) thl0 ( ie + 1 , :, :) = thl0 ( ie + 1 , :, :) - ( thl0 ( ie + 1 , :, :) - thl0 ( ie , :, :)) * dxi * rk3coef * uouttot thlm ( ie + 1 , :, :) = thlm ( ie + 1 , :, :) - ( thlm ( ie + 1 , :, :) - thlm ( ie , :, :)) * dxi * rk3coef * uouttot end subroutine xTo_convective","tags":"","url":"proc/xto_convective.html"},{"title":"xTo_Neumann – uDALES","text":"private  subroutine xTo_Neumann() Uses modfields modglobal proc~~xto_neumann~~UsesGraph proc~xto_neumann xTo_Neumann module~modfields modfields proc~xto_neumann->module~modfields module~modglobal modglobal proc~xto_neumann->module~modglobal decomp_2d decomp_2d module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Source Code subroutine xTo_Neumann use modglobal , only : ie use modfields , only : thl0 , thlm thl0 ( ie + 1 , :, :) = thl0 ( ie , :, :) thlm ( ie + 1 , :, :) = thlm ( ie , :, :) end subroutine xTo_Neumann","tags":"","url":"proc/xto_neumann.html"},{"title":"xqo_convective – uDALES","text":"private  subroutine xqo_convective() Uses modfields modglobal proc~~xqo_convective~~UsesGraph proc~xqo_convective xqo_convective module~modfields modfields proc~xqo_convective->module~modfields module~modglobal modglobal proc~xqo_convective->module~modglobal decomp_2d decomp_2d module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~xqo_convective~~CalledByGraph proc~xqo_convective xqo_convective proc~boundary boundary proc~boundary->proc~xqo_convective program~dalesurban DALESURBAN program~dalesurban->proc~boundary Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine xqo_convective use modglobal , only : ie , dxi , rk3step , dt use modfields , only : qt0 , qtm , uouttot real rk3coef rk3coef = dt / ( 4. - dble ( rk3step )) qt0 ( ie + 1 , :, :) = qt0 ( ie , :, :) - ( qt0 ( ie + 1 , :, :) - qt0 ( ie , :, :)) * dxi * rk3coef * uouttot qtm ( ie + 1 , :, :) = qtm ( ie , :, :) - ( qtm ( ie + 1 , :, :) - qtm ( ie , :, :)) * dxi * rk3coef * uouttot end subroutine xqo_convective","tags":"","url":"proc/xqo_convective.html"},{"title":"xso_convective – uDALES","text":"private  subroutine xso_convective() Uses modfields modglobal proc~~xso_convective~~UsesGraph proc~xso_convective xso_convective module~modfields modfields proc~xso_convective->module~modfields module~modglobal modglobal proc~xso_convective->module~modglobal decomp_2d decomp_2d module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~xso_convective~~CalledByGraph proc~xso_convective xso_convective proc~boundary boundary proc~boundary->proc~xso_convective program~dalesurban DALESURBAN program~dalesurban->proc~boundary Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine xso_convective use modglobal , only : ie , rk3step , dt , dxi , nsv use modfields , only : sv0 , svm , uouttot real rk3coef integer n rk3coef = dt / ( 4. - dble ( rk3step )) do n = 1 , nsv sv0 ( ie + 1 , :, :, n ) = sv0 ( ie + 1 , :, :, n ) - ( sv0 ( ie + 1 , :, :, n ) - sv0 ( ie , :, :, n )) * dxi * rk3coef * uouttot svm ( ie + 1 , :, :, n ) = svm ( ie + 1 , :, :, n ) - ( svm ( ie + 1 , :, :, n ) - svm ( ie , :, :, n )) * dxi * rk3coef * uouttot end do end subroutine xso_convective","tags":"","url":"proc/xso_convective.html"},{"title":"xso_Neumann – uDALES","text":"private  subroutine xso_Neumann() Uses modfields modglobal proc~~xso_neumann~~UsesGraph proc~xso_neumann xso_Neumann module~modfields modfields proc~xso_neumann->module~modfields module~modglobal modglobal proc~xso_neumann->module~modglobal decomp_2d decomp_2d module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Source Code subroutine xso_Neumann use modglobal , only : ie , ihc , rk3step , dt , dxi , nsv use modfields , only : sv0 , svm real rk3coef integer n , m rk3coef = dt / ( 4. - dble ( rk3step )) do n = 1 , nsv do m = 1 , ihc sv0 ( ie + m , :, :, n ) = sv0 ( ie , :, :, n ) svm ( ie + m , :, :, n ) = svm ( ie , :, :, n ) end do end do end subroutine xso_Neumann","tags":"","url":"proc/xso_neumann.html"},{"title":"ymi_profile – uDALES","text":"private  subroutine ymi_profile() Uses modfields modsubgriddata modglobal proc~~ymi_profile~~UsesGraph proc~ymi_profile ymi_profile module~modfields modfields proc~ymi_profile->module~modfields module~modglobal modglobal proc~ymi_profile->module~modglobal module~modsubgriddata modsubgriddata proc~ymi_profile->module~modsubgriddata decomp_2d decomp_2d module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~ymi_profile~~CalledByGraph proc~ymi_profile ymi_profile proc~boundary boundary proc~boundary->proc~ymi_profile program~dalesurban DALESURBAN program~dalesurban->proc~boundary Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine ymi_profile use modglobal , only : ib , ie , jb , je , kb , ke use modfields , only : u0 , um , v0 , vm , w0 , wm , e120 , e12m , uprof , vprof , e12prof use modsubgriddata , only : loneeqn integer i , k do i = ib - 1 , ie + 1 do k = kb , ke + 1 v0 ( i , jb , k ) = vprof ( k ) vm ( i , jb , k ) = vprof ( k ) v0 ( i , jb - 1 , k ) = 2 * v0 ( i , jb , k ) - v0 ( i , jb + 1 , k ) vm ( i , jb - 1 , k ) = 2 * vm ( i , jb , k ) - vm ( i , jb + 1 , k ) u0 ( i , jb - 1 , k ) = 2 * uprof ( k ) - u0 ( i , jb , k ) um ( i , jb - 1 , k ) = 2 * uprof ( k ) - um ( i , jb , k ) w0 ( i , jb - 1 , k ) = - w0 ( i , jb , k ) wm ( i , jb - 1 , k ) = - wm ( i , jb , k ) end do end do if ( loneeqn ) then do i = ib - 1 , ie + 1 do k = kb , ke + 1 e120 ( i , jb - 1 , k ) = 2 * e12prof ( k ) - e120 ( i , jb - 1 , k ) e12m ( i , jb - 1 , k ) = 2 * e12prof ( k ) - e12m ( i , jb - 1 , k ) end do end do end if end subroutine ymi_profile","tags":"","url":"proc/ymi_profile.html"},{"title":"yTi_profile – uDALES","text":"private  subroutine yTi_profile() Uses modfields modglobal proc~~yti_profile~~UsesGraph proc~yti_profile yTi_profile module~modfields modfields proc~yti_profile->module~modfields module~modglobal modglobal proc~yti_profile->module~modglobal decomp_2d decomp_2d module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~yti_profile~~CalledByGraph proc~yti_profile yTi_profile proc~boundary boundary proc~boundary->proc~yti_profile program~dalesurban DALESURBAN program~dalesurban->proc~boundary Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine yTi_profile use modglobal , only : ib , ie , jb , je , kb , ke use modfields , only : thl0 , thlm , thlprof integer i , k do i = ib - 1 , ie + 1 do k = kb , ke + 1 thl0 ( i , jb - 1 , k ) = 2 * thlprof ( k ) - thl0 ( i , jb , k ) thlm ( i , jb - 1 , k ) = 2 * thlprof ( k ) - thlm ( i , jb , k ) end do end do end subroutine yTi_profile","tags":"","url":"proc/yti_profile.html"},{"title":"yqi_profile – uDALES","text":"private  subroutine yqi_profile() Uses modfields modglobal proc~~yqi_profile~~UsesGraph proc~yqi_profile yqi_profile module~modfields modfields proc~yqi_profile->module~modfields module~modglobal modglobal proc~yqi_profile->module~modglobal decomp_2d decomp_2d module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~yqi_profile~~CalledByGraph proc~yqi_profile yqi_profile proc~boundary boundary proc~boundary->proc~yqi_profile program~dalesurban DALESURBAN program~dalesurban->proc~boundary Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine yqi_profile use modglobal , only : ib , ie , jb , je , kb , ke use modfields , only : qt0 , qtm , qtprof integer i , k do i = jb - 1 , ie + 1 do k = kb , ke + 1 qt0 ( i , jb - 1 , k ) = 2 * qtprof ( k ) - qt0 ( i , jb , k ) qtm ( i , jb - 1 , k ) = 2 * qtprof ( k ) - qtm ( i , jb , k ) end do end do end subroutine yqi_profile","tags":"","url":"proc/yqi_profile.html"},{"title":"ysi_profile – uDALES","text":"private  subroutine ysi_profile() Uses modfields modglobal proc~~ysi_profile~~UsesGraph proc~ysi_profile ysi_profile module~modfields modfields proc~ysi_profile->module~modfields module~modglobal modglobal proc~ysi_profile->module~modglobal decomp_2d decomp_2d module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~ysi_profile~~CalledByGraph proc~ysi_profile ysi_profile proc~boundary boundary proc~boundary->proc~ysi_profile program~dalesurban DALESURBAN program~dalesurban->proc~boundary Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine ysi_profile use modglobal , only : ib , ie , jb , je , kb , ke , nsv , ihc use modfields , only : sv0 , svm , svprof integer i , k , n , m do i = ib - 1 , ie + 1 do k = kb , ke + 1 do n = 1 , nsv do m = 1 , ihc sv0 ( i , jb - m , k , n ) = 2 * svprof ( k , n ) - sv0 ( i , jb - m + 1 , k , n ) svm ( i , jb - m , k , n ) = 2 * svprof ( k , n ) - svm ( i , jb - m + 1 , k , n ) end do end do end do end do end subroutine ysi_profile","tags":"","url":"proc/ysi_profile.html"},{"title":"ymo_convective – uDALES","text":"private  subroutine ymo_convective() Uses modfields modsubgriddata modglobal proc~~ymo_convective~~UsesGraph proc~ymo_convective ymo_convective module~modfields modfields proc~ymo_convective->module~modfields module~modglobal modglobal proc~ymo_convective->module~modglobal module~modsubgriddata modsubgriddata proc~ymo_convective->module~modsubgriddata decomp_2d decomp_2d module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~ymo_convective~~CalledByGraph proc~ymo_convective ymo_convective proc~boundary boundary proc~boundary->proc~ymo_convective program~dalesurban DALESURBAN program~dalesurban->proc~boundary Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine ymo_convective use modglobal , only : je , dyi , rk3step , dt use modfields , only : u0 , um , v0 , vm , w0 , wm , e120 , e12m , vouttot use modsubgriddata , only : loneeqn real rk3coef rk3coef = dt / ( 4. - dble ( rk3step )) ! change to vouttot u0 (:, je + 1 , :) = u0 (:, je + 1 , :) - ( u0 (:, je + 1 , :) - u0 (:, je , :)) * dyi * rk3coef * vouttot um (:, je + 1 , :) = um (:, je + 1 , :) - ( um (:, je + 1 , :) - um (:, je , :)) * dyi * rk3coef * vouttot w0 (:, je + 1 , :) = w0 (:, je + 1 , :) - ( w0 (:, je + 1 , :) - w0 (:, je , :)) * dyi * rk3coef * vouttot wm (:, je + 1 , :) = wm (:, je + 1 , :) - ( wm (:, je + 1 , :) - wm (:, je , :)) * dyi * rk3coef * vouttot if ( loneeqn ) then e120 (:, je + 1 , :) = e120 (:, je + 1 , :) - ( e120 (:, je + 1 , :) - e120 (:, je , :)) * dyi * rk3coef * vouttot e12m (:, je + 1 , :) = e12m (:, je + 1 , :) - ( e12m (:, je + 1 , :) - e12m (:, je , :)) * dyi * rk3coef * vouttot end if end subroutine ymo_convective","tags":"","url":"proc/ymo_convective.html"},{"title":"yTo_convective – uDALES","text":"private  subroutine yTo_convective() Uses modfields modglobal proc~~yto_convective~~UsesGraph proc~yto_convective yTo_convective module~modfields modfields proc~yto_convective->module~modfields module~modglobal modglobal proc~yto_convective->module~modglobal decomp_2d decomp_2d module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~yto_convective~~CalledByGraph proc~yto_convective yTo_convective proc~boundary boundary proc~boundary->proc~yto_convective program~dalesurban DALESURBAN program~dalesurban->proc~boundary Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine yTo_convective use modglobal , only : je , dyi , rk3step , dt use modfields , only : thl0 , thlm , v0 , vouttot real rk3coef rk3coef = dt / ( 4. - dble ( rk3step )) thl0 (:, je + 1 , :) = thl0 (:, je + 1 , :) - ( thl0 (:, je + 1 , :) - thl0 (:, je , :)) * dyi * rk3coef * vouttot thlm (:, je + 1 , :) = thlm (:, je + 1 , :) - ( thlm (:, je + 1 , :) - thlm (:, je , :)) * dyi * rk3coef * vouttot end subroutine yTo_convective","tags":"","url":"proc/yto_convective.html"},{"title":"yqo_convective – uDALES","text":"private  subroutine yqo_convective() Uses modfields modglobal proc~~yqo_convective~~UsesGraph proc~yqo_convective yqo_convective module~modfields modfields proc~yqo_convective->module~modfields module~modglobal modglobal proc~yqo_convective->module~modglobal decomp_2d decomp_2d module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~yqo_convective~~CalledByGraph proc~yqo_convective yqo_convective proc~boundary boundary proc~boundary->proc~yqo_convective program~dalesurban DALESURBAN program~dalesurban->proc~boundary Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine yqo_convective use modglobal , only : je , dyi , rk3step , dt use modfields , only : qt0 , qtm , v0 , vouttot real rk3coef rk3coef = dt / ( 4. - dble ( rk3step )) qt0 (:, je + 1 , :) = qt0 (:, je + 1 , :) - ( qt0 (:, je + 1 , :) - qt0 (:, je , :)) * dyi * rk3coef * vouttot qtm (:, je + 1 , :) = qtm (:, je + 1 , :) - ( qtm (:, je + 1 , :) - qtm (:, je , :)) * dyi * rk3coef * vouttot end subroutine yqo_convective","tags":"","url":"proc/yqo_convective.html"},{"title":"yso_convective – uDALES","text":"private  subroutine yso_convective() Uses modfields modglobal proc~~yso_convective~~UsesGraph proc~yso_convective yso_convective module~modfields modfields proc~yso_convective->module~modfields module~modglobal modglobal proc~yso_convective->module~modglobal decomp_2d decomp_2d module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~yso_convective~~CalledByGraph proc~yso_convective yso_convective proc~boundary boundary proc~boundary->proc~yso_convective program~dalesurban DALESURBAN program~dalesurban->proc~boundary Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine yso_convective use modglobal , only : je , rk3step , dt , dyi , nsv use modfields , only : sv0 , svm , v0 , vouttot real rk3coef integer n rk3coef = dt / ( 4. - dble ( rk3step )) do n = 1 , nsv sv0 (:, je + 1 , :, n ) = sv0 (:, je + 1 , :, n ) - ( sv0 (:, je + 1 , :, n ) - sv0 (:, je , :, n )) * dyi * rk3coef * vouttot svm (:, je + 1 , :, n ) = svm (:, je + 1 , :, n ) - ( svm (:, je + 1 , :, n ) - svm (:, je , :, n )) * dyi * rk3coef * vouttot end do end subroutine yso_convective","tags":"","url":"proc/yso_convective.html"},{"title":"yso_Neumann – uDALES","text":"private  subroutine yso_Neumann() Uses modfields modglobal proc~~yso_neumann~~UsesGraph proc~yso_neumann yso_Neumann module~modfields modfields proc~yso_neumann->module~modfields module~modglobal modglobal proc~yso_neumann->module~modglobal decomp_2d decomp_2d module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Source Code subroutine yso_Neumann use modglobal , only : je , jhc , rk3step , dt , dyi , nsv use modfields , only : sv0 , svm real rk3coef integer n , m rk3coef = dt / ( 4. - dble ( rk3step )) do n = 1 , nsv do m = 1 , jhc sv0 (:, je + m , :, n ) = sv0 (:, je , :, n ) svm (:, je + m , :, n ) = svm (:, je , :, n ) end do end do end subroutine yso_Neumann","tags":"","url":"proc/yso_neumann.html"},{"title":"bcpup – uDALES","text":"public  subroutine bcpup(pup, pvp, pwp, rk3coef) Uses modmpi decomp_2d modinletdata modglobal modfields proc~~bcpup~~UsesGraph proc~bcpup bcpup decomp_2d decomp_2d proc~bcpup->decomp_2d module~modfields modfields proc~bcpup->module~modfields module~modglobal modglobal proc~bcpup->module~modglobal module~modinletdata modinletdata proc~bcpup->module~modinletdata module~modmpi modmpi proc~bcpup->module~modmpi module~modfields->decomp_2d mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(ib - ih:ie + ih, jb - jh:je + jh, kb:ke + kh) :: pup real, intent(inout), dimension(ib - ih:ie + ih, jb - jh:je + jh, kb:ke + kh) :: pvp real, intent(inout), dimension(ib - ih:ie + ih, jb - jh:je + jh, kb:ke + kh) :: pwp real, intent(in) :: rk3coef Calls proc~~bcpup~~CallsGraph proc~bcpup bcpup exchange_halo_z exchange_halo_z proc~bcpup->exchange_halo_z proc~avexy_ibm avexy_ibm proc~bcpup->proc~avexy_ibm mpi_allreduce mpi_allreduce proc~avexy_ibm->mpi_allreduce Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine bcpup ( pup , pvp , pwp , rk3coef ) use modglobal , only : ib , ie , jb , je , ih , jh , kb , ke , kh , rk3step , dxi , dyi , dzhi , & ibrank , ierank , jbrank , jerank , BCxm , BCym , BCtopm , & BCtopm_freeslip , BCtopm_noslip , BCtopm_pressure , & BCxm_periodic , BCxm_profile , BCxm_driver , & BCym_periodic , BCym_profile use modfields , only : pres0 , up , vp , wp , um , vm , wm , w0 , u0 , v0 , uouttot , vouttot , uinit , vinit , uprof , vprof , pres0 , IIc , IIcs use modmpi , only : excjs , excis , myid , avexy_ibm use modinletdata , only : u0driver use decomp_2d , only : exchange_halo_z real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ), intent ( inout ) :: pup real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ), intent ( inout ) :: pvp real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ), intent ( inout ) :: pwp real , dimension ( kb : ke + kh ) :: pres0ij real , intent ( in ) :: rk3coef real rk3coefi integer i , j , k rk3coefi = 1. / rk3coef ! if (jbrank) write(*,*) \"jb before exhange_halo \", pvp(ie/2,jb,ke) ! if (jerank) write(*,*) \"je before exhange_halo \", pvp(ie/2,je+1,ke) ! Watch this communication as it is slightly different to normal - ! maybe safer to just resize to kb-kh:ke+kh call exchange_halo_z ( pup , opt_zlevel = ( / ih , jh , 0 / )) call exchange_halo_z ( pvp , opt_zlevel = ( / ih , jh , 0 / )) call exchange_halo_z ( pwp , opt_zlevel = ( / ih , jh , 0 / )) ! if (jbrank) write(*,*) \"jb after exhange_halo \", pvp(ie/2,jb,ke) ! if (jerank) write(*,*) \"je after exhange_halo \", pvp(ie/2,je+1,ke) select case ( BCtopm ) case ( BCtopm_freeslip , BCtopm_noslip ) do j = jb , je do i = ib , ie pwp ( i , j , kb ) = 0. pwp ( i , j , ke + kh ) = 0. end do end do case ( BCtopm_pressure ) call avexy_ibm ( pres0ij ( kb : ke + kh ), pres0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) do j = jb , je do i = ib , ie pwp ( i , j , kb ) = 0. !pwp(i, j, ke + 1) = wm(i, j, ke+1) * rk3coefi - (-pres0ij(ke) - pres0(i,j,ke)) * dzhi(ke+1) ! Doesn't work pwp ( i , j , ke + 1 ) = wm ( i , j , ke + 1 ) * rk3coefi + 2 * pres0ij ( ke ) * dzhi ( ke + 1 ) wp ( i , j , ke + 1 ) = pwp ( i , j , ke + 1 ) - wm ( i , j , ke + 1 ) * rk3coefi end do end do end select !BCtopm select case ( BCxm ) case ( BCxm_periodic ) if ( ibrank . and . ierank ) then ! not parallelised in x do k = kb , ke do j = jb , je pup ( ie + 1 , j , k ) = pup ( ib , j , k ) ! cyclic end do end do end if case ( BCxm_profile ) if ( ibrank ) then do k = kb , ke do j = jb - 1 , je + 1 pup ( ib , j , k ) = uprof ( k ) * rk3coefi up ( ib , j , k ) = 0. end do end do end if if ( ierank ) then do k = kb + 1 , ke do j = jb - 1 , je + 1 ! convective pup ( ie + 1 , j , k ) = um ( ie + 1 , j , k ) * rk3coefi - ( u0 ( ie + 1 , j , k ) - u0 ( ie , j , k )) * dxi * uouttot !u0(ie,j,k) ! du/dt +u*du/dx=0 -> pup(i)=um(i)/rk3coef -um(i)*(um(i)-um(i-1))/dxf(i-1) ! Neumann !pup(ie+1,j,k) = pup(ie,j,k) up ( ie + 1 , j , k ) = pup ( ie + 1 , j , k ) - um ( ie + 1 , j , k ) * rk3coefi end do end do ! Neumann at bottom - performs better with no slip pup ( ie + 1 , :, kb ) = pup ( ie , :, kb ) up ( ie + 1 , :, kb ) = pup ( ie + 1 ,: , kb ) - um ( ie + 1 , :, kb ) * rk3coefi end if case ( BCxm_driver ) if ( ibrank ) then do k = kb , ke do j = jb - 1 , je + 1 pup ( ib , j , k ) = u0driver ( j , k ) * rk3coefi up ( ib , j , k ) = 0. ! u(ib) only evolves according to pressure correction end do end do end if if ( ierank ) then do k = kb , ke do j = jb - 1 , je + 1 pup ( ie + 1 , j , k ) = um ( ie + 1 , j , k ) * rk3coefi - ( u0 ( ie + 1 , j , k ) - u0 ( ie , j , k )) * dxi * uouttot ! du/dt +u*du/dx=0 -> pup(i)=um(i)/rk3coef -um(i)*(um(i)-um(i-1))/dxf(i-1) ! !Neumann !pup(ie+1,j,k) = pup(ie,j,k) up ( ie + 1 , j , k ) = pup ( ie + 1 , j , k ) - um ( ie + 1 , j , k ) * rk3coefi end do end do ! Neumann at bottom - performs better with no slip ! pup(ie+1, :, kb) = pup(ie, :, kb) ! up(ie+1, :, kb) = pup(ie+1, :, kb) - um(ie+1, :, kb) * rk3coefi end if end select ! BCxm select case ( BCym ) case ( BCym_periodic ) if ( jbrank . and . jerank ) then ! not parallelised in y do k = kb , ke do i = ib , ie pvp ( i , je + 1 , k ) = pvp ( i , jb , k ) ! cyclic end do end do end if case ( BCym_profile ) if ( jbrank ) then do k = kb , ke do i = ib - 1 , ie + 1 pvp ( i , jb , k ) = vprof ( k ) * rk3coefi vp ( i , jb , k ) = 0. end do end do end if if ( jerank ) then do k = kb , ke do i = ib - 1 , ie + 1 ! change to vouttot pvp ( i , je + 1 , k ) = vm ( i , je + 1 , k ) * rk3coefi - ( v0 ( i , je + 1 , k ) - v0 ( i , je , k )) * dyi * vouttot vp ( i , je + 1 , k ) = pvp ( i , je + 1 , k ) - vm ( i , je + 1 , k ) * rk3coefi end do end do pvp (:, je + 1 , kb ) = pvp (:, je , kb ) vp (:, je + 1 , kb ) = pvp (:, je + 1 , kb ) - vm (:, je + 1 , kb ) * rk3coefi end if end select end subroutine bcpup","tags":"","url":"proc/bcpup.html"},{"title":"bcp – uDALES","text":"public  subroutine bcp(p) Uses modfields decomp_2d modglobal proc~~bcp~~UsesGraph proc~bcp bcp decomp_2d decomp_2d proc~bcp->decomp_2d module~modfields modfields proc~bcp->module~modfields module~modglobal modglobal proc~bcp->module~modglobal module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(ib - ih:ie + ih, jb - jh:je + jh, kb - kh:ke + kh) :: p Calls proc~~bcp~~CallsGraph proc~bcp bcp exchange_halo_z exchange_halo_z proc~bcp->exchange_halo_z Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine bcp ( p ) use modglobal , only : ib , ie , jb , je , ih , jh , kb , ke , kh , dyi , rk3step , dt , & ibrank , ierank , jbrank , jerank , BCxm , BCym , BCxm_periodic , BCym_periodic use modfields , only : pres0 , up , u0 , um , uouttot , vp , v0 use decomp_2d , only : exchange_halo_z real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ), intent ( inout ) :: p !< pressure integer i , j , k real rk3coef , rk3coefi if ( rk3step == 0 ) then ! dt not defined yet rk3coef = 1. else rk3coef = dt / ( 4. - dble ( rk3step )) end if rk3coefi = 1. / rk3coef call exchange_halo_z ( p ) call exchange_halo_z ( pres0 ) if ( BCxm . eq . BCxm_periodic ) then if ( ibrank . and . ierank ) then do j = jb , je do k = kb , ke p ( ib - 1 , j , k ) = p ( ie , j , k ) p ( ie + 1 , j , k ) = p ( ib , j , k ) !pres0(ib - 1, j, k) = pres0(ie, j, k) !pres0(ie + 1, j, k) = pres0(ib, j, k) end do end do end if else if ( ibrank ) then do k = kb , ke do j = jb - 1 , je + 1 p ( ib - 1 , j , k ) = p ( ib , j , k ) pres0 ( ib - 1 , j , k ) = pres0 ( ib , j , k ) end do end do end if if ( ierank ) then do k = kb , ke do j = jb - 1 , je + 1 p ( ie + 1 , j , k ) = p ( ie , j , k ) pres0 ( ie + 1 , j , k ) = pres0 ( ie , j , k ) end do end do end if end if ! BCxm if ( BCym . eq . BCym_periodic ) then if ( jbrank . and . jerank ) then do i = ib , ie do k = kb , ke p ( i , jb - 1 , k ) = p ( i , je , k ) p ( i , je + 1 , k ) = p ( i , jb , k ) !pres0(ib - 1, j, k) = pres0(ie, j, k) !pres0(ie + 1, j, k) = pres0(ib, j, k) end do end do end if else if ( jbrank ) then do k = kb , ke do i = ib - 1 , ie + 1 p ( i , jb - 1 , k ) = p ( i , jb , k ) pres0 ( i , jb - 1 , k ) = pres0 ( i , jb , k ) enddo enddo end if if ( jerank ) then do k = kb , ke do i = ib - 1 , ie + 1 p ( i , je + 1 , k ) = p ( i , je , k ) pres0 ( i , je + 1 , k ) = pres0 ( i , je , k ) end do end do end if end if !BCym end subroutine bcp","tags":"","url":"proc/bcp.html"},{"title":"grwdamp – uDALES","text":"public  subroutine grwdamp() Uses modfields modmpi modglobal proc~~grwdamp~~UsesGraph proc~grwdamp grwdamp module~modfields modfields proc~grwdamp->module~modfields module~modglobal modglobal proc~grwdamp->module~modglobal module~modmpi modmpi proc~grwdamp->module~modmpi decomp_2d decomp_2d module~modfields->decomp_2d mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~grwdamp~~CalledByGraph proc~grwdamp grwdamp program~dalesurban DALESURBAN program~dalesurban->proc~grwdamp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine grwdamp use modglobal , only : ke , kmax , lcoriol , igrw_damp , geodamptime use modfields , only : up , vp , wp , thlp , qtp , u0 , v0 , w0 , thl0 , qt0 , ug , vg , thl0av , qt0av , u0av , v0av use modmpi , only : myid implicit none integer k select case ( igrw_damp ) case ( 0 ) !do nothing case ( 1 ) do k = ksp , ke up (:, :, k ) = up (:, :, k ) - ( u0 (:, :, k ) - u0av ( k )) * tsc ( k ) vp (:, :, k ) = vp (:, :, k ) - ( v0 (:, :, k ) - v0av ( k )) * tsc ( k ) wp (:, :, k ) = wp (:, :, k ) - w0 (:, :, k ) * tsc ( k ) thlp (:, :, k ) = thlp (:, :, k ) - ( thl0 (:, :, k ) - thl0av ( k )) * tsc ( k ) qtp (:, :, k ) = qtp (:, :, k ) - ( qt0 (:, :, k ) - qt0av ( k )) * tsc ( k ) end do if ( lcoriol ) then do k = ksp , ke up (:, :, k ) = up (:, :, k ) - ( u0 (:, :, k ) - ug ( k )) * (( 1. / ( geodamptime * rnu0 )) * tsc ( k )) vp (:, :, k ) = vp (:, :, k ) - ( v0 (:, :, k ) - vg ( k )) * (( 1. / ( geodamptime * rnu0 )) * tsc ( k )) end do end if case ( 2 ) do k = ksp , ke up (:, :, k ) = up (:, :, k ) - ( u0 (:, :, k ) - ug ( k )) * tsc ( k ) vp (:, :, k ) = vp (:, :, k ) - ( v0 (:, :, k ) - vg ( k )) * tsc ( k ) wp (:, :, k ) = wp (:, :, k ) - w0 (:, :, k ) * tsc ( k ) thlp (:, :, k ) = thlp (:, :, k ) - ( thl0 (:, :, k ) - thl0av ( k )) * tsc ( k ) qtp (:, :, k ) = qtp (:, :, k ) - ( qt0 (:, :, k ) - qt0av ( k )) * tsc ( k ) end do case ( 3 ) do k = ksp , ke up (:, :, k ) = up (:, :, k ) - ( u0 (:, :, k ) - u0av ( k )) * tsc ( k ) vp (:, :, k ) = vp (:, :, k ) - ( v0 (:, :, k ) - v0av ( k )) * tsc ( k ) wp (:, :, k ) = wp (:, :, k ) - w0 (:, :, k ) * tsc ( k ) thlp (:, :, k ) = thlp (:, :, k ) - ( thl0 (:, :, k ) - thl0av ( k )) * tsc ( k ) qtp (:, :, k ) = qtp (:, :, k ) - ( qt0 (:, :, k ) - qt0av ( k )) * tsc ( k ) end do case default write ( 0 , * ) \"ERROR: no gravity wave damping option selected\" stop 1 end select return end subroutine grwdamp","tags":"","url":"proc/grwdamp.html"},{"title":"fluxtop – uDALES","text":"private  subroutine fluxtop(field, ek, flux) Uses modglobal proc~~fluxtop~~UsesGraph proc~fluxtop fluxtop module~modglobal modglobal proc~fluxtop->module~modglobal Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(inout) :: field (ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh) real, intent(in) :: ek (ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh) real, intent(in) :: flux Called by proc~~fluxtop~~CalledByGraph proc~fluxtop fluxtop proc~boundary boundary proc~boundary->proc~fluxtop program~dalesurban DALESURBAN program~dalesurban->proc~boundary Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine fluxtop ( field , ek , flux ) use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , dzf , dzh , dzhi , eps1 real , intent ( inout ) :: field ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ) real , intent ( in ) :: ek ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ) real , intent ( in ) :: flux ! if ( abs ( flux ) . le . eps1 ) then !it's zero-flux, we don't need to do the calculation field (:, :, ke + 1 ) = field (:, :, ke ) else field (:, :, ke + 1 ) = field (:, :, ke ) + dzh ( ke + 1 ) * flux / ( dzhi ( ke + 1 ) * ( 0.5 * ( dzf ( ke ) * ek (:, :, ke + 1 ) + dzf ( ke + 1 ) * ek (:, :, ke )))) end if ! end subroutine fluxtop","tags":"","url":"proc/fluxtop.html"},{"title":"valuetop – uDALES","text":"private  subroutine valuetop(field, val) Uses modmpi modglobal proc~~valuetop~~UsesGraph proc~valuetop valuetop module~modglobal modglobal proc~valuetop->module~modglobal module~modmpi modmpi proc~valuetop->module~modmpi mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(inout) :: field (ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh) real, intent(in) :: val Called by proc~~valuetop~~CalledByGraph proc~valuetop valuetop proc~boundary boundary proc~boundary->proc~valuetop program~dalesurban DALESURBAN program~dalesurban->proc~boundary Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine valuetop ( field , val ) use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , dzh , dzf , dzhi , dzfi use modmpi , only : myid real , intent ( inout ) :: field ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ) real , intent ( in ) :: val ! (field(i, j, kp)*dzf(k) + field(i, j, k)*dzf(kp))*dzhi(kp)*0.5 = val !field(:,:,ke+1) = (2.*val*dzh(ke+1) - field(:,:,ke)*dzf(ke+1)) * dzfi(ke) field (:, :, ke + 1 ) = 2 * val - field (:, :, ke ) !if (myid == 0) write(*,*) (field(40, 1, ke+1)*dzf(ke) + field(40, 1, ke)*dzf(ke+1))*dzhi(ke+1)*0.5 end subroutine valuetop","tags":"","url":"proc/valuetop.html"},{"title":"fluxtopscal – uDALES","text":"private  subroutine fluxtopscal(flux) Uses modfields modsubgriddata modglobal proc~~fluxtopscal~~UsesGraph proc~fluxtopscal fluxtopscal module~modfields modfields proc~fluxtopscal->module~modfields module~modglobal modglobal proc~fluxtopscal->module~modglobal module~modsubgriddata modsubgriddata proc~fluxtopscal->module~modsubgriddata decomp_2d decomp_2d module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(in) :: flux (1:nsv) Called by proc~~fluxtopscal~~CalledByGraph proc~fluxtopscal fluxtopscal proc~boundary boundary proc~boundary->proc~fluxtopscal program~dalesurban DALESURBAN program~dalesurban->proc~boundary Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine fluxtopscal ( flux ) use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , dzf , dzh , dzhi , nsv , khc use modfields , only : sv0 , svm use modsubgriddata , only : ekh real , intent ( in ) :: flux ( 1 : nsv ) integer :: m , n ! !all the ghost cells have the same value? do m = 1 , khc do n = 1 , nsv sv0 ( ib - ih : ie + ih , jb - jh : je + jh , ke + m , n ) = sv0 ( ib - ih : ie + ih , jb - jh : je + jh , ke , n ) + dzh ( ke + 1 ) * flux ( n ) / ( dzhi ( ke + 1 ) * ( 0.5 * ( dzf ( ke ) * ekh ( ib - ih : ie + ih , jb - jh : je + jh , ke + 1 ) + dzf ( ke + 1 ) * ekh ( ib - ih : ie + ih , jb - jh : je + jh , ke )))) svm ( ib - ih : ie + ih , jb - jh : je + jh , ke + m , n ) = svm ( ib - ih : ie + ih , jb - jh : je + jh , ke , n ) + dzh ( ke + 1 ) * flux ( n ) / ( dzhi ( ke + 1 ) * ( 0.5 * ( dzf ( ke ) * ekh ( ib - ih : ie + ih , jb - jh : je + jh , ke + 1 ) + dzf ( ke + 1 ) * ekh ( ib - ih : ie + ih , jb - jh : je + jh , ke )))) end do end do ! end subroutine fluxtopscal","tags":"","url":"proc/fluxtopscal.html"},{"title":"valuetopscal – uDALES","text":"private  subroutine valuetopscal(val) Uses modfields modglobal proc~~valuetopscal~~UsesGraph proc~valuetopscal valuetopscal module~modfields modfields proc~valuetopscal->module~modfields module~modglobal modglobal proc~valuetopscal->module~modglobal decomp_2d decomp_2d module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(in) :: val (1:nsv) Called by proc~~valuetopscal~~CalledByGraph proc~valuetopscal valuetopscal proc~boundary boundary proc~boundary->proc~valuetopscal program~dalesurban DALESURBAN program~dalesurban->proc~boundary Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine valuetopscal ( val ) use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , eps1 , nsv , khc use modfields , only : sv0 , svm real , intent ( in ) :: val ( 1 : nsv ) integer :: m , n ! ! all the ghost cells have the same vlaue? do m = 1 , khc do n = 1 , nsv sv0 (: , : , ke + m , n ) = 2 * val ( n ) - sv0 (: , : , ke , n ) svm (: , : , ke + m , n ) = 2 * val ( n ) - svm (: , : , ke , n ) end do end do ! end subroutine valuetopscal","tags":"","url":"proc/valuetopscal.html"},{"title":"tqaver – uDALES","text":"public  subroutine tqaver() Uses modfields modmpi modglobal proc~~tqaver~~UsesGraph proc~tqaver tqaver module~modfields modfields proc~tqaver->module~modfields module~modglobal modglobal proc~tqaver->module~modglobal module~modmpi modmpi proc~tqaver->module~modmpi decomp_2d decomp_2d module~modfields->decomp_2d mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~tqaver~~CallsGraph proc~tqaver tqaver mpi_allreduce mpi_allreduce proc~tqaver->mpi_allreduce Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine tqaver use modmpi , only : comm3d , mpierr , my_real , mpi_sum use modglobal , only : ib , ie , jb , je , ih , jh , kb , ke , nsv , rslabs use modfields , only : thl0 , qt0 , sv0 implicit none real thl0a , qt0a real thl0al , qt0al integer n real , allocatable , dimension (:) :: sv0al , sv0a allocate ( sv0al ( nsv ), sv0a ( nsv )) thl0al = sum ( thl0 ( ib : ie , jb : je , ke )) qt0al = sum ( qt0 ( ib : ie , jb : je , ke )) do n = 1 , nsv sv0al ( n ) = sum ( sv0 ( ib : ie , jb : je , ke , n )) enddo call MPI_ALLREDUCE ( thl0al , thl0a , 1 , MY_REAL , & MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( qt0al , qt0a , 1 , MY_REAL , & MPI_SUM , comm3d , mpierr ) if ( nsv > 0 ) then call MPI_ALLREDUCE ( sv0al , sv0a , nsv , MY_REAL , & MPI_SUM , comm3d , mpierr ) end if thl0a = thl0a / rslabs qt0a = qt0a / rslabs sv0a = sv0a / rslabs thl0 ( ib : ie , jb : je , ke ) = thl0a qt0 ( ib : ie , jb : je , ke ) = qt0a do n = 1 , nsv sv0 ( ib : ie , jb : je , ke , n ) = sv0a ( n ) enddo deallocate ( sv0al , sv0a ) return end subroutine tqaver","tags":"","url":"proc/tqaver.html"},{"title":"initglobal – uDALES","text":"public  subroutine initglobal() Uses decomp_2d modmpi proc~~initglobal~~UsesGraph proc~initglobal initglobal decomp_2d decomp_2d proc~initglobal->decomp_2d module~modmpi modmpi proc~initglobal->module~modmpi mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~initglobal~~CallsGraph proc~initglobal initglobal float float proc~initglobal->float mpi_bcast mpi_bcast proc~initglobal->mpi_bcast xsize xsize proc~initglobal->xsize ysize ysize proc~initglobal->ysize zend zend proc~initglobal->zend zsize zsize proc~initglobal->zsize zstart zstart proc~initglobal->zstart Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~initglobal~~CalledByGraph proc~initglobal initglobal program~dalesurban DALESURBAN program~dalesurban->proc~initglobal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine initglobal use modmpi , only : myid , comm3d , my_real , mpierr use decomp_2d implicit none integer :: advarr ( 4 ) real phi , colat , silat , omega , omega_gs integer :: i , j , k , n character ( 80 ) chmess ! Global constants ! Select advection scheme for scalars. If not set in the options file, the momentum scheme is used if ( iadv_tke < 0 ) iadv_tke = iadv_mom if ( iadv_thl < 0 ) iadv_thl = iadv_mom if ( iadv_qt < 0 ) iadv_qt = iadv_mom !CvH remove where !where (iadv_sv<0)  iadv_sv  = iadv_mom !tg3315 added - only uses kappa advection scheme... do n = 1 , nsv iadv_sv ( n ) = iadv_kappa end do !ends here !timestepping if ( courant < 0 ) then select case ( iadv_mom ) case ( iadv_cd2 ) courant = 1.5 case default courant = 1.4 end select if ( any ( iadv_sv ( 1 : nsv ) == iadv_kappa ) . or . any (( / iadv_thl , iadv_qt , iadv_tke / ) == iadv_kappa )) then courant = min ( courant , 1.1 ) elseif ( any ( iadv_sv ( 1 : nsv ) == iadv_upw ) . or . any (( / iadv_thl , iadv_qt , iadv_tke / ) == iadv_upw )) then courant = min ( courant , 1.1 ) elseif ( any ( iadv_sv ( 1 : nsv ) == iadv_cd2 ) . or . any (( / iadv_thl , iadv_qt , iadv_tke / ) == iadv_cd2 )) then courant = min ( courant , 1.5 ) end if end if ! phsgrid !jmax = jtot/nprocy ! Only in z-pencil and not true generally - uneven no. !imax = itot/nprocx ! Only in z-pencil isen = imax ! Only in z-pencil - replace eventually so it is pencil-independent (in poisson) jsen = jmax ! Only in z-pencil - replace eventually so it is pencil-independent (in poisson) !set the number of ghost cells. NB: This switch has to run in order of required ghost cells advarr = ( / iadv_mom , iadv_tke , iadv_thl , iadv_qt / ) if ( any ( advarr == iadv_kappa )) then ih = 2 jh = 2 kh = 1 ! SO: think this is inconsistent elseif ( any ( advarr == iadv_cd2 ) . or . any ( iadv_sv ( 1 : nsv ) == iadv_cd2 )) then ih = 1 jh = 1 kh = 1 ihc = 1 jhc = 1 khc = 1 end if ! J. Tomas added this for using only kappa scheme for sv(:) if ( any ( iadv_sv ( 1 : nsv ) == iadv_kappa ) . or . ( iadv_thl == iadv_kappa )) then ih = 1 jh = 1 kh = 1 ihc = 2 jhc = 2 khc = 2 end if ! Eventually ib etc should be completely replaced. ! All arrays start at 1, like in 2DECOMP, and end at e.g. zsize(1) = imax in old terminology ib = 1 ! Remove eventually jb = 1 jgb = jb ! global j range (starting at the same as j as the processor j range) jge = jtot ! global j range kb = 1 ! Make redundant !kmax = ktot ! Define indices in terms of 2DECOMP's. Subject to change! z=pencil 'special' for now, but could rename e.g. imax -> imax3 imax1 = xsize ( 1 ) !=itot imax2 = ysize ( 1 ) imax = zsize ( 1 ) jmax1 = xsize ( 2 ) jmax2 = ysize ( 2 ) !=jtot jmax = zsize ( 2 ) kmax1 = xsize ( 3 ) kmax2 = ysize ( 3 ) kmax = zsize ( 3 ) ie = imax je = jmax ke = kmax decomp_main % zlevel = ( / ih , jh , kh / ) if ( zstart ( 1 ) == 1 ) then ibrank = . true . else ibrank = . false . end if if ( zend ( 1 ) == itot ) then ierank = . true . else ierank = . false . end if if ( zstart ( 2 ) == 1 ) then jbrank = . true . else jbrank = . false . end if if ( zend ( 2 ) == jtot ) then jerank = . true . else jerank = . false . end if !write(*,*) \"myid, ibrank, ierank\", myid, ibrank, ierank phi = xlat * pi / 18 0. colat = cos ( phi ) silat = sin ( phi ) omega = 7.292e-5 omega_gs = 7.292e-5 om22 = 2. * omega * colat om23 = 2. * omega * silat om22_gs = 2. * omega_gs * colat om23_gs = 2. * omega_gs * silat ! Variables allocate ( dsv ( nsv )) ! Create the physical grid variables allocate ( dzf ( kb - kh : ke + kh )) allocate ( dzf2 ( kb - kh : ke + kh )) allocate ( dzfi ( kb - kh : ke + kh )) allocate ( dzfiq ( kb - kh : ke + kh )) allocate ( dzfi5 ( kb - kh : ke + kh )) allocate ( dzh ( kb : ke + kh )) allocate ( dzhi ( kb : ke + kh )) allocate ( dzhiq ( kb : ke + kh )) allocate ( dzh2i ( kb : ke + kh )) allocate ( zh ( kb : ke + kh )) allocate ( zf ( kb : ke + kh )) allocate ( dxf ( ib - ih : itot + ih )) allocate ( dxf2 ( ib - ih : itot + ih )) allocate ( dxfi ( ib - ih : itot + ih )) allocate ( dxfiq ( ib - ih : itot + ih )) allocate ( dxfi5 ( ib - ih : itot + ih )) allocate ( dxh ( ib : itot + ih )) allocate ( dxhi ( ib : itot + ih )) allocate ( dxhiq ( ib : itot + ih )) allocate ( dxh2i ( ib : itot + ih )) allocate ( xh ( ib : itot + ih )) allocate ( xf ( ib : itot + ih )) allocate ( yh ( jb : jtot + jh )) allocate ( yf ( jb : jtot + jh )) allocate ( delta ( ib - ih : itot + ih , kb : ke + kh )) rslabs = real ( itot * jtot ) dx = xlen / float ( itot ) dy = ylen / float ( jtot ) ! MPI ! Note, that the loop for reading zf and calculating zh ! has been split so that reading is only done on PE 1 write ( cexpnr , '(i3.3)' ) iexpnr if ( nrank == 0 ) then open ( ifinput , file = 'prof.inp.' // cexpnr ) read ( ifinput , '(a72)' ) chmess read ( ifinput , '(a72)' ) chmess do k = kb , ke read ( ifinput , * ) zf ( k ) end do close ( ifinput ) ! ! J. Tomas: Read the x-coordinates of the cell centers from xgrid.inp.XXX ! ! SO: still reads for now, but need to remove any reference to xf, xh, etc eventually ! open (ifinput, file='xgrid.inp.'//cexpnr) ! read (ifinput, '(a72)') chmess ! read (ifinput, '(a72)') chmess ! ! do i = ib, itot !    read (ifinput, *) xf(i) ! end do ! close (ifinput) end if ! end if nrank==0 ! MPI broadcast ktot elements from zf call MPI_BCAST ( zf , ktot , MY_REAL , 0 , comm3d , mpierr ) ! MPI broadcast itot elements from xf ! call MPI_BCAST(xf, itot, MY_REAL, 0, comm3d, mpierr) zh ( kb ) = 0.0 do k = kb , ke zh ( k + 1 ) = zh ( k ) + 2.0 * ( zf ( k ) - zh ( k )) end do zf ( ke + kh ) = zf ( ke ) + 2.0 * ( zh ( ke + kh ) - zf ( ke )) do k = kb , ke dzf ( k ) = zh ( k + 1 ) - zh ( k ) end do dzf ( ke + 1 ) = dzf ( ke ) dzf ( kb - 1 ) = dzf ( kb ) dzh ( kb ) = 2 * zf ( kb ) do k = kb + 1 , ke + kh dzh ( k ) = zf ( k ) - zf ( k - 1 ) end do ! j. tomas: same trick for x-direction... ! xh(ib) = 0.0 ! do i = ib, itot !    xh(i + 1) = xh(i) + 2.0*(xf(i) - xh(i)) ! end do ! xf(itot + ih) = xf(itot) + 2.0*(xh(itot + ih) - xf(itot)) do i = ib , itot + ih xh ( i ) = ( i - 1 ) * dx xf ( i ) = xh ( i ) + dx / 2 end do do j = jb , jtot + jh yh ( j ) = ( j - 1 ) * dy yf ( j ) = yh ( j ) + dy / 2 end do ! These should be removed eventually do i = ib , itot dxf ( i ) = xh ( i + 1 ) - xh ( i ) end do dxf ( itot + 1 ) = dxf ( itot ) dxf ( ib - 1 ) = dxf ( ib ) dxh ( ib ) = 2 * xf ( ib ) do i = 2 , itot + ih dxh ( i ) = xf ( i ) - xf ( i - 1 ) end do do k = kb , ke + kh do i = ib - ih , itot + ih delta ( i , k ) = ( dxf ( i ) * dy * dzf ( k )) ** ( 1. / 3. ) end do end do !-------------------------------------------------- ! *** Check whether the grid is equidistant ***** !-------------------------------------------------- !if (myid == 0) then !do k=kb,ke+kh !if (.not.(dzf(k).eq.dzf(1))) !      write (6, *) & !      'WARNING, You are working with a non-equidistant grid!!!!' !end if !end do !end if ! end if myid==0 dzhi = 1. / dzh dzfi = 1. / dzf dzf2 = dzf * dzf dxhi = 1. / dxh dxfi = 1. / dxf dxf2 = dxf * dxf dxi = 1. / dx dx2 = dx * dx dyi = 1. / dy dy2 = dy * dy dzhiq = 0.25 * dzhi dzfiq = 0.25 * dzfi dxhiq = 0.25 * dxhi dxfiq = 0.25 * dxfi dyiq = 0.25 * dyi dxiq = 0.25 * dxi dzh2i = dzhi * dzhi dxh2i = dxhi * dxhi dy2i = dyi * dyi dx2i = dxi * dxi dzfi5 = 0.5 * dzfi dxfi5 = 0.5 * dxfi dyi5 = 0.5 * dyi dxi5 = 0.5 * dxi ! Grid used in kappa scheme advection (extra ghost nodes) if ( any ( iadv_sv ( 1 : nsv ) == iadv_kappa ) . or . ( iadv_thl == iadv_kappa )) then allocate ( dzfc ( kb - khc : ke + khc )) allocate ( dxfc ( ib - ihc : itot + ihc )) allocate ( dzfci ( kb - khc : ke + khc )) allocate ( dxfci ( ib - ihc : itot + ihc )) allocate ( dzhci ( kb - 1 : ke + khc )) allocate ( dxhci ( ib - 1 : itot + ihc )) dzfc ( kb - kh : ke + kh ) = dzf ( kb - kh : ke + kh ) dzfc ( kb - khc ) = dzfc ( kb - kh ) dzfc ( ke + khc ) = dzfc ( ke + kh ) dxfc ( ib - ih : itot + ih ) = dxf ( ib - ih : itot + ih ) dxfc ( ib - ihc ) = dxfc ( ib - ih ) dxfc ( itot + ihc ) = dxfc ( itot + ih ) dzhci ( kb : ke + kh ) = dzhi ( kb : ke + kh ) dzhci ( kb - 1 ) = dzhci ( kb ) dzhci ( ke + khc ) = dzhci ( ke + kh ) dxhci ( ib : itot + ih ) = dxhi ( ib : itot + ih ) dxhci ( ib - 1 ) = dxhci ( ib ) dxhci ( itot + ihc ) = dxhci ( itot + ih ) dzfci = 1. / dzfc dxfci = 1. / dxfc end if tnextrestart = trestart tnextfielddump = tfielddump !    tnextstatsdump = tstatsdump timeleft = runtime ! tg3315 previously btime + runtime end subroutine initglobal","tags":"","url":"proc/initglobal.html"},{"title":"exitglobal – uDALES","text":"public  subroutine exitglobal() Arguments None Called by proc~~exitglobal~~CalledByGraph proc~exitglobal exitglobal proc~exitmodules exitmodules proc~exitmodules->proc~exitglobal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine exitglobal deallocate ( dsv , dzf , dzh , zh , zf , delta ) end subroutine exitglobal","tags":"","url":"proc/exitglobal.html"},{"title":"trilinear_interp_var – uDALES","text":"public  function trilinear_interp_var(var, cell, xgrid, ygrid, zgrid, x, y, z) Uses decomp_2d modglobal proc~~trilinear_interp_var~~UsesGraph proc~trilinear_interp_var trilinear_interp_var decomp_2d decomp_2d proc~trilinear_interp_var->decomp_2d module~modglobal modglobal proc~trilinear_interp_var->module~modglobal Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(in) :: var (ib-ih:ie+ih,jb-jh:je+jh,kb-kh:kb+kh) integer, intent(in) :: cell (3) real, intent(in), dimension(ib:itot+ih) :: xgrid real, intent(in), dimension(jb:jtot+jh) :: ygrid real, intent(in), dimension(kb:ktot+kh) :: zgrid real, intent(in) :: x real, intent(in) :: y real, intent(in) :: z Return Value real Calls proc~~trilinear_interp_var~~CallsGraph proc~trilinear_interp_var trilinear_interp_var proc~eval_corners eval_corners proc~trilinear_interp_var->proc~eval_corners proc~trilinear_interp trilinear_interp proc~trilinear_interp_var->proc~trilinear_interp zstart zstart proc~trilinear_interp_var->zstart Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~trilinear_interp_var~~CalledByGraph proc~trilinear_interp_var trilinear_interp_var proc~wallfunheat wallfunheat proc~wallfunheat->proc~trilinear_interp_var proc~wallfunmom wallfunmom proc~wallfunmom->proc~trilinear_interp_var proc~ibmwallfun ibmwallfun proc~ibmwallfun->proc~wallfunheat proc~ibmwallfun->proc~wallfunmom program~dalesurban DALESURBAN program~dalesurban->proc~ibmwallfun Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code real function trilinear_interp_var ( var , cell , xgrid , ygrid , zgrid , x , y , z ) use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , itot , jtot , ktot use decomp_2d , only : zstart implicit none real , intent ( in ) :: var ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : kb + kh ) integer , intent ( in ) :: cell ( 3 ) ! GLOBAL indices of cell containing the point real , intent ( in ), dimension ( ib : itot + ih ) :: xgrid real , intent ( in ), dimension ( jb : jtot + jh ) :: ygrid real , intent ( in ), dimension ( kb : ktot + kh ) :: zgrid real , intent ( in ) :: x , y , z ! location of point to interpolate at real , dimension ( 8 ) :: corners ( 8 ) real :: x0 , y0 , z0 , x1 , y1 , z1 integer :: i , j , k i = cell ( 1 ) - zstart ( 1 ) + 1 j = cell ( 2 ) - zstart ( 2 ) + 1 k = cell ( 3 ) - zstart ( 3 ) + 1 if (( i < ib - 1 ) . or . ( i > ie + 1 ) . or . ( j < jb - 1 ) . or . ( j > je + 1 )) then write ( * , * ) \"problem in trilinear_interp_var\" , i , j , k stop 1 end if corners = eval_corners ( var , i , j , k ) x0 = xgrid ( cell ( 1 )) y0 = ygrid ( cell ( 2 )) z0 = zgrid ( cell ( 3 )) x1 = xgrid ( cell ( 1 ) + 1 ) y1 = ygrid ( cell ( 2 ) + 1 ) z1 = zgrid ( cell ( 3 ) + 1 ) trilinear_interp_var = trilinear_interp ( x , y , z , x0 , y0 , z0 , x1 , y1 , z1 , corners ) end function trilinear_interp_var","tags":"","url":"proc/trilinear_interp_var.html"},{"title":"eval_corners – uDALES","text":"public  function eval_corners(var, i, j, k) Uses modglobal proc~~eval_corners~~UsesGraph proc~eval_corners eval_corners module~modglobal modglobal proc~eval_corners->module~modglobal Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(in) :: var (ib-ih:ie+ih,jb-jh:je+jh,kb-kh:kb+kh) integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k Return Value real, dimension(8), (8) Called by proc~~eval_corners~~CalledByGraph proc~eval_corners eval_corners proc~trilinear_interp_var trilinear_interp_var proc~trilinear_interp_var->proc~eval_corners proc~wallfunheat wallfunheat proc~wallfunheat->proc~trilinear_interp_var proc~wallfunmom wallfunmom proc~wallfunmom->proc~trilinear_interp_var proc~ibmwallfun ibmwallfun proc~ibmwallfun->proc~wallfunheat proc~ibmwallfun->proc~wallfunmom program~dalesurban DALESURBAN program~dalesurban->proc~ibmwallfun Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function eval_corners ( var , i , j , k ) use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh integer , intent ( in ) :: i , j , k ! LOCAL indices real , intent ( in ) :: var ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : kb + kh ) real , dimension ( 8 ) :: eval_corners ( 8 ) eval_corners ( 1 ) = var ( i , j , k ) !c000 eval_corners ( 2 ) = var ( i + 1 , j , k ) !c100 eval_corners ( 3 ) = var ( i , j + 1 , k ) !c010 eval_corners ( 4 ) = var ( i + 1 , j + 1 , k ) !c110 eval_corners ( 5 ) = var ( i , j , k + 1 ) !c001 eval_corners ( 6 ) = var ( i + 1 , j , k + 1 ) !c101 eval_corners ( 7 ) = var ( i , j + 1 , k + 1 ) !c011 eval_corners ( 8 ) = var ( i + 1 , j + 1 , k + 1 ) !c111 end function eval_corners","tags":"","url":"proc/eval_corners.html"},{"title":"trilinear_interp – uDALES","text":"public  function trilinear_interp(x, y, z, x0, y0, z0, x1, y1, z1, corners) Arguments Type Intent Optional Attributes Name real, intent(in) :: x real, intent(in) :: y real, intent(in) :: z real, intent(in) :: x0 real, intent(in) :: y0 real, intent(in) :: z0 real, intent(in) :: x1 real, intent(in) :: y1 real, intent(in) :: z1 real, intent(in) :: corners (8) Return Value real Called by proc~~trilinear_interp~~CalledByGraph proc~trilinear_interp trilinear_interp proc~trilinear_interp_var trilinear_interp_var proc~trilinear_interp_var->proc~trilinear_interp proc~wallfunheat wallfunheat proc~wallfunheat->proc~trilinear_interp_var proc~wallfunmom wallfunmom proc~wallfunmom->proc~trilinear_interp_var proc~ibmwallfun ibmwallfun proc~ibmwallfun->proc~wallfunheat proc~ibmwallfun->proc~wallfunmom program~dalesurban DALESURBAN program~dalesurban->proc~ibmwallfun Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code real function trilinear_interp ( x , y , z , x0 , y0 , z0 , x1 , y1 , z1 , corners ) real , intent ( in ) :: x , y , z , x0 , y0 , z0 , x1 , y1 , z1 , corners ( 8 ) real :: xd , yd , zd xd = ( x - x0 ) / ( x1 - x0 ) yd = ( y - y0 ) / ( y1 - y0 ) zd = ( z - z0 ) / ( z1 - z0 ) ! check all positive trilinear_interp = corners ( 1 ) * ( 1 - xd ) * ( 1 - yd ) * ( 1 - zd ) + & ! c000 corners ( 2 ) * ( xd ) * ( 1 - yd ) * ( 1 - zd ) + & ! c100 corners ( 3 ) * ( 1 - xd ) * ( yd ) * ( 1 - zd ) + & ! c010 corners ( 4 ) * ( xd ) * ( yd ) * ( 1 - zd ) + & ! c110 corners ( 5 ) * ( 1 - xd ) * ( 1 - yd ) * ( zd ) + & ! c001 corners ( 6 ) * ( xd ) * ( 1 - yd ) * ( zd ) + & ! c101 corners ( 7 ) * ( 1 - xd ) * ( yd ) * ( zd ) + & ! c011 corners ( 8 ) * ( xd ) * ( yd ) * ( zd ) ! c111 end function trilinear_interp","tags":"","url":"proc/trilinear_interp.html"},{"title":"alignment – uDALES","text":"public  function alignment(n) Uses modglobal proc~~alignment~~UsesGraph proc~alignment alignment module~modglobal modglobal proc~alignment->module~modglobal Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(in), dimension(3) :: n Return Value integer Calls proc~~alignment~~CallsGraph proc~alignment alignment proc~is_equal is_equal proc~alignment->proc~is_equal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~alignment~~CalledByGraph proc~alignment alignment proc~initibmwallfun initibmwallfun proc~initibmwallfun->proc~alignment proc~wallfunmom wallfunmom proc~wallfunmom->proc~alignment proc~ibmwallfun ibmwallfun proc~ibmwallfun->proc~wallfunmom proc~initibm initibm proc~initibm->proc~initibmwallfun program~dalesurban DALESURBAN program~dalesurban->proc~ibmwallfun program~dalesurban->proc~initibm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code integer function alignment ( n ) ! returns an integer determining whether a unit vector n is aligned with the ! coordinates axes. use modglobal , only : xhat , yhat , zhat implicit none real , dimension ( 3 ), intent ( in ) :: n ! must be unit vector if ( is_equal ( n , xhat )) then alignment = 1 elseif ( is_equal ( n , yhat )) then alignment = 2 elseif ( is_equal ( n , zhat )) then alignment = 3 elseif ( is_equal ( n , - xhat )) then alignment = - 1 elseif ( is_equal ( n , - yhat )) then alignment = - 2 elseif ( is_equal ( n , - zhat )) then alignment = - 3 else alignment = 0 end if end function alignment","tags":"","url":"proc/alignment.html"},{"title":"is_equal – uDALES","text":"public  function is_equal(a, b) Uses modglobal proc~~is_equal~~UsesGraph proc~is_equal is_equal module~modglobal modglobal proc~is_equal->module~modglobal Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(in), dimension(3) :: a real, intent(in), dimension(3) :: b Return Value logical Called by proc~~is_equal~~CalledByGraph proc~is_equal is_equal proc~alignment alignment proc~alignment->proc~is_equal proc~local_coords local_coords proc~local_coords->proc~is_equal proc~wallfunheat wallfunheat proc~wallfunheat->proc~is_equal proc~wallfunheat->proc~local_coords proc~wallfunmom wallfunmom proc~wallfunmom->proc~is_equal proc~wallfunmom->proc~alignment proc~wallfunmom->proc~local_coords proc~ibmwallfun ibmwallfun proc~ibmwallfun->proc~wallfunheat proc~ibmwallfun->proc~wallfunmom proc~initibmwallfun initibmwallfun proc~initibmwallfun->proc~alignment proc~initibm initibm proc~initibm->proc~initibmwallfun program~dalesurban DALESURBAN program~dalesurban->proc~ibmwallfun program~dalesurban->proc~initibm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code logical function is_equal ( a , b ) ! determines whether two vectors are equal to each other within a tolerance of eps1 use modglobal , only : eps1 implicit none real , dimension ( 3 ), intent ( in ) :: a , b if ( all ( abs ( a - b ) < eps1 )) then is_equal = . true . else is_equal = . false . end if end function is_equal","tags":"","url":"proc/is_equal.html"},{"title":"cross_product – uDALES","text":"public  function cross_product(a, b) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(3) :: a real, intent(in), dimension(3) :: b Return Value real, dimension(3) Called by proc~~cross_product~~CalledByGraph proc~cross_product cross_product proc~local_coords local_coords proc~local_coords->proc~cross_product proc~wallfunheat wallfunheat proc~wallfunheat->proc~local_coords proc~wallfunmom wallfunmom proc~wallfunmom->proc~local_coords proc~ibmwallfun ibmwallfun proc~ibmwallfun->proc~wallfunheat proc~ibmwallfun->proc~wallfunmom program~dalesurban DALESURBAN program~dalesurban->proc~ibmwallfun Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function cross_product ( a , b ) ! Calculate the cross product (a x b) implicit none real , dimension ( 3 ) :: cross_product real , dimension ( 3 ), intent ( in ) :: a , b cross_product ( 1 ) = a ( 2 ) * b ( 3 ) - a ( 3 ) * b ( 2 ) cross_product ( 2 ) = a ( 3 ) * b ( 1 ) - a ( 1 ) * b ( 3 ) cross_product ( 3 ) = a ( 1 ) * b ( 2 ) - a ( 2 ) * b ( 1 ) end function cross_product","tags":"","url":"proc/cross_product.html"},{"title":"interp_velocity_u – uDALES","text":"public  function interp_velocity_u(i, j, k) Uses modfields proc~~interp_velocity_u~~UsesGraph proc~interp_velocity_u interp_velocity_u module~modfields modfields proc~interp_velocity_u->module~modfields decomp_2d decomp_2d module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k Return Value real, (3) Source Code function interp_velocity_u ( i , j , k ) ! interpolates the velocity at u-grid location i,j,k use modfields , only : u0 , v0 , w0 real :: interp_velocity_u ( 3 ) integer , intent ( in ) :: i , j , k interp_velocity_u ( 1 ) = u0 ( i , j , k ) interp_velocity_u ( 2 ) = 0.25 * ( v0 ( i , j , k ) + v0 ( i , j + 1 , k ) + v0 ( i - 1 , j , k ) + v0 ( i - 1 , j + 1 , k )) interp_velocity_u ( 3 ) = 0.25 * ( w0 ( i , j , k ) + w0 ( i , j , k + 1 ) + w0 ( i - 1 , j , k ) + w0 ( i - 1 , j , k + 1 )) !only for equidistant grid! return end function interp_velocity_u","tags":"","url":"proc/interp_velocity_u.html"},{"title":"interp_velocity_v – uDALES","text":"public  function interp_velocity_v(i, j, k) Uses modfields proc~~interp_velocity_v~~UsesGraph proc~interp_velocity_v interp_velocity_v module~modfields modfields proc~interp_velocity_v->module~modfields decomp_2d decomp_2d module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k Return Value real, (3) Source Code function interp_velocity_v ( i , j , k ) ! interpolates the velocity at v-grid location i,j,k use modfields , only : u0 , v0 , w0 real :: interp_velocity_v ( 3 ) integer , intent ( in ) :: i , j , k interp_velocity_v ( 1 ) = 0.25 * ( u0 ( i , j , k ) + u0 ( i + 1 , j , k ) + u0 ( i , j - 1 , k ) + u0 ( i + 1 , j - 1 , k )) interp_velocity_v ( 2 ) = v0 ( i , j , k ) interp_velocity_v ( 3 ) = 0.25 * ( w0 ( i , j , k ) + w0 ( i , j , k + 1 ) + w0 ( i , j - 1 , k ) + w0 ( i , j - 1 , k + 1 )) !only for equidistant grid! return end function interp_velocity_v","tags":"","url":"proc/interp_velocity_v.html"},{"title":"interp_velocity_w – uDALES","text":"public  function interp_velocity_w(i, j, k) Uses modfields proc~~interp_velocity_w~~UsesGraph proc~interp_velocity_w interp_velocity_w module~modfields modfields proc~interp_velocity_w->module~modfields decomp_2d decomp_2d module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k Return Value real, (3) Source Code function interp_velocity_w ( i , j , k ) ! interpolates the velocity at w-grid location i,j,k use modfields , only : u0 , v0 , w0 real :: interp_velocity_w ( 3 ) integer , intent ( in ) :: i , j , k interp_velocity_w ( 1 ) = 0.25 * ( u0 ( i , j , k ) + u0 ( i + 1 , j , k ) + u0 ( i , j - 1 , k ) + u0 ( i + 1 , j - 1 , k )) interp_velocity_w ( 2 ) = v0 ( i , j , k ) interp_velocity_w ( 3 ) = 0.25 * ( w0 ( i , j , k ) + w0 ( i , j , k + 1 ) + w0 ( i , j - 1 , k ) + w0 ( i , j - 1 , k + 1 )) !only for equidistant grid! return end function interp_velocity_w","tags":"","url":"proc/interp_velocity_w.html"},{"title":"interp_velocity_c – uDALES","text":"public  function interp_velocity_c(i, j, k) Uses modfields proc~~interp_velocity_c~~UsesGraph proc~interp_velocity_c interp_velocity_c module~modfields modfields proc~interp_velocity_c->module~modfields decomp_2d decomp_2d module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k Return Value real, (3) Called by proc~~interp_velocity_c~~CalledByGraph proc~interp_velocity_c interp_velocity_c proc~wallfunheat wallfunheat proc~wallfunheat->proc~interp_velocity_c proc~ibmwallfun ibmwallfun proc~ibmwallfun->proc~wallfunheat program~dalesurban DALESURBAN program~dalesurban->proc~ibmwallfun Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function interp_velocity_c ( i , j , k ) ! interpolates the velocity at c-grid location i,j,k use modfields , only : u0 , v0 , w0 real :: interp_velocity_c ( 3 ) integer , intent ( in ) :: i , j , k interp_velocity_c ( 1 ) = 0.5 * ( u0 ( i , j , k ) + u0 ( i + 1 , j , k )) interp_velocity_c ( 2 ) = 0.5 * ( v0 ( i , j , k ) + v0 ( i , j + 1 , k )) interp_velocity_c ( 3 ) = 0.5 * ( w0 ( i , j , k ) + w0 ( i , j , k + 1 )) return end function interp_velocity_c","tags":"","url":"proc/interp_velocity_c.html"},{"title":"interp_temperature_u – uDALES","text":"public  function interp_temperature_u(i, j, k) Uses modfields proc~~interp_temperature_u~~UsesGraph proc~interp_temperature_u interp_temperature_u module~modfields modfields proc~interp_temperature_u->module~modfields decomp_2d decomp_2d module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k Return Value real Source Code real function interp_temperature_u ( i , j , k ) ! interpolates the temperature at u-grid location i,j,k use modfields , only : thl0 integer , intent ( in ) :: i , j , k !interp_temperature_u = 0.5 * (thl0(i,j,k) + thl0(i-1,j,k)) interp_temperature_u = 0.5 * ( thl0 ( i , j , k ) * mask_c ( i , j , k ) * ( 2. - mask_c ( i - 1 , j , k )) & + thl0 ( i - 1 , j , k ) * mask_c ( i - 1 , j , k ) * ( 2. - mask_c ( i , j , k ))) return end function interp_temperature_u","tags":"","url":"proc/interp_temperature_u.html"},{"title":"interp_temperature_v – uDALES","text":"public  function interp_temperature_v(i, j, k) Uses modfields proc~~interp_temperature_v~~UsesGraph proc~interp_temperature_v interp_temperature_v module~modfields modfields proc~interp_temperature_v->module~modfields decomp_2d decomp_2d module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k Return Value real Source Code real function interp_temperature_v ( i , j , k ) ! interpolates the temperature at v-grid location i,j,k use modfields , only : thl0 integer , intent ( in ) :: i , j , k !interp_temperature_v = 0.5 * (thl0(i,j,k) + thl0(i,j-1,k)) interp_temperature_v = 0.5 * ( thl0 ( i , j , k ) * mask_c ( i , j , k ) * ( 2. - mask_c ( i , j - 1 , k )) & + thl0 ( i , j - 1 , k ) * mask_c ( i , j - 1 , k ) * ( 2. - mask_c ( i , j , k ))) return end function interp_temperature_v","tags":"","url":"proc/interp_temperature_v.html"},{"title":"interp_temperature_w – uDALES","text":"public  function interp_temperature_w(i, j, k) Uses modfields proc~~interp_temperature_w~~UsesGraph proc~interp_temperature_w interp_temperature_w module~modfields modfields proc~interp_temperature_w->module~modfields decomp_2d decomp_2d module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k Return Value real Source Code real function interp_temperature_w ( i , j , k ) ! interpolates the temperature at w-grid location i,j,k use modfields , only : thl0 integer , intent ( in ) :: i , j , k !interp_temperature_w = 0.5 * (thl0(i,j,k) + thl0(i,j,k-1)) interp_temperature_w = 0.5 * ( thl0 ( i , j , k ) * mask_c ( i , j , k ) * ( 2. - mask_c ( i , j , k - 1 )) & + thl0 ( i , j , k - 1 ) * mask_c ( i , j , k - 1 ) * ( 2. - mask_c ( i , j , k ))) return end function interp_temperature_w","tags":"","url":"proc/interp_temperature_w.html"},{"title":"mom_transfer_coef_stability – uDALES","text":"public  function mom_transfer_coef_stability(utan, dist, z0, z0h, Tair, Tsurf) Uses modglobal proc~~mom_transfer_coef_stability~~UsesGraph proc~mom_transfer_coef_stability mom_transfer_coef_stability module~modglobal modglobal proc~mom_transfer_coef_stability->module~modglobal Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(in) :: utan real, intent(in) :: dist real, intent(in) :: z0 real, intent(in) :: z0h real, intent(in) :: Tair real, intent(in) :: Tsurf Return Value real Called by proc~~mom_transfer_coef_stability~~CalledByGraph proc~mom_transfer_coef_stability mom_transfer_coef_stability proc~wallfunmom wallfunmom proc~wallfunmom->proc~mom_transfer_coef_stability proc~ibmwallfun ibmwallfun proc~ibmwallfun->proc~wallfunmom program~dalesurban DALESURBAN program~dalesurban->proc~ibmwallfun Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code real function mom_transfer_coef_stability ( utan , dist , z0 , z0h , Tair , Tsurf ) ! By Ivo Suter. calculates the momentum transfer coefficient based on the ! surface tangential velocity 'utan' at a distance 'dist' from the surface, ! for a surface with momentum roughness length z0 and heat roughness length z0h. ! Stability are included using the air temperature Tair and surface temperature Tsurf. use modglobal , only : grav , fkar , prandtlturb implicit none real , intent ( in ) :: dist , z0 , z0h , Tsurf , Tair , utan real , parameter :: b1 = 9.4 !parameters from uno1995 real , parameter :: b2 = 4.7 real , parameter :: dm = 7.4 real , parameter :: dh = 5.3 real :: dT , Ribl0 , logdz , logdzh , logzh , sqdz , fkar2 , Ribl1 , Fm , Fh , cm , ch , Ctm , M dT = Tair - Tsurf Ribl0 = grav * dist * dT / ( Tsurf * utan ** 2 ) !Eq. 6, guess initial Ri logdz = LOG ( dist / z0 ) logdzh = LOG ( dist / z0h ) logzh = LOG ( z0 / z0h ) sqdz = SQRT ( dist / z0 ) fkar2 = fkar ** 2 IF ( Ribl0 > 0. ) THEN !0.25 approx critical for bulk Richardson number  => stable Fm = 1. / ( 1. + b2 * Ribl0 ) ** 2 !Eq. 4 Fh = Fm !Eq. 4 ELSE ! => unstable cm = ( dm * fkar2 ) / ( logdz ** 2 ) * b1 * sqdz !Eq. 5 ch = ( dh * fkar2 ) / ( logdz ** 2 ) * b1 * sqdz !Eq. 5 Fm = 1. - ( b1 * Ribl0 ) / ( 1. + cm * SQRT ( ABS ( Ribl0 ))) !Eq. 3 Fh = 1. - ( b1 * Ribl0 ) / ( 1. + ch * SQRT ( ABS ( Ribl0 ))) !Eq. 3 END IF M = prandtlturb * logdz * SQRT ( Fm ) / Fh !Eq. 14 Ribl1 = Ribl0 - Ribl0 * prandtlturb * logzh / ( prandtlturb * logzh + M ) !Eq. 17 !interate to get new Richardson number IF ( Ribl1 > 0. ) THEN !0.25 approx critical for bulk Richardson number  => stable Fm = 1. / ( 1. + b2 * Ribl1 ) ** 2 !Eq. 4 ELSE ! => unstable cm = ( dm * fkar2 ) / ( logdz ** 2 ) * b1 * sqdz !Eq. 5 Fm = 1. - ( b1 * Ribl1 ) / ( 1. + cm * SQRT ( ABS ( Ribl1 ))) !Eq. 3 END IF mom_transfer_coef_stability = fkar2 / ( logdz ** 2 ) * Fm !Eq. 7 end function mom_transfer_coef_stability","tags":"","url":"proc/mom_transfer_coef_stability.html"},{"title":"mom_transfer_coef_neutral – uDALES","text":"public  function mom_transfer_coef_neutral(dist, z0) Uses modglobal proc~~mom_transfer_coef_neutral~~UsesGraph proc~mom_transfer_coef_neutral mom_transfer_coef_neutral module~modglobal modglobal proc~mom_transfer_coef_neutral->module~modglobal Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(in) :: dist real, intent(in) :: z0 Return Value real Called by proc~~mom_transfer_coef_neutral~~CalledByGraph proc~mom_transfer_coef_neutral mom_transfer_coef_neutral proc~wallfunmom wallfunmom proc~wallfunmom->proc~mom_transfer_coef_neutral proc~ibmwallfun ibmwallfun proc~ibmwallfun->proc~wallfunmom program~dalesurban DALESURBAN program~dalesurban->proc~ibmwallfun Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code real function mom_transfer_coef_neutral ( dist , z0 ) ! calculates the heat transfer coefficient based on the (neutral) log law, ! for a distance 'dist' and a momentum roughness length 'z0'. use modglobal , only : fkar implicit none real , intent ( in ) :: dist , z0 mom_transfer_coef_neutral = ( fkar / log ( dist / z0 )) ** 2 end function mom_transfer_coef_neutral","tags":"","url":"proc/mom_transfer_coef_neutral.html"},{"title":"moist_flux – uDALES","text":"public  function moist_flux(cveg, resa, qtair, qwall, hurel, resc, ress) Arguments Type Intent Optional Attributes Name real, intent(in) :: cveg real, intent(in) :: resa real, intent(in) :: qtair real, intent(in) :: qwall real, intent(in) :: hurel real, intent(in) :: resc real, intent(in) :: ress Return Value real Called by proc~~moist_flux~~CalledByGraph proc~moist_flux moist_flux proc~wallfunheat wallfunheat proc~wallfunheat->proc~moist_flux proc~ibmwallfun ibmwallfun proc~ibmwallfun->proc~wallfunheat program~dalesurban DALESURBAN program~dalesurban->proc~ibmwallfun Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code real function moist_flux ( cveg , resa , qtair , qwall , hurel , resc , ress ) real , intent ( in ) :: cveg , resa , qtair , qwall , hurel , resc , ress moist_flux = min ( 0. , cveg * ( qtair - qwall ) / ( resa + resc ) + & ( 1 - cveg ) * ( qtair - qwall * hurel ) / ( resa + ress )) end function moist_flux","tags":"","url":"proc/moist_flux.html"},{"title":"initibm – uDALES","text":"public  subroutine initibm() Uses decomp_2d modmpi modstat_nc modglobal proc~~initibm~~UsesGraph proc~initibm initibm decomp_2d decomp_2d proc~initibm->decomp_2d module~modglobal modglobal proc~initibm->module~modglobal module~modmpi modmpi proc~initibm->module~modmpi module~modstat_nc modstat_nc proc~initibm->module~modstat_nc mpi mpi module~modmpi->mpi module~modstat_nc->module~modmpi netcdf netcdf module~modstat_nc->netcdf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~initibm~~CallsGraph proc~initibm initibm exchange_halo_z exchange_halo_z proc~initibm->exchange_halo_z proc~define_nc define_nc proc~initibm->proc~define_nc proc~initibmnorm initibmnorm proc~initibm->proc~initibmnorm proc~initibmwallfun initibmwallfun proc~initibm->proc~initibmwallfun proc~ncinfo ncinfo proc~initibm->proc~ncinfo proc~open_nc open_nc proc~initibm->proc~open_nc proc~solid solid proc~initibm->proc~solid proc~writestat_dims_nc writestat_dims_nc proc~initibm->proc~writestat_dims_nc nf90_def_var nf90_def_var proc~define_nc->nf90_def_var nf90_enddef nf90_enddef proc~define_nc->nf90_enddef nf90_inq_dimid nf90_inq_dimid proc~define_nc->nf90_inq_dimid nf90_inq_varid nf90_inq_varid proc~define_nc->nf90_inq_varid nf90_put_att nf90_put_att proc~define_nc->nf90_put_att nf90_redef nf90_redef proc~define_nc->nf90_redef proc~nchandle_error nchandle_error proc~define_nc->proc~nchandle_error mpi_bcast mpi_bcast proc~initibmnorm->mpi_bcast zend zend proc~initibmnorm->zend zstart zstart proc~initibmnorm->zstart proc~initibmwallfun->mpi_bcast proc~alignment alignment proc~initibmwallfun->proc~alignment proc~plane_line_intersection plane_line_intersection proc~initibmwallfun->proc~plane_line_intersection proc~initibmwallfun->zend proc~initibmwallfun->zstart nf90_create nf90_create proc~open_nc->nf90_create nf90_def_dim nf90_def_dim proc~open_nc->nf90_def_dim proc~open_nc->nf90_def_var proc~open_nc->nf90_enddef nf90_get_var nf90_get_var proc~open_nc->nf90_get_var proc~open_nc->nf90_inq_dimid proc~open_nc->nf90_inq_varid nf90_inquire nf90_inquire proc~open_nc->nf90_inquire nf90_inquire_dimension nf90_inquire_dimension proc~open_nc->nf90_inquire_dimension nf90_open nf90_open proc~open_nc->nf90_open proc~open_nc->nf90_put_att nf90_sync nf90_sync proc~open_nc->nf90_sync proc~solid->zstart proc~writestat_dims_nc->nf90_inq_varid proc~writestat_dims_nc->nf90_inquire_dimension nf90_put_var nf90_put_var proc~writestat_dims_nc->nf90_put_var proc~is_equal is_equal proc~alignment->proc~is_equal nf90_strerror nf90_strerror proc~nchandle_error->nf90_strerror Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~initibm~~CalledByGraph proc~initibm initibm program~dalesurban DALESURBAN program~dalesurban->proc~initibm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine initibm use modglobal , only : libm , xh , xf , yh , yf , zh , zf , xhat , yhat , zhat , vec0 , & ib , ie , ih , ihc , jb , je , jh , jhc , kb , ke , kh , khc , nsv , & iwallmom , lmoist , ltempeq , cexpnr , nfcts , lwritefac use decomp_2d , only : exchange_halo_z use modmpi , only : myid use modstat_nc , only : open_nc , define_nc , ncinfo , writestat_dims_nc real , allocatable :: rhs (:,:,:) if (. not . libm ) return solid_info_u % nsolpts = nsolpts_u solid_info_v % nsolpts = nsolpts_v solid_info_w % nsolpts = nsolpts_w call initibmnorm ( 'solid_u.txt' , solid_info_u ) call initibmnorm ( 'solid_v.txt' , solid_info_v ) call initibmnorm ( 'solid_w.txt' , solid_info_w ) ! Define (real) masks ! Hopefully this can be removed eventually if (integer) IIx halos can be communicated ! These are only used in modibm, to cancel subgrid term across solid boundaries allocate ( mask_u ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )); mask_u = 1. allocate ( mask_v ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )); mask_v = 1. allocate ( mask_w ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )); mask_w = 1. mask_w (:,:, kb ) = 0. ! In future this shouldn't be needed? mask_u (:,:, kb - kh ) = 0. mask_v (:,:, kb - kh ) = 0. mask_w (:,:, kb - kh ) = 0. allocate ( rhs ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) call solid ( solid_info_u , mask_u , rhs , 0. , ih , jh , kh ) call solid ( solid_info_v , mask_v , rhs , 0. , ih , jh , kh ) call solid ( solid_info_w , mask_w , rhs , 0. , ih , jh , kh ) call exchange_halo_z ( mask_u ) !, opt_zlevel=(/ih,jh,0/)) call exchange_halo_z ( mask_v ) !, opt_zlevel=(/ih,jh,0/)) call exchange_halo_z ( mask_w ) !, opt_zlevel=(/ih,jh,0/)) if ( iwallmom > 1 ) then bound_info_u % nbndpts = nbndpts_u bound_info_v % nbndpts = nbndpts_v bound_info_w % nbndpts = nbndpts_w bound_info_u % nfctsecs = nfctsecs_u bound_info_v % nfctsecs = nfctsecs_v bound_info_w % nfctsecs = nfctsecs_w call initibmwallfun ( 'fluid_boundary_u.txt' , 'facet_sections_u.txt' , xhat , bound_info_u ) call initibmwallfun ( 'fluid_boundary_v.txt' , 'facet_sections_v.txt' , yhat , bound_info_v ) call initibmwallfun ( 'fluid_boundary_w.txt' , 'facet_sections_w.txt' , zhat , bound_info_w ) end if if ( ltempeq . or . lmoist . or . nsv > 0 . or . lwritefac ) then solid_info_c % nsolpts = nsolpts_c call initibmnorm ( 'solid_c.txt' , solid_info_c ) bound_info_c % nbndpts = nbndpts_c bound_info_c % nfctsecs = nfctsecs_c call initibmwallfun ( 'fluid_boundary_c.txt' , 'facet_sections_c.txt' , vec0 , bound_info_c ) allocate ( mask_c ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )); mask_c = 1. mask_c (:,:, kb - kh ) = 0. call solid ( solid_info_c , mask_c , rhs , 0. , ih , jh , kh ) call exchange_halo_z ( mask_c ) !, opt_zlevel=(/ih,jh,0/)) end if deallocate ( rhs ) ! write facet stresses and pressure to fac.xxx.nc if ( lwritefac ) then allocate ( fac_tau_x ( 1 : nfcts )) allocate ( fac_tau_y ( 1 : nfcts )) allocate ( fac_tau_z ( 1 : nfcts )) allocate ( fac_pres ( 1 : nfcts )) allocate ( fac_pres2 ( 1 : nfcts )) allocate ( fac_htc ( 1 : nfcts )) allocate ( fac_cth ( 1 : nfcts )) fac_tau_x = 0. fac_tau_y = 0. fac_tau_z = 0. fac_pres = 0. fac_pres2 = 0. fac_htc = 0. fac_cth = 0. allocate ( fac_tau_x_av ( 1 : nfcts )) allocate ( fac_tau_y_av ( 1 : nfcts )) allocate ( fac_tau_z_av ( 1 : nfcts )) allocate ( fac_pres_av ( 1 : nfcts )) allocate ( fac_pres2_av ( 1 : nfcts )) allocate ( fac_htc_av ( 1 : nfcts )) allocate ( fac_cth_av ( 1 : nfcts )) fac_tau_x_av = 0. fac_tau_y_av = 0. fac_tau_z_av = 0. fac_pres_av = 0. fac_pres2_av = 0. fac_htc_av = 0. fac_cth_av = 0. facname ( 5 : 7 ) = cexpnr allocate ( ncstatfac ( nstatfac , 4 )) call ncinfo ( tncstatfac ( 1 ,:), 't' , 'Time' , 's' , 'time' ) call ncinfo ( ncstatfac ( 1 ,:), 'tau_x' , 'tau_x' , 'm&#94;2/s&#94;2' , 'ft' ) call ncinfo ( ncstatfac ( 2 ,:), 'tau_y' , 'tau_y' , 'm&#94;2/s&#94;2' , 'ft' ) call ncinfo ( ncstatfac ( 3 ,:), 'tau_z' , 'tau_z' , 'm&#94;2/s&#94;2' , 'ft' ) call ncinfo ( ncstatfac ( 4 ,:), 'pres' , 'pressure' , 'm&#94;2/s&#94;2' , 'ft' ) call ncinfo ( ncstatfac ( 5 ,:), 'htc' , 'heat transfer coefficient' , '' , 'ft' ) call ncinfo ( ncstatfac ( 6 ,:), 'cth' , 'heat transfer coefficient (Ivo)' , '' , 'ft' ) call ncinfo ( ncstatfac ( 7 ,:), 'pres_flc' , 'pressure fluctuation' , '' , 'ft' ) if ( myid == 0 ) then call open_nc ( facname , ncidfac , nrecfac , nfcts = nfcts ) if ( nrecfac == 0 ) then call define_nc ( ncidfac , 1 , tncstatfac ) call writestat_dims_nc ( ncidfac ) end if call define_nc ( ncidfac , nstatfac , ncstatfac ) end if end if end subroutine initibm","tags":"","url":"proc/initibm.html"},{"title":"initibmnorm – uDALES","text":"public  subroutine initibmnorm(fname, solid_info) Uses decomp_2d modmpi modglobal proc~~initibmnorm~~UsesGraph proc~initibmnorm initibmnorm decomp_2d decomp_2d proc~initibmnorm->decomp_2d module~modglobal modglobal proc~initibmnorm->module~modglobal module~modmpi modmpi proc~initibmnorm->module~modmpi mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name character(len=11), intent(in) :: fname type( solid_info_type ), intent(inout) :: solid_info Calls proc~~initibmnorm~~CallsGraph proc~initibmnorm initibmnorm mpi_bcast mpi_bcast proc~initibmnorm->mpi_bcast zend zend proc~initibmnorm->zend zstart zstart proc~initibmnorm->zstart Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~initibmnorm~~CalledByGraph proc~initibmnorm initibmnorm proc~initibm initibm proc~initibm->proc~initibmnorm program~dalesurban DALESURBAN program~dalesurban->proc~initibm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine initibmnorm ( fname , solid_info ) use modglobal , only : ifinput use modmpi , only : myid , comm3d , mpierr use decomp_2d , only : zstart , zend character ( 11 ), intent ( in ) :: fname type ( solid_info_type ), intent ( inout ) :: solid_info logical :: lsolptsrank ( solid_info % nsolpts ) integer n , m character ( 80 ) chmess allocate ( solid_info % solpts ( solid_info % nsolpts , 3 )) ! read u points if ( myid == 0 ) then open ( ifinput , file = fname ) read ( ifinput , '(a80)' ) chmess do n = 1 , solid_info % nsolpts read ( ifinput , * ) solid_info % solpts ( n , 1 ), solid_info % solpts ( n , 2 ), solid_info % solpts ( n , 3 ) end do close ( ifinput ) end if call MPI_BCAST ( solid_info % solpts , solid_info % nsolpts * 3 , MPI_INTEGER , 0 , comm3d , mpierr ) ! Determine whether points are on this rank solid_info % nsolptsrank = 0 do n = 1 , solid_info % nsolpts if (( solid_info % solpts ( n , 1 ) >= zstart ( 1 ) . and . solid_info % solpts ( n , 1 ) <= zend ( 1 )) . and . & ( solid_info % solpts ( n , 2 ) >= zstart ( 2 ) . and . solid_info % solpts ( n , 2 ) <= zend ( 2 ))) then lsolptsrank ( n ) = . true . solid_info % nsolptsrank = solid_info % nsolptsrank + 1 else lsolptsrank ( n ) = . false . end if end do ! Store points on current rank - only loop through these points allocate ( solid_info % solptsrank ( solid_info % nsolptsrank )) allocate ( solid_info % solpts_loc ( solid_info % nsolptsrank , 3 )) m = 0 do n = 1 , solid_info % nsolpts if ( lsolptsrank ( n )) then m = m + 1 solid_info % solptsrank ( m ) = n solid_info % solpts_loc ( m ,:) = ( / solid_info % solpts ( n , 1 ), solid_info % solpts ( n , 2 ), solid_info % solpts ( n , 3 ) / ) end if end do !write(*,*) \"rank \", myid, \" has \", solid_info%nsolptsrank, \" solid points from \", fname deallocate ( solid_info % solpts ) end subroutine initibmnorm","tags":"","url":"proc/initibmnorm.html"},{"title":"initibmwallfun – uDALES","text":"public  subroutine initibmwallfun(fname_bnd, fname_sec, dir, bound_info) Uses decomp_2d modmpi initfac modglobal proc~~initibmwallfun~~UsesGraph proc~initibmwallfun initibmwallfun decomp_2d decomp_2d proc~initibmwallfun->decomp_2d module~initfac initfac proc~initibmwallfun->module~initfac module~modglobal modglobal proc~initibmwallfun->module~modglobal module~modmpi modmpi proc~initibmwallfun->module~modmpi module~initfac->module~modglobal module~initfac->module~modmpi mpi mpi module~initfac->mpi netcdf netcdf module~initfac->netcdf module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name character(len=20), intent(in) :: fname_bnd character(len=20), intent(in) :: fname_sec real, intent(in), dimension(3) :: dir type( bound_info_type ) :: bound_info Calls proc~~initibmwallfun~~CallsGraph proc~initibmwallfun initibmwallfun mpi_bcast mpi_bcast proc~initibmwallfun->mpi_bcast proc~alignment alignment proc~initibmwallfun->proc~alignment proc~plane_line_intersection plane_line_intersection proc~initibmwallfun->proc~plane_line_intersection zend zend proc~initibmwallfun->zend zstart zstart proc~initibmwallfun->zstart proc~is_equal is_equal proc~alignment->proc~is_equal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~initibmwallfun~~CalledByGraph proc~initibmwallfun initibmwallfun proc~initibm initibm proc~initibm->proc~initibmwallfun program~dalesurban DALESURBAN program~dalesurban->proc~initibm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine initibmwallfun ( fname_bnd , fname_sec , dir , bound_info ) use modglobal , only : ifinput , ib , ie , itot , ih , jb , je , jtot , jh , kb , ktot , kh , & xf , yf , zf , xh , yh , zh , dx , dy , dzh , dzf , xhat , yhat , zhat , eps1 use modmpi , only : myid , comm3d , MY_REAL , mpierr use initfac , only : facnorm , facz0 use decomp_2d , only : zstart , zend character ( 20 ), intent ( in ) :: fname_bnd , fname_sec type ( bound_info_type ) :: bound_info real , intent ( in ), dimension ( 3 ) :: dir real , dimension ( ib : itot + ih ) :: xgrid real , dimension ( jb : jtot + jh ) :: ygrid real , dimension ( kb : ktot + kh ) :: zgrid logical , dimension ( bound_info % nbndpts ) :: lbndptsrank logical , dimension ( bound_info % nfctsecs ) :: lfctsecsrank real , dimension ( 3 ) :: norm , p0 , p1 , pxl , pxu , pyl , pyu , pzl , pzu integer , dimension ( 6 ) :: check integer , dimension ( 1 ) :: pos_min_dist real , dimension ( 6 , 3 ) :: inter real , dimension ( 6 ) :: inter_dists real :: xc , yc , zc , xl , yl , zl , xu , yu , zu , checkxl , checkxu , checkyl , checkyu , checkzl , checkzu , inter_dist integer i , j , k , n , m , norm_align , dir_align , pos , p real dst character ( 80 ) chmess allocate ( bound_info % bndpts ( bound_info % nbndpts , 3 )) ! read u points if ( myid == 0 ) then open ( ifinput , file = fname_bnd ) read ( ifinput , '(a80)' ) chmess do n = 1 , bound_info % nbndpts read ( ifinput , * ) bound_info % bndpts ( n , 1 ), bound_info % bndpts ( n , 2 ), bound_info % bndpts ( n , 3 ) end do close ( ifinput ) end if call MPI_BCAST ( bound_info % bndpts , bound_info % nbndpts * 3 , MPI_INTEGER , 0 , comm3d , mpierr ) ! Determine whether points are on this rank bound_info % nbndptsrank = 0 do n = 1 , bound_info % nbndpts if (( bound_info % bndpts ( n , 1 ) >= zstart ( 1 ) . and . bound_info % bndpts ( n , 1 ) <= zend ( 1 )) . and . & ( bound_info % bndpts ( n , 2 ) >= zstart ( 2 ) . and . bound_info % bndpts ( n , 2 ) <= zend ( 2 ))) then lbndptsrank ( n ) = . true . bound_info % nbndptsrank = bound_info % nbndptsrank + 1 else lbndptsrank ( n ) = . false . end if end do !write(*,*) \"rank \", myid, \" has \", bound_info%nbndptsrank, \"points from \", fname_bnd ! Store indices of points on current rank - only loop through these points allocate ( bound_info % bndptsrank ( bound_info % nbndptsrank )) ! index in global list allocate ( bound_info % bndpts_loc ( bound_info % nbndptsrank , 3 )) ! location m = 0 do n = 1 , bound_info % nbndpts if ( lbndptsrank ( n )) then i = bound_info % bndpts ( n , 1 ) - zstart ( 1 ) + 1 j = bound_info % bndpts ( n , 2 ) - zstart ( 2 ) + 1 k = bound_info % bndpts ( n , 3 ) - zstart ( 3 ) + 1 if (( i < ib ) . or . ( i > ie ) . or . ( j < jb ) . or . ( j > je )) then write ( * , * ) \"problem in initibmwallfun\" , i , j stop 1 end if m = m + 1 bound_info % bndptsrank ( m ) = n bound_info % bndpts_loc ( m ,:) = ( / bound_info % bndpts ( n , 1 ), bound_info % bndpts ( n , 2 ), bound_info % bndpts ( n , 3 ) / ) end if end do allocate ( bound_info % secfacids ( bound_info % nfctsecs )) allocate ( bound_info % secareas ( bound_info % nfctsecs )) allocate ( bound_info % secbndptids ( bound_info % nfctsecs )) !allocate(bound_info%intpts(bound_info%nfctsecs,3)) allocate ( bound_info % bnddst ( bound_info % nfctsecs )) !allocate(bound_info%bndvec(bound_info%nfctsecs,3)) allocate ( bound_info % recpts ( bound_info % nfctsecs , 3 )) allocate ( bound_info % recids_u ( bound_info % nfctsecs , 3 )) allocate ( bound_info % recids_v ( bound_info % nfctsecs , 3 )) allocate ( bound_info % recids_w ( bound_info % nfctsecs , 3 )) allocate ( bound_info % recids_c ( bound_info % nfctsecs , 3 )) allocate ( bound_info % lcomprec ( bound_info % nfctsecs )) allocate ( bound_info % lskipsec ( bound_info % nfctsecs )) dir_align = alignment ( dir ) select case ( dir_align ) case ( 1 ) xgrid = xh ygrid = yf zgrid = zf case ( 2 ) xgrid = xf ygrid = yh zgrid = zf case ( 3 ) xgrid = xf ygrid = yf zgrid = zh case ( 0 ) xgrid = xf ygrid = yf zgrid = zf end select if ( myid == 0 ) then open ( ifinput , file = fname_sec ) read ( ifinput , '(a80)' ) chmess do n = 1 , bound_info % nfctsecs read ( ifinput , * ) bound_info % secfacids ( n ), bound_info % secareas ( n ), bound_info % secbndptids ( n ), bound_info % bnddst ( n ) !bound_info%intpts(n,1),  bound_info%intpts(n,2), bound_info%intpts(n,3) end do close ( ifinput ) do n = 1 , bound_info % nfctsecs m = bound_info % secbndptids ( n ) !bound_info%bndvec(n,1) = xgrid(bound_info%bndpts(m,1)) - bound_info%intpts(n,1) !bound_info%bndvec(n,2) = ygrid(bound_info%bndpts(m,2)) - bound_info%intpts(n,2) !bound_info%bndvec(n,3) = zgrid(bound_info%bndpts(m,3)) - bound_info%intpts(n,3) !bound_info%bnddst(n) = norm2(bound_info%bndvec(n,:)) !write(*,*) bound_info%bnddst(n) !bound_info%bndvec(n,:) = bound_info%bndvec(n,:) / bound_info%bnddst(n) norm = facnorm ( bound_info % secfacids ( n ),:) norm_align = alignment ( norm ) if (( dir_align /= 0 . and . dir_align == norm_align ) . or . ( facz0 ( bound_info % secfacids ( n )) < eps1 )) then ! (for velocities) if the facet is aligned with the grid AND in the same direction as the current velocity grid direction ! therefore no tangential component, don't need to calculate shear stress bound_info % lskipsec ( n ) = . true . cycle else bound_info % lskipsec ( n ) = . false . end if if ( log ( bound_info % bnddst ( n ) / facz0 ( bound_info % secfacids ( n ))) > 1. . or . lnorec ) then ! the wall function is well-defined bound_info % lcomprec ( n ) = . true . ! do simple reconstruction else ! need to reconstruct bound_info % lcomprec ( n ) = . false . ! Find reconstruction point ! cell centre (of current grid) xc = xgrid ( bound_info % bndpts ( m , 1 )) yc = ygrid ( bound_info % bndpts ( m , 2 )) zc = zgrid ( bound_info % bndpts ( m , 3 )) ! cell edges xl = xc - dx / 2. xu = xc + dx / 2. yl = yc - dy / 2. yu = yc + dy / 2. zl = zc - dzf ( 1 ) / 2. ! assumes equidistant zu = zc + dzf ( 1 ) / 2. ! assumes equidistant ! points on planes pxl = ( / xl , yc , zc / ) pxu = ( / xu , yc , zc / ) pyl = ( / xc , yl , zc / ) pyu = ( / xc , yu , zc / ) pzl = ( / xc , yc , zl / ) pzu = ( / xc , yc , zu / ) p0 = ( / xc , yc , zc / ) p1 = p0 + norm * sqrt ( 3. ) * ( dx * dy * dzf ( 1 )) ** ( 1. / 3. ) call plane_line_intersection ( xhat , pxl , p0 , p1 , inter ( 1 ,:), check ( 1 ), inter_dists ( 1 )) call plane_line_intersection ( xhat , pxu , p0 , p1 , inter ( 2 ,:), check ( 2 ), inter_dists ( 2 )) call plane_line_intersection ( yhat , pyl , p0 , p1 , inter ( 3 ,:), check ( 3 ), inter_dists ( 3 )) call plane_line_intersection ( yhat , pyu , p0 , p1 , inter ( 4 ,:), check ( 4 ), inter_dists ( 4 )) call plane_line_intersection ( zhat , pzl , p0 , p1 , inter ( 5 ,:), check ( 5 ), inter_dists ( 5 )) call plane_line_intersection ( zhat , pzu , p0 , p1 , inter ( 6 ,:), check ( 6 ), inter_dists ( 6 )) pos_min_dist = minloc ( inter_dists , mask = check == 1 ) pos = pos_min_dist ( 1 ) if ( pos == 0 ) then write ( * , * ) \"ERROR: no intersection found\" stop 1 else bound_info % recpts ( n ,:) = inter ( pos ,:) ! x y z end if ! find which cell the point lies in bound_info % recids_u ( n , 1 ) = findloc ( bound_info % recpts ( n , 1 ) >= xh , . true ., 1 , back = . true .) bound_info % recids_u ( n , 2 ) = findloc ( bound_info % recpts ( n , 2 ) >= yf , . true ., 1 , back = . true .) bound_info % recids_u ( n , 3 ) = findloc ( bound_info % recpts ( n , 3 ) >= zf , . true ., 1 , back = . true .) bound_info % recids_v ( n , 1 ) = findloc ( bound_info % recpts ( n , 1 ) >= xf , . true ., 1 , back = . true .) bound_info % recids_v ( n , 2 ) = findloc ( bound_info % recpts ( n , 2 ) >= yh , . true ., 1 , back = . true .) bound_info % recids_v ( n , 3 ) = findloc ( bound_info % recpts ( n , 3 ) >= zf , . true ., 1 , back = . true .) bound_info % recids_w ( n , 1 ) = findloc ( bound_info % recpts ( n , 1 ) >= xf , . true ., 1 , back = . true .) bound_info % recids_w ( n , 2 ) = findloc ( bound_info % recpts ( n , 2 ) >= yf , . true ., 1 , back = . true .) bound_info % recids_w ( n , 3 ) = findloc ( bound_info % recpts ( n , 3 ) >= zh , . true ., 1 , back = . true .) bound_info % recids_c ( n , 1 ) = findloc ( bound_info % recpts ( n , 1 ) >= xf , . true ., 1 , back = . true .) bound_info % recids_c ( n , 2 ) = findloc ( bound_info % recpts ( n , 2 ) >= yf , . true ., 1 , back = . true .) bound_info % recids_c ( n , 3 ) = findloc ( bound_info % recpts ( n , 3 ) >= zf , . true ., 1 , back = . true .) ! check to see if recids is inside the domain if ( bound_info % recids_u ( m , 1 ) == 0 . or . bound_info % recids_u ( m , 2 ) == 0 . or . bound_info % recids_u ( m , 3 ) == 0 ) then bound_info % lskipsec ( n ) = . true . cycle end if if ( bound_info % recids_v ( m , 1 ) == 0 . or . bound_info % recids_v ( m , 2 ) == 0 . or . bound_info % recids_v ( m , 3 ) == 0 ) then bound_info % lskipsec ( n ) = . true . cycle end if if ( bound_info % recids_w ( m , 1 ) == 0 . or . bound_info % recids_w ( m , 2 ) == 0 . or . bound_info % recids_w ( m , 3 ) == 0 ) then bound_info % lskipsec ( n ) = . true . cycle end if if ( bound_info % recids_c ( m , 1 ) == 0 . or . bound_info % recids_c ( m , 2 ) == 0 . or . bound_info % recids_c ( m , 3 ) == 0 ) then bound_info % lskipsec ( n ) = . true . cycle end if !check recpts is inside the box defined by the corners ! u if (( bound_info % recpts ( n , 1 ) < xh ( bound_info % recids_u ( n , 1 ))) . or . & ( bound_info % recpts ( n , 1 ) > xh ( bound_info % recids_u ( n , 1 ) + 1 ))) then write ( * , * ) \"ERROR: x out of bounds\" stop 1 end if if (( bound_info % recpts ( n , 2 ) < yf ( bound_info % recids_u ( n , 2 ))) . or . & ( bound_info % recpts ( n , 2 ) > yf ( bound_info % recids_u ( n , 2 ) + 1 ))) then write ( * , * ) \"ERROR: y out of bounds\" stop 1 end if if (( bound_info % recpts ( n , 3 ) < zf ( bound_info % recids_u ( n , 3 ))) . or . & ( bound_info % recpts ( n , 3 ) > zf ( bound_info % recids_u ( n , 3 ) + 1 ))) then write ( * , * ) \"ERROR: z out of bounds\" stop 1 end if ! v if (( bound_info % recpts ( n , 1 ) < xf ( bound_info % recids_v ( n , 1 ))) . or . & ( bound_info % recpts ( n , 1 ) > xf ( bound_info % recids_v ( n , 1 ) + 1 ))) then write ( * , * ) \"ERROR: x out of bounds\" stop 1 end if if (( bound_info % recpts ( n , 2 ) < yh ( bound_info % recids_v ( n , 2 ))) . or . & ( bound_info % recpts ( n , 2 ) > yh ( bound_info % recids_v ( n , 2 ) + 1 ))) then write ( * , * ) \"ERROR: y out of bounds\" stop 1 end if if (( bound_info % recpts ( n , 3 ) < zf ( bound_info % recids_v ( n , 3 ))) . or . & ( bound_info % recpts ( n , 3 ) > zf ( bound_info % recids_v ( n , 3 ) + 1 ))) then write ( * , * ) \"ERROR: z out of bounds\" stop 1 end if ! w if (( bound_info % recpts ( n , 1 ) < xf ( bound_info % recids_w ( n , 1 ))) . or . & ( bound_info % recpts ( n , 1 ) > xf ( bound_info % recids_w ( n , 1 ) + 1 ))) then write ( * , * ) \"ERROR: x out of bounds\" stop 1 end if if (( bound_info % recpts ( n , 2 ) < yf ( bound_info % recids_w ( n , 2 ))) . or . & ( bound_info % recpts ( n , 2 ) > yf ( bound_info % recids_w ( n , 2 ) + 1 ))) then write ( * , * ) \"ERROR: y out of bounds\" stop 1 end if if (( bound_info % recpts ( n , 3 ) < zh ( bound_info % recids_w ( n , 3 ))) . or . & ( bound_info % recpts ( n , 3 ) > zh ( bound_info % recids_w ( n , 3 ) + 1 ))) then write ( * , * ) \"ERROR: z out of bounds\" stop 1 end if end if end do end if ! myid==0 call MPI_BCAST ( bound_info % secfacids , bound_info % nfctsecs , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( bound_info % secareas , bound_info % nfctsecs , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( bound_info % secbndptids , bound_info % nfctsecs , MPI_INTEGER , 0 , comm3d , mpierr ) !call MPI_BCAST(bound_info%intpts,      bound_info%nfctsecs*3, MY_REAL,     0, comm3d, mpierr) !call MPI_BCAST(bound_info%bndvec,      bound_info%nfctsecs*3, MY_REAL,     0, comm3d, mpierr) call MPI_BCAST ( bound_info % bnddst , bound_info % nfctsecs , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( bound_info % recpts , bound_info % nfctsecs * 3 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( bound_info % recids_u , bound_info % nfctsecs * 3 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( bound_info % recids_v , bound_info % nfctsecs * 3 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( bound_info % recids_w , bound_info % nfctsecs * 3 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( bound_info % recids_c , bound_info % nfctsecs * 3 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( bound_info % lskipsec , bound_info % nfctsecs , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( bound_info % lcomprec , bound_info % nfctsecs , MPI_LOGICAL , 0 , comm3d , mpierr ) ! Determine whether section needs to be updated by this rank bound_info % nfctsecsrank = 0 do n = 1 , bound_info % nfctsecs if ( lbndptsrank ( bound_info % secbndptids ( n ))) then lfctsecsrank ( n ) = . true . bound_info % nfctsecsrank = bound_info % nfctsecsrank + 1 else lfctsecsrank ( n ) = . false . end if end do ! Store indices of sections on current rank - only loop through these sections allocate ( bound_info % fctsecsrank ( bound_info % nfctsecsrank )) ! allocate local arrays allocate ( bound_info % secfacids_loc ( bound_info % nfctsecsrank )) allocate ( bound_info % secareas_loc ( bound_info % nfctsecsrank )) allocate ( bound_info % secbndpts_loc ( bound_info % nfctsecsrank , 3 )) allocate ( bound_info % bnddst_loc ( bound_info % nfctsecsrank )) allocate ( bound_info % recpts_loc ( bound_info % nfctsecsrank , 3 )) allocate ( bound_info % recids_u_loc ( bound_info % nfctsecsrank , 3 )) allocate ( bound_info % recids_v_loc ( bound_info % nfctsecsrank , 3 )) allocate ( bound_info % recids_w_loc ( bound_info % nfctsecsrank , 3 )) allocate ( bound_info % recids_c_loc ( bound_info % nfctsecsrank , 3 )) allocate ( bound_info % lcomprec_loc ( bound_info % nfctsecsrank )) allocate ( bound_info % lskipsec_loc ( bound_info % nfctsecsrank )) m = 0 do n = 1 , bound_info % nfctsecs if ( lfctsecsrank ( n )) then m = m + 1 bound_info % fctsecsrank ( m ) = n bound_info % secfacids_loc ( m ) = bound_info % secfacids ( n ) ! facet id bound_info % secareas_loc ( m ) = bound_info % secareas ( n ) bound_info % secbndpts_loc ( m ,:) = bound_info % bndpts ( bound_info % secbndptids ( n ),:) ! boundary point location (in global coordinates) if ( bound_info % bndpts ( bound_info % secbndptids ( n ), 1 ) < zstart ( 1 ) . or . bound_info % bndpts ( bound_info % secbndptids ( n ), 1 ) > zend ( 1 )) then write ( * , * ) \"problem in x boundary points on : \" , myid , n , bound_info % secbndptids ( n ), bound_info % bndpts ( bound_info % secbndptids ( n ), 1 ), zstart ( 1 ), zend ( 1 ) end if if ( bound_info % bndpts ( bound_info % secbndptids ( n ), 2 ) < zstart ( 2 ) . or . bound_info % bndpts ( bound_info % secbndptids ( n ), 2 ) > zend ( 2 )) then write ( * , * ) \"problem in y boundary points on rank: \" , myid , n , bound_info % secbndptids ( n ), bound_info % bndpts ( bound_info % secbndptids ( n ), 2 ), zstart ( 2 ), zend ( 2 ) end if bound_info % bnddst_loc ( m ) = bound_info % bnddst ( n ) bound_info % recpts_loc ( m ,:) = bound_info % recpts ( n ,:) bound_info % recids_u_loc ( m ,:) = bound_info % recids_u ( n ,:) bound_info % recids_v_loc ( m ,:) = bound_info % recids_v ( n ,:) bound_info % recids_w_loc ( m ,:) = bound_info % recids_w ( n ,:) bound_info % recids_c_loc ( m ,:) = bound_info % recids_c ( n ,:) bound_info % lcomprec_loc ( m ) = bound_info % lcomprec ( n ) bound_info % lskipsec_loc ( m ) = bound_info % lskipsec ( n ) end if end do deallocate ( bound_info % bndpts ) deallocate ( bound_info % secfacids ) deallocate ( bound_info % secbndptids ) deallocate ( bound_info % bnddst ) deallocate ( bound_info % recpts ) deallocate ( bound_info % recids_u ) deallocate ( bound_info % recids_v ) deallocate ( bound_info % recids_w ) deallocate ( bound_info % recids_c ) deallocate ( bound_info % lcomprec ) deallocate ( bound_info % lskipsec ) end subroutine initibmwallfun","tags":"","url":"proc/initibmwallfun.html"},{"title":"plane_line_intersection – uDALES","text":"public  subroutine plane_line_intersection(norm, V0, P0, P1, I, check, dist) Uses modglobal proc~~plane_line_intersection~~UsesGraph proc~plane_line_intersection plane_line_intersection module~modglobal modglobal proc~plane_line_intersection->module~modglobal Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(in), dimension(3) :: norm real, intent(in), dimension(3) :: V0 real, intent(in), dimension(3) :: P0 real, intent(in), dimension(3) :: P1 real, intent(out), dimension(3) :: I integer, intent(out) :: check real, intent(out) :: dist Called by proc~~plane_line_intersection~~CalledByGraph proc~plane_line_intersection plane_line_intersection proc~initibmwallfun initibmwallfun proc~initibmwallfun->proc~plane_line_intersection proc~initibm initibm proc~initibm->proc~initibmwallfun program~dalesurban DALESURBAN program~dalesurban->proc~initibm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine plane_line_intersection ( norm , V0 , P0 , P1 , I , check , dist ) use modglobal , only : vec0 , eps1 implicit none ! determines the intersection of a plane and a line segment ! norm: plane normal ! V0: point on the plane ! P0: start of line segment ! P1: end of line segment ! I: intersection point ! dist: distance from P0 to intersection point ! check: 0 if no intersection !        1 if unique intersection !        2 if line segment is in the plane !        3 if intersection is outside line segment real , intent ( in ), dimension ( 3 ) :: norm , V0 , P0 , P1 real , intent ( out ), dimension ( 3 ) :: I integer , intent ( out ) :: check real , intent ( out ) :: dist real , dimension ( 3 ) :: u , w real :: D , N , sI I = vec0 w = P0 - V0 u = P1 - P0 D = dot_product ( norm , u ) N =- dot_product ( norm , w ) if ( abs ( D ) < eps1 ) then ! line orthogonal to plane normal -> segment parallel to plane if ( abs ( N ) < eps1 ) then ! start point is on the plane -> segment lies in the plane check = 2 return else check = 0 return end if end if sI = N / D I = P0 + sI * u dist = norm2 ( I - P0 ) if (( sI < 0. ) . or . ( sI > 1. )) then check = 3 else check = 1 end if end subroutine plane_line_intersection","tags":"","url":"proc/plane_line_intersection.html"},{"title":"ibmnorm – uDALES","text":"public  subroutine ibmnorm() Uses modmpi modboundary decomp_2d modglobal modfields proc~~ibmnorm~~UsesGraph proc~ibmnorm ibmnorm decomp_2d decomp_2d proc~ibmnorm->decomp_2d module~modboundary modboundary proc~ibmnorm->module~modboundary module~modfields modfields proc~ibmnorm->module~modfields module~modglobal modglobal proc~ibmnorm->module~modglobal module~modmpi modmpi proc~ibmnorm->module~modmpi mpi mpi module~modboundary->mpi module~modfields->decomp_2d module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~ibmnorm~~CallsGraph proc~ibmnorm ibmnorm proc~advecc2nd_corr_liberal advecc2nd_corr_liberal proc~ibmnorm->proc~advecc2nd_corr_liberal proc~solid solid proc~ibmnorm->proc~solid zstart zstart proc~advecc2nd_corr_liberal->zstart proc~solid->zstart Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~ibmnorm~~CalledByGraph proc~ibmnorm ibmnorm program~dalesurban DALESURBAN program~dalesurban->proc~ibmnorm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine ibmnorm use modglobal , only : ih , jh , kh , ihc , jhc , khc , nsv , dzf , zh , kb , ke , kh , nsv , libm , ltempeq , lmoist , iadv_sv , iadv_cd2 , iadv_thl use modfields , only : um , vm , wm , thlm , qtm , svm , up , vp , wp , thlp , qtp , svp , thl0 , qt0 , sv0 , thl0av use modboundary , only : halos use decomp_2d , only : zstart , zend use modmpi , only : myid integer i , j , k , n , m if (. not . libm ) return ! Set internal velocities to zero call solid ( solid_info_u , um , up , 0. , ih , jh , kh ) call solid ( solid_info_v , vm , vp , 0. , ih , jh , kh ) call solid ( solid_info_w , wm , wp , 0. , ih , jh , kh ) ! Scalars ! Solid value does not matter when using second order scheme ! Set interior to a constant and boundary to average of fluid neighbours if ( ltempeq ) then call solid ( solid_info_c , thlm , thlp , sum ( thl0av ( kb : ke ) * dzf ( kb : ke )) / zh ( ke + 1 ), ih , jh , kh , mask_c ) if ( iadv_thl == iadv_cd2 ) call advecc2nd_corr_liberal ( thl0 , thlp ) end if if ( lmoist ) then call solid ( solid_info_c , qtm , qtp , 0. , ih , jh , kh , mask_c ) call advecc2nd_corr_liberal ( qt0 , qtp ) end if do n = 1 , nsv call solid ( solid_info_c , svm (:,:,:, n ), svp (:,:,:, n ), 0. , ihc , jhc , khc , mask_c ) if ( iadv_sv ( n ) == iadv_cd2 ) call advecc2nd_corr_liberal ( sv0 (:,:,:, n ), svp (:,:,:, n )) end do end subroutine ibmnorm","tags":"","url":"proc/ibmnorm.html"},{"title":"solid – uDALES","text":"public  subroutine solid(solid_info, var, rhs, val, hi, hj, hk, mask) Uses decomp_2d modglobal proc~~solid~~UsesGraph proc~solid solid decomp_2d decomp_2d proc~solid->decomp_2d module~modglobal modglobal proc~solid->module~modglobal Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type( solid_info_type ), intent(in) :: solid_info real, intent(inout) :: var (ib-hi:ie+hi,jb-hj:je+hj,kb-hk:ke+hk) real, intent(inout) :: rhs (ib-hi:ie+hi,jb-hj:je+hj,kb:ke+hk) real, intent(in) :: val integer, intent(in) :: hi integer, intent(in) :: hj integer, intent(in) :: hk real, intent(in), optional :: mask (ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh) Calls proc~~solid~~CallsGraph proc~solid solid zstart zstart proc~solid->zstart Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~solid~~CalledByGraph proc~solid solid proc~ibmnorm ibmnorm proc~ibmnorm->proc~solid proc~initibm initibm proc~initibm->proc~solid program~dalesurban DALESURBAN program~dalesurban->proc~ibmnorm program~dalesurban->proc~initibm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine solid ( solid_info , var , rhs , val , hi , hj , hk , mask ) use modglobal , only : ib , ie , jb , je , kb , ke , ih , jh , kh , eps1 use decomp_2d , only : zstart type ( solid_info_type ), intent ( in ) :: solid_info integer , intent ( in ) :: hi , hj , hk real , intent ( inout ) :: var ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) real , intent ( inout ) :: rhs ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ) real , intent ( in ) :: val real , intent ( in ), optional :: mask ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ) real :: count integer :: i , j , k , n , m if ( present ( mask ) . eqv . . false .) then do n = 1 , solid_info % nsolptsrank !n = solid_info%solptsrank(m) i = solid_info % solpts_loc ( n , 1 ) - zstart ( 1 ) + 1 j = solid_info % solpts_loc ( n , 2 ) - zstart ( 2 ) + 1 k = solid_info % solpts_loc ( n , 3 ) - zstart ( 3 ) + 1 var ( i , j , k ) = val rhs ( i , j , k ) = 0. end do else do n = 1 , solid_info % nsolptsrank !n = solid_info%solptsrank(m) i = solid_info % solpts_loc ( n , 1 ) - zstart ( 1 ) + 1 j = solid_info % solpts_loc ( n , 2 ) - zstart ( 2 ) + 1 k = solid_info % solpts_loc ( n , 3 ) - zstart ( 3 ) + 1 var ( i , j , k ) = val rhs ( i , j , k ) = 0. count = 0 ! Attempt to set zero flux BC if ( abs ( mask ( i , j + 1 , k ) - 1. ) < eps1 ) then ! fluid neighbour count = count + 1 var ( i , j , k ) = var ( i , j , k ) + var ( i , j + 1 , k ) rhs ( i , j , k ) = rhs ( i , j , k ) + rhs ( i , j + 1 , k ) end if if ( abs ( mask ( i , j - 1 , k ) - 1. ) < eps1 ) then count = count + 1 var ( i , j , k ) = var ( i , j , k ) + var ( i , j - 1 , k ) rhs ( i , j , k ) = rhs ( i , j , k ) + rhs ( i , j - 1 , k ) end if if ( abs ( mask ( i , j , k + 1 ) - 1. ) < eps1 ) then count = count + 1 var ( i , j , k ) = var ( i , j , k ) + var ( i , j , k + 1 ) rhs ( i , j , k ) = rhs ( i , j , k ) + rhs ( i , j , k + 1 ) end if if ( abs ( mask ( i , j , k - 1 ) - 1. ) < eps1 ) then count = count + 1 var ( i , j , k ) = var ( i , j , k ) + var ( i , j , k - 1 ) rhs ( i , j , k ) = rhs ( i , j , k ) + rhs ( i , j , k - 1 ) end if if ( abs ( mask ( i + 1 , j , k ) - 1. ) < eps1 ) then count = count + 1 var ( i , j , k ) = var ( i , j , k ) + var ( i + 1 , j , k ) rhs ( i , j , k ) = rhs ( i , j , k ) + rhs ( i + 1 , j , k ) end if if ( abs ( mask ( i - 1 , j , k ) - 1. ) < eps1 ) then count = count + 1 var ( i , j , k ) = var ( i , j , k ) + var ( i - 1 , j , k ) rhs ( i , j , k ) = rhs ( i , j , k ) + rhs ( i - 1 , j , k ) end if if ( count > 0 ) then var ( i , j , k ) = ( var ( i , j , k ) - val ) / count rhs ( i , j , k ) = rhs ( i , j , k ) / count end if end do end if end subroutine solid","tags":"","url":"proc/solid.html"},{"title":"advecc2nd_corr_conservative – uDALES","text":"public  subroutine advecc2nd_corr_conservative(var, rhs) Uses modfields decomp_2d modsubgriddata modglobal proc~~advecc2nd_corr_conservative~~UsesGraph proc~advecc2nd_corr_conservative advecc2nd_corr_conservative decomp_2d decomp_2d proc~advecc2nd_corr_conservative->decomp_2d module~modfields modfields proc~advecc2nd_corr_conservative->module~modfields module~modglobal modglobal proc~advecc2nd_corr_conservative->module~modglobal module~modsubgriddata modsubgriddata proc~advecc2nd_corr_conservative->module~modsubgriddata module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(in) :: var (ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh) real, intent(inout) :: rhs (ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) Calls proc~~advecc2nd_corr_conservative~~CallsGraph proc~advecc2nd_corr_conservative advecc2nd_corr_conservative zstart zstart proc~advecc2nd_corr_conservative->zstart Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine advecc2nd_corr_conservative ( var , rhs ) ! Removes the advection contribution from solid velocities, which should be ! close to zero but are not necessarily due to pressure correction. ! Has a fairly drastic effect on the initial flow, but the scalar is ! conserved throughout the simulation. use modglobal , only : eps1 , ib , ie , ih , jb , je , jh , kb , ke , kh , & dx2i , dxi5 , dy2i , dyi5 , dzf , dzh2i , dzfi , dzhi , dzfi5 use modfields , only : u0 , v0 , w0 use modsubgriddata , only : ekh use decomp_2d , only : zstart real , intent ( in ) :: var ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ) real , intent ( inout ) :: rhs ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ) integer :: i , j , k , n , m do n = 1 , bound_info_c % nbndptsrank !n = bound_info_c%bndptsrank(m) i = bound_info_c % bndpts_loc ( n , 1 ) - zstart ( 1 ) + 1 j = bound_info_c % bndpts_loc ( n , 2 ) - zstart ( 2 ) + 1 k = bound_info_c % bndpts_loc ( n , 3 ) - zstart ( 3 ) + 1 if (( abs ( mask_u ( i + 1 , j , k )) < eps1 ) . or . ( abs ( mask_c ( i + 1 , j , k )) < eps1 )) then rhs ( i , j , k ) = rhs ( i , j , k ) + u0 ( i + 1 , j , k ) * ( var ( i + 1 , j , k ) + var ( i , j , k )) * dxi5 end if if (( abs ( mask_u ( i , j , k )) < eps1 ) . or . ( abs ( mask_c ( i - 1 , j , k )) < eps1 )) then rhs ( i , j , k ) = rhs ( i , j , k ) - u0 ( i , j , k ) * ( var ( i - 1 , j , k ) + var ( i , j , k )) * dxi5 end if if (( abs ( mask_v ( i , j + 1 , k )) < eps1 ) . or . ( abs ( mask_c ( i , j + 1 , k )) < eps1 )) then rhs ( i , j , k ) = rhs ( i , j , k ) + v0 ( i , j + 1 , k ) * ( var ( i , j + 1 , k ) + var ( i , j , k )) * dyi5 end if if (( abs ( mask_v ( i , j , k )) < eps1 ) . or . ( abs ( mask_c ( i , j - 1 , k )) < eps1 )) then rhs ( i , j , k ) = rhs ( i , j , k ) - v0 ( i , j , k ) * ( var ( i , j - 1 , k ) + var ( i , j , k )) * dyi5 end if if (( abs ( mask_w ( i , j , k + 1 )) < eps1 ) . or . ( abs ( mask_c ( i , j , k + 1 )) < eps1 )) then rhs ( i , j , k ) = rhs ( i , j , k ) + w0 ( i , j , k + 1 ) * ( var ( i , j , k + 1 ) * dzf ( k ) + var ( i , j , k ) * dzf ( k + 1 )) * dzhi ( k + 1 ) * dzfi5 ( k ) end if if (( abs ( mask_w ( i , j , k )) < eps1 ) . or . ( abs ( mask_c ( i , j , k - 1 )) < eps1 )) then rhs ( i , j , k ) = rhs ( i , j , k ) - w0 ( i , j , k ) * ( var ( i , j , k - 1 ) * dzf ( k ) + var ( i , j , k ) * dzf ( k - 1 )) * dzhi ( k ) * dzfi5 ( k ) end if end do end subroutine advecc2nd_corr_conservative","tags":"","url":"proc/advecc2nd_corr_conservative.html"},{"title":"advecc2nd_corr_liberal – uDALES","text":"public  subroutine advecc2nd_corr_liberal(var, rhs) Uses modfields decomp_2d modsubgriddata modglobal proc~~advecc2nd_corr_liberal~~UsesGraph proc~advecc2nd_corr_liberal advecc2nd_corr_liberal decomp_2d decomp_2d proc~advecc2nd_corr_liberal->decomp_2d module~modfields modfields proc~advecc2nd_corr_liberal->module~modfields module~modglobal modglobal proc~advecc2nd_corr_liberal->module~modglobal module~modsubgriddata modsubgriddata proc~advecc2nd_corr_liberal->module~modsubgriddata module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(in) :: var (ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh) real, intent(inout) :: rhs (ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) Calls proc~~advecc2nd_corr_liberal~~CallsGraph proc~advecc2nd_corr_liberal advecc2nd_corr_liberal zstart zstart proc~advecc2nd_corr_liberal->zstart Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~advecc2nd_corr_liberal~~CalledByGraph proc~advecc2nd_corr_liberal advecc2nd_corr_liberal proc~ibmnorm ibmnorm proc~ibmnorm->proc~advecc2nd_corr_liberal program~dalesurban DALESURBAN program~dalesurban->proc~ibmnorm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine advecc2nd_corr_liberal ( var , rhs ) ! Removes the advection contribution from solid scalar points as calculated ! by the 2nd order scheme, and replaces it with a contribution in which the ! value inside the solid is equal to the value outside, thereby modelling ! a zero (advective) flux condition. ! Due to potentially nonzero solid velocities due to the pressure correction, ! the IBM will not be conservative. use modglobal , only : eps1 , ib , ie , ih , jb , je , jh , kb , ke , kh , & dx2i , dxi5 , dy2i , dyi5 , dzf , dzh2i , dzfi , dzhi , dzfi5 use modfields , only : u0 , v0 , w0 use modsubgriddata , only : ekh use decomp_2d , only : zstart real , intent ( in ) :: var ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ) real , intent ( inout ) :: rhs ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ) integer :: i , j , k , n , m do n = 1 , bound_info_c % nbndptsrank !n = bound_info_c%bndptsrank(m) i = bound_info_c % bndpts_loc ( n , 1 ) - zstart ( 1 ) + 1 j = bound_info_c % bndpts_loc ( n , 2 ) - zstart ( 2 ) + 1 k = bound_info_c % bndpts_loc ( n , 3 ) - zstart ( 3 ) + 1 if ( abs ( mask_c ( i + 1 , j , k )) < eps1 ) then ! var(i+1) is solid rhs ( i , j , k ) = rhs ( i , j , k ) + u0 ( i + 1 , j , k ) * ( var ( i + 1 , j , k ) + var ( i , j , k )) * dxi5 & ! negate contribution added in advection using var(i+1) - u0 ( i + 1 , j , k ) * ( var ( i , j , k ) + var ( i , j , k )) * dxi5 ! add corresponding contribution with var(i+1) = var(i) end if if ( abs ( mask_c ( i - 1 , j , k )) < eps1 ) then ! var(i-1) is solid rhs ( i , j , k ) = rhs ( i , j , k ) - u0 ( i , j , k ) * ( var ( i - 1 , j , k ) + var ( i , j , k )) * dxi5 & ! negate contribution added in advection using var(i-1) + u0 ( i , j , k ) * ( var ( i , j , k ) + var ( i , j , k )) * dxi5 ! add corresponding contribution with var(i-1) = var(i) end if if ( abs ( mask_c ( i , j + 1 , k )) < eps1 ) then ! var(j+1) is solid rhs ( i , j , k ) = rhs ( i , j , k ) + v0 ( i , j + 1 , k ) * ( var ( i , j + 1 , k ) + var ( i , j , k )) * dyi5 & ! negate contribution added in advection using var(j+1) - v0 ( i , j + 1 , k ) * ( var ( i , j , k ) + var ( i , j , k )) * dyi5 ! add corresponding contribution with var(j+1) = var(j) end if if ( abs ( mask_c ( i , j - 1 , k )) < eps1 ) then ! var(j-1) is solid rhs ( i , j , k ) = rhs ( i , j , k ) - v0 ( i , j , k ) * ( var ( i , j - 1 , k ) + var ( i , j , k )) * dyi5 & ! negate contribution added in advection using var(j-1) + v0 ( i , j , k ) * ( var ( i , j , k ) + var ( i , j , k )) * dyi5 ! add corresponding contribution with var(j-1) = var(j) end if if ( abs ( mask_c ( i , j , k + 1 )) < eps1 ) then ! var(k+1) is solid rhs ( i , j , k ) = rhs ( i , j , k ) + w0 ( i , j , k + 1 ) * ( var ( i , j , k + 1 ) * dzf ( k ) + var ( i , j , k ) * dzf ( k + 1 )) * dzhi ( k + 1 ) * dzfi5 ( k ) & ! negate contribution added in advection using var(k+1) - w0 ( i , j , k + 1 ) * ( var ( i , j , k ) * dzf ( k ) + var ( i , j , k ) * dzf ( k + 1 )) * dzhi ( k + 1 ) * dzfi5 ( k ) ! add corresponding contribution with var(k+1) = var(k) end if if ( abs ( mask_c ( i , j , k - 1 )) < eps1 ) then ! var(k-1) is solid rhs ( i , j , k ) = rhs ( i , j , k ) - w0 ( i , j , k ) * ( var ( i , j , k - 1 ) * dzf ( k ) + var ( i , j , k ) * dzf ( k - 1 )) * dzhi ( k ) * dzfi5 ( k ) & ! negate contribution added in advection using var(k-1) + w0 ( i , j , k ) * ( var ( i , j , k ) * dzf ( k ) + var ( i , j , k ) * dzf ( k - 1 )) * dzhi ( k ) * dzfi5 ( k ) ! add corresponding contribution with var(k-1) = var(k) end if end do end subroutine advecc2nd_corr_liberal","tags":"","url":"proc/advecc2nd_corr_liberal.html"},{"title":"diffu_corr – uDALES","text":"public  subroutine diffu_corr() Uses modfields decomp_2d modsubgriddata modglobal proc~~diffu_corr~~UsesGraph proc~diffu_corr diffu_corr decomp_2d decomp_2d proc~diffu_corr->decomp_2d module~modfields modfields proc~diffu_corr->module~modfields module~modglobal modglobal proc~diffu_corr->module~modglobal module~modsubgriddata modsubgriddata proc~diffu_corr->module~modsubgriddata module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~diffu_corr~~CallsGraph proc~diffu_corr diffu_corr zstart zstart proc~diffu_corr->zstart Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~diffu_corr~~CalledByGraph proc~diffu_corr diffu_corr proc~ibmwallfun ibmwallfun proc~ibmwallfun->proc~diffu_corr program~dalesurban DALESURBAN program~dalesurban->proc~ibmwallfun Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine diffu_corr ! Negate subgrid rhs contributions from solid points (added by diffu in modsubgrid) use modglobal , only : eps1 , ib , ie , ih , jb , je , jh , kb , ke , kh , & dx2i , dxi5 , dy2i , dyi5 , dzf , dzh2i , dzfi , dzhi , dzfi5 , dzhiq use modfields , only : u0 , up use modsubgriddata , only : ekm use decomp_2d , only : zstart real :: empo , emmo , emop , emom integer :: i , j , k , n , m do n = 1 , bound_info_u % nbndptsrank !n = bound_info_u%bndptsrank(m) i = bound_info_u % bndpts_loc ( n , 1 ) - zstart ( 1 ) + 1 j = bound_info_u % bndpts_loc ( n , 2 ) - zstart ( 2 ) + 1 k = bound_info_u % bndpts_loc ( n , 3 ) - zstart ( 3 ) + 1 if ( abs ( mask_u ( i , j + 1 , k )) < eps1 ) then empo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , j + 1 , k )) + ( ekm ( i - 1 , j , k ) + ekm ( i - 1 , j + 1 , k ))) up ( i , j , k ) = up ( i , j , k ) - empo * ( u0 ( i , j + 1 , k ) - u0 ( i , j , k )) * dy2i end if if ( abs ( mask_u ( i , j - 1 , k )) < eps1 ) then emmo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , j - 1 , k )) + ( ekm ( i - 1 , j - 1 , k ) + ekm ( i - 1 , j , k ))) up ( i , j , k ) = up ( i , j , k ) + emmo * ( u0 ( i , j , k ) - u0 ( i , j - 1 , k )) * dy2i end if if ( abs ( mask_u ( i , j , k + 1 )) < eps1 ) then emop = ( dzf ( k + 1 ) * ( ekm ( i , j , k ) + ekm ( i - 1 , j , k )) + & dzf ( k ) * ( ekm ( i , j , k + 1 ) + ekm ( i - 1 , j , k + 1 ))) * dzhiq ( k + 1 ) up ( i , j , k ) = up ( i , j , k ) - emop * ( u0 ( i , j , k + 1 ) - u0 ( i , j , k )) * dzhi ( k + 1 ) * dzfi ( k ) end if if ( abs ( mask_u ( i , j , k - 1 )) < eps1 ) then emom = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) + ekm ( i - 1 , j , k )) + & dzf ( k ) * ( ekm ( i , j , k - 1 ) + ekm ( i - 1 , j , k - 1 ))) * dzhiq ( k ) up ( i , j , k ) = up ( i , j , k ) + emom * ( u0 ( i , j , k ) - u0 ( i , j , k - 1 )) * dzhi ( k ) * dzfi ( k ) end if end do end subroutine diffu_corr","tags":"","url":"proc/diffu_corr.html"},{"title":"diffv_corr – uDALES","text":"public  subroutine diffv_corr() Uses modfields decomp_2d modsubgriddata modglobal proc~~diffv_corr~~UsesGraph proc~diffv_corr diffv_corr decomp_2d decomp_2d proc~diffv_corr->decomp_2d module~modfields modfields proc~diffv_corr->module~modfields module~modglobal modglobal proc~diffv_corr->module~modglobal module~modsubgriddata modsubgriddata proc~diffv_corr->module~modsubgriddata module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~diffv_corr~~CallsGraph proc~diffv_corr diffv_corr zstart zstart proc~diffv_corr->zstart Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~diffv_corr~~CalledByGraph proc~diffv_corr diffv_corr proc~ibmwallfun ibmwallfun proc~ibmwallfun->proc~diffv_corr program~dalesurban DALESURBAN program~dalesurban->proc~ibmwallfun Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine diffv_corr ! Negate subgrid rhs contributions from solid points (added by diffv in modsubgrid) use modglobal , only : eps1 , ib , ie , ih , jb , je , jh , kb , ke , kh , & dx2i , dxi5 , dy2i , dyi5 , dzf , dzh2i , dzfi , dzhi , dzfi5 , dzhiq use modfields , only : v0 , vp use modsubgriddata , only : ekm use decomp_2d , only : zstart real :: epmo , emmo , eomp , eomm integer :: i , j , k , n , m do n = 1 , bound_info_v % nbndptsrank !n = bound_info_v%bndptsrank(m) i = bound_info_v % bndpts_loc ( n , 1 ) - zstart ( 1 ) + 1 j = bound_info_v % bndpts_loc ( n , 2 ) - zstart ( 2 ) + 1 k = bound_info_v % bndpts_loc ( n , 3 ) - zstart ( 3 ) + 1 if ( abs ( mask_v ( i + 1 , j , k )) < eps1 ) then epmo = 0.25 * ( ekm ( i , j , k ) + ekm ( i , j - 1 , k ) + ekm ( i + 1 , j - 1 , k ) + ekm ( i + 1 , j , k )) vp ( i , j , k ) = vp ( i , j , k ) - epmo * ( v0 ( i + 1 , j , k ) - v0 ( i , j , k )) * dx2i end if if ( abs ( mask_v ( i - 1 , j , k )) < eps1 ) then emmo = 0.25 * ( ekm ( i , j , k ) + ekm ( i , j - 1 , k ) + ekm ( i - 1 , j - 1 , k ) + ekm ( i - 1 , j , k )) vp ( i , j , k ) = vp ( i , j , k ) + emmo * ( v0 ( i , j , k ) - v0 ( i - 1 , j , k )) * dx2i end if if ( abs ( mask_v ( i , j , k + 1 )) < eps1 ) then eomp = ( dzf ( k + 1 ) * ( ekm ( i , j , k ) + ekm ( i , j - 1 , k ) ) + & dzf ( k ) * ( ekm ( i , j , k + 1 ) + ekm ( i , j - 1 , k + 1 ))) * dzhiq ( k + 1 ) vp ( i , j , k ) = vp ( i , j , k ) - eomp * ( v0 ( i , j , k + 1 ) - v0 ( i , j , k )) * dzhi ( k + 1 ) * dzfi ( k ) end if if ( abs ( mask_v ( i , j , k - 1 )) < eps1 ) then eomm = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) + ekm ( i , j - 1 , k ) ) + & dzf ( k ) * ( ekm ( i , j , k - 1 ) + ekm ( i , j - 1 , k - 1 ))) * dzhiq ( k ) vp ( i , j , k ) = vp ( i , j , k ) + eomm * ( v0 ( i , j , k ) - v0 ( i , j , k - 1 )) * dzhi ( k ) * dzfi ( k ) end if end do end subroutine diffv_corr","tags":"","url":"proc/diffv_corr.html"},{"title":"diffw_corr – uDALES","text":"public  subroutine diffw_corr() Uses modfields decomp_2d modsubgriddata modglobal proc~~diffw_corr~~UsesGraph proc~diffw_corr diffw_corr decomp_2d decomp_2d proc~diffw_corr->decomp_2d module~modfields modfields proc~diffw_corr->module~modfields module~modglobal modglobal proc~diffw_corr->module~modglobal module~modsubgriddata modsubgriddata proc~diffw_corr->module~modsubgriddata module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~diffw_corr~~CallsGraph proc~diffw_corr diffw_corr zstart zstart proc~diffw_corr->zstart Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~diffw_corr~~CalledByGraph proc~diffw_corr diffw_corr proc~ibmwallfun ibmwallfun proc~ibmwallfun->proc~diffw_corr program~dalesurban DALESURBAN program~dalesurban->proc~ibmwallfun Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine diffw_corr ! Negate subgrid rhs contributions from solid points (added by diffw in modsubgrid) use modglobal , only : eps1 , ib , ie , ih , jb , je , jh , kb , ke , kh , & dx2i , dxi5 , dy2i , dyi5 , dzf , dzh2i , dzfi , dzhi , dzfi5 , dzhiq use modfields , only : w0 , wp use modsubgriddata , only : ekm use decomp_2d , only : zstart real :: epom , emom , eopm , eomm integer :: i , j , k , n , m do n = 1 , bound_info_w % nbndptsrank !n = bound_info_w%bndptsrank(m) i = bound_info_w % bndpts_loc ( n , 1 ) - zstart ( 1 ) + 1 j = bound_info_w % bndpts_loc ( n , 2 ) - zstart ( 2 ) + 1 k = bound_info_w % bndpts_loc ( n , 3 ) - zstart ( 3 ) + 1 ! Account for solid w points if ( abs ( mask_w ( i + 1 , j , k )) < eps1 ) then epom = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) + ekm ( i + 1 , j , k )) + & dzf ( k ) * ( ekm ( i , j , k - 1 ) + ekm ( i + 1 , j , k - 1 ))) * dzhiq ( k ) wp ( i , j , k ) = wp ( i , j , k ) - epom * ( w0 ( i + 1 , j , k ) - w0 ( i , j , k )) * dx2i end if if ( abs ( mask_w ( i - 1 , j , k )) < eps1 ) then emom = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) + ekm ( i - 1 , j , k )) + & dzf ( k ) * ( ekm ( i , j , k - 1 ) + ekm ( i - 1 , j , k - 1 ))) * dzhiq ( k ) wp ( i , j , k ) = wp ( i , j , k ) + emom * ( w0 ( i , j , k ) - w0 ( i - 1 , j , k )) * dx2i end if if ( abs ( mask_w ( i , j + 1 , k )) < eps1 ) then eopm = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) + ekm ( i , j + 1 , k )) + & dzf ( k ) * ( ekm ( i , j , k - 1 ) + ekm ( i , j + 1 , k - 1 ))) * dzhiq ( k ) wp ( i , j , k ) = wp ( i , j , k ) - eopm * ( w0 ( i , j + 1 , k ) - w0 ( i , j , k )) * dy2i end if if ( abs ( mask_w ( i , j - 1 , k )) < eps1 ) then eomm = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) + ekm ( i , j - 1 , k )) + & dzf ( k ) * ( ekm ( i , j , k - 1 ) + ekm ( i , j - 1 , k - 1 ))) * dzhiq ( k ) wp ( i , j , k ) = wp ( i , j , k ) + eomm * ( w0 ( i , j , k ) - w0 ( i , j - 1 , k )) * dy2i end if end do end subroutine diffw_corr","tags":"","url":"proc/diffw_corr.html"},{"title":"diffc_corr – uDALES","text":"public  subroutine diffc_corr(var, rhs, hi, hj, hk) Uses decomp_2d modsubgriddata modglobal proc~~diffc_corr~~UsesGraph proc~diffc_corr diffc_corr decomp_2d decomp_2d proc~diffc_corr->decomp_2d module~modglobal modglobal proc~diffc_corr->module~modglobal module~modsubgriddata modsubgriddata proc~diffc_corr->module~modsubgriddata Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(in) :: var (ib-hi:ie+hi,jb-hj:je+hj,kb-hk:ke+hk) real, intent(inout) :: rhs (ib-hi:ie+hi,jb-hj:je+hj,kb:ke+hk) integer, intent(in) :: hi integer, intent(in) :: hj integer, intent(in) :: hk Calls proc~~diffc_corr~~CallsGraph proc~diffc_corr diffc_corr zstart zstart proc~diffc_corr->zstart Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~diffc_corr~~CalledByGraph proc~diffc_corr diffc_corr proc~ibmwallfun ibmwallfun proc~ibmwallfun->proc~diffc_corr program~dalesurban DALESURBAN program~dalesurban->proc~ibmwallfun Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine diffc_corr ( var , rhs , hi , hj , hk ) ! Negate subgrid rhs contributions from solid points (added by diffc in modsubgrid) use modglobal , only : eps1 , ib , ie , jb , je , kb , ke , kh , & dx2i , dxi5 , dy2i , dyi5 , dzf , dzh2i , dzfi , dzhi , dzfi5 use modsubgriddata , only : ekh use decomp_2d , only : zstart integer , intent ( in ) :: hi , hj , hk real , intent ( in ) :: var ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) real , intent ( inout ) :: rhs ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ) integer :: i , j , k , n , m do n = 1 , bound_info_c % nbndptsrank !n = bound_info_c%bndptsrank(m) i = bound_info_c % bndpts_loc ( n , 1 ) - zstart ( 1 ) + 1 j = bound_info_c % bndpts_loc ( n , 2 ) - zstart ( 2 ) + 1 k = bound_info_c % bndpts_loc ( n , 3 ) - zstart ( 3 ) + 1 if ( abs ( mask_c ( i + 1 , j , k )) < eps1 ) then rhs ( i , j , k ) = rhs ( i , j , k ) - 0.5 * ( ekh ( i + 1 , j , k ) + ekh ( i , j , k )) * ( var ( i + 1 , j , k ) - var ( i , j , k )) * dx2i end if if ( abs ( mask_c ( i - 1 , j , k )) < eps1 ) then rhs ( i , j , k ) = rhs ( i , j , k ) + 0.5 * ( ekh ( i , j , k ) + ekh ( i - 1 , j , k )) * ( var ( i , j , k ) - var ( i - 1 , j , k )) * dx2i end if if ( abs ( mask_c ( i , j + 1 , k )) < eps1 ) then rhs ( i , j , k ) = rhs ( i , j , k ) - 0.5 * ( ekh ( i , j + 1 , k ) + ekh ( i , j , k )) * ( var ( i , j + 1 , k ) - var ( i , j , k )) * dy2i end if if ( abs ( mask_c ( i , j - 1 , k )) < eps1 ) then rhs ( i , j , k ) = rhs ( i , j , k ) + 0.5 * ( ekh ( i , j , k ) + ekh ( i , j - 1 , k )) * ( var ( i , j , k ) - var ( i , j - 1 , k )) * dy2i end if if ( abs ( mask_c ( i , j , k + 1 )) < eps1 ) then rhs ( i , j , k ) = rhs ( i , j , k ) - 0.5 * ( dzf ( k + 1 ) * ekh ( i , j , k ) + dzf ( k ) * ekh ( i , j , k + 1 )) & * ( var ( i , j , k + 1 ) - var ( i , j , k )) * dzh2i ( k + 1 ) * dzfi ( k ) end if if ( abs ( mask_c ( i , j , k - 1 )) < eps1 ) then rhs ( i , j , k ) = rhs ( i , j , k ) + 0.5 * ( dzf ( k - 1 ) * ekh ( i , j , k ) + dzf ( k ) * ekh ( i , j , k - 1 )) & * ( var ( i , j , k ) - var ( i , j , k - 1 )) * dzh2i ( k ) * dzfi ( k ) end if end do end subroutine diffc_corr","tags":"","url":"proc/diffc_corr.html"},{"title":"ibmwallfun – uDALES","text":"public  subroutine ibmwallfun() Uses modmpi modsubgriddata modstat_nc modglobal modfields proc~~ibmwallfun~~UsesGraph proc~ibmwallfun ibmwallfun module~modfields modfields proc~ibmwallfun->module~modfields module~modglobal modglobal proc~ibmwallfun->module~modglobal module~modmpi modmpi proc~ibmwallfun->module~modmpi module~modstat_nc modstat_nc proc~ibmwallfun->module~modstat_nc module~modsubgriddata modsubgriddata proc~ibmwallfun->module~modsubgriddata decomp_2d decomp_2d module~modfields->decomp_2d mpi mpi module~modmpi->mpi module~modstat_nc->module~modmpi netcdf netcdf module~modstat_nc->netcdf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~ibmwallfun~~CallsGraph proc~ibmwallfun ibmwallfun interface~writestat_nc writestat_nc proc~ibmwallfun->interface~writestat_nc proc~diffc_corr diffc_corr proc~ibmwallfun->proc~diffc_corr proc~diffu_corr diffu_corr proc~ibmwallfun->proc~diffu_corr proc~diffv_corr diffv_corr proc~ibmwallfun->proc~diffv_corr proc~diffw_corr diffw_corr proc~ibmwallfun->proc~diffw_corr proc~wallfunheat wallfunheat proc~ibmwallfun->proc~wallfunheat proc~wallfunmom wallfunmom proc~ibmwallfun->proc~wallfunmom proc~writestat_1d_nc writestat_1D_nc proc~ibmwallfun->proc~writestat_1d_nc interface~writestat_nc->proc~writestat_1d_nc proc~writestat_2d_nc writestat_2D_nc interface~writestat_nc->proc~writestat_2d_nc proc~writestat_3d_nc writestat_3D_nc interface~writestat_nc->proc~writestat_3d_nc proc~writestat_3d_short_nc writestat_3D_short_nc interface~writestat_nc->proc~writestat_3d_short_nc proc~writestat_time_nc writestat_time_nc interface~writestat_nc->proc~writestat_time_nc zstart zstart proc~diffc_corr->zstart proc~diffu_corr->zstart proc~diffv_corr->zstart proc~diffw_corr->zstart mpi_allreduce mpi_allreduce proc~wallfunheat->mpi_allreduce proc~heat_transfer_coef_flux heat_transfer_coef_flux proc~wallfunheat->proc~heat_transfer_coef_flux proc~interp_velocity_c interp_velocity_c proc~wallfunheat->proc~interp_velocity_c proc~is_equal is_equal proc~wallfunheat->proc~is_equal proc~local_coords local_coords proc~wallfunheat->proc~local_coords proc~moist_flux moist_flux proc~wallfunheat->proc~moist_flux proc~trilinear_interp_var trilinear_interp_var proc~wallfunheat->proc~trilinear_interp_var proc~wallfunheat->zstart proc~wallfunmom->mpi_allreduce proc~alignment alignment proc~wallfunmom->proc~alignment proc~wallfunmom->proc~is_equal proc~wallfunmom->proc~local_coords proc~mom_transfer_coef_neutral mom_transfer_coef_neutral proc~wallfunmom->proc~mom_transfer_coef_neutral proc~mom_transfer_coef_stability mom_transfer_coef_stability proc~wallfunmom->proc~mom_transfer_coef_stability proc~wallfunmom->proc~trilinear_interp_var proc~wallfunmom->zstart nf90_inq_varid nf90_inq_varid proc~writestat_1d_nc->nf90_inq_varid nf90_put_var nf90_put_var proc~writestat_1d_nc->nf90_put_var nf90_sync nf90_sync proc~writestat_1d_nc->nf90_sync proc~alignment->proc~is_equal proc~local_coords->proc~is_equal proc~cross_product cross_product proc~local_coords->proc~cross_product proc~trilinear_interp_var->zstart proc~eval_corners eval_corners proc~trilinear_interp_var->proc~eval_corners proc~trilinear_interp trilinear_interp proc~trilinear_interp_var->proc~trilinear_interp proc~writestat_2d_nc->nf90_inq_varid proc~writestat_2d_nc->nf90_put_var proc~writestat_2d_nc->nf90_sync proc~writestat_3d_nc->nf90_inq_varid proc~writestat_3d_nc->nf90_put_var proc~writestat_3d_nc->nf90_sync proc~writestat_3d_short_nc->nf90_inq_varid proc~writestat_3d_short_nc->nf90_put_var proc~writestat_3d_short_nc->nf90_sync proc~writestat_time_nc->nf90_inq_varid proc~writestat_time_nc->nf90_put_var proc~writestat_time_nc->nf90_sync Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~ibmwallfun~~CalledByGraph proc~ibmwallfun ibmwallfun program~dalesurban DALESURBAN program~dalesurban->proc~ibmwallfun Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine ibmwallfun use modglobal , only : libm , iwallmom , iwalltemp , xhat , yhat , zhat , ltempeq , lmoist , & ib , ie , ih , ihc , jb , je , jh , jhc , kb , ke , kh , khc , nsv , totheatflux , totqflux , nfcts , rk3step , timee , nfcts , lwritefac , dt , dtfac , tfac , tnextfac use modfields , only : u0 , v0 , w0 , thl0 , qt0 , sv0 , up , vp , wp , thlp , qtp , svp , & tau_x , tau_y , tau_z , thl_flux use modsubgriddata , only : ekm , ekh use modmpi , only : myid , comm3d , MPI_SUM , mpierr , MY_REAL use modstat_nc , only : writestat_nc , writestat_1D_nc , writestat_2D_nc real , allocatable :: rhs (:,:,:) integer n real :: thl_flux_sum , thl_flux_tot , mom_flux_sum , mom_flux_tot logical thl_flux_file_exists , mom_flux_file_exists if (. not . libm ) return allocate ( rhs ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) if ( iwallmom > 1 ) then rhs = up call wallfunmom ( xhat , up , bound_info_u ) tau_x (:,:, kb : ke + kh ) = tau_x (:,:, kb : ke + kh ) + ( up - rhs ) rhs = vp call wallfunmom ( yhat , vp , bound_info_v ) tau_y (:,:, kb : ke + kh ) = tau_y (:,:, kb : ke + kh ) + ( vp - rhs ) rhs = wp call wallfunmom ( zhat , wp , bound_info_w ) tau_z (:,:, kb : ke + kh ) = tau_z (:,:, kb : ke + kh ) + ( wp - rhs ) ! mom_flux_sum = sum(tau_x(ib:ie,jb:je,kb+1:ke) + tau_y(ib:ie,jb:je,kb+1:ke) + tau_z(ib:ie,jb:je,kb+1:ke)) ! call MPI_ALLREDUCE(mom_flux_sum, mom_flux_tot, 1, MY_REAL, MPI_SUM, comm3d, mpierr) ! if (myid == 0) then !    if (rk3step == 3) then !         inquire(file=\"mom_flux.txt\", exist=mom_flux_file_exists) !         if (mom_flux_file_exists) then !           open(12, file=\"mom_flux.txt\", status=\"old\", position=\"append\", action=\"write\") !         else !           open(12, file=\"mom_flux.txt\", status=\"new\", action=\"write\") !         end if !         write(12, *) timee, -mom_flux_tot !         close(12) !    end if ! end if end if call diffu_corr call diffv_corr call diffw_corr if ( ltempeq . or . lmoist . or . lwritefac ) then rhs = thlp totheatflux = 0 ! Reset total heat flux to zero so we only account for that in this step. totqflux = 0 call wallfunheat thl_flux (:,:, kb : ke + kh ) = thl_flux (:,:, kb : ke + kh ) + ( thlp - rhs ) if ( ltempeq ) call diffc_corr ( thl0 , thlp , ih , jh , kh ) if ( lmoist ) call diffc_corr ( qt0 , qtp , ih , jh , kh ) ! thl_flux_sum = sum(thl_flux(ib:ie,jb:je,kb+1:ke)) ! call MPI_ALLREDUCE(thl_flux_sum, thl_flux_tot, 1, MY_REAL, MPI_SUM, comm3d, mpierr) ! if (myid == 0) then !    if (rk3step == 3) then !         inquire(file=\"thl_flux.txt\", exist=thl_flux_file_exists) !         if (thl_flux_file_exists) then !           open(12, file=\"thl_flux.txt\", status=\"old\", position=\"append\", action=\"write\") !         else !           open(12, file=\"thl_flux.txt\", status=\"new\", action=\"write\") !         end if !         write(12, *) timee, thl_flux_tot !         close(12) !    end if ! end if end if do n = 1 , nsv call diffc_corr ( sv0 (:,:,:, n ), svp (:,:,:, n ), ihc , jhc , khc ) end do deallocate ( rhs ) if ( lwritefac . and . rk3step == 3 ) then if ( myid == 0 ) then fac_tau_x_av = fac_tau_x_av + dt * fac_tau_x fac_tau_y_av = fac_tau_y_av + dt * fac_tau_y fac_tau_z_av = fac_tau_z_av + dt * fac_tau_z fac_pres_av = fac_pres_av + dt * fac_pres fac_pres2_av = fac_pres2_av + dt * fac_pres2 fac_htc_av = fac_htc_av + dt * fac_htc fac_cth_av = fac_cth_av + dt * fac_cth if ( timee >= tnextfac ) then tfac = timee - tfac allocate ( varsfac ( nfcts , nstatfac )) varsfac (:, 1 ) = fac_tau_x_av ( 1 : nfcts ) / tfac varsfac (:, 2 ) = fac_tau_y_av ( 1 : nfcts ) / tfac varsfac (:, 3 ) = fac_tau_z_av ( 1 : nfcts ) / tfac varsfac (:, 4 ) = fac_pres_av ( 1 : nfcts ) / tfac varsfac (:, 5 ) = fac_htc_av ( 1 : nfcts ) / tfac varsfac (:, 6 ) = fac_cth_av ( 1 : nfcts ) / tfac varsfac (:, 7 ) = fac_pres2_av ( 1 : nfcts ) / tfac - ( fac_pres_av ( 1 : nfcts ) / dtfac * fac_pres_av ( 1 : nfcts ) / tfac ) call writestat_nc ( ncidfac , 1 , tncstatfac ,( / timee / ), nrecfac ,. true .) call writestat_1D_nc ( ncidfac , nstatfac , ncstatfac , varsfac , nrecfac , nfcts ) deallocate ( varsfac ) tfac = timee tnextfac = NINT (( timee + dtfac )) * 1.0 fac_tau_x_av = 0. fac_tau_y_av = 0. fac_tau_z_av = 0. fac_pres_av = 0. fac_pres2_av = 0. fac_htc_av = 0. fac_cth_av = 0. end if end if !myid end if end subroutine ibmwallfun","tags":"","url":"proc/ibmwallfun.html"},{"title":"wallfunmom – uDALES","text":"public  subroutine wallfunmom(dir, rhs, bound_info) Uses modmpi decomp_2d initfac modglobal modfields proc~~wallfunmom~~UsesGraph proc~wallfunmom wallfunmom decomp_2d decomp_2d proc~wallfunmom->decomp_2d module~initfac initfac proc~wallfunmom->module~initfac module~modfields modfields proc~wallfunmom->module~modfields module~modglobal modglobal proc~wallfunmom->module~modglobal module~modmpi modmpi proc~wallfunmom->module~modmpi module~initfac->module~modglobal module~initfac->module~modmpi mpi mpi module~initfac->mpi netcdf netcdf module~initfac->netcdf module~modfields->decomp_2d module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(in) :: dir (3) real, intent(inout) :: rhs (ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) type( bound_info_type ) :: bound_info Calls proc~~wallfunmom~~CallsGraph proc~wallfunmom wallfunmom mpi_allreduce mpi_allreduce proc~wallfunmom->mpi_allreduce proc~alignment alignment proc~wallfunmom->proc~alignment proc~is_equal is_equal proc~wallfunmom->proc~is_equal proc~local_coords local_coords proc~wallfunmom->proc~local_coords proc~mom_transfer_coef_neutral mom_transfer_coef_neutral proc~wallfunmom->proc~mom_transfer_coef_neutral proc~mom_transfer_coef_stability mom_transfer_coef_stability proc~wallfunmom->proc~mom_transfer_coef_stability proc~trilinear_interp_var trilinear_interp_var proc~wallfunmom->proc~trilinear_interp_var zstart zstart proc~wallfunmom->zstart proc~alignment->proc~is_equal proc~local_coords->proc~is_equal proc~cross_product cross_product proc~local_coords->proc~cross_product proc~trilinear_interp_var->zstart proc~eval_corners eval_corners proc~trilinear_interp_var->proc~eval_corners proc~trilinear_interp trilinear_interp proc~trilinear_interp_var->proc~trilinear_interp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~wallfunmom~~CalledByGraph proc~wallfunmom wallfunmom proc~ibmwallfun ibmwallfun proc~ibmwallfun->proc~wallfunmom program~dalesurban DALESURBAN program~dalesurban->proc~ibmwallfun Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine wallfunmom ( dir , rhs , bound_info ) use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , xf , yf , zf , xh , yh , zh , & eps1 , fkar , dx , dy , dzf , iwallmom , xhat , yhat , zhat , vec0 , nfcts , lwritefac , rk3step use modfields , only : u0 , v0 , w0 , thl0 , tau_x , tau_y , tau_z use initfac , only : facT , facz0 , facz0h , facnorm , faca use decomp_2d , only : zstart use modmpi , only : comm3d , mpi_sum , mpierr , my_real real , intent ( in ) :: dir ( 3 ) real , intent ( inout ) :: rhs ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ) type ( bound_info_type ) :: bound_info integer i , j , k , n , m , sec , pt , fac real dist , stress , stress_dir , stress_aligned , area , vol , momvol , Tair , Tsurf , x , y , z , & utan , udir , ctm , a , a_is , a_xn , a_yn , a_zn , stress_ix , stress_iy , stress_iz , xrec , yrec , zrec real , dimension ( 3 ) :: uvec , norm , strm , span , stressvec logical :: valid real , dimension ( 1 : nfcts ) :: fac_tau_loc , fac_tau !real, dimension(:), allocatable :: fac_tau, fac_pres procedure ( interp_velocity ), pointer :: interp_velocity_ptr => null () procedure ( interp_temperature ), pointer :: interp_temperature_ptr => null () select case ( alignment ( dir )) case ( 1 ) interp_velocity_ptr => interp_velocity_u interp_temperature_ptr => interp_temperature_u case ( 2 ) interp_velocity_ptr => interp_velocity_v interp_temperature_ptr => interp_temperature_v case ( 3 ) interp_velocity_ptr => interp_velocity_w interp_temperature_ptr => interp_temperature_w end select fac_tau_loc = 0. do sec = 1 , bound_info % nfctsecsrank !sec = bound_info%fctsecsrank(m) ! index of section !n = bound_info%secbndptids(sec) ! index of boundary point area = bound_info % secareas_loc ( sec ) ! area of section fac = bound_info % secfacids_loc ( sec ) ! index of facet norm = facnorm ( fac ,:) ! facet normal if ( bound_info % lskipsec_loc ( sec )) cycle !if (facz0(fac) < eps1) cycle ! i = bound_info%bndpts(n,1) - zstart(1) + 1 ! j = bound_info%bndpts(n,2) - zstart(2) + 1 ! k = bound_info%bndpts(n,3) - zstart(3) + 1 i = bound_info % secbndpts_loc ( sec , 1 ) - zstart ( 1 ) + 1 ! should be on this rank! j = bound_info % secbndpts_loc ( sec , 2 ) - zstart ( 2 ) + 1 ! should be on this rank! k = bound_info % secbndpts_loc ( sec , 3 ) - zstart ( 3 ) + 1 ! should be on this rank! if (( i < ib ) . or . ( i > ie ) . or . ( j < jb ) . or . ( j > je )) then write ( * , * ) \"problem in wallfunmom\" , alignment ( dir ), bound_info % secbndpts_loc ( sec , 1 ), bound_info % secbndpts_loc ( sec , 2 ) stop 1 end if if ( bound_info % lcomprec_loc ( sec ) . or . lnorec ) then uvec = interp_velocity_ptr ( i , j , k ) if ( iwallmom == 2 ) then Tair = interp_temperature_ptr ( i , j , k ) end if dist = bound_info % bnddst_loc ( sec ) else xrec = bound_info % recpts_loc ( sec , 1 ) yrec = bound_info % recpts_loc ( sec , 2 ) zrec = bound_info % recpts_loc ( sec , 3 ) uvec ( 1 ) = trilinear_interp_var ( u0 , bound_info % recids_u_loc ( sec ,:), xh , yf , zf , xrec , yrec , zrec ) uvec ( 2 ) = trilinear_interp_var ( v0 , bound_info % recids_v_loc ( sec ,:), xf , yh , zf , xrec , yrec , zrec ) uvec ( 3 ) = trilinear_interp_var ( w0 , bound_info % recids_w_loc ( sec ,:), xf , yf , zh , xrec , yrec , zrec ) if ( iwallmom == 2 ) Tair = trilinear_interp_var ( thl0 , bound_info % recids_c_loc ( sec ,:), xf , yf , zf , xrec , yrec , zrec ) dist = bound_info % bnddst_loc ( sec ) + norm2 (( / xrec - xf ( bound_info % secbndpts_loc ( sec , 1 )), & yrec - yf ( bound_info % secbndpts_loc ( sec , 2 )), & zrec - zf ( bound_info % secbndpts_loc ( sec , 3 )) / )) end if if ( log ( dist / facz0 ( fac )) <= 1. ) then cycle ! ideally would set a value for dist that gives a resonable (large) flux !dist = facz0(fac)+facz0h(fac) end if if ( is_equal ( uvec , vec0 )) cycle call local_coords ( uvec , norm , span , strm , valid ) if (. not . valid ) cycle utan = dot_product ( uvec , strm ) !utan = max(0.01, utan) ! uDALES 1 ! calcualate momentum transfer coefficient ! make into interface somehow? because iwallmom doesn't change in the loop if ( iwallmom == 2 ) then ! stability included ctm = mom_transfer_coef_stability ( utan , dist , facz0 ( fac ), facz0h ( fac ), Tair , facT ( fac , 1 )) else if ( iwallmom == 3 ) then ! neutral ctm = mom_transfer_coef_neutral ( dist , facz0 ( fac )) end if stress = ctm * utan ** 2 if ( bound_info % lcomprec_loc ( sec )) then a = dot_product ( dir , strm ) stress_dir = a * stress else ! Rotation from local (strm,span,norm) to global (xhat,yhat,zhat) basis ! \\tau'_ij = a_ip a_jq \\tau_pq ! \\tau_pq in local coordinates is something like \\tau \\delta_13, because we only have \\tau_{strm,norm}) a_is = dot_product ( dir , strm ) a_xn = dot_product ( xhat , norm ) a_yn = dot_product ( yhat , norm ) a_zn = dot_product ( zhat , norm ) stress_ix = a_is * a_xn * stress stress_iy = a_is * a_yn * stress stress_iz = a_is * a_zn * stress stressvec ( 1 ) = stress_ix stressvec ( 2 ) = stress_iy stressvec ( 3 ) = stress_iz stress_dir = norm2 ( stressvec ) end if stress_dir = sign ( stress_dir , dot_product ( uvec , dir )) vol = dx * dy * dzf ( k ) momvol = stress_dir * area / vol rhs ( i , j , k ) = rhs ( i , j , k ) - momvol fac_tau_loc ( fac ) = fac_tau_loc ( fac ) + stress_dir * area ! output stresses on facets end do if ( lwritefac . and . rk3step == 3 ) then fac_tau_loc ( 1 : nfcts ) = fac_tau_loc ( 1 : nfcts ) / faca ( 1 : nfcts ) call MPI_ALLREDUCE ( fac_tau_loc ( 1 : nfcts ), fac_tau ( 1 : nfcts ), nfcts , MY_REAL , MPI_SUM , comm3d , mpierr ) select case ( alignment ( dir )) case ( 1 ) fac_tau_x = fac_tau case ( 2 ) fac_tau_y = fac_tau case ( 3 ) fac_tau_z = fac_tau end select end if ! Do time-averaging like in modEB end subroutine wallfunmom","tags":"","url":"proc/wallfunmom.html"},{"title":"wallfunheat – uDALES","text":"public  subroutine wallfunheat() Uses modmpi modsurfdata decomp_2d initfac modibmdata modglobal modfields proc~~wallfunheat~~UsesGraph proc~wallfunheat wallfunheat decomp_2d decomp_2d proc~wallfunheat->decomp_2d module~initfac initfac proc~wallfunheat->module~initfac module~modfields modfields proc~wallfunheat->module~modfields module~modglobal modglobal proc~wallfunheat->module~modglobal module~modibmdata modibmdata proc~wallfunheat->module~modibmdata module~modmpi modmpi proc~wallfunheat->module~modmpi module~modsurfdata modsurfdata proc~wallfunheat->module~modsurfdata module~initfac->module~modglobal module~initfac->module~modmpi mpi mpi module~initfac->mpi netcdf netcdf module~initfac->netcdf module~modfields->decomp_2d module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~wallfunheat~~CallsGraph proc~wallfunheat wallfunheat mpi_allreduce mpi_allreduce proc~wallfunheat->mpi_allreduce proc~heat_transfer_coef_flux heat_transfer_coef_flux proc~wallfunheat->proc~heat_transfer_coef_flux proc~interp_velocity_c interp_velocity_c proc~wallfunheat->proc~interp_velocity_c proc~is_equal is_equal proc~wallfunheat->proc~is_equal proc~local_coords local_coords proc~wallfunheat->proc~local_coords proc~moist_flux moist_flux proc~wallfunheat->proc~moist_flux proc~trilinear_interp_var trilinear_interp_var proc~wallfunheat->proc~trilinear_interp_var zstart zstart proc~wallfunheat->zstart proc~local_coords->proc~is_equal proc~cross_product cross_product proc~local_coords->proc~cross_product proc~trilinear_interp_var->zstart proc~eval_corners eval_corners proc~trilinear_interp_var->proc~eval_corners proc~trilinear_interp trilinear_interp proc~trilinear_interp_var->proc~trilinear_interp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~wallfunheat~~CalledByGraph proc~wallfunheat wallfunheat proc~ibmwallfun ibmwallfun proc~ibmwallfun->proc~wallfunheat program~dalesurban DALESURBAN program~dalesurban->proc~ibmwallfun Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine wallfunheat use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , xf , yf , zf , xh , yh , zh , dx , dy , dzh , eps1 , & xhat , yhat , zhat , vec0 , fkar , ltempeq , lmoist , iwalltemp , iwallmoist , lEB , lwritefac , nfcts , rk3step , totheatflux , totqflux use modfields , only : u0 , v0 , w0 , thl0 , thlp , qt0 , qtp , pres0 use initfac , only : facT , facz0 , facz0h , facnorm , fachf , facef , facqsat , fachurel , facf , faclGR , faca use modmpi , only : comm3d , mpi_sum , mpierr , my_real use modsurfdata , only : z0 , z0h use modibmdata , only : bctfxm , bctfxp , bctfym , bctfyp , bctfz use decomp_2d , only : zstart integer i , j , k , n , m , sec , fac real :: dist , flux , area , vol , tempvol , Tair , Tsurf , utan , cth , htc , cveg , hurel , qtair , qwall , resa , resc , ress , xrec , yrec , zrec real , dimension ( 3 ) :: uvec , norm , span , strm real , dimension ( 1 : nfcts ) :: fac_htc_loc , fac_cth_loc , fac_pres_loc , fac_pres2_loc logical :: valid fac_htc_loc = 0. fac_cth_loc = 0. fac_pres_loc = 0. fac_pres2_loc = 0. do sec = 1 , bound_info_c % nfctsecsrank ! sec = bound_info_c%fctsecsrank(m) ! index of section !n =   bound_info_c%secbndptids(sec) ! index of boundary point fac = bound_info_c % secfacids_loc ( sec ) ! index of facet area = bound_info_c % secareas_loc ( sec ) ! area norm = facnorm ( fac ,:) ! i = bound_info_c%bndpts(n,1) - zstart(1) + 1 ! should be on this rank! ! j = bound_info_c%bndpts(n,2) - zstart(2) + 1 ! should be on this rank! ! k = bound_info_c%bndpts(n,3) - zstart(3) + 1 ! should be on this rank! i = bound_info_c % secbndpts_loc ( sec , 1 ) - zstart ( 1 ) + 1 ! should be on this rank! j = bound_info_c % secbndpts_loc ( sec , 2 ) - zstart ( 2 ) + 1 ! should be on this rank! k = bound_info_c % secbndpts_loc ( sec , 3 ) - zstart ( 3 ) + 1 ! should be on this rank! if (( i < ib ) . or . ( i > ie ) . or . ( j < jb ) . or . ( j > je )) then write ( * , * ) \"problem in wallfunheat\" , i , j stop 1 end if fac_pres_loc ( fac ) = fac_pres_loc ( fac ) + pres0 ( i , j , k ) * area ! output pressure on facets fac_pres2_loc ( fac ) = fac_pres2_loc ( fac ) + pres0 ( i , j , k ) * pres0 ( i , j , k ) * area if ( bound_info_c % lskipsec_loc ( sec )) cycle !if (facz0(fac) < eps1) cycle if ( bound_info_c % lcomprec_loc ( sec ) . or . lnorec ) then ! section aligned with grid - use this cell's velocity uvec = interp_velocity_c ( i , j , k ) Tair = thl0 ( i , j , k ) qtair = qt0 ( i , j , k ) dist = bound_info_c % bnddst_loc ( sec ) else ! use velocity at reconstruction point xrec = bound_info_c % recpts_loc ( sec , 1 ) yrec = bound_info_c % recpts_loc ( sec , 2 ) zrec = bound_info_c % recpts_loc ( sec , 3 ) uvec ( 1 ) = trilinear_interp_var ( u0 , bound_info_c % recids_u_loc ( sec ,:), xh , yf , zf , xrec , yrec , zrec ) uvec ( 2 ) = trilinear_interp_var ( v0 , bound_info_c % recids_v_loc ( sec ,:), xf , yh , zf , xrec , yrec , zrec ) uvec ( 3 ) = trilinear_interp_var ( w0 , bound_info_c % recids_w_loc ( sec ,:), xf , yf , zh , xrec , yrec , zrec ) Tair = trilinear_interp_var ( thl0 , bound_info_c % recids_c_loc ( sec ,:), xf , yf , zf , xrec , yrec , zrec ) qtair = trilinear_interp_var ( qt0 , bound_info_c % recids_c_loc ( sec ,:), xf , yf , zf , xrec , yrec , zrec ) ! dist = bound_info_c%bnddst(sec) + norm2((/xrec - xf(bound_info_c%bndpts(n,1)), & !                                           yrec - yf(bound_info_c%bndpts(n,2)), & !                                           zrec - zf(bound_info_c%bndpts(n,3))/)) dist = bound_info_c % bnddst_loc ( sec ) + norm2 (( / xrec - xf ( bound_info_c % secbndpts_loc ( sec , 1 )), & yrec - yf ( bound_info_c % secbndpts_loc ( sec , 2 )), & zrec - zf ( bound_info_c % secbndpts_loc ( sec , 3 )) / )) end if if ( log ( dist / facz0 ( fac )) <= 1. ) then cycle !dist = facz0(fac)+facz0h(fac) end if if ( is_equal ( uvec , vec0 )) cycle call local_coords ( uvec , norm , span , strm , valid ) if (. not . valid ) cycle utan = dot_product ( uvec , strm ) !utan = max(0.01, utan) ! uDALES 1 ! Sensible heat if ( ltempeq ) then if ( iwalltemp == 1 ) then ! probably remove this eventually, only relevant to grid-aligned facets !if     (all(abs(norm - xhat) < eps1)) then if ( is_equal ( norm , xhat )) then flux = bctfxp !elseif (all(abs(norm + xhat) < eps1)) then elseif ( is_equal ( norm , - xhat )) then flux = bctfxm !elseif (all(abs(norm - yhat) < eps1)) then elseif ( is_equal ( norm , yhat )) then flux = bctfyp !elseif (all(abs(norm + yhat) < eps1)) then elseif ( is_equal ( norm , - yhat )) then flux = bctfxm !elseif (all(abs(norm - zhat) < eps1)) then elseif ( is_equal ( norm , zhat )) then flux = bctfz end if elseif ( iwalltemp == 2 ) then call heat_transfer_coef_flux ( utan , dist , facz0 ( fac ), facz0h ( fac ), Tair , facT ( fac , 1 ), cth , flux , htc ) fac_cth_loc ( fac ) = fac_cth_loc ( fac ) + cth * area ! output heat transfer coefficients on facets fac_htc_loc ( fac ) = fac_htc_loc ( fac ) + htc * area ! output heat transfer coefficients on facets end if ! flux [Km/s] ! fluid volumetric sensible heat source/sink = flux * area / volume [K/s] ! facet sensible heat flux = volumetric heat capacity of air * flux * sectionarea / facetarea [W/m&#94;2] thlp ( i , j , k ) = thlp ( i , j , k ) - flux * area / ( dx * dy * dzh ( k )) if ( lEB ) then totheatflux = totheatflux + flux * area ! [Km&#94;3s&#94;-1] This sums the flux over all facets fachf ( fac ) = fachf ( fac ) + flux * area ! [Km&#94;2/s] (will be divided by facetarea(fac) in modEB) end if end if ! Latent heat if ( lmoist . and . faclGR ( fac )) then if ( iwallmoist == 1 ) then ! probably remove this eventually, only relevant to grid-aligned facets if ( is_equal ( norm , xhat )) then flux = bcqfxp elseif ( is_equal ( norm , - xhat )) then flux = bcqfxm elseif ( is_equal ( norm , yhat )) then flux = bcqfyp elseif ( is_equal ( norm , - yhat )) then flux = bcqfym elseif ( is_equal ( norm , zhat )) then flux = bcqfz end if elseif ( iwallmoist == 2 ) then if ( abs ( htc * abs ( utan )) > 0. ) then qwall = facqsat ( fac ) ! saturation humidity hurel = fachurel ( fac ) ! relative humidity resa = 1. / ( htc * abs ( utan )) ! aerodynamic resistance resc = facf ( fac , 4 ) ! canopy resistance ress = facf ( fac , 5 ) ! soil resistance cveg = 0.8 ! vegetation fraction flux = moist_flux ( cveg , resa , qtair , qwall , hurel , resc , ress ) end if end if ! flux [kg/kg m/s] ! fluid volumetric latent heat source/sink = flux * area / volume [kg/kg / s] ! facet latent heat flux = volumetric heat capacity of air * flux * sectionarea / facetarea [W/m&#94;2] totqflux = totqflux + flux * area ! [Km&#94;3s&#94;-1] This sums the flux over all facets qtp ( i , j , k ) = qtp ( i , j , k ) - flux * area / ( dx * dy * dzh ( k )) if ( lEB ) then facef ( fac ) = facef ( fac ) + flux * area ! [Km&#94;2/s] (will be divided by facetarea(fac) in modEB) end if end if end do if ( lwritefac . and . rk3step == 3 ) then fac_cth_loc ( 1 : nfcts ) = fac_cth_loc ( 1 : nfcts ) / faca ( 1 : nfcts ) fac_htc_loc ( 1 : nfcts ) = fac_htc_loc ( 1 : nfcts ) / faca ( 1 : nfcts ) fac_pres_loc ( 1 : nfcts ) = fac_pres_loc ( 1 : nfcts ) / faca ( 1 : nfcts ) fac_pres2_loc ( 1 : nfcts ) = fac_pres2_loc ( 1 : nfcts ) / faca ( 1 : nfcts ) call MPI_ALLREDUCE ( fac_cth_loc ( 1 : nfcts ), fac_cth ( 1 : nfcts ), nfcts , MY_REAL , MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( fac_htc_loc ( 1 : nfcts ), fac_htc ( 1 : nfcts ), nfcts , MY_REAL , MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( fac_pres_loc ( 1 : nfcts ), fac_pres ( 1 : nfcts ), nfcts , MY_REAL , MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( fac_pres2_loc ( 1 : nfcts ), fac_pres2 ( 1 : nfcts ), nfcts , MY_REAL , MPI_SUM , comm3d , mpierr ) end if end subroutine wallfunheat","tags":"","url":"proc/wallfunheat.html"},{"title":"local_coords – uDALES","text":"public  subroutine local_coords(uvec, norm, span, strm, valid) Uses modglobal proc~~local_coords~~UsesGraph proc~local_coords local_coords module~modglobal modglobal proc~local_coords->module~modglobal Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(in), dimension(3) :: uvec real, intent(in), dimension(3) :: norm real, intent(out), dimension(3) :: span real, intent(out), dimension(3) :: strm logical, intent(out) :: valid Calls proc~~local_coords~~CallsGraph proc~local_coords local_coords proc~cross_product cross_product proc~local_coords->proc~cross_product proc~is_equal is_equal proc~local_coords->proc~is_equal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~local_coords~~CalledByGraph proc~local_coords local_coords proc~wallfunheat wallfunheat proc~wallfunheat->proc~local_coords proc~wallfunmom wallfunmom proc~wallfunmom->proc~local_coords proc~ibmwallfun ibmwallfun proc~ibmwallfun->proc~wallfunheat proc~ibmwallfun->proc~wallfunmom program~dalesurban DALESURBAN program~dalesurban->proc~ibmwallfun Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine local_coords ( uvec , norm , span , strm , valid ) ! returns the local streamwise (strm) and spanwise vectors (span) in the ! plane normal to (norm) containing the velocity vector (uvec) use modglobal , only : vec0 real , intent ( in ), dimension ( 3 ) :: uvec , norm real , intent ( out ), dimension ( 3 ) :: span , strm logical , intent ( out ) :: valid span = cross_product ( norm , uvec ) !if (is_equal(span, (/0.,0.,0./))) then ! velocity is pointing into or outof the surface if ( is_equal ( span , vec0 )) then strm = 0. valid = . false . else span = span / norm2 ( span ) valid = . true . end if strm = cross_product ( span , norm ) end subroutine local_coords","tags":"","url":"proc/local_coords.html"},{"title":"heat_transfer_coef_flux – uDALES","text":"public  subroutine heat_transfer_coef_flux(utan, dist, z0, z0h, Tair, Tsurf, cth, flux, htc) Uses modglobal proc~~heat_transfer_coef_flux~~UsesGraph proc~heat_transfer_coef_flux heat_transfer_coef_flux module~modglobal modglobal proc~heat_transfer_coef_flux->module~modglobal Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(in) :: utan real, intent(in) :: dist real, intent(in) :: z0 real, intent(in) :: z0h real, intent(in) :: Tair real, intent(in) :: Tsurf real, intent(out) :: cth real, intent(out) :: flux real, intent(out) :: htc Called by proc~~heat_transfer_coef_flux~~CalledByGraph proc~heat_transfer_coef_flux heat_transfer_coef_flux proc~wallfunheat wallfunheat proc~wallfunheat->proc~heat_transfer_coef_flux proc~ibmwallfun ibmwallfun proc~ibmwallfun->proc~wallfunheat program~dalesurban DALESURBAN program~dalesurban->proc~ibmwallfun Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine heat_transfer_coef_flux ( utan , dist , z0 , z0h , Tair , Tsurf , cth , flux , htc ) use modglobal , only : grav , fkar , prandtlturb implicit none real , intent ( in ) :: dist , z0 , z0h , Tsurf , Tair , utan real , intent ( out ) :: cth , flux , htc real , parameter :: b1 = 9.4 !parameters from Uno1995 real , parameter :: b2 = 4.7 real , parameter :: dm = 7.4 real , parameter :: dh = 5.3 !real :: Pr real :: dT , Ribl0 , logdz , logdzh , logzh , sqdz , fkar2 , Ribl1 , Fm , Fh , cm , ch , M , dTrough !Pr = 1. !Pr = prandtlmol dT = Tair - Tsurf Ribl0 = grav * dist * dT / ( Tsurf * utan ** 2 ) !Eq. 6, guess initial Ri logdz = log ( dist / z0 ) logdzh = log ( dist / z0h ) logzh = log ( z0 / z0h ) sqdz = sqrt ( dist / z0 ) fkar2 = fkar ** 2 cth = 0. flux = 0. if ( Ribl0 > 0. ) then Fm = 1. / ( 1. + b2 * Ribl0 ) ** 2 !Eq. 4 Fh = Fm !Eq. 4 else ! => unstable cm = ( dm * fkar2 ) / ( logdz ** 2 ) * b1 * sqdz !Eq. 5 ch = ( dh * fkar2 ) / ( logdz ** 2 ) * b1 * sqdz !Eq. 5 Fm = 1. - ( b1 * Ribl0 ) / ( 1. + cm * sqrt ( abs ( Ribl0 ))) !Eq. 3 Fh = 1. - ( b1 * Ribl0 ) / ( 1. + ch * sqrt ( abs ( Ribl0 ))) !Eq. 3 end if M = prandtlturb * logdz * sqrt ( Fm ) / Fh !Eq. 14 Ribl1 = Ribl0 - Ribl0 * prandtlturb * logzh / ( prandtlturb * logzh + M ) !Eq. 17 !interate to get new Richardson number if ( Ribl1 > 0. ) then Fm = 1. / ( 1. + b2 * Ribl1 ) ** 2 !Eq. 4 Fh = Fm !Eq. 4 else ! => unstable cm = ( dm * fkar2 ) / ( logdz ** 2 ) * b1 * sqdz !Eq. 5 ch = ( dh * fkar2 ) / ( logdz ** 2 ) * b1 * sqdz !Eq. 5 Fm = 1. - ( b1 * Ribl1 ) / ( 1. + cm * sqrt ( abs ( Ribl1 ))) !Eq. 3 Fh = 1. - ( b1 * Ribl1 ) / ( 1. + ch * sqrt ( abs ( Ribl1 ))) !Eq. 3 end if ! Uno (2) M = prandtlturb * logdz * sqrt ( Fm ) / Fh !Eq. 14 dTrough = dT * 1. / ( prandtlturb * logzh / M + 1. ) !Eq. 13a cth = fkar2 / ( logdz * logdz ) * Fh / prandtlturb ! Ivo's heat transfer coefficient flux = abs ( utan ) * cth * dTrough if ( abs ( abs ( utan ) * dT ) > 0. ) then htc = flux / ( abs ( utan ) * dT ) else htc = 0. end if ! ! Uno (8) ! cth = abs(utan)*fkar2/(logdz*logdzh)*Fh/prandtlturb !Eq. 8 ! flux = cth*dT !Eq. 2, Eq. 8 end subroutine heat_transfer_coef_flux","tags":"","url":"proc/heat_transfer_coef_flux.html"},{"title":"bottom – uDALES","text":"public  subroutine bottom() Uses modmpi modsubgriddata modsurfdata modglobal modfields proc~~bottom~~UsesGraph proc~bottom bottom module~modfields modfields proc~bottom->module~modfields module~modglobal modglobal proc~bottom->module~modglobal module~modmpi modmpi proc~bottom->module~modmpi module~modsubgriddata modsubgriddata proc~bottom->module~modsubgriddata module~modsurfdata modsurfdata proc~bottom->module~modsurfdata decomp_2d decomp_2d module~modfields->decomp_2d mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~bottom~~CallsGraph proc~bottom bottom wfmneutral wfmneutral proc~bottom->wfmneutral wfuno wfuno proc~bottom->wfuno Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~bottom~~CalledByGraph proc~bottom bottom program~dalesurban DALESURBAN program~dalesurban->proc~bottom Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine bottom ! By Ivo Suter. !kind of obsolete when road facets are being used !vegetated floor not added (could simply be copied from vegetated horizontal facets) use modglobal , only : ib , ie , ih , jh , kb , ke , kh , jb , je , kb , numol , prandtlmol , dzh , nsv , & dxf , dxhi , dzf , dzfi , numoli , ltempeq , khc , lmoist , BCbotT , BCbotq , BCbotm , BCbots , dzh2i , libm use modfields , only : u0 , v0 , e120 , um , vm , w0 , wm , e12m , thl0 , qt0 , sv0 , thlm , qtm , svm , up , vp , wp , thlp , qtp , svp , shear , momfluxb , tfluxb , cth , tau_x , tau_y , tau_z , thl_flux use modsurfdata , only : thlflux , qtflux , svflux , ustar , thvs , wtsurf , wqsurf , thls , z0 , z0h use modsubgriddata , only : ekm , ekh use modmpi , only : myid implicit none integer :: i , j , jp , jm , m e120 (:, :, kb - 1 ) = e120 (:, :, kb ) e12m (:, :, kb - 1 ) = e12m (:, :, kb ) ! wm(:, :, kb) = 0. ! SO moved to modboundary ! w0(:, :, kb) = 0. tau_x (:,:, kb : ke + kh ) = up tau_y (:,:, kb : ke + kh ) = vp tau_z (:,:, kb : ke + kh ) = wp thl_flux (:,:, kb : ke + kh ) = thlp !if (.not.(libm)) then if ( lbottom ) then !momentum if ( BCbotm . eq . 2 ) then call wfuno ( ih , jh , kh , up , vp , thlp , momfluxb , tfluxb , cth , bcTfluxA , u0 , v0 , thl0 , thls , z0 , z0h , 0 , 1 , 91 ) elseif ( BCbotm . eq . 3 ) then call wfmneutral ( ih , jh , kh , up , vp , momfluxb , u0 , v0 , z0 , 0 , 1 , 91 ) else write ( 0 , * ) \"ERROR: bottom boundary type for momentum undefined\" stop 1 end if if ( ltempeq ) then if ( BCbotT . eq . 1 ) then !neumann/fixed flux bc for temperature do j = jb , je do i = ib , ie thlp ( i , j , kb ) = thlp ( i , j , kb ) & + ( & 0.5 * ( dzf ( kb - 1 ) * ekh ( i , j , kb ) + dzf ( kb ) * ekh ( i , j , kb - 1 )) & * ( thl0 ( i , j , kb ) - thl0 ( i , j , kb - 1 )) & * dzh2i ( kb ) & - wtsurf & ) * dzfi ( kb ) end do end do else if ( BCbotT . eq . 2 ) then !wall function bc for temperature (fixed temperature) call wfuno ( ih , jh , kh , up , vp , thlp , momfluxb , tfluxb , cth , bcTfluxA , u0 , v0 , thl0 , thls , z0 , z0h , 0 , 1 , 92 ) else write ( 0 , * ) \"ERROR: bottom boundary type for temperature undefined\" stop 1 end if end if ! ltempeq if ( lmoist ) then if ( BCbotq . eq . 1 ) then !neumann/fixed flux bc for moisture do j = jb , je do i = ib , ie qtp ( i , j , kb ) = qtp ( i , j , kb ) + ( & 0.5 * ( dzf ( kb - 1 ) * ekh ( i , j , kb ) + dzf ( kb ) * ekh ( i , j , kb - 1 )) & * ( qt0 ( i , j , kb ) - qt0 ( i , j , kb - 1 )) & * dzh2i ( kb ) & + wqsurf & ) * dzfi ( kb ) end do end do else write ( 0 , * ) \"ERROR: bottom boundary type for moisture undefined\" stop 1 end if ! end if !lmoist if ( nsv > 0 ) then if ( BCbots . eq . 1 ) then !neumann/fixed flux bc for moisture do j = jb , je do i = ib , ie do m = 1 , nsv svp ( i , j , kb , m ) = svp ( i , j , kb , m ) + ( & 0.5 * ( dzf ( kb - 1 ) * ekh ( i , j , kb ) + dzf ( kb ) * ekh ( i , j , kb - 1 )) & * ( sv0 ( i , j , kb , m ) - sv0 ( i , j , kb - 1 , m )) & * dzh2i ( kb ) & + 0. & ) * dzfi ( kb ) end do end do end do else write ( 0 , * ) \"ERROR: bottom boundary type for scalars undefined\" stop 1 end if ! end if end if tau_x (:,:, kb : ke + kh ) = up - tau_x (:,:, kb : ke + kh ) tau_y (:,:, kb : ke + kh ) = vp - tau_y (:,:, kb : ke + kh ) tau_z (:,:, kb : ke + kh ) = wp - tau_z (:,:, kb : ke + kh ) thl_flux (:,:, kb : ke + kh ) = thlp - thl_flux (:,:, kb : ke + kh ) return end subroutine bottom","tags":"","url":"proc/bottom.html"},{"title":"createmasks – uDALES","text":"public  subroutine createmasks() Uses decomp_2d modfields modmpi modglobal proc~~createmasks~~UsesGraph proc~createmasks createmasks decomp_2d decomp_2d proc~createmasks->decomp_2d module~modfields modfields proc~createmasks->module~modfields module~modglobal modglobal proc~createmasks->module~modglobal module~modmpi modmpi proc~createmasks->module~modmpi module~modfields->decomp_2d mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~createmasks~~CallsGraph proc~createmasks createmasks mpi_allreduce mpi_allreduce proc~createmasks->mpi_allreduce zstart zstart proc~createmasks->zstart Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~createmasks~~CalledByGraph proc~createmasks createmasks program~dalesurban DALESURBAN program~dalesurban->proc~createmasks Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine createmasks use modglobal , only : libm , ib , ie , ih , ihc , jb , je , jh , jhc , kb , ke , kh , khc , itot , jtot , rslabs use modfields , only : IIc , IIu , IIv , IIw , IIuw , IIvw , IIuv , & IIcs , IIus , IIvs , IIws , IIuws , IIvws , IIuvs , & IIct , IIut , IIvt , IIwt , IIuwt , um , u0 , vm , v0 , wm , w0 use modmpi , only : myid , comm3d , mpierr , MY_REAL , nprocs use decomp_2d , only : zstart , exchange_halo_z integer :: IIcl ( kb : ke + khc ), IIul ( kb : ke + khc ), IIvl ( kb : ke + khc ), IIwl ( kb : ke + khc ), IIuwl ( kb : ke + khc ), IIvwl ( kb : ke + khc ), IIuvl ( kb : ke + khc ) integer :: IIcd ( ib : ie , kb : ke ) integer :: IIwd ( ib : ie , kb : ke ) integer :: IIuwd ( ib : ie , kb : ke ) integer :: IIud ( ib : ie , kb : ke ) integer :: IIvd ( ib : ie , kb : ke ) integer :: i , j , k , n , m ! II*l needn't be defined up to ke_khc, but for now would require large scale changes in modstatsdump so if works leave as is ! tg3315 04/07/18 if (. not . libm ) then IIc (:, :, :) = 1 IIu (:, :, :) = 1 IIv (:, :, :) = 1 IIw (:, :, :) = 1 IIuw (:, :, :) = 1 IIvw (:, :, :) = 1 IIuv (:, :, :) = 1 IIcs (:) = nint ( rslabs ) IIus (:) = nint ( rslabs ) IIvs (:) = nint ( rslabs ) IIws (:) = nint ( rslabs ) IIuws (:) = nint ( rslabs ) IIvws (:) = nint ( rslabs ) IIuvs (:) = nint ( rslabs ) IIct (:, :) = jtot IIut (:, :) = jtot IIvt (:, :) = jtot IIwt (:, :) = jtot IIuwt (:, :) = jtot return end if ! Create masking matrices IIc = 1 ; IIu = 1 ; IIv = 1 ; IIct = 1 ; IIw = 1 ; IIuw = 1 ; IIvw = 1 ; IIuv = 1 ; IIwt = 1 ; IIut = 1 ; IIvt = 1 ; IIuwt = 1 ; IIcs = 1 ; IIus = 1 ; IIvs = 1 ; IIws = 1 ; IIuws = 1 ; IIvws = 1 ; IIuvs = 1 do n = 1 , solid_info_u % nsolptsrank !n = solid_info_u%solptsrank(m) i = solid_info_u % solpts_loc ( n , 1 ) - zstart ( 1 ) + 1 j = solid_info_u % solpts_loc ( n , 2 ) - zstart ( 2 ) + 1 k = solid_info_u % solpts_loc ( n , 3 ) - zstart ( 3 ) + 1 IIu ( i , j , k ) = 0 end do do n = 1 , solid_info_v % nsolptsrank !n = solid_info_v%solptsrank(m) i = solid_info_v % solpts_loc ( n , 1 ) - zstart ( 1 ) + 1 j = solid_info_v % solpts_loc ( n , 2 ) - zstart ( 2 ) + 1 k = solid_info_v % solpts_loc ( n , 3 ) - zstart ( 3 ) + 1 IIv ( i , j , k ) = 0 end do do n = 1 , solid_info_w % nsolptsrank !n = solid_info_w%solptsrank(m) i = solid_info_w % solpts_loc ( n , 1 ) - zstart ( 1 ) + 1 j = solid_info_w % solpts_loc ( n , 2 ) - zstart ( 2 ) + 1 k = solid_info_w % solpts_loc ( n , 3 ) - zstart ( 3 ) + 1 IIw ( i , j , k ) = 0 end do do n = 1 , solid_info_c % nsolptsrank !n = solid_info_c%solptsrank(m) i = solid_info_c % solpts_loc ( n , 1 ) - zstart ( 1 ) + 1 j = solid_info_c % solpts_loc ( n , 2 ) - zstart ( 2 ) + 1 k = solid_info_c % solpts_loc ( n , 3 ) - zstart ( 3 ) + 1 IIc ( i , j , k ) = 0 end do IIw (:, :, kb ) = 0 ; IIuw (:, :, kb ) = 0 ; IIvw (:, :, kb ) = 0 do i = ib , ie do j = jb , je IIuv ( i , j , kb ) = IIu ( i , j , kb ) * IIu ( i , j - 1 , kb ) * IIv ( i , j , kb ) * IIv ( i - 1 , j , kb ) do k = kb + 1 , ke ! Classed as solid (set to zero) unless ALL points in the stencil are fluid IIuv ( i , j , k ) = IIu ( i , j , k ) * IIu ( i , j - 1 , k ) * IIv ( i , j , k ) * IIv ( i - 1 , j , k ) IIuw ( i , j , k ) = IIu ( i , j , k ) * IIu ( i , j , k - 1 ) * IIw ( i , j , k ) * IIw ( i - 1 , j , k ) IIvw ( i , j , k ) = IIv ( i , j , k ) * IIv ( i , j , k - 1 ) * IIw ( i , j , k ) * IIw ( i , j - 1 , k ) end do end do end do ! Can't do this because no interface for integers ! call exchange_halo_z(IIuv, opt_zlevel=(/ihc,jhc,0/)) ! call exchange_halo_z(IIuv, opt_zlevel=(/ihc,jhc,0/)) ! call exchange_halo_z(IIvw, opt_zlevel=(/ihc,jhc,0/)) do k = kb , ke + khc IIcl ( k ) = sum ( IIc ( ib : ie , jb : je , k )) IIul ( k ) = sum ( IIu ( ib : ie , jb : je , k )) IIvl ( k ) = sum ( IIv ( ib : ie , jb : je , k )) IIwl ( k ) = sum ( IIw ( ib : ie , jb : je , k )) IIuwl ( k ) = sum ( IIuw ( ib : ie , jb : je , k )) IIvwl ( k ) = sum ( IIvw ( ib : ie , jb : je , k )) IIuvl ( k ) = sum ( IIuv ( ib : ie , jb : je , k )) enddo call MPI_ALLREDUCE ( IIcl , IIcs , ke + khc - kb + 1 , MPI_INTEGER , & MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( IIul , IIus , ke + khc - kb + 1 , MPI_INTEGER , & MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( IIvl , IIvs , ke + khc - kb + 1 , MPI_INTEGER , & MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( IIwl , IIws , ke + khc - kb + 1 , MPI_INTEGER , & MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( IIuwl , IIuws , ke + khc - kb + 1 , MPI_INTEGER , & MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( IIvwl , IIvws , ke + khc - kb + 1 , MPI_INTEGER , & MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( IIuvl , IIuvs , ke + khc - kb + 1 , MPI_INTEGER , & MPI_SUM , comm3d , mpierr ) IIcd ( ib : ie , kb : ke ) = sum ( IIc ( ib : ie , jb : je , kb : ke ), DIM = 2 ) IIwd ( ib : ie , kb : ke ) = sum ( IIw ( ib : ie , jb : je , kb : ke ), DIM = 2 ) IIuwd ( ib : ie , kb : ke ) = sum ( IIuw ( ib : ie , jb : je , kb : ke ), DIM = 2 ) IIud ( ib : ie , kb : ke ) = sum ( IIu ( ib : ie , jb : je , kb : ke ), DIM = 2 ) IIvd ( ib : ie , kb : ke ) = sum ( IIv ( ib : ie , jb : je , kb : ke ), DIM = 2 ) call MPI_ALLREDUCE ( IIwd ( ib : ie , kb : ke ), IIwt ( ib : ie , kb : ke ), ( ke - kb + 1 ) * ( ie - ib + 1 ), MPI_INTEGER , MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( IIcd ( ib : ie , kb : ke ), IIct ( ib : ie , kb : ke ), ( ke - kb + 1 ) * ( ie - ib + 1 ), MPI_INTEGER , MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( IIuwd ( ib : ie , kb : ke ), IIuwt ( ib : ie , kb : ke ), ( ke - kb + 1 ) * ( ie - ib + 1 ), MPI_INTEGER , MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( IIud ( ib : ie , kb : ke ), IIut ( ib : ie , kb : ke ), ( ke - kb + 1 ) * ( ie - ib + 1 ), MPI_INTEGER , MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( IIvd ( ib : ie , kb : ke ), IIvt ( ib : ie , kb : ke ), ( ke - kb + 1 ) * ( ie - ib + 1 ), MPI_INTEGER , MPI_SUM , comm3d , mpierr ) end subroutine createmasks","tags":"","url":"proc/createmasks.html"},{"title":"initsubgrid – uDALES","text":"public  subroutine initsubgrid() Uses modmpi modglobal proc~~initsubgrid~~UsesGraph proc~initsubgrid initsubgrid module~modglobal modglobal proc~initsubgrid->module~modglobal module~modmpi modmpi proc~initsubgrid->module~modmpi mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~initsubgrid~~CallsGraph proc~initsubgrid initsubgrid proc~subgridnamelist subgridnamelist proc~initsubgrid->proc~subgridnamelist mpi_bcast mpi_bcast proc~subgridnamelist->mpi_bcast Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~initsubgrid~~CalledByGraph proc~initsubgrid initsubgrid program~dalesurban DALESURBAN program~dalesurban->proc~initsubgrid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine initsubgrid use modglobal , only : ih , ib , ie , jh , jb , je , kb , ke , kh , delta , zf , fkar , & pi , ifnamopt , fname_options use modmpi , only : myid implicit none integer :: i , k real :: ceps , ch real :: mlen call subgridnamelist allocate ( ekm ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( ekh ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( zlt ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( sbdiss ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( sbshr ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( sbbuo ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( csz ( ib - ih : ie + ih , kb : ke + kh )) allocate ( damp ( ib : ie , jb : je , kb : ke )) damp = 1. cm = cf / ( 2. * pi ) * ( 1.5 * alpha_kolm ) ** ( - 1.5 ) ch = prandtl ch2 = ch - ch1 ceps = 2. * pi / cf * ( 1.5 * alpha_kolm ) ** ( - 1.5 ) ce1 = ( cn ** 2 ) * ( cm / Rigc - ch1 * cm ) ce2 = ceps - ce1 if ( cs == - 1. ) then csz (:,:) = ( cm ** 3 / ceps ) ** 0.25 !< Smagorinsky constant else csz (:,:) = cs end if end subroutine initsubgrid","tags":"","url":"proc/initsubgrid.html"},{"title":"subgridnamelist – uDALES","text":"public  subroutine subgridnamelist() Uses modmpi modglobal proc~~subgridnamelist~~UsesGraph proc~subgridnamelist subgridnamelist module~modglobal modglobal proc~subgridnamelist->module~modglobal module~modmpi modmpi proc~subgridnamelist->module~modmpi mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~subgridnamelist~~CallsGraph proc~subgridnamelist subgridnamelist mpi_bcast mpi_bcast proc~subgridnamelist->mpi_bcast Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~subgridnamelist~~CalledByGraph proc~subgridnamelist subgridnamelist proc~initsubgrid initsubgrid proc~initsubgrid->proc~subgridnamelist program~dalesurban DALESURBAN program~dalesurban->proc~initsubgrid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Namelists Namelist NAMSUBGRID Variables Name Type Default Description ldelta logical .false. lmason logical .false. cf real 2.5 cn real 0.76 Rigc real 0.25 Prandtl real 0.333 lsmagorinsky logical .false. lvreman logical .true. loneeqn logical .false. c_vreman real 0.07 cs real -1. nmason real 2. lbuoycorr logical .false. Source Code subroutine subgridnamelist use modglobal , only : pi , ifnamopt , fname_options , lles , lbuoyancy use modmpi , only : myid , nprocs , comm3d , mpierr , my_real , mpi_logical , mpi_integer implicit none integer :: ierr namelist / NAMSUBGRID / & ldelta , lmason , cf , cn , Rigc , Prandtl , lsmagorinsky , lvreman , loneeqn , c_vreman , cs , nmason , lbuoycorr if ( myid == 0 ) then open ( ifnamopt , file = fname_options , status = 'old' , iostat = ierr ) read ( ifnamopt , NAMSUBGRID , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions NAMSUBGRID' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif !write(6 ,NAMSUBGRID) close ( ifnamopt ) end if call MPI_BCAST ( ldelta , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lmason , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( nmason , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lsmagorinsky , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lvreman , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lbuoycorr , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( loneeqn , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( c_vreman , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( cs , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( cf , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( cn , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( Rigc , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( Prandtl , 1 , MY_REAL , 0 , comm3d , mpierr ) prandtli = 1. / Prandtl if (( lsmagorinsky ) . or . ( lvreman ) . or . ( loneeqn )) then lles = . true . endif if ( lbuoyancy ) lbuoycorr = . true . end subroutine subgridnamelist","tags":"","url":"proc/subgridnamelist.html"},{"title":"subgrid – uDALES","text":"public  subroutine subgrid() Uses modfields modsurfdata modmpi modglobal proc~~subgrid~~UsesGraph proc~subgrid subgrid module~modfields modfields proc~subgrid->module~modfields module~modglobal modglobal proc~subgrid->module~modglobal module~modmpi modmpi proc~subgrid->module~modmpi module~modsurfdata modsurfdata proc~subgrid->module~modsurfdata decomp_2d decomp_2d module~modfields->decomp_2d mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~subgrid~~CallsGraph proc~subgrid subgrid proc~closure closure proc~subgrid->proc~closure proc~diffc diffc proc~subgrid->proc~diffc proc~diffe diffe proc~subgrid->proc~diffe proc~diffu diffu proc~subgrid->proc~diffu proc~diffv diffv proc~subgrid->proc~diffv proc~diffw diffw proc~subgrid->proc~diffw proc~sources sources proc~subgrid->proc~sources proc~closurebc closurebc proc~closure->proc~closurebc exchange_halo_z exchange_halo_z proc~closurebc->exchange_halo_z Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~subgrid~~CalledByGraph proc~subgrid subgrid program~dalesurban DALESURBAN program~dalesurban->proc~subgrid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/subgrid.html"},{"title":"exitsubgrid – uDALES","text":"public  subroutine exitsubgrid() Arguments None Called by proc~~exitsubgrid~~CalledByGraph proc~exitsubgrid exitsubgrid proc~exitmodules exitmodules proc~exitmodules->proc~exitsubgrid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine exitsubgrid implicit none deallocate ( ekm , ekh , zlt , sbdiss , sbbuo , sbshr , csz ) end subroutine exitsubgrid","tags":"","url":"proc/exitsubgrid.html"},{"title":"closure – uDALES","text":"public  subroutine closure() Uses modmpi modboundary modsurfdata modinletdata modglobal modfields proc~~closure~~UsesGraph proc~closure closure module~modboundary modboundary proc~closure->module~modboundary module~modfields modfields proc~closure->module~modfields module~modglobal modglobal proc~closure->module~modglobal module~modinletdata modinletdata proc~closure->module~modinletdata module~modmpi modmpi proc~closure->module~modmpi module~modsurfdata modsurfdata proc~closure->module~modsurfdata mpi mpi module~modboundary->mpi decomp_2d decomp_2d module~modfields->decomp_2d module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~closure~~CallsGraph proc~closure closure proc~closurebc closurebc proc~closure->proc~closurebc exchange_halo_z exchange_halo_z proc~closurebc->exchange_halo_z Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~closure~~CalledByGraph proc~closure closure proc~subgrid subgrid proc~subgrid->proc~closure program~dalesurban DALESURBAN program~dalesurban->proc~subgrid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine closure !-----------------------------------------------------------------| !                                                                 | !*** *closure*  calculates K-coefficients                         | !                                                                 | !      Hans Cuijpers   I.M.A.U.   06/01/1995                      | !                                                                 | !     purpose.                                                    | !     --------                                                    | !                                                                 | !     All the K-closure factors are calculated.                   | !                                                                 | !     ekm(i,j,k) = k sub m : for velocity-closure                 | !     ekh(i,j,k) = k sub h : for temperture-closure               | !     ekh(i,j,k) = k sub h = k sub c : for concentration-closure  | !                                                                 | !     We will use the next model for these factors:               | !                                                                 | !     k sub m = 0.12 * l * sqrt(E)                                | !                                                                 | !     k sub h = k sub c = ( 1 + (2*l)/D ) * k sub m               | !                                                                 | !           where : l = mixing length  ( in model = z2 )          | !                   E = subgrid energy                            | !                   D = grid-size distance                        | !                                                                 | !**   interface.                                                  | !     ----------                                                  | !                                                                 | !             *closure* is called from *program*.                 | !                                                                 | !-----------------------------------------------------------------| use modglobal , only : ib , ie , jb , je , kb , ke , kh , ih , jh , jmax , delta , ekmin , grav , zf , fkar , jgb , jge ,& dx , dxi , dxiq , dx2 , dy2 , dyi , dyiq , dzf , dzf2 , dzfi , dzhi , rk3step , rslabs , & numol , numoli , prandtlmoli , lles , rk3step , dzfiq , lbuoyancy , dzh use modfields , only : dthvdz , e120 , u0 , v0 , w0 , thl0 , mindist , wall , shear use modsurfdata , only : dudz , dvdz , thvs , ustar use modmpi , only : excjs , myid , nprocs , comm3d , mpierr , my_real , mpi_sum , slabsumi use modboundary , only : closurebc use modinletdata , only : utaui implicit none real , dimension ( ib : ie ) :: shearbot real :: strain2 , mlen , uhor , distplus , utaubot , a11 , a12 , a13 , & a21 , a22 , a23 , a31 , a32 , a33 , aa , b11 , b12 , b13 , b21 , b22 , & b23 , b33 , bb , const , const2 integer :: i , j , k , kp , km , jp , jm , im , ip , iw , jw , kw , c1 , c2 !  if (lles  .and. rk3step == 1) then        ! compute ekm and ekh only once in complete RK-cycle if ( lsmagorinsky ) then do k = kb , ke kp = k + 1 km = k - 1 do i = ib , ie ip = i + 1 im = i - 1 mlen = csz ( i , k ) * delta ( i , k ) do j = jb , je jp = j + 1 jm = j - 1 ! iw = wall(i,j,k,1)   ! indices of closest wall ! jw = wall(i,j,k,2)-myid*jmax   ! indices of closest wall in local j-index ! kw = wall(i,j,k,3) ! c1 = wall(i,j,k,4)   ! shear stress component ! c2 = wall(i,j,k,5)   ! shear stress component ! if ((jw >= jb-1) .and. (jw <= je+1)) then      ! check if jw is within the halo of this proc !    !write(*,'(A,E9.2,A,E9.2,A,E9.2,A,E9.2)') 'component1:', c1, 'component2:', c2, 'shear c1:', shear(iw,jw,kw,c1), 'shear c2:', shear(iw,jw,kw,c2) !    distplus = mindist(i,j,k)*sqrt(abs(shear(iw,jw,kw,c1))+abs(shear(iw,jw,kw,c2)))*numoli !    damp(i,j,k) = sqrt(1. - exp((-distplus*0.04)**3.))            ! Wall-damping according to Piomelli !    !    write(*,'(A,2(1pE9.2))') 'damp, distplus', damp(i,j,k), distplus ! else damp ( i , j , k ) = 1. ! end if strain2 = (( u0 ( ip , j , k ) - u0 ( i , j , k )) * dxi ) ** 2 & + (( v0 ( i , jp , k ) - v0 ( i , j , k )) * dyi ) ** 2 & + (( w0 ( i , j , kp ) - w0 ( i , j , k )) * dzfi ( k ) ) ** 2 strain2 = strain2 + 0.125 * ( & + (( w0 ( i , j , kp ) - w0 ( im , j , kp )) * dxi + ( u0 ( i , j , kp ) - u0 ( i , j , k )) * dzhi ( kp )) ** 2 & + (( w0 ( i , j , k ) - w0 ( im , j , k )) * dxi + ( u0 ( i , j , k ) - u0 ( i , j , km )) * dzhi ( k )) ** 2 & + (( w0 ( ip , j , k ) - w0 ( i , j , k )) * dxi + ( u0 ( ip , j , k ) - u0 ( ip , j , km )) * dzhi ( k )) ** 2 & + (( w0 ( ip , j , kp ) - w0 ( i , j , kp )) * dxi + ( u0 ( ip , j , kp ) - u0 ( ip , j , k )) * dzhi ( kp )) ** 2 ) strain2 = strain2 + 0.125 * ( & + (( u0 ( i , jp , k ) - u0 ( i , j , k )) * dyi + ( v0 ( i , jp , k ) - v0 ( im , jp , k )) * dxi ) ** 2 & + (( u0 ( i , j , k ) - u0 ( i , jm , k )) * dyi + ( v0 ( i , j , k ) - v0 ( im , j , k )) * dxi ) ** 2 & + (( u0 ( ip , j , k ) - u0 ( ip , jm , k )) * dyi + ( v0 ( ip , j , k ) - v0 ( i , j , k )) * dxi ) ** 2 & + (( u0 ( ip , jp , k ) - u0 ( ip , j , k )) * dyi + ( v0 ( ip , jp , k ) - v0 ( i , jp , k )) * dxi ) ** 2 ) strain2 = strain2 + 0.125 * ( & + (( v0 ( i , j , kp ) - v0 ( i , j , k )) * dzhi ( kp ) + ( w0 ( i , j , kp ) - w0 ( i , jm , kp )) * dyi ) ** 2 & + (( v0 ( i , j , k ) - v0 ( i , j , km )) * dzhi ( k ) + ( w0 ( i , j , k ) - w0 ( i , jm , k )) * dyi ) ** 2 & + (( v0 ( i , jp , k ) - v0 ( i , jp , km )) * dzhi ( k ) + ( w0 ( i , jp , k ) - w0 ( i , j , k )) * dyi ) ** 2 & + (( v0 ( i , jp , kp ) - v0 ( i , jp , k )) * dzhi ( kp ) + ( w0 ( i , jp , kp ) - w0 ( i , j , kp )) * dyi ) ** 2 ) ekm ( i , j , k ) = ( mlen * damp ( i , j , k )) ** 2. * sqrt ( 2. * strain2 ) ekh ( i , j , k ) = ekm ( i , j , k ) * prandtli end do end do end do damp (:,:,:) = max ( damp (:,:,:), dampmin ) ekm (:,:,:) = ekm (:,:,:) + numol ! add molecular viscosity ekh (:,:,:) = ekh (:,:,:) + numol * prandtlmoli ! add molecular diffusivity ! ekm(:,:,:) = max(ekm(:,:,:),ekmin) ! ekh(:,:,:) = max(ekh(:,:,:),ekmin) elseif ( lvreman ) then if (( lbuoyancy ) . and . ( lbuoycorr )) then const = prandtli * grav / ( thvs * sqrt ( 2. * 3. )) do k = kb , ke kp = k + 1 km = k - 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie ! aij = du_j / dx_i ip = i + 1 im = i - 1 a11 = ( u0 ( ip , j , k ) - u0 ( i , j , k )) * dxi a12 = ( v0 ( ip , jp , k ) + v0 ( ip , j , k ) - v0 ( im , jp , k ) - v0 ( im , j , k ) ) * dxiq a13 = ( w0 ( ip , j , kp ) + w0 ( ip , j , k ) - w0 ( im , j , kp ) - w0 ( im , j , k ) ) * dxiq a21 = ( u0 ( ip , jp , k ) + u0 ( i , jp , k ) - u0 ( ip , jm , k ) - u0 ( i , jm , k ) ) * dyiq a22 = ( v0 ( i , jp , k ) - v0 ( i , j , k )) * dyi a23 = ( w0 ( i , jp , kp ) + w0 ( i , jp , k ) - w0 ( i , jm , kp ) - w0 ( i , jm , k ) ) * dyiq a31 = ( & (( u0 ( ip , j , kp ) + u0 ( i , j , kp )) * dzf ( k ) + ( u0 ( ip , j , k ) + u0 ( i , j , k )) * dzf ( kp )) * dzhi ( kp ) & - (( u0 ( ip , j , k ) + u0 ( i , j , k )) * dzf ( km ) + ( u0 ( ip , j , km ) + u0 ( i , j , km )) * dzf ( k )) * dzhi ( k ) & ) & * dzfiq ( k ) a32 = ( & (( v0 ( i , jp , kp ) + v0 ( i , j , kp )) * dzf ( k ) + ( v0 ( i , jp , k ) + v0 ( i , j , k )) * dzf ( kp )) * dzhi ( kp ) & - (( v0 ( i , jp , k ) + v0 ( i , j , k )) * dzf ( km ) + ( v0 ( i , jp , km ) + v0 ( i , j , km )) * dzf ( k )) * dzhi ( k ) & ) & * dzfiq ( k ) a33 = ( w0 ( i , j , kp ) - w0 ( i , j , k )) * dzfi ( k ) aa = a11 * a11 + a21 * a21 + a31 * a31 + & a12 * a12 + a22 * a22 + a32 * a32 + & a13 * a13 + a23 * a23 + a33 * a33 b11 = dx2 * a11 * a11 + dy2 * a21 * a21 + dzf2 ( k ) * a31 * a31 b22 = dx2 * a12 * a12 + dy2 * a22 * a22 + dzf2 ( k ) * a32 * a32 b12 = dx2 * a11 * a12 + dy2 * a21 * a22 + dzf2 ( k ) * a31 * a32 b33 = dx2 * a13 * a13 + dy2 * a23 * a23 + dzf2 ( k ) * a33 * a33 b13 = dx2 * a11 * a13 + dy2 * a21 * a23 + dzf2 ( k ) * a31 * a33 b23 = dx2 * a12 * a13 + dy2 * a22 * a23 + dzf2 ( k ) * a32 * a33 bb = b11 * b22 - b12 * b12 + b11 * b33 - b13 * b13 + b22 * b33 - b23 * b23 dthvdz ( i , j , k ) = ( thl0 ( i , j , k + 1 ) - thl0 ( i , j , k - 1 )) / ( dzh ( k + 1 ) + dzh ( k )) if ( dthvdz ( i , j , k ) <= 0 ) then const2 = ( bb / aa ) else const2 = ( bb / aa ) - ( delta ( i , k ) ** 4 ) * dthvdz ( i , j , k ) * const if ( const2 < 0.0 ) const2 = 0.0 end if ekm ( i , j , k ) = c_vreman * sqrt ( const2 ) ekh ( i , j , k ) = ekm ( i , j , k ) * prandtli end do end do end do !  ekm(:,:,:) = ekm(:,:,:) + numol                             ! add molecular viscosity !  ekh(:,:,:) = ekh(:,:,:) + numol*prandtlmoli                 ! add molecular diffusivity else ! neutral case do k = kb , ke kp = k + 1 km = k - 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie ! aij = du_j / dx_i ip = i + 1 im = i - 1 a11 = ( u0 ( ip , j , k ) - u0 ( i , j , k )) * dxi a12 = ( v0 ( ip , jp , k ) + v0 ( ip , j , k ) - v0 ( im , jp , k ) - v0 ( im , j , k ) ) * dxiq a13 = ( w0 ( ip , j , kp ) + w0 ( ip , j , k ) - w0 ( im , j , kp ) - w0 ( im , j , k ) ) * dxiq a21 = ( u0 ( ip , jp , k ) + u0 ( i , jp , k ) - u0 ( ip , jm , k ) - u0 ( i , jm , k ) ) * dyiq a22 = ( v0 ( i , jp , k ) - v0 ( i , j , k )) * dyi a23 = ( w0 ( i , jp , kp ) + w0 ( i , jp , k ) - w0 ( i , jm , kp ) - w0 ( i , jm , k ) ) * dyiq a31 = ( & (( u0 ( ip , j , kp ) + u0 ( i , j , kp )) * dzf ( k ) + ( u0 ( ip , j , k ) + u0 ( i , j , k )) * dzf ( kp )) * dzhi ( kp ) & - (( u0 ( ip , j , k ) + u0 ( i , j , k )) * dzf ( km ) + ( u0 ( ip , j , km ) + u0 ( i , j , km )) * dzf ( k )) * dzhi ( k ) & ) & * dzfiq ( k ) a32 = ( & (( v0 ( i , jp , kp ) + v0 ( i , j , kp )) * dzf ( k ) + ( v0 ( i , jp , k ) + v0 ( i , j , k )) * dzf ( kp )) * dzhi ( kp ) & - (( v0 ( i , jp , k ) + v0 ( i , j , k )) * dzf ( km ) + ( v0 ( i , jp , km ) + v0 ( i , j , km )) * dzf ( k )) * dzhi ( k ) & ) & * dzfiq ( k ) a33 = ( w0 ( i , j , kp ) - w0 ( i , j , k )) * dzfi ( k ) aa = a11 * a11 + a21 * a21 + a31 * a31 + & a12 * a12 + a22 * a22 + a32 * a32 + & a13 * a13 + a23 * a23 + a33 * a33 b11 = dx2 * a11 * a11 + dy2 * a21 * a21 + dzf2 ( k ) * a31 * a31 b22 = dx2 * a12 * a12 + dy2 * a22 * a22 + dzf2 ( k ) * a32 * a32 b12 = dx2 * a11 * a12 + dy2 * a21 * a22 + dzf2 ( k ) * a31 * a32 b33 = dx2 * a13 * a13 + dy2 * a23 * a23 + dzf2 ( k ) * a33 * a33 b13 = dx2 * a11 * a13 + dy2 * a21 * a23 + dzf2 ( k ) * a31 * a33 b23 = dx2 * a12 * a13 + dy2 * a22 * a23 + dzf2 ( k ) * a32 * a33 bb = b11 * b22 - b12 * b12 + b11 * b33 - b13 * b13 + b22 * b33 - b23 * b23 if ( bb < 0.00000001 ) then ekm ( i , j , k ) = 0. ekh ( i , j , k ) = 0. else ekm ( i , j , k ) = c_vreman * sqrt ( bb / aa ) ekh ( i , j , k ) = ekm ( i , j , k ) * prandtli end if end do end do end do ! ekm(:,:,:) = max(ekm(:,:,:),ekmin) ! ekh(:,:,:) = max(ekh(:,:,:),ekmin) end if ! lbuoyancy ekm (:,:,:) = ekm (:,:,:) + numol ! add molecular viscosity ekh (:,:,:) = ekh (:,:,:) + numol * prandtlmoli ! add molecular diffusivity ! TKE scheme elseif ( loneeqn ) then do k = kb , ke do j = jb , je do i = ib , ie ! iw = wall(i,j,k,1)   ! indices of closest wall ! jw = wall(i,j,k,2)-myid*jmax   ! indices of closest wall in local j-index ! kw = wall(i,j,k,3) ! c1 = wall(i,j,k,4)   ! shear stress component ! c2 = wall(i,j,k,5)   ! shear stress component !ILS13 removed near-wall damping 25.06.2014 !if (jw >= jb-1 .and. jw <= je+1) then      ! check if jw is within the halo of this proc !  distplus = mindist(i,j,k)*sqrt(abs(shear(iw,jw,kw,c1))+abs(shear(iw,jw,kw,c2)))*numoli !  damp(i,j,k) = sqrt(1. - exp((-distplus*0.04)**3.))            ! Wall-damping according to Piomelli !else damp ( i , j , k ) = 1. !end if if (( ldelta ) . or . ( dthvdz ( i , j , k ) <= 0 )) then zlt ( i , j , k ) = delta ( i , k ) ekm ( i , j , k ) = cm * zlt ( i , j , k ) * damp ( i , j , k ) * e120 ( i , j , k ) !* 0.5! LES with near-wall damping !!! added factor 0.5 for shear-driven flow ekh ( i , j , k ) = ( ch1 + ch2 ) * ekm ( i , j , k ) ! maybe ekh should be calculated from (molecular) Prandtl number ekm ( i , j , k ) = ekm ( i , j , k ) + numol ! add molecular viscosity ekh ( i , j , k ) = ekh ( i , j , k ) + numol * prandtlmoli ! add molecular diffusivity else !            zlt(i,j,k) = min(delta(i,k),cn*e120(i,j,k)/sqrt(grav/thvs*abs(dthvdz(i,j,k)))) zlt ( i , j , k ) = min ( delta ( i , k ), cn * e120 ( i , j , k ) / sqrt ( grav / thvs * abs ( dthvdz ( i , j , k )))) !thls is used ekm ( i , j , k ) = cm * zlt ( i , j , k ) * damp ( i , j , k ) * e120 ( i , j , k ) !* 0.5     ! LES with near-wall damping !!! added factor 0.5 for shear-driven flow ekh ( i , j , k ) = ( ch1 + ch2 * zlt ( i , j , k ) / delta ( i , k )) * ekm ( i , j , k ) !  needed in LES! ekm ( i , j , k ) = ekm ( i , j , k ) + numol ! add molecular viscosity ekh ( i , j , k ) = ekh ( i , j , k ) + numol * prandtlmoli ! add molecular diffusivity endif end do end do end do damp (:,:,:) = max ( damp (:,:,:), dampmin ) ! ekm(:,:,:) = max(ekm(:,:,:),ekmin) ! ekh(:,:,:) = max(ekh(:,:,:),ekmin) else ! no subgrid model (DNS!) ekm = numol ekh = numol * prandtlmoli end if !************************************************************* !     Set boundary condition for K-closure factors.          ! Also other BC's!! !************************************************************* call closurebc return end subroutine closure","tags":"","url":"proc/closure.html"},{"title":"sources – uDALES","text":"public  subroutine sources() Uses modfields modsurfdata modglobal proc~~sources~~UsesGraph proc~sources sources module~modfields modfields proc~sources->module~modfields module~modglobal modglobal proc~sources->module~modglobal module~modsurfdata modsurfdata proc~sources->module~modsurfdata decomp_2d decomp_2d module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~sources~~CalledByGraph proc~sources sources proc~subgrid subgrid proc~subgrid->proc~sources program~dalesurban DALESURBAN program~dalesurban->proc~subgrid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine sources ! only in case of LES computation !-----------------------------------------------------------------| !                                                                 | !*** *sources*                                                    | !      calculates various terms from the subgrid TKE equation     | !                                                                 | !     Hans Cuijpers   I.M.A.U.     06/01/1995                     | !                                                                 | !     purpose.                                                    | !     --------                                                    | !                                                                 | !      Subroutine sources calculates all other terms in the       | !      subgrid energy equation, except for the diffusion terms.   | !      These terms are calculated in subroutine diff.             | !                                                                 | !**   interface.                                                  | !     ----------                                                  | !                                                                 | !     *sources* is called from *program*.                         | !                                                                 | !-----------------------------------------------------------------| use modglobal , only : ib , ie , jb , je , kb , ke , dxi , delta , dy , dyi , dzfi , dzhi , grav , numol , prandtlmol ,& dzh , delta use modfields , only : u0 , v0 , w0 , e120 , e12p , dthvdz , thl0 , thvf use modsurfdata , only : dudz , dvdz , thvs !    use modmpi,       only : myid implicit none real tdef2 , prandtlmoli integer i , j , k , im , ip , jm , jp , km , kp prandtlmoli = 1. / prandtlmol do k = kb + 1 , ke do j = jb , je do i = ib , ie kp = k + 1 km = k - 1 jp = j + 1 jm = j - 1 ip = i + 1 im = i - 1 tdef2 = 2. * ( & (( u0 ( ip , j , k ) - u0 ( i , j , k )) * dxi ) ** 2 & + (( v0 ( i , jp , k ) - v0 ( i , j , k )) * dyi ) ** 2 & + (( w0 ( i , j , kp ) - w0 ( i , j , k )) * dzfi ( k ) ) ** 2 ) tdef2 = tdef2 + 0.25 * ( & (( w0 ( i , j , kp ) - w0 ( im , j , kp )) * dxi + ( u0 ( i , j , kp ) - u0 ( i , j , k )) * dzhi ( kp )) ** 2 & + (( w0 ( i , j , k ) - w0 ( im , j , k )) * dxi + ( u0 ( i , j , k ) - u0 ( i , j , km )) * dzhi ( k )) ** 2 & + (( w0 ( ip , j , k ) - w0 ( i , j , k )) * dxi + ( u0 ( ip , j , k ) - u0 ( ip , j , km )) * dzhi ( k )) ** 2 & + (( w0 ( ip , j , kp ) - w0 ( i , j , kp )) * dxi + ( u0 ( ip , j , kp ) - u0 ( ip , j , k )) * dzhi ( kp )) ** 2 ) tdef2 = tdef2 + 0.25 * ( & (( u0 ( i , jp , k ) - u0 ( i , j , k )) * dyi + ( v0 ( i , jp , k ) - v0 ( im , jp , k )) * dxi ) ** 2 & + (( u0 ( i , j , k ) - u0 ( i , jm , k )) * dyi + ( v0 ( i , j , k ) - v0 ( im , j , k )) * dxi ) ** 2 & + (( u0 ( ip , j , k ) - u0 ( ip , jm , k )) * dyi + ( v0 ( ip , j , k ) - v0 ( i , j , k )) * dxi ) ** 2 & + (( u0 ( ip , jp , k ) - u0 ( ip , j , k )) * dyi + ( v0 ( ip , jp , k ) - v0 ( i , jp , k )) * dxi ) ** 2 ) tdef2 = tdef2 + 0.25 * ( & (( v0 ( i , j , kp ) - v0 ( i , j , k )) * dzhi ( kp ) + ( w0 ( i , j , kp ) - w0 ( i , jm , kp )) * dyi ) ** 2 & + (( v0 ( i , j , k ) - v0 ( i , j , km )) * dzhi ( k ) + ( w0 ( i , j , k ) - w0 ( i , jm , k )) * dyi ) ** 2 & + (( v0 ( i , jp , k ) - v0 ( i , jp , km )) * dzhi ( k ) + ( w0 ( i , jp , k ) - w0 ( i , j , k )) * dyi ) ** 2 & + (( v0 ( i , jp , kp ) - v0 ( i , jp , k )) * dzhi ( kp ) + ( w0 ( i , jp , kp ) - w0 ( i , j , kp )) * dyi ) ** 2 ) !    sbshr(i,j,k)  = ekm(i,j,k)*tdef2/ ( 2*e120(i,j,k)) !    sbbuo(i,j,k)  = -ekh(i,j,k)*grav/thvs*dthvdz(i,j,k)/ ( 2*e120(i,j,k)) !    sbdiss(i,j,k) = - (ce1 + ce2*zlt(i,j,k)/delta(i,k)) * e120(i,j,k)**2 /(2.*zlt(i,j,k)) sbshr ( i , j , k ) = ( ekm ( i , j , k ) - numol ) * tdef2 / ( 2 * e120 ( i , j , k )) ! subtract molecular viscosity !    sbbuo(i,j,k)  = -(ekh(i,j,k)-numol*prandtlmoli)*grav/thvs*dthvdz(i,j,k)/ ( 2*e120(i,j,k))     ! subtract molecular diffusivity sbbuo ( i , j , k ) = - ( ekh ( i , j , k ) - numol * prandtlmoli ) * grav / thvs * dthvdz ( i , j , k ) / ( 2 * e120 ( i , j , k )) ! subtract molecular diffusivity and use thls instead of thvs (not defined) !    sbdiss(i,j,k) = - (ce1 + ce2*zlt(i,j,k)/delta(i,k)) * e120(i,j,k)**2 /(2.*damp*zlt(i,j,k))   ! add near-wall damping function ! added factor 2. for shear-driven flow sbdiss ( i , j , k ) = - 2. * ( ce1 + ce2 * zlt ( i , j , k ) / delta ( i , k )) * e120 ( i , j , k ) ** 2 / ( 2. * damp ( i , j , k ) * zlt ( i , j , k )) ! add near-wall damping function !! added f end do end do end do !     ----------------------------------------------end i,j,k-loop !    special treatment for lowest level ! Don't do this - wall function at bottom ! do j=jb,je !    do i=ib,ie !       jp=j+1 !       jm=j-1 !       ip=i+1 !       im=i-1 ! !       tdef2 = 2. * ( & !               ((u0(ip,j,kb) - u0(i,j,kb))*dxi)**2 & !             + ((v0(i,jp,kb) - v0(i,j,kb))*dyi)**2 & !             + ((w0(i,j,kb+1) -w0(i,j,kb))*dzfi(kb))**2 & !               ) ! !       tdef2 = tdef2 + ( 0.25*(w0(i+1,j,kb+1)-w0(i-1,j,kb+1))*dxfi(i) + dudz(i,j))**2 ! !       tdef2 = tdef2 + 0.25 * ( & !               ((u0(i ,jp,kb) - u0(i ,j ,kb)) * dyi + (v0(i ,jp,kb) - v0(im,jp,kb)) * dxi)**2 & !             + ((u0(i ,j ,kb) - u0(i ,jm,kb)) * dyi + (v0(i ,j ,kb) - v0(im,j ,kb)) * dxi)**2 & !             + ((u0(ip,j ,kb) - u0(ip,jm,kb)) * dyi + (v0(ip,j ,kb) - v0(i ,j ,kb)) * dxi)**2 & !             + ((u0(ip,jp,kb) - u0(ip,j ,kb)) * dyi + (v0(ip,jp,kb) - v0(i ,jp,kb)) * dxi)**2 & !             ) ! !       tdef2 = tdef2 + ( 0.25 * (w0(i,jp,kb+1) - w0(i,jm,kb+1)) * dyi + dvdz(i,j))**2 ! !       ! **  Include shear and buoyancy production terms and dissipation ** ! !       sbshr(i,j,kb)  = ekm(i,j,kb)*tdef2/ ( 2*e120(i,j,kb)) !       sbbuo(i,j,kb)  = -ekh(i,j,kb)*grav/thvf(kb)*dthvdz(i,j,kb)/ ( 2*e120(i,j,kb)) !       sbdiss(i,j,kb) = - (ce1 + ce2*zlt(i,j,kb)/delta(i,kb)) * e120(i,j,kb)**2 /(2.*zlt(i,j,kb)) !    end do ! end do !    ------------------------------------------------ e12p ( ib : ie , jb : je , kb : ke ) = e12p ( ib : ie , jb : je , kb : ke ) + & sbshr ( ib : ie , jb : je , kb : ke ) + sbbuo ( ib : ie , jb : je , kb : ke ) + sbdiss ( ib : ie , jb : je , kb : ke ) return end subroutine sources","tags":"","url":"proc/sources.html"},{"title":"diffc – uDALES","text":"public  subroutine diffc(hi, hj, hk, putin, putout) Uses modmpi modglobal proc~~diffc~~UsesGraph proc~diffc diffc module~modglobal modglobal proc~diffc->module~modglobal module~modmpi modmpi proc~diffc->module~modmpi mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name integer, intent(in) :: hi integer, intent(in) :: hj integer, intent(in) :: hk real, intent(in) :: putin (ib-hi:ie+hi,jb-hj:je+hj,kb-hk:ke+hk) real, intent(inout) :: putout (ib-hi:ie+hi,jb-hj:je+hj,kb:ke+hk) Called by proc~~diffc~~CalledByGraph proc~diffc diffc proc~subgrid subgrid proc~subgrid->proc~diffc program~dalesurban DALESURBAN program~dalesurban->proc~subgrid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine diffc ( hi , hj , hk , putin , putout ) use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , dx2i , dzf , dzfi , dyi , dy2i ,& dzhi , dzh2i , jmax , numol , prandtlmoli , lles use modmpi , only : myid implicit none integer , intent ( in ) :: hi !<size of halo in i integer , intent ( in ) :: hj !<size of halo in j integer , intent ( in ) :: hk !<size of halo in k real , intent ( in ) :: putin ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) real , intent ( inout ) :: putout ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ) real cekh integer i , j , k , im , ip , jm , jp , km , kp if ( lles ) then do k = kb , ke kp = k + 1 km = k - 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie ip = i + 1 im = i - 1 putout ( i , j , k ) = putout ( i , j , k ) & + 0.5 * ( & ( & ( ekh ( ip , j , k ) + ekh ( i , j , k )) * ( putin ( ip , j , k ) - putin ( i , j , k )) & - ( ekh ( i , j , k ) + ekh ( im , j , k )) * ( putin ( i , j , k ) - putin ( im , j , k )) & ) * dx2i & + ( & ( ekh ( i , jp , k ) + ekh ( i , j , k )) * ( putin ( i , jp , k ) - putin ( i , j , k )) & - ( ekh ( i , j , k ) + ekh ( i , jm , k )) * ( putin ( i , j , k ) - putin ( i , jm , k )) & ) * dy2i & + ( & ( dzf ( kp ) * ekh ( i , j , k ) + dzf ( k ) * ekh ( i , j , kp )) * ( putin ( i , j , kp ) - putin ( i , j , k )) * dzh2i ( kp ) & - ( dzf ( km ) * ekh ( i , j , k ) + dzf ( k ) * ekh ( i , j , km )) * ( putin ( i , j , k ) - putin ( i , j , km )) * dzh2i ( k ) & ) * dzfi ( k ) & ) end do end do end do else ! DNS cekh = numol * prandtlmoli do k = kb , ke kp = k + 1 km = k - 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie ip = i + 1 im = i - 1 putout ( i , j , k ) = putout ( i , j , k ) & + ( & ( & cekh * ( putin ( ip , j , k ) - putin ( i , j , k )) & - cekh * ( putin ( i , j , k ) - putin ( im , j , k )) & ) * dx2i & + ( & cekh * ( putin ( i , jp , k ) - putin ( i , j , k )) & - cekh * ( putin ( i , j , k ) - putin ( i , jm , k )) & ) * dy2i & + ( & cekh * ( putin ( i , j , kp ) - putin ( i , j , k )) * dzhi ( kp ) & - cekh * ( putin ( i , j , k ) - putin ( i , j , km )) * dzhi ( k ) & ) * dzfi ( k ) & ) end do end do end do end if ! lles=.true. end subroutine diffc","tags":"","url":"proc/diffc.html"},{"title":"diffe – uDALES","text":"public  subroutine diffe(putout) Uses modfields modmpi modglobal proc~~diffe~~UsesGraph proc~diffe diffe module~modfields modfields proc~diffe->module~modfields module~modglobal modglobal proc~diffe->module~modglobal module~modmpi modmpi proc~diffe->module~modmpi decomp_2d decomp_2d module~modfields->decomp_2d mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(inout) :: putout (ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) Called by proc~~diffe~~CalledByGraph proc~diffe diffe proc~subgrid subgrid proc~subgrid->proc~diffe program~dalesurban DALESURBAN program~dalesurban->proc~subgrid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine diffe ( putout ) use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , dx2i , dzf , dzfi ,& dy2i , dzhi , dzh2i , jmax use modfields , only : e120 use modmpi , only : myid implicit none real , intent ( inout ) :: putout ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ) integer :: i , j , k , im , ip , jm , jp , km , kp do k = kb , ke kp = k + 1 km = k - 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie ip = i + 1 im = i - 1 putout ( i , j , k ) = putout ( i , j , k ) & + 1.0 * ( & ( & ( ekm ( ip , j , k ) + ekm ( i , j , k )) * ( e120 ( ip , j , k ) - e120 ( i , j , k )) & - ( ekm ( i , j , k ) + ekm ( im , j , k )) * ( e120 ( i , j , k ) - e120 ( im , j , k )) & ) * dx2i & + ( & ( ekm ( i , jp , k ) + ekm ( i , j , k )) * ( e120 ( i , jp , k ) - e120 ( i , j , k )) & - ( ekm ( i , j , k ) + ekm ( i , jm , k )) * ( e120 ( i , j , k ) - e120 ( i , jm , k )) & ) * dy2i & + ( & ( dzf ( kp ) * ekm ( i , j , k ) + dzf ( k ) * ekm ( i , j , kp )) * ( e120 ( i , j , kp ) - e120 ( i , j , k )) * dzh2i ( kp ) & - ( dzf ( km ) * ekm ( i , j , k ) + dzf ( k ) * ekm ( i , j , km )) * ( e120 ( i , j , k ) - e120 ( i , j , km )) * dzh2i ( k ) & ) * dzfi ( k ) & ) end do end do end do end subroutine diffe","tags":"","url":"proc/diffe.html"},{"title":"diffu – uDALES","text":"public  subroutine diffu(putout) Uses modfields modsurfdata modmpi modglobal proc~~diffu~~UsesGraph proc~diffu diffu module~modfields modfields proc~diffu->module~modfields module~modglobal modglobal proc~diffu->module~modglobal module~modmpi modmpi proc~diffu->module~modmpi module~modsurfdata modsurfdata proc~diffu->module~modsurfdata decomp_2d decomp_2d module~modfields->decomp_2d mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(inout) :: putout (ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) Called by proc~~diffu~~CalledByGraph proc~diffu diffu proc~subgrid subgrid proc~subgrid->proc~diffu program~dalesurban DALESURBAN program~dalesurban->proc~subgrid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine diffu ( putout ) use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , kmax , dx2i , dxi , lles ,& dzf , dzfi , dy , dyi , dy2i , dzhi , dzhiq , jmax , numol use modfields , only : u0 , v0 , w0 use modsurfdata , only : ustar use modmpi , only : myid implicit none real , intent ( inout ) :: putout ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ) real :: emmo , emom , emop , empo real :: fu , dummy real :: ucu , upcu integer :: i , j , k , jm , jp , km , kp if ( lles ) then do k = kb , ke kp = k + 1 km = k - 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie emom = ( dzf ( km ) * ( ekm ( i , j , k ) + ekm ( i - 1 , j , k ) ) + & dzf ( k ) * ( ekm ( i , j , km ) + ekm ( i - 1 , j , km ))) * dzhiq ( k ) emop = ( dzf ( kp ) * ( ekm ( i , j , k ) + ekm ( i - 1 , j , k )) + & dzf ( k ) * ( ekm ( i , j , kp ) + ekm ( i - 1 , j , kp ))) * dzhiq ( kp ) empo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , jp , k )) + ( ekm ( i - 1 , j , k ) + ekm ( i - 1 , jp , k ))) emmo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , jm , k )) + ( ekm ( i - 1 , jm , k ) + ekm ( i - 1 , j , k ))) ! Discretized diffusion term putout ( i , j , k ) = putout ( i , j , k ) & + ( & ekm ( i , j , k ) * ( u0 ( i + 1 , j , k ) - u0 ( i , j , k )) & - ekm ( i - 1 , j , k ) * ( u0 ( i , j , k ) - u0 ( i - 1 , j , k )) & ) * 2. * dx2i & + ( & empo * ( & ( u0 ( i , jp , k ) - u0 ( i , j , k )) * dyi & + ( v0 ( i , jp , k ) - v0 ( i - 1 , jp , k )) * dxi & ) & - emmo * ( & ( u0 ( i , j , k ) - u0 ( i , jm , k )) * dyi & + ( v0 ( i , j , k ) - v0 ( i - 1 , j , k )) * dxi & ) & ) * dyi & + ( & emop * ( & ( u0 ( i , j , kp ) - u0 ( i , j , k )) * dzhi ( kp ) & + ( w0 ( i , j , kp ) - w0 ( i - 1 , j , kp )) * dxi ) & - emom * ( & ( u0 ( i , j , k ) - u0 ( i , j , km )) * dzhi ( k ) & + ( w0 ( i , j , k ) - w0 ( i - 1 , j , k )) * dxi ) & ) * dzfi ( k ) end do end do end do else ! DNS do k = kb , ke kp = k + 1 km = k - 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie ! Discretized diffusion term putout ( i , j , k ) = putout ( i , j , k ) & + ( & numol * ( u0 ( i + 1 , j , k ) - u0 ( i , j , k )) * dxi & - numol * ( u0 ( i , j , k ) - u0 ( i - 1 , j , k )) * dxi & ) * 2. * dxi & + ( & numol * ( & ( u0 ( i , jp , k ) - u0 ( i , j , k )) * dyi & + ( v0 ( i , jp , k ) - v0 ( i - 1 , jp , k )) * dxi & ) & - numol * ( & ( u0 ( i , j , k ) - u0 ( i , jm , k )) * dyi & + ( v0 ( i , j , k ) - v0 ( i - 1 , j , k )) * dxi & ) & ) * dyi & + ( & numol * ( & ( u0 ( i , j , kp ) - u0 ( i , j , k )) * dzhi ( kp ) & + ( w0 ( i , j , kp ) - w0 ( i - 1 , j , kp )) * dxi ) & - numol * ( & ( u0 ( i , j , k ) - u0 ( i , j , km )) * dzhi ( k ) & + ( w0 ( i , j , k ) - w0 ( i - 1 , j , k )) * dxi & ) & ) * dzfi ( k ) end do end do end do end if ! lles end subroutine diffu","tags":"","url":"proc/diffu.html"},{"title":"diffv – uDALES","text":"public  subroutine diffv(putout) Uses modfields modsurfdata modmpi modglobal proc~~diffv~~UsesGraph proc~diffv diffv module~modfields modfields proc~diffv->module~modfields module~modglobal modglobal proc~diffv->module~modglobal module~modmpi modmpi proc~diffv->module~modmpi module~modsurfdata modsurfdata proc~diffv->module~modsurfdata decomp_2d decomp_2d module~modfields->decomp_2d mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(inout) :: putout (ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) Called by proc~~diffv~~CalledByGraph proc~diffv diffv proc~subgrid subgrid proc~subgrid->proc~diffv program~dalesurban DALESURBAN program~dalesurban->proc~subgrid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine diffv ( putout ) use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , dxi , dzf , dzfi , dyi ,& dy2i , dzhi , dzhiq , jmax , numol , lles use modfields , only : u0 , v0 , w0 use modsurfdata , only : ustar use modmpi , only : myid implicit none real , intent ( inout ) :: putout ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ) real :: emmo , eomm , eomp , epmo real :: fv , vcv , vpcv integer :: i , j , k , jm , jp , km , kp if ( lles ) then do k = kb , ke kp = k + 1 km = k - 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie eomm = ( dzf ( km ) * ( ekm ( i , j , k ) + ekm ( i , jm , k ) ) + & dzf ( k ) * ( ekm ( i , j , km ) + ekm ( i , jm , km ) ) ) * dzhiq ( k ) eomp = ( dzf ( kp ) * ( ekm ( i , j , k ) + ekm ( i , jm , k ) ) + & dzf ( k ) * ( ekm ( i , j , kp ) + ekm ( i , jm , kp ) ) ) * dzhiq ( kp ) emmo = 0.25 * ( ekm ( i , j , k ) + ekm ( i , jm , k ) + ekm ( i - 1 , jm , k ) + ekm ( i - 1 , j , k ) ) epmo = 0.25 * ( ekm ( i , j , k ) + ekm ( i , jm , k ) + ekm ( i + 1 , jm , k ) + ekm ( i + 1 , j , k ) ) ! discretized diffusion term putout ( i , j , k ) = putout ( i , j , k ) & + ( & epmo * ( & ( v0 ( i + 1 , j , k ) - v0 ( i , j , k )) * dxi & + ( u0 ( i + 1 , j , k ) - u0 ( i + 1 , jm , k )) * dyi & ) & - emmo * ( & ( v0 ( i , j , k ) - v0 ( i - 1 , j , k )) * dxi & + ( u0 ( i , j , k ) - u0 ( i , jm , k )) * dyi & ) & ) * dxi & ! = d/dx( Km*(dv/dx + du/dy) ) + ( & ekm ( i , j , k ) * ( v0 ( i , jp , k ) - v0 ( i , j , k )) & - ekm ( i , jm , k ) * ( v0 ( i , j , k ) - v0 ( i , jm , k )) & ) * 2. * dy2i & ! = d/dy( 2*Km*(dv/dy) ) + ( & eomp * ( & ( v0 ( i , j , kp ) - v0 ( i , j , k )) * dzhi ( kp ) & + ( w0 ( i , j , kp ) - w0 ( i , jm , kp )) * dyi & ) & - eomm * ( & ( v0 ( i , j , k ) - v0 ( i , j , km )) * dzhi ( k ) & + ( w0 ( i , j , k ) - w0 ( i , jm , k )) * dyi & ) & ) * dzfi ( k ) ! = d/dz( Km*(dv/dz + dw/dy) ) end do end do end do else ! DNS do k = kb , ke kp = k + 1 km = k - 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie putout ( i , j , k ) = putout ( i , j , k ) & + ( & numol * ( & ( v0 ( i + 1 , j , k ) - v0 ( i , j , k )) * dxi & + ( u0 ( i + 1 , j , k ) - u0 ( i + 1 , jm , k )) * dyi & ) & - numol * ( & ( v0 ( i , j , k ) - v0 ( i - 1 , j , k )) * dxi & + ( u0 ( i , j , k ) - u0 ( i , jm , k )) * dyi & ) & ) * dxi & ! = d/dx( Km*(dv/dx + du/dy) ) + ( & numol * ( v0 ( i , jp , k ) - v0 ( i , j , k )) & - numol * ( v0 ( i , j , k ) - v0 ( i , jm , k )) & ) * 2. * dy2i & ! = d/dy( 2*Km*(dv/dy) ) + ( & numol * ( & ( v0 ( i , j , kp ) - v0 ( i , j , k )) * dzhi ( kp ) & + ( w0 ( i , j , kp ) - w0 ( i , jm , kp )) * dyi ) & - numol * ( & ( v0 ( i , j , k ) - v0 ( i , j , km )) * dzhi ( k ) & + ( w0 ( i , j , k ) - w0 ( i , jm , k )) * dyi & ) & ) * dzfi ( k ) ! = d/dz( Km*(dv/dz + dw/dy) ) end do end do end do end if end subroutine diffv","tags":"","url":"proc/diffv.html"},{"title":"diffw – uDALES","text":"public  subroutine diffw(putout) Uses modfields modmpi modglobal proc~~diffw~~UsesGraph proc~diffw diffw module~modfields modfields proc~diffw->module~modfields module~modglobal modglobal proc~diffw->module~modglobal module~modmpi modmpi proc~diffw->module~modmpi decomp_2d decomp_2d module~modfields->decomp_2d mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(inout) :: putout (ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) Called by proc~~diffw~~CalledByGraph proc~diffw diffw proc~subgrid subgrid proc~subgrid->proc~diffw program~dalesurban DALESURBAN program~dalesurban->proc~subgrid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine diffw ( putout ) use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , kmax , dxi , dy ,& dyi , dy2i , dzf , dzfi , dzhi , dzhiq , jmax , numol , lles use modfields , only : u0 , v0 , w0 use modmpi , only : myid implicit none !***************************************************************** real , intent ( inout ) :: putout ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ) real :: emom , eomm , eopm , epom integer :: i , j , k , jm , jp , km , kp if ( lles ) then do k = kb + 1 , ke kp = k + 1 km = k - 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie emom = ( dzf ( km ) * ( ekm ( i , j , k ) + ekm ( i - 1 , j , k ) ) + & dzf ( k ) * ( ekm ( i , j , km ) + ekm ( i - 1 , j , km ) ) ) * dzhiq ( k ) eomm = ( dzf ( km ) * ( ekm ( i , j , k ) + ekm ( i , jm , k ) ) + & dzf ( k ) * ( ekm ( i , j , km ) + ekm ( i , jm , km ) ) ) * dzhiq ( k ) eopm = ( dzf ( km ) * ( ekm ( i , j , k ) + ekm ( i , jp , k ) ) + & dzf ( k ) * ( ekm ( i , j , km ) + ekm ( i , jp , km ) ) ) * dzhiq ( k ) epom = ( dzf ( km ) * ( ekm ( i , j , k ) + ekm ( i + 1 , j , k ) ) + & dzf ( k ) * ( ekm ( i , j , km ) + ekm ( i + 1 , j , km ) ) ) * dzhiq ( k ) ! discretized diffusion term putout ( i , j , k ) = putout ( i , j , k ) & + ( & epom * ( & ( w0 ( i + 1 , j , k ) - w0 ( i , j , k )) * dxi & + ( u0 ( i + 1 , j , k ) - u0 ( i + 1 , j , km )) * dzhi ( k ) & ) & - emom * ( & ( w0 ( i , j , k ) - w0 ( i - 1 , j , k )) * dxi & + ( u0 ( i , j , k ) - u0 ( i , j , km )) * dzhi ( k ) & ) & ) * dxi & + ( & eopm * ( & ( w0 ( i , jp , k ) - w0 ( i , j , k )) * dyi & + ( v0 ( i , jp , k ) - v0 ( i , jp , km )) * dzhi ( k ) & ) & - eomm * ( & ( w0 ( i , j , k ) - w0 ( i , jm , k )) * dyi & + ( v0 ( i , j , k ) - v0 ( i , j , km )) * dzhi ( k ) & ) & ) * dyi & + ( & ekm ( i , j , k ) * ( w0 ( i , j , kp ) - w0 ( i , j , k )) * dzfi ( k ) & - ekm ( i , j , km ) * ( w0 ( i , j , k ) - w0 ( i , j , km )) * dzfi ( km ) & ) * 2. * dzhi ( k ) end do end do end do else ! DNS do k = kb + 1 , ke kp = k + 1 km = k - 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie ! discretized diffusion term putout ( i , j , k ) = putout ( i , j , k ) & + ( & numol * ( & ( w0 ( i + 1 , j , k ) - w0 ( i , j , k )) * dxi & + ( u0 ( i + 1 , j , k ) - u0 ( i + 1 , j , km )) * dzhi ( k ) & ) & - numol * ( & ( w0 ( i , j , k ) - w0 ( i - 1 , j , k )) * dxi & + ( u0 ( i , j , k ) - u0 ( i , j , km )) * dzhi ( k ) & ) & ) * dxi & + ( & numol * ( & ( w0 ( i , jp , k ) - w0 ( i , j , k )) * dyi & + ( v0 ( i , jp , k ) - v0 ( i , jp , km )) * dzhi ( k ) ) & - numol * ( & ( w0 ( i , j , k ) - w0 ( i , jm , k )) * dyi & + ( v0 ( i , j , k ) - v0 ( i , j , km )) * dzhi ( k ) & ) & ) * dyi & + ( & numol * ( w0 ( i , j , kp ) - w0 ( i , j , k )) * dzfi ( k ) & - numol * ( w0 ( i , j , k ) - w0 ( i , j , km )) * dzfi ( km ) & ) * 2. * dzhi ( k ) end do end do end do end if end subroutine diffw","tags":"","url":"proc/diffw.html"},{"title":"qsat – uDALES","text":"public  function qsat(T) Arguments Type Intent Optional Attributes Name real, intent(in) :: T Return Value real Called by proc~~qsat~~CalledByGraph proc~qsat qsat proc~readfacetfiles readfacetfiles proc~readfacetfiles->proc~qsat proc~updategr updateGR proc~updategr->proc~qsat proc~eb EB proc~eb->proc~updategr program~dalesurban DALESURBAN program~dalesurban->proc~readfacetfiles program~dalesurban->proc~eb Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code real function qsat ( T ) implicit none real , intent ( in ) :: T real :: gres gres = 61 1.00 * exp ( 1 7.27 * ( T - 27 3.15 ) / ( T - 3 5.85 )) ![Pa] Bolton 1980 qsat = 0.62198 * 0.01 * gres / ( 1000 - 0.01 * gres ) ![kg/kg] Murphy & Koop 2005 !1000 can be replaced with actual air pressure if desired end function qsat","tags":"","url":"proc/qsat.html"},{"title":"dqsatdT – uDALES","text":"public  function dqsatdT(T) Arguments Type Intent Optional Attributes Name real, intent(in) :: T Return Value real Source Code real function dqsatdT ( T ) implicit none real , intent ( in ) :: T dqsatdT = 0.1384832710e-2 + 0.7708409674e-4 * ( T - 300 ) + 0.2022064593e-5 * ( T - 300 ) ** 2 + 0.000000036561 * ( T - 300 ) ** 3 !expansion of qsat(T) end function dqsatdt","tags":"","url":"proc/dqsatdt.html"},{"title":"readfacetfiles – uDALES","text":"public  subroutine readfacetfiles() Uses modglobal proc~~readfacetfiles~~UsesGraph proc~readfacetfiles readfacetfiles module~modglobal modglobal proc~readfacetfiles->module~modglobal Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~readfacetfiles~~CallsGraph proc~readfacetfiles readfacetfiles mpi_bcast mpi_bcast proc~readfacetfiles->mpi_bcast nf90_get_var nf90_get_var proc~readfacetfiles->nf90_get_var nf90_inq_varid nf90_inq_varid proc~readfacetfiles->nf90_inq_varid nf90_open nf90_open proc~readfacetfiles->nf90_open proc~qsat qsat proc~readfacetfiles->proc~qsat Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~readfacetfiles~~CalledByGraph proc~readfacetfiles readfacetfiles program~dalesurban DALESURBAN program~dalesurban->proc~readfacetfiles Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine readfacetfiles use modglobal , only : block , cexpnr , iwallmom , iwalltemp , iwallmoist implicit none !use modglobal, only:block !read initial&unchangeable facet values from files !read blocks and facet Nr corresponding to block faces (Order: Top, West, East, North, South) !define facets with properties and initial temperature !read facets.inp.xxx facetarea.inp.xxx vf.inp.xxx factypes.inp.xxx !read netsw.inp.xxx (if sun is not constant, K needs to be calculated at every EB-timestep) !read tfacinit.inp.xxx !use modglobal, only : nblocks, nfcts, cexpnr, ifinput character ( len = 13 ) :: FILE_VF = 'vf.nc.inp.xxx' integer :: ncid , varid integer :: n = 0 , m = 0 , i = 0 , j = 0 , k = 0 , io = 0 integer :: iret if (. not .( nfcts > 0 )) return nfacprops = 6 + 4 * nfaclyrs + 1 ! used by LES solver - needed on every rank allocate ( facets ( nfcts )); facets = 0 allocate ( facnorm ( nfcts , 3 )); facnorm = 0. allocate ( facz0 ( 0 : nfcts )); facz0 = 0. allocate ( facz0h ( 0 : nfcts )); facz0h = 0. allocate ( faca ( 0 : nfcts )); faca = 0. allocate ( faclGR ( 0 : nfcts )); faclGR = . false . ! only used by SEB if ( myid == 0 ) then !allocate (facalb(0:nfcts)); facalb = 0. allocate ( facem ( 0 : nfcts )); facem = 0. allocate ( facd ( 0 : nfcts , nfaclyrs )); facd = 0. allocate ( faccp ( 0 : nfcts , nfaclyrs )); faccp = 0. allocate ( faclam ( 0 : nfcts , nfaclyrs + 1 )); faclam = 0. !allocate (fackappa(0:nfcts, nfaclyrs+1)); fackappa = 0. end if ! quantities needed when temperature/humidity of facets is specified if ( lEB . or . iwallmom == 2 . or . iwalltemp == 2 . or . iwallmoist == 2 ) then allocate ( facT ( 0 : nfcts , nfaclyrs + 1 )); facT = 0. allocate ( fachurel ( 0 : nfcts )); fachurel = 0 ; allocate ( facqsat ( 0 : nfcts )); facqsat = 0 ; allocate ( facf ( 0 : nfcts , 5 )); facf = 0. ; facf (:, 4 ) = 20 0. ; facf (:, 5 ) = 5 0. ! standard plant & soil resistance for grass (Manickathan2018) in s/m if ( myid == 0 ) then allocate ( Tfacinit ( 1 : nfcts )); Tfacinit = 0. allocate ( Tfacinit_layers ( 1 : nfcts , nfaclyrs )) end if end if ! quantities associated with surface energy balance if ( lEB ) then allocate ( fachf ( 0 : nfcts )); fachf = 0. allocate ( facef ( 1 : nfcts )); facef = 0. allocate ( fachfsum ( 1 : nfcts )); fachfsum = 0. allocate ( facefsum ( 1 : nfcts )); facefsum = 0. if ( myid == 0 ) then allocate ( facTdash ( 1 : nfcts , nfaclyrs + 1 )); facTdash = 0. allocate ( fachfi ( 0 : nfcts )); fachfi = 0. allocate ( facefi ( 1 : nfcts )); facefi = 0. allocate ( facwsoil ( 0 : nfcts )); facwsoil = 0 ; allocate ( svf ( 1 : nfcts )); svf = 0. allocate ( netsw ( 1 : nfcts )); netsw = 0. allocate ( facLWin ( 1 : nfcts )); facLWin = 0. if ( lvfsparse ) then allocate ( ivfsparse ( 1 : nnz )); ivfsparse = 0 allocate ( jvfsparse ( 1 : nnz )); jvfsparse = 0 allocate ( vfsparse ( 1 : nnz )); vfsparse = 0. else allocate ( vf ( 1 : nfcts , 1 : nfcts )); vf = 0. end if end if end if ! Read files if ( myid == 0 . and . libm ) then nfactypes = - 3 !3 lines as headers open ( ifinput , file = 'factypes.inp.' // cexpnr ) do read ( ifinput , * , iostat = io ) if ( io /= 0 ) exit nfactypes = nfactypes + 1 end do close ( ifinput ) end if call MPI_BCAST ( nfactypes , 1 , MPI_Integer , 0 , comm3d , mpierr ) allocate ( factypes ( 1 : nfactypes , nfacprops )) if ( myid == 0 . and . libm ) then open ( ifinput , file = 'factypes.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess read ( ifinput , '(a80)' ) chmess read ( ifinput , '(a80)' ) chmess do n = 1 , nfactypes read ( ifinput , * ) ( factypes ( n , m ), m = 1 , nfacprops ) end do close ( ifinput ) end if call MPI_BCAST ( factypes , nfacprops * nfactypes , MY_REAL , 0 , comm3d , mpierr ) !create an array mapping factypes to sequential integers for indexing !e.g. lets assume walltype -3,-1,1,2,3 and 5 are defined. !index: [-3,-2,-1,0,1,2,3,4,5]  -> [-3,-2,-1,0,1,2,3,4,5] !value: [ 0, 0, 0,0,0,0,0,0,0]  -> [ 1, 0, 2,0,3,4,5,0,6] allocate ( typeloc ( int ( minval ( factypes (:, 1 ))): int ( maxval ( factypes (:, 1 ))))) if ( myid . eq . 0 . and . libm ) then typeloc = 0 do n = 1 , nfactypes typeloc ( int ( factypes ( n , 1 ))) = n end do open ( ifinput , file = 'facets.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess do n = 1 , nfcts read ( ifinput , * ) facets ( n ), facnorm ( n , 1 ), facnorm ( n , 2 ), facnorm ( n , 3 ) end do close ( ifinput ) do n = 1 , nfcts i = typeloc ( facets ( n )) faclGR ( n ) = ( abs ( factypes ( i , 2 ) - 1.00 ) < 1.0D-5 ) !logic for green surface, conversion from real to logical facz0 ( n ) = factypes ( i , 3 ) !surface momentum roughness facz0h ( n ) = factypes ( i , 4 ) !surface heat & moisture roughness !facalb(n) = factypes(i, 5) !surface shortwave albedo facem ( n ) = factypes ( i , 6 ) !surface longwave emissivity if ( facets ( n ) < - 100 ) then !it's a bounding wall, or more generally a facet for which we don't want to model SEB do j = 1 , nfaclyrs facd ( n , j ) = 0. faclam ( n , j ) = 0. faccp ( n , j ) = 0. end do else do j = 1 , nfaclyrs !for all layers facd ( n , j ) = factypes ( i , 6 + j ) !facet thickness of layer j faccp ( n , j ) = factypes ( i , 6 + nfaclyrs + j ) !specific heat capacity of layer j !faclam(n, j) = factypes(i, 6 + 2 * nfaclyrs + j) !heat conductivity of layer j end do faclam ( n , 1 ) = factypes ( i , 6 + 2 * nfaclyrs + 1 ) do j = 2 , nfaclyrs faclam ( n , j ) = ( factypes ( i , 6 + 2 * nfaclyrs + j - 1 ) + factypes ( i , 6 + 2 * nfaclyrs + j )) / 2. !inverse of heat conductivity of layer j end do end if faclam ( n , nfaclyrs + 1 ) = faclam ( n , nfaclyrs ) ! do j= 1,nfaclyrs+1 !   fackappa(n, j) = factypes(i, 6 + 3 * nfaclyrs + j) !heat diffusivity of layer 1 ! end do end do if ( lEB . or . lwritefac ) then ! read facet areas open ( ifinput , file = 'facetarea.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess do n = 1 , nfcts read ( ifinput , * ) & faca ( n ) end do close ( ifinput ) end if if ( lEB ) then if ( lvfsparse ) then open ( ifinput , file = 'vfsparse.inp.' // cexpnr ) do n = 1 , nnz read ( ifinput , * ) ivfsparse ( n ), jvfsparse ( n ), vfsparse ( n ) end do close ( ifinput ) else FILE_VF = 'vf.nc.inp.' // cexpnr iret = nf90_open ( FILE_VF , NF90_NOWRITE , ncid ) ! Get the varid of the data variable, based on its name. iret = nf90_inq_varid ( ncid , \"view factor\" , varid ) ! Read the data. iret = nf90_get_var ( ncid , varid , vf ) end if ! read skyviewfactors open ( ifinput , file = 'svf.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess do n = 1 , nfcts read ( ifinput , * ) & svf ( n ) end do close ( ifinput ) ! read net shortwave radiation open ( ifinput , file = 'netsw.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess do n = 1 , nfcts read ( ifinput , * ) & netsw ( n ) end do close ( ifinput ) do n = 1 , nfcts if ( faclGR ( n )) then facwsoil ( n ) = wsoil end if end do end if !lEB if (( lEB ) . or . ( iwalltemp == 2 ) . or . ( iwallmom == 2 ) . or . ( iwallmoist == 2 )) then ! initial facet temperatures if ( lfacTlyrs ) then open ( ifinput , file = 'Tfacinit_layers.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess do n = 1 , nfcts read ( ifinput , * ) ( Tfacinit_layers ( n , j ), j = 1 , nfaclyrs ) end do close ( ifinput ) do n = 1 , nfcts do j = 1 , nfaclyrs facT ( n , j ) = Tfacinit_layers ( n , j ) end do if ( facets ( n ) > 0 ) then ! Not a floor facT ( n , nfaclyrs + 1 ) = bldT else !floor facT ( n , nfaclyrs + 1 ) = flrT end if end do else open ( ifinput , file = 'Tfacinit.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess do n = 1 , nfcts read ( ifinput , * ) & Tfacinit ( n ) end do close ( ifinput ) do n = 1 , nfcts facT ( n , 1 ) = Tfacinit ( n ) !building surfaces is given an initial temperature if ( facets ( n ) > 0 ) then ! Not a floor facT ( n , nfaclyrs + 1 ) = bldT !inner most layer has the same temperature as the building interior do j = 2 , nfaclyrs facT ( n , j ) = Tfacinit ( n ) - ( Tfacinit ( n ) - bldT ) / nfaclyrs * ( j - 1 ) !scale linearly inside the wall end do else !floor facT ( n , nfaclyrs + 1 ) = flrT !inner most layer has the same temperature as the ground do j = 2 , nfaclyrs facT ( n , j ) = Tfacinit ( n ) - ( Tfacinit ( n ) - flrT ) / nfaclyrs * ( j - 1 ) !scale linearly inside the wall end do end if end do end if ! lfacTlyrs do n = 1 , nfaclyrs facT ( 0 , n ) = 28 8. end do facT ( 0 , nfaclyrs + 1 ) = 29 9. ! assign initial soil moisture for outermost layer do n = 1 , nfcts facqsat ( n ) = qsat ( facT ( n , 1 )) if ( faclGR ( n )) then fachurel ( n ) = 0.5 * ( 1. - cos ( 3.14159 * wsoil / wfc )) end if end do end if !((lEB) .or. (iwalltemp == 2) .or. (iwallmoist==2)) end if !(myid .eq. 0) call MPI_BCAST ( facz0 ( 0 : nfcts ), nfcts + 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( facz0h ( 0 : nfcts ), nfcts + 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( faca ( 0 : nfcts ), nfcts + 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( facets , nfcts , MPI_Integer , 0 , comm3d , mpierr ) call MPI_BCAST ( facnorm , nfcts * 3 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( faclGR ( 0 : nfcts ), nfcts + 1 , mpi_logical , 0 , comm3d , mpierr ) !call MPI_BCAST(facalb(0:nfcts), nfcts + 1, MY_REAL, 0, comm3d, mpierr) !call MPI_BCAST(facem(0:nfcts), nfcts + 1, MY_REAL, 0, comm3d, mpierr) !call MPI_BCAST(facd(0:nfcts,1:nfaclyrs),(nfcts+1)*nfaclyrs, MY_REAL, 0, comm3d, mpierr) !call MPI_BCAST(faccp(0:nfcts, 1:nfaclyrs), (nfcts + 1)*nfaclyrs, MY_REAL, 0, comm3d, mpierr) !call MPI_BCAST(faclam(0:nfcts, 1:nfaclyrs), (nfcts + 1)*nfaclyrs, MY_REAL, 0, comm3d, mpierr) !call MPI_BCAST(fackappa(0:nfcts, 1:nfaclyrs+1), (nfcts + 1)*(nfaclyrs+1), MY_REAL, 0, comm3d, mpierr) if ( lEB ) then ! no need to broadcast - only used by rank 0 !call MPI_BCAST(svf(1:nfcts), nfcts, MY_REAL, 0, comm3d, mpierr) !call MPI_BCAST(netsw(1:nfcts), nfcts, MY_REAL, 0, comm3d, mpierr) ! no need to broadcast - not dependent on input files !call MPI_BCAST(facTdash(1:nfcts, 1:nfaclyrs+1), (nfcts)*(nfaclyrs+1), MY_REAL, 0, comm3d, mpierr) !call MPI_BCAST(facef(1:nfcts), nfcts, MY_REAL, 0, comm3d, mpierr) !call MPI_BCAST(facefi(1:nfcts), nfcts, MY_REAL, 0, comm3d, mpierr) !call MPI_BCAST(facefsum(1:nfcts), nfcts, MY_REAL, 0, comm3d, mpierr) !call MPI_BCAST(fachf(0:nfcts), nfcts + 1, MY_REAL, 0, comm3d, mpierr) !call MPI_BCAST(fachfi(0:nfcts), nfcts + 1, MY_REAL, 0, comm3d, mpierr) !call MPI_BCAST(fachfsum(1:nfcts), nfcts, MY_REAL, 0, comm3d, mpierr) !call MPI_BCAST(facwsoil(0:nfcts), nfcts + 1, MY_REAL, 0, comm3d, mpierr) !call MPI_BCAST(facf(0:nfcts, 1:5), (nfcts + 1)*5, MY_REAL, 0, comm3d, mpierr) end if if (( lEB ) . or . ( iwalltemp == 2 ) . or . ( iwallmom == 2 )) then call MPI_BCAST ( facT ( 0 : nfcts , 1 : nfaclyrs + 1 ), ( nfcts + 1 ) * ( nfaclyrs + 1 ), MY_REAL , 0 , comm3d , mpierr ) !call MPI_BCAST(Tfacinit(1:nfcts), nfcts, MY_REAL, 0, comm3d, mpierr) call MPI_BCAST ( fachurel ( 0 : nfcts ), nfcts + 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( facqsat ( 0 : nfcts ), nfcts + 1 , MY_REAL , 0 , comm3d , mpierr ) if ( myid == 0 ) then deallocate ( Tfacinit ) deallocate ( Tfacinit_layers ) end if end if end subroutine readfacetfiles","tags":"","url":"proc/readfacetfiles.html"},{"title":"initdriver – uDALES","text":"public  subroutine initdriver() Uses decomp_2d modfields modmpi modglobal proc~~initdriver~~UsesGraph proc~initdriver initdriver decomp_2d decomp_2d proc~initdriver->decomp_2d module~modfields modfields proc~initdriver->module~modfields module~modglobal modglobal proc~initdriver->module~modglobal module~modmpi modmpi proc~initdriver->module~modmpi module~modfields->decomp_2d mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~initdriver~~CallsGraph proc~initdriver initdriver zend zend proc~initdriver->zend zstart zstart proc~initdriver->zstart Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~initdriver~~CalledByGraph proc~initdriver initdriver program~dalesurban DALESURBAN program~dalesurban->proc~initdriver Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine initdriver use modglobal , only : ih , ib , ie , jh , jb , je , kb , ke , kh , jhc , khc , idriver , lchunkread , chunkread_size , iplane , xf , lstoreplane , nstore , Uinf , ltempeq , lmoist , pi , zf , zh , driverstore , tdriverstart , tdriverdump , timeleft , dtdriver , nsv , timee , lhdriver , lqdriver , lsdriver , ibrank , iplanerank , driverid , cdriverid use modfields , only : um use modmpi , only : myid , nprocs , myidy , nprocy use decomp_2d , only : zstart , zend implicit none real :: pfi , epsi integer :: k if ( idriver == 1 ) then ! if (tdriverstart < timee) then !   write(0, *) 'ERROR: tdriverstart must be greater than the elapsed time at the start of the simulation' !   stop 1 ! end if tdriverdump = tdriverstart if (( iplane >= zstart ( 1 )) . and . ( iplane <= zend ( 1 ))) then iplanerank = . true . irecydriver = iplane - zstart ( 1 ) + 1 end if endif driverid = mod ( myidy , nprocy ) write ( cdriverid , '(i3.3)' ) driverid if ( idriver == 1 . and . iplanerank ) then allocate ( storetdriver ( 1 : driverstore )) allocate ( storeu0driver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storeumdriver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storev0driver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storevmdriver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storew0driver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storewmdriver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) !allocate(storee120driver(jb-jh:je+jh,kb-kh:ke+kh,1:driverstore)) !allocate(storee12mdriver(jb-jh:je+jh,kb-kh:ke+kh,1:driverstore)) if ( ltempeq ) then allocate ( storethl0driver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storethlmdriver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) end if if ( lmoist ) then allocate ( storeqt0driver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storeqtmdriver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) end if if ( nsv > 0 ) then allocate ( storesv0driver ( jb - jhc : je + jhc , kb - khc : ke + khc , 1 : nsv , 1 : driverstore )) allocate ( storesvmdriver ( jb - jhc : je + jhc , kb - khc : ke + khc , 1 : nsv , 1 : driverstore )) end if else if ( idriver == 2 . and . ibrank ) then allocate ( storetdriver ( 1 : driverstore )) if (. not .( lchunkread )) then allocate ( storeu0driver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storeumdriver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storev0driver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storevmdriver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storew0driver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storewmdriver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) !allocate(storee120driver(jb-jh:je+jh,kb-kh:ke+kh,1:driverstore)) !allocate(storee12mdriver(jb-jh:je+jh,kb-kh:ke+kh,1:driverstore)) allocate ( u0driver ( jb - jh : je + jh , kb - kh : ke + kh )) allocate ( v0driver ( jb - jh : je + jh , kb - kh : ke + kh )) allocate ( u0driverrot ( jb - jh : je + jh , kb - kh : ke + kh )) allocate ( v0driverrot ( jb - jh : je + jh , kb - kh : ke + kh )) allocate ( w0driver ( jb - jh : je + jh , kb - kh : ke + kh )) !allocate(e120driver(jb-jh:je+jh,kb-kh:ke+kh)) allocate ( umdriver ( jb - jh : je + jh , kb - kh : ke + kh )) allocate ( vmdriver ( jb - jh : je + jh , kb - kh : ke + kh )) allocate ( wmdriver ( jb - jh : je + jh , kb - kh : ke + kh )) !allocate(e12mdriver(jb-jh:je+jh,kb-kh:ke+kh)) if ( ltempeq . and . lhdriver ) then allocate ( storethl0driver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storethlmdriver ( jb - jh : je + kh , kb - kh : ke + kh , 1 : driverstore )) allocate ( thl0driver ( jb - jh : je + jh , kb - kh : ke + kh )) allocate ( thlmdriver ( jb - jh : je + jh , kb - kh : ke + kh )) end if if ( lmoist . and . lqdriver ) then allocate ( storeqt0driver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storeqtmdriver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( qt0driver ( jb - jh : je + jh , kb - kh : ke + kh )) allocate ( qtmdriver ( jb - jh : je + jh , kb - kh : ke + kh )) end if if ( nsv > 0 . and . lsdriver ) then allocate ( storesv0driver ( jb - jhc : je + jhc , kb - khc : ke + khc , 1 : nsv , 1 : driverstore )) allocate ( storesvmdriver ( jb - jhc : je + jhc , kb - khc : ke + khc , 1 : nsv , 1 : driverstore )) allocate ( sv0driver ( jb - jhc : je + jhc , kb - khc : ke + khc , 1 : nsv )) allocate ( svmdriver ( jb - jhc : je + jhc , kb - khc : ke + khc , 1 : nsv )) end if else ! if(lchunkread) allocate ( storeu0driver ( jb - jh : je + jh , kb - kh : ke + kh , 0 : chunkread_size )) allocate ( storeumdriver ( jb - jh : je + jh , kb - kh : ke + kh , 0 : chunkread_size )) allocate ( storev0driver ( jb - jh : je + jh , kb - kh : ke + kh , 0 : chunkread_size )) allocate ( storevmdriver ( jb - jh : je + jh , kb - kh : ke + kh , 0 : chunkread_size )) allocate ( storew0driver ( jb - jh : je + jh , kb - kh : ke + kh , 0 : chunkread_size )) allocate ( storewmdriver ( jb - jh : je + jh , kb - kh : ke + kh , 0 : chunkread_size )) !allocate(storee120driver(jb-jh:je+jh,kb-kh:ke+kh,0:chunkread_size)) !allocate(storee12mdriver(jb-jh:je+jh,kb-kh:ke+kh,0:chunkread_size)) allocate ( u0driver ( jb - jh : je + jh , kb - kh : ke + kh )) allocate ( v0driver ( jb - jh : je + jh , kb - kh : ke + kh )) allocate ( u0driverrot ( jb - jh : je + jh , kb - kh : ke + kh )) allocate ( v0driverrot ( jb - jh : je + jh , kb - kh : ke + kh )) allocate ( w0driver ( jb - jh : je + jh , kb - kh : ke + kh )) !allocate(e120driver(jb-jh:je+jh,kb-kh:ke+kh)) allocate ( umdriver ( jb - jh : je + jh , kb - kh : ke + kh )) allocate ( vmdriver ( jb - jh : je + jh , kb - kh : ke + kh )) allocate ( wmdriver ( jb - jh : je + jh , kb - kh : ke + kh )) !allocate(e12mdriver(jb-jh:je+jh,kb-kh:ke+kh)) if ( ltempeq . and . lhdriver ) then allocate ( storethl0driver ( jb - jh : je + jh , kb - kh : ke + kh , 0 : chunkread_size )) allocate ( storethlmdriver ( jb - jh : je + kh , kb - kh : ke + kh , 0 : chunkread_size )) allocate ( thl0driver ( jb - jh : je + jh , kb - kh : ke + kh )) allocate ( thlmdriver ( jb - jh : je + jh , kb - kh : ke + kh )) end if if ( lmoist . and . lqdriver ) then allocate ( storeqt0driver ( jb - jh : je + jh , kb - kh : ke + kh , 0 : chunkread_size )) allocate ( storeqtmdriver ( jb - jh : je + jh , kb - kh : ke + kh , 0 : chunkread_size )) allocate ( qt0driver ( jb - jh : je + jh , kb - kh : ke + kh )) allocate ( qtmdriver ( jb - jh : je + jh , kb - kh : ke + kh )) end if if ( nsv > 0 . and . lsdriver ) then allocate ( storesv0driver ( jb - jhc : je + jhc , kb - khc : ke + khc , 1 : nsv , 0 : chunkread_size )) allocate ( storesvmdriver ( jb - jhc : je + jhc , kb - khc : ke + khc , 1 : nsv , 0 : chunkread_size )) allocate ( sv0driver ( jb - jhc : je + jhc , kb - khc : ke + khc , 1 : nsv )) allocate ( svmdriver ( jb - jhc : je + jhc , kb - khc : ke + khc , 1 : nsv )) end if end if else return end if end subroutine initdriver","tags":"","url":"proc/initdriver.html"},{"title":"drivergen – uDALES","text":"public  subroutine drivergen() Uses modfields modmpi modsave modglobal proc~~drivergen~~UsesGraph proc~drivergen drivergen module~modfields modfields proc~drivergen->module~modfields module~modglobal modglobal proc~drivergen->module~modglobal module~modmpi modmpi proc~drivergen->module~modmpi module~modsave modsave proc~drivergen->module~modsave decomp_2d decomp_2d module~modfields->decomp_2d mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~drivergen~~CallsGraph proc~drivergen drivergen proc~writedriverfile writedriverfile proc~drivergen->proc~writedriverfile Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~drivergen~~CalledByGraph proc~drivergen drivergen proc~boundary boundary proc~boundary->proc~drivergen proc~readinitfiles readinitfiles proc~readinitfiles->proc~drivergen program~dalesurban DALESURBAN program~dalesurban->proc~boundary program~dalesurban->proc~readinitfiles Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine drivergen use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , zf , zh , dzf , dzhi , timee , btime , totavtime , rk3step ,& dt , numol , iplane , lles , idriver , inletav , runavtime , Uinf , lwallfunc , linletRA ,& totinletav , lstoreplane , nstore , driverstore , prandtlmoli , numol , grav , lbuoyancy ,& lfixinlet , lfixutauin , tdriverstart , dtdriver , tdriverdump , lchunkread , chunkread_size , ltempeq , lmoist , nsv , lhdriver , lqdriver , lsdriver ,& ibrank , iplanerank , driverid , cdriverid , runtime , lwarmstart , cdriverjobnr use modfields , only : u0 , v0 , w0 , e120 , thl0 , qt0 , wm , uprof , vprof use modsave , only : writerestartfiles use modmpi , only : slabsum , myid implicit none real :: inlrec ! time of last inlet record real :: elapsrec ! time elapsed in this inlet record real :: dtint ! dt for linear interpolation real , PARAMETER :: eps = 1 d - 4 integer i , j , k , kk , kdamp , x , xc if ( idriver == 1 . and . iplanerank ) then ! if (.not. (rk3step==3)) return if (. not . ( timee >= tdriverstart )) return if (. not . ( timee >= tdriverdump )) return if ( nstepreaddriver >= driverstore ) return if ( nstepreaddriver == 0 ) then ! tdriverdump = timee tdriverdump = tdriverstart ! tdriverstart = timee   !Update tdriverstart to the actual recorded value if (( driverid == 0 ) . and . ( rk3step == 3 )) then write ( 6 , * ) '==================================================================' write ( 6 , * ) '*** Starting to write data for driver simulation ***' write ( 6 , * ) 'Driver recording variables:' write ( 6 , '(A,F15.5,A,I8,A,F12.9)' ) ' Starting time: ' , tdriverdump , ' Stored time steps: ' , driverstore , '     Inlet record intervals: ' , dtdriver write ( 6 , * ) '==================================================================' end if end if if ( rk3step == 3 ) then nstepreaddriver = nstepreaddriver + 1 tdriverdump = tdriverdump + dtdriver ! storetinlet(nstepreaddriver) = timee - tdriverstart call writedriverfile end if elseif ( idriver == 2 ) then ! this gets called in modboundary when ibrank=.true., so no need for switch if ( timee > ( runtime + btime )) return if ( driverid == 0 ) then if (. not .( lwarmstart )) then if ( runtime > maxval ( storetdriver )) then write ( * , '(A,F15.5,A,F15.5,A)' ) \"Simulation will stop before runtime = \" , runtime , \", since last & &read driver time (\" , maxval ( storetdriver ), \") is less than runtime.\" end if else ! if lwarmstart if ( runtime + btime > maxval ( storetdriver )) then write ( * , '(A,F15.5,A,F15.5,A)' ) \"Simulation will stop before runtime+btime = \" , runtime + btime , \", since last & &read driver time (\" , maxval ( storetdriver ), \") is less than runtime+btime.\" end if end if end if ! if (.not. rk3step==1) return if ( timee > maxval ( storetdriver )) then if ( driverid == 0 ) then write ( 0 , '(A,F15.5,A,F15.5)' ) 'timee: ' , timee , '     Final inlet driver time:' , maxval ( storetdriver ) write ( 0 , '(A,I8,A,I8)' ) 'Inlet driver step: ' , nstepreaddriver , '     Total inlet driver steps:' , driverstore end if stop 'Time in simulation has exceeded the inlet information - no more inlet data available!' end if if (. not .( lchunkread )) then x = minloc ( abs ( storetdriver - timee ), 1 ) elapsrec = storetdriver ( x ) - timee if ( myid == 0 ) then ! if(rk3step==1) then ! write(6,*) '============ Inlet interpolating =============' ! write(6,*) 'Inlet interpolation time = ', elapsrec ! write(6,'(A,F9.4)') 'Inlet driver time stamp (x)  = ', storetdriver(x) ! write(6,'(A,F9.4)') 'Inlet driver time stamp (x+1) = ', storetdriver(x+1) ! write(6,'(A,F9.4)') 'Inlet driver time stamp (x-1) = ', storetdriver(x-1) ! write(6,'(A,E20.12)') 'Reading driver velocity: storeu0driver(je,ke,x) = ', storeu0driver(je,ke,x) ! write(6,*) 'Inlet step = ',nstepreaddriver ! end if end if if ( abs ( elapsrec ) < eps ) then if (( driverid == 0 ) . and . (( rk3step == 0 ) . or . ( rk3step == 3 ))) then write ( * , '(A,I8,A,F15.5,A)' ) '======= Inputs loaded from driver tstep ' , x , ' (at ' , storetdriver ( x ), 's) =======' end if u0driver (:,:) = storeu0driver (:,:, x ) v0driver (:,:) = storev0driver (:,:, x ) w0driver (:,:) = storew0driver (:,:, x ) !e120driver(:,:) = storee120driver(:,:,x) if ( ltempeq . and . lhdriver ) then thl0driver (:,:) = storethl0driver (:,:, x ) end if if ( lmoist . and . lqdriver ) then qt0driver (:,:) = storeqt0driver (:,:, x ) end if if ( nsv > 0 . and . lsdriver ) then sv0driver (:,:,:) = storesv0driver (:,:,:, x ) end if nstepreaddriver = x elseif (( elapsrec > 0. ) . and . ( x == 1 )) then if (( driverid == 0 ) . and . (( rk3step == 0 ) . or . ( rk3step == 3 ))) then write ( * , '(A,F15.5,A)' ) '======= Inputs loaded from the proceeding driver tstep 1 (at ' , storetdriver ( x ), 's) =======' end if u0driver (:,:) = storeu0driver (:,:, x ) v0driver (:,:) = storev0driver (:,:, x ) w0driver (:,:) = storew0driver (:,:, x ) ! e120driver(:,:) = storee120driver(:,:,x) if ( ltempeq . and . lhdriver ) then thl0driver (:,:) = storethl0driver (:,:, x ) end if if ( lmoist . and . lqdriver ) then qt0driver (:,:) = storeqt0driver (:,:, x ) end if if ( nsv > 0 . and . lsdriver ) then sv0driver (:,:,:) = storesv0driver (:,:,:, x ) end if nstepreaddriver = x elseif ( elapsrec < 0. ) then if (( driverid == 0 ) . and . (( rk3step == 0 ) . or . ( rk3step == 3 ))) then write ( * , '(A,I8,A,F15.5,A,I8,A,F15.5,A)' ) '======= Inputs interpolated from driver tsteps ' , x , ' (' , storetdriver ( x ), ' s) and ' , x + 1 , ' (' , storetdriver ( x + 1 ), ' s) =======' end if dtint = ( timee - storetdriver ( x )) / ( storetdriver ( x + 1 ) - storetdriver ( x )) ! if(myid==0) then ! write(6,'(A,I4)') 'x: ', x ! write(6,'(A,F9.4)') 'dtint: ', dtint ! write(6,'(A,E20.12)') 'storeu0driver(1,32,x): ', storeu0driver(1,32,x) ! write(6,'(A,E20.12)') 'storeu0driver(1,32,x+1): ', storeu0driver(1,32,x+1) ! write(6,'(A,E20.12)') 'u0driver(1,32): ',  storeu0driver(1,32,x) + (storeu0driver(1,32,x+1)-storeu0driver(1,32,x))*dtint ! end if u0driver (:,:) = storeu0driver (:,:, x ) + ( storeu0driver (:,:, x + 1 ) - storeu0driver (:,:, x )) * dtint v0driver (:,:) = storev0driver (:,:, x ) + ( storev0driver (:,:, x + 1 ) - storev0driver (:,:, x )) * dtint w0driver (:,:) = storew0driver (:,:, x ) + ( storew0driver (:,:, x + 1 ) - storew0driver (:,:, x )) * dtint ! e120driver(:,:) = storee120driver(:,:,x) + (storee120driver(:,:,x+1)-storee120driver(:,:,x))*dtint if ( ltempeq . and . lhdriver ) then thl0driver (:,:) = storethl0driver (:,:, x ) + ( storethl0driver (:,:, x + 1 ) - storethl0driver (:,:, x )) * dtint end if if ( lmoist . and . lqdriver ) then qt0driver (:,:) = storeqt0driver (:,:, x ) + ( storeqt0driver (:,:, x + 1 ) - storeqt0driver (:,:, x )) * dtint end if if ( nsv > 0 . and . lsdriver ) then sv0driver (:,:,:) = storesv0driver (:,:,:, x ) + ( storesv0driver (:,:,:, x + 1 ) - storesv0driver (:,:,:, x )) * dtint end if nstepreaddriver = x elseif ( elapsrec > 0. ) then if (( driverid == 0 ) . and . (( rk3step == 0 ) . or . ( rk3step == 3 ))) then write ( * , '(A,I8,A,F15.5,A,I8,A,F15.5,A)' ) '======= Inputs interpolated from driver tsteps ' , x , ' (' , storetdriver ( x ), ' s) and ' , x - 1 , ' (' , storetdriver ( x - 1 ), ' s) =======' end if dtint = ( timee - storetdriver ( x - 1 )) / ( storetdriver ( x ) - storetdriver ( x - 1 )) u0driver (:,:) = storeu0driver (:,:, x - 1 ) + ( storeu0driver (:,:, x ) - storeu0driver (:,:, x - 1 )) * dtint v0driver (:,:) = storev0driver (:,:, x - 1 ) + ( storev0driver (:,:, x ) - storev0driver (:,:, x - 1 )) * dtint w0driver (:,:) = storew0driver (:,:, x - 1 ) + ( storew0driver (:,:, x ) - storew0driver (:,:, x - 1 )) * dtint ! e120driver(:,:) = storee120driver(:,:,x-1) + (storee120driver(:,:,x)-storee120driver(:,:,x-1))*dtint if ( ltempeq . and . lhdriver ) then thl0driver (:,:) = storethl0driver (:,:, x - 1 ) + ( storethl0driver (:,:, x ) - storethl0driver (:,:, x - 1 )) * dtint end if if ( lmoist . and . lqdriver ) then qt0driver (:,:) = storeqt0driver (:,:, x - 1 ) + ( storeqt0driver (:,:, x ) - storeqt0driver (:,:, x - 1 )) * dtint end if if ( nsv > 0 . and . lsdriver ) then sv0driver (:,:,:) = storesv0driver (:,:,:, x - 1 ) + ( storesv0driver (:,:,:, x ) - storesv0driver (:,:,:, x - 1 )) * dtint end if nstepreaddriver = x end if else ! if (lchunkread) x = minloc ( abs ( storetdriver - timee ), 1 ) xc = mod ( x , chunkread_size ) if ( xc == 0 ) xc = x - ( chunkreadctr - 2 ) * chunkread_size elapsrec = storetdriver ( x ) - timee if ( myid == 0 ) then ! if(rk3step==1) then ! write(6,*) '============ Inlet interpolating =============' ! write(6,*) 'Inlet interpolation time = ', elapsrec ! write(6,'(A,F9.4)') 'Inlet driver time stamp (x)  = ', storetdriver(x) ! write(6,'(A,F9.4)') 'Inlet driver time stamp (x+1) = ', storetdriver(x+1) ! write(6,'(A,F9.4)') 'Inlet driver time stamp (x-1) = ', storetdriver(x-1) ! write(6,'(A,E20.12)') 'Reading driver velocity: storeu0driver(je,ke,x) = ', storeu0driver(je,ke,x) ! write(6,*) 'Inlet step = ',nstepreaddriver ! end if end if if ( abs ( elapsrec ) < eps ) then if (( driverid == 0 ) . and . (( rk3step == 0 ) . or . ( rk3step == 3 ))) then write ( * , '(A,I8,A,I8,A,F15.5,A)' ) '======= Inputs loaded from driver tstep ' , x , '(' , xc , ') (at ' , storetdriver ( x ), 's) =======' end if u0driver (:,:) = storeu0driver (:,:, xc ) v0driver (:,:) = storev0driver (:,:, xc ) w0driver (:,:) = storew0driver (:,:, xc ) !e120driver(:,:) = storee120driver(:,:,xc) if ( ltempeq . and . lhdriver ) then thl0driver (:,:) = storethl0driver (:,:, xc ) end if if ( lmoist . and . lqdriver ) then qt0driver (:,:) = storeqt0driver (:,:, xc ) end if if ( nsv > 0 . and . lsdriver ) then sv0driver (:,:,:) = storesv0driver (:,:,:, xc ) end if elseif (( elapsrec > 0. ) . and . ( x == 1 )) then if (( driverid == 0 ) . and . (( rk3step == 0 ) . or . ( rk3step == 3 ))) then write ( * , '(A,F15.5,A,I8,A,I8)' ) '======= Inputs loaded from the proceeding driver tstep 1 (at ' , storetdriver ( x ), 's) =======' , x , '  ' , xc end if u0driver (:,:) = storeu0driver (:,:, xc ) v0driver (:,:) = storev0driver (:,:, xc ) w0driver (:,:) = storew0driver (:,:, xc ) ! e120driver(:,:) = storee120driver(:,:,xc) if ( ltempeq . and . lhdriver ) then thl0driver (:,:) = storethl0driver (:,:, xc ) end if if ( lmoist . and . lqdriver ) then qt0driver (:,:) = storeqt0driver (:,:, xc ) end if if ( nsv > 0 . and . lsdriver ) then sv0driver (:,:,:) = storesv0driver (:,:,:, xc ) end if elseif ( elapsrec < 0. ) then if (( driverid == 0 ) . and . (( rk3step == 0 ) . or . ( rk3step == 3 ))) then write ( * , '(A,I8,A,I8,A,F15.5,A,I8,A,I8,A,F15.5,A)' ) '======= Inputs interpolated from driver tsteps ' , x , '(' , xc , ') (' , storetdriver ( x ), ' s) and ' , x + 1 , '(' , xc + 1 , ') (' , storetdriver ( x + 1 ), ' s) =======' end if dtint = ( timee - storetdriver ( x )) / ( storetdriver ( x + 1 ) - storetdriver ( x )) ! if(myid==0) then ! write(6,'(A,I4)') 'x: ', x ! write(6,'(A,F9.4)') 'dtint: ', dtint ! write(6,'(A,E20.12)') 'storeu0driver(1,32,x): ', storeu0driver(1,32,x) ! write(6,'(A,E20.12)') 'storeu0driver(1,32,x+1): ', storeu0driver(1,32,x+1) ! write(6,'(A,E20.12)') 'u0driver(1,32): ',  storeu0driver(1,32,x) + (storeu0driver(1,32,x+1)-storeu0driver(1,32,x))*dtint ! end if u0driver (:,:) = storeu0driver (:,:, xc ) + ( storeu0driver (:,:, xc + 1 ) - storeu0driver (:,:, xc )) * dtint v0driver (:,:) = storev0driver (:,:, xc ) + ( storev0driver (:,:, xc + 1 ) - storev0driver (:,:, xc )) * dtint w0driver (:,:) = storew0driver (:,:, xc ) + ( storew0driver (:,:, xc + 1 ) - storew0driver (:,:, xc )) * dtint ! e120driver(:,:) = storee120driver(:,:,xc) + (storee120driver(:,:,xc+1)-storee120driver(:,:,xc))*dtint if ( ltempeq . and . lhdriver ) then thl0driver (:,:) = storethl0driver (:,:, xc ) + ( storethl0driver (:,:, xc + 1 ) - storethl0driver (:,:, xc )) * dtint end if if ( lmoist . and . lqdriver ) then qt0driver (:,:) = storeqt0driver (:,:, xc ) + ( storeqt0driver (:,:, xc + 1 ) - storeqt0driver (:,:, xc )) * dtint end if if ( nsv > 0 . and . lsdriver ) then sv0driver (:,:,:) = storesv0driver (:,:,:, xc ) + ( storesv0driver (:,:,:, xc + 1 ) - storesv0driver (:,:,:, xc )) * dtint end if elseif ( elapsrec > 0. ) then if (( driverid == 0 ) . and . (( rk3step == 0 ) . or . ( rk3step == 3 ))) then write ( * , '(A,I8,A,I8,A,F15.5,A,I8,A,I8,A,F15.5,A)' ) '======= Inputs interpolated from driver tsteps ' , x , '(' , xc , ') (' , storetdriver ( x ), ' s) and ' , x - 1 , '(' , xc - 1 , ') (' , storetdriver ( x - 1 ), ' s) =======' end if dtint = ( timee - storetdriver ( x - 1 )) / ( storetdriver ( x ) - storetdriver ( x - 1 )) u0driver (:,:) = storeu0driver (:,:, xc - 1 ) + ( storeu0driver (:,:, xc ) - storeu0driver (:,:, xc - 1 )) * dtint v0driver (:,:) = storev0driver (:,:, xc - 1 ) + ( storev0driver (:,:, xc ) - storev0driver (:,:, xc - 1 )) * dtint w0driver (:,:) = storew0driver (:,:, xc - 1 ) + ( storew0driver (:,:, xc ) - storew0driver (:,:, xc - 1 )) * dtint ! e120driver(:,:) = storee120driver(:,:,xc-1) + (storee120driver(:,:,xc)-storee120driver(:,:,xc-1))*dtint if ( ltempeq . and . lhdriver ) then thl0driver (:,:) = storethl0driver (:,:, xc - 1 ) + ( storethl0driver (:,:, xc ) - storethl0driver (:,:, xc - 1 )) * dtint end if if ( lmoist . and . lqdriver ) then qt0driver (:,:) = storeqt0driver (:,:, xc - 1 ) + ( storeqt0driver (:,:, xc ) - storeqt0driver (:,:, xc - 1 )) * dtint end if if ( nsv > 0 . and . lsdriver ) then sv0driver (:,:,:) = storesv0driver (:,:,:, xc - 1 ) + ( storesv0driver (:,:,:, xc ) - storesv0driver (:,:,:, xc - 1 )) * dtint end if end if nstepreaddriver = x !! Not sure.. may need modification end if ! rotate u0driverrot = u0driver * cos ( iangle ) - v0driver * sin ( iangle ) v0driverrot = v0driver * cos ( iangle ) + u0driver * sin ( iangle ) u0driver = u0driverrot v0driver = v0driverrot ! if(myid==0) then ! write(6,'(A,F9.4)') 'Simulation time: ', timee ! write(6,'(A,F9.4)') 'dtint: ', dtint ! write(6,*) 'Velocities interpolated:' ! write(6,'(A,e20.12)') 'storeu0driver(je,ke,x-1): ', storeu0driver(je,ke,x-1) ! write(6,'(A,e20.12)') 'storeu0driver(je,ke,x): ', storeu0driver(je,ke,x) ! write(6,'(A,e20.12)') 'storeu0driver(je,ke,x+1): ', storeu0driver(je,ke,x+1) ! write(6,'(A,e20.12)') 'Interpolated inlet velocity (jb,20): ', u0driver(jb,20) ! write(6,*) 'Temperatures interpolated:' ! write(6,'(A,e20.12)') 'storethl0driver(je,20,x-1): ', storethl0driver(jb,20,x-1) ! write(6,'(A,e20.12)') 'storethl0driver(je,20,x): ', storethl0driver(jb,20,x) ! write(6,'(A,e20.12)') 'storethl0driver(je,20,x+1): ', storethl0driver(jb,20,x+1) ! write(6,'(A,e20.12)') 'Interpolated inlet temperature (jb,20): ', thl0driver(jb,20) ! end if ! umdriver = u0driver   ! MAYBE ITS BETTER TO WRITE THE M VARIABLES TO FILE TOO AND JUST READ THEM - THOUGH CURRENTLY THIS IS NOT DONE FOR RESTART FILES?? ae1212 ! vmdriver = v0driver   ! EDIT READ AND WRITE INLET FILES (AND CHECK MODBOUNDARY & MODSURFACE) TO INCLUDE M VARIABLES ! wmdriver = w0driver ! thlmdriver = thl0driver ! qtmdriver = qt0driver if ( rk3step == 0 . or . rk3step == 3 ) then umdriver = u0driver vmdriver = v0driver wmdriver = w0driver !e12mdriver = e120driver if ( ltempeq . and . lhdriver ) then thlmdriver = thl0driver end if if ( lmoist . and . lqdriver ) then qtmdriver = qt0driver end if if ( nsv > 0 . and . lsdriver ) then svmdriver = sv0driver end if end if else return end if ! idrivergen end subroutine drivergen","tags":"","url":"proc/drivergen.html"},{"title":"writedriverfile – uDALES","text":"public  subroutine writedriverfile() Uses modfields modinletdata modmpi modglobal proc~~writedriverfile~~UsesGraph proc~writedriverfile writedriverfile module~modfields modfields proc~writedriverfile->module~modfields module~modglobal modglobal proc~writedriverfile->module~modglobal module~modinletdata modinletdata proc~writedriverfile->module~modinletdata module~modmpi modmpi proc~writedriverfile->module~modmpi decomp_2d decomp_2d module~modfields->decomp_2d mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~writedriverfile~~CalledByGraph proc~writedriverfile writedriverfile proc~drivergen drivergen proc~drivergen->proc~writedriverfile proc~boundary boundary proc~boundary->proc~drivergen proc~readinitfiles readinitfiles proc~readinitfiles->proc~drivergen program~dalesurban DALESURBAN program~dalesurban->proc~boundary program~dalesurban->proc~readinitfiles Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine writedriverfile use modglobal , only : runtime , timee , tdriverstart , tdriverstart_cold , ib , ie , ih , jb , je , jh , kb , ke , kh , cexpnr , ifoutput , nstore , ltempeq , lmoist , driverstore , dtdriver , nsv , lhdriver , lqdriver , lsdriver , ibrank , iplanerank , driverid , cdriverid , btime , lwarmstart use modfields , only : u0 , v0 , w0 , e120 , thl0 , qt0 , um , sv0 use modmpi , only : cmyid , myid use modinletdata , only : storetdriver , storeu0driver , storev0driver , storew0driver , storethl0driver , storeqt0driver ,& storesv0driver , nfile , nstepreaddriver implicit none integer :: fileid , IOS integer :: i , j , k , n integer :: filesizet , filesizev , filesizetest1 , filesizetest2 , filesizes character ( 15 ) :: name logical :: lexist real , allocatable :: arraysizetest (:,:) allocate ( arraysizetest ( jb - jh : je + jh , kb - kh : ke + kh )) inquire ( iolength = filesizet )( timee - tdriverstart ) ! inquire(iolength=filesizetest1)(timee) ! inquire(iolength=filesizetest2)u0(1,1,1) inquire ( iolength = filesizev ) u0 ( irecydriver ,:,:) inquire ( iolength = filesizes ) sv0 ( irecydriver ,:,:,:) !! ! if((myid==0) .and. (nstepreaddriver==1)) then ! write(6,*) 'inquire iolength ', filesizet ! write(6,*) 'inquire iolength test', filesizetest1 ! write(6,*) 'inquire iolength test u', filesizetest2 ! end if ! inquire(iolength=filesizetest1)arraysizetest(:,:) ! filesizetest2 = (je-jb+2*jh)*(ke-kb+2*kh) ! if((myid==0) .and. (nstepreaddriver==1)) then ! write(6,*) 'je,jb,jh,ke,kb,kh', je,jb,jh,ke,kb,kh ! write(6,*) 'inquire iolength test 1 ', filesizetest1 ! write(6,*) 'inquire iolength test 2', filesizetest2 ! write(6,*) 'inquire iolength', filesizev ! end if if ( driverid == 0 ) then write ( 6 , * ) '============ Writing driver files ============' write ( * , * ) 'Driver timestep: ' , nstepreaddriver end if if ( driverid == 0 ) then name = 'tdriver_   .' name ( 9 : 11 ) = cdriverid name ( 13 : 15 ) = cexpnr ! name(15:18)= '.txt' inquire ( file = name , exist = lexist ) if ( lexist ) then ! write(6,*) 'Writing Time stamp to file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , access = 'direct' , recl = filesizet , action = 'write' ) else ! write(6,*) 'Creating Time stamp driver file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'replace' , access = 'direct' , recl = filesizet , action = 'write' , IOSTAT = IOS ) ! if (IOS > 0) then ! write(6,*) 'IOS = ',IOS ! endif end if ! write(*,*) 'filesizet', filesizet ! write(ifoutput)  ( storetdriver (n),  n=1,nstore) ! write(6,'(A,F9.2)') 'Writing time stamp to file: ', timee-tdriverstart if (. not .( lwarmstart )) then write ( 11 , rec = nstepreaddriver ) ( timee - tdriverstart ) write ( * , * ) 'Driver time:' , timee - tdriverstart else ! if lwarmstart if ( btime < tdriverstart ) then write ( 11 , rec = nstepreaddriver ) ( timee - tdriverstart ) write ( * , * ) 'Driver time:' , timee - tdriverstart else write ( 11 , rec = nstepreaddriver ) ( timee - tdriverstart_cold ) write ( * , * ) 'Driver time:' , timee - tdriverstart_cold end if end if close ( unit = 11 ) end if name = 'udriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cdriverid name ( 13 : 15 ) = cexpnr ! name(15:18)= '.txt' inquire ( file = name , exist = lexist ) if ( lexist ) then ! write(6,*) 'Writing Inlet u-velocity to file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , access = 'direct' , recl = filesizev , action = 'write' ) else ! write(6,*) 'Creating Inlet u-velocity inlet file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'replace' , access = 'direct' , recl = filesizev , action = 'write' ) end if ! write(ifoutput)  (((storeu0driver (j,k,n),j=jb,je),k=kb,ke),  n=1,nstore) ! Nested implied do-loop !if(myid==0) then !write(6,'(A,e20.12)') 'Writing u0 to file. u0(irecydriver,je,ke)', u0(irecydriver,je,ke) !write(6,'(A,e20.12)') 'u0(irecydriver,jb,kb)', u0(irecydriver,jb,kb) !write(6,'(A,e20.12)') 'Writing thl0 to file. thl0(irecydriver-1,je,ke)', thl0(irecydriver-1,je,ke) !write(6,'(A,e20.12)') 'thl0(irecydriver-1,jb,kb)', thl0(irecydriver-1,jb,kb) ! write(6,*) 'irecydriver, je, ke, ib, jb, kb', irecydriver, je, ke, ib, jb, kb !end if write ( 11 , rec = nstepreaddriver ) ( u0 ( irecydriver ,:,:)) close ( unit = 11 ) name = 'vdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cdriverid name ( 13 : 15 ) = cexpnr ! name(15:18)= '.txt' inquire ( file = name , exist = lexist ) if ( lexist ) then ! write(6,*) 'Writing Inlet v-velocity to file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'write' , access = 'direct' , recl = filesizev ) else ! write(6,*) 'Creating v-velocity inlet file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'replace' , access = 'direct' , recl = filesizev , action = 'write' ) end if ! write(ifoutput)  (((storev0driver (j,k,n),j=jb,je),k=kb,ke),  n=1,nstore) ! '(F8.4)' write ( 11 , rec = nstepreaddriver ) ( v0 ( irecydriver - 1 ,:,:)) !tg3315 removed irecydriver-1 close ( unit = 11 ) name = 'wdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cdriverid name ( 13 : 15 ) = cexpnr ! name(15:18)= '.txt' inquire ( file = name , exist = lexist ) if ( lexist ) then ! write(6,*) 'Writing Inlet w-velocity to file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'write' , access = 'direct' , recl = filesizev ) else ! write(6,*) 'Creating w-velocity inlet file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'replace' , access = 'direct' , recl = filesizev , action = 'write' ) end if ! write(ifoutput)  (((storew0driver (j,k,n),j=jb,je),k=kb,ke+1),n=1,nstore) write ( 11 , rec = nstepreaddriver ) ( w0 ( irecydriver - 1 ,:,:)) !tg3315 removed irecydriver-1 close ( unit = 11 ) ! name = 'edriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile ! name(9:11)= cmyid ! name(13:15)= cexpnr ! name(15:18)= '.txt' ! inquire(file=name,exist=lexist) ! if (lexist) then ! write(6,*) 'Writing Inlet w-velocity to file: ', name ! open(unit=11,file=name,form='unformatted',status='old',action='write',access='direct',recl=filesizev) ! else ! write(6,*) 'Creating w-velocity inlet file: ', name ! open(unit=11,file=name,form='unformatted',status='replace',access='direct',recl=filesizev,action='write') ! end if ! write(ifoutput)  (((storew0driver (j,k,n),j=jb,je),k=kb,ke+1),n=1,nstore) ! write(11,rec=nstepreaddriver)  (e120(irecydriver,:,:)) !tg3315 removed irecydriver-1 ! close (unit=11) if ( ltempeq ) then name = 'hdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cdriverid name ( 13 : 15 ) = cexpnr ! name(15:18)= '.txt' inquire ( file = name , exist = lexist ) if ( lexist ) then ! write(6,*) 'Writing Inlet temperature to file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'write' , access = 'direct' , recl = filesizev ) else ! write(6,*) 'Creating temperature inlet file: ', name ! write(6,*) 'Creating w-velocity inlet file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'replace' , access = 'direct' , recl = filesizev , action = 'write' ) end if ! write(ifoutput)  (((storew0driver (j,k,n),j=jb,je),k=kb,ke+1),n=1,nstore) write ( 11 , rec = nstepreaddriver ) ( thl0 ( irecydriver - 1 ,:,:)) !tg3315 removed irecydriver-1 close ( unit = 11 ) end if if ( lmoist ) then name = 'qdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cdriverid name ( 13 : 15 ) = cexpnr ! name(15:18)= '.txt' inquire ( file = name , exist = lexist ) if ( lexist ) then ! write(6,*) 'Writing Inlet temperature to file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'write' , access = 'direct' , recl = filesizev ) else ! write(6,*) 'Creating temperature inlet file: ', name ! write(6,*) 'Creating w-velocity inlet file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'replace' , access = 'direct' , recl = filesizev , action = 'write' ) end if ! write(ifoutput)  (((storew0driver (j,k,n),j=jb,je),k=kb,ke+1),n=1,nstore) write ( 11 , rec = nstepreaddriver ) ( qt0 ( irecydriver - 1 ,:,:)) !tg3315 removed irecydriver-1 close ( unit = 11 ) end if if ( nsv > 0 ) then name = 'sdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cdriverid name ( 13 : 15 ) = cexpnr ! name(15:18)= '.txt' inquire ( file = name , exist = lexist ) if ( lexist ) then ! write(6,*) 'Writing Inlet temperature to file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'write' , access = 'direct' , recl = filesizes ) else ! write(6,*) 'Creating temperature inlet file: ', name ! write(6,*) 'Creating w-velocity inlet file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'replace' , access = 'direct' , recl = filesizes , action = 'write' ) end if ! write(ifoutput)  (((storew0driver (j,k,n),j=jb,je),k=kb,ke+1),n=1,nstore) write ( 11 , rec = nstepreaddriver ) ( sv0 ( irecydriver - 1 ,:,:,:)) !tg3315 removed irecydriver-1 close ( unit = 11 ) end if if (. not .( lwarmstart )) then if ( driverid == 0 . and . runtime + 1e-10 < ( tdriverstart + ( driverstore - 1 ) * dtdriver )) then write ( * , * ) 'Warning! Driver files cannot be written upto ' , driverstore , ' steps. & &Consider taking runtime >= (tdriverstart + (driverstore-1)*dtdriver).' end if else ! if lwarmstart if ( btime < tdriverstart ) then if ( driverid == 0 . and . ( btime + runtime ) < ( tdriverstart + ( driverstore - 1 ) * dtdriver ) ) then write ( * , * ) 'Warning! Driver files cannot be written upto ' , driverstore , ' steps. & &Consider taking runtime + ' , btime , ' >= (tdriverstart + (driverstore-1)*dtdriver).' end if else if ( driverid == 0 . and . runtime + 1e-10 < ( driverstore - 1 ) * dtdriver ) then write ( * , * ) 'Warning! Driver files cannot be written upto ' , driverstore , ' steps. & &Consider taking runtime >= (driverstore-1)*dtdriver).' end if end if end if end subroutine writedriverfile","tags":"","url":"proc/writedriverfile.html"},{"title":"readdriverfile – uDALES","text":"public  subroutine readdriverfile() Uses modinletdata modglobal modmpi modfields proc~~readdriverfile~~UsesGraph proc~readdriverfile readdriverfile module~modfields modfields proc~readdriverfile->module~modfields module~modglobal modglobal proc~readdriverfile->module~modglobal module~modinletdata modinletdata proc~readdriverfile->module~modinletdata module~modmpi modmpi proc~readdriverfile->module~modmpi decomp_2d decomp_2d module~modfields->decomp_2d mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~readdriverfile~~CalledByGraph proc~readdriverfile readdriverfile proc~readinitfiles readinitfiles proc~readinitfiles->proc~readdriverfile program~dalesurban DALESURBAN program~dalesurban->proc~readinitfiles Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine readdriverfile ! this gets called in modstartup (readinitfiles) when ibrank=.true. use modfields , only : u0 , sv0 use modglobal , only : ib , jb , je , jmax , kb , ke , kh , jhc , khc , cexpnr , ifinput , driverstore , ltempeq , lmoist , zh , jh , driverjobnr , cdriverjobnr , nsv , timee , tdriverstart , lhdriver , lqdriver , lsdriver , ibrank , iplanerank , driverid , cdriverid , lwarmstart use modmpi , only : cmyid , myid , nprocs , slabsum , excjs use modinletdata , only : storetdriver , storeu0driver , storev0driver , storew0driver , storethl0driver , storeqt0driver , storesv0driver , nfile implicit none integer :: filen , filee integer :: fileid , IOS , filesize , filesizes integer :: j , k , m , n , js , jf , jfdum , jsdum character ( 24 ) :: name write ( cdriverjobnr , '(i3.3)' ) driverjobnr if ( driverid == 0 ) then write ( * , * ) \"Consider setting 'trestart' as '(driverstore-1)*dtdriver' of driver case \" , cdriverjobnr , & \" or a value such that (((driverstore-1)*dtdriver)/trestart) is an integer. Ignore, if set already.\" if (. not .( lwarmstart )) then write ( * , * ) \"NOTE: ensure ylen,ytot,nprocy == ylen,ytot,nprocy of driver case \" , cdriverjobnr , \", respectively\" write ( * , * ) \"NOTE: ensure ztot == ztot of driver case \" , cdriverjobnr write ( * , * ) \"NOTE: ensure z direction grid (i.e. zsize and other parameters if stretching) == z direction grid of driver case \" , cdriverjobnr write ( * , * ) \"NOTE: ensure driverstore <= last driver entry step count in driver case \" , cdriverjobnr , \", check corresponding simulation log.\" else ! if lwarmstart write ( * , * ) \"NOTE: ensure driverstore <= last driver entry step count in driver case \" , cdriverjobnr , \", check corresponding simulation log.\" end if write ( * , * ) '========================================================================' write ( * , * ) '*** Reading precursor driver simulation ***' end if name = 'tdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = '000' ! write (name(18:20)  ,'(i3.3)') filen write ( name ( 13 : 15 ) , '(i3.3)' ) driverjobnr inquire ( file = name , size = filesize ) ! if(driverid==0) then !   write(6,*) 'Reading time stamps: ', name !   write(6,*) 'driverstore: ', driverstore !   write(6,*) 'File size of time in bytes (/8) = ', filesize ! endif ! driverstore = driverstore/4. ! write(6,*) 'driverstore: ', driverstore inquire ( iolength = filesize )( timee - tdriverstart ) open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'read' , access = 'direct' , recl = filesize , IOSTAT = IOS ) ! if(myid==0) then !   if (IOS > 0) then !     write(6,*) 'IOS = ',IOS !   endif ! endif do n = 1 , driverstore read ( 11 , rec = n , IOSTAT = IOS ) storetdriver ( n ) ! if(myid==0) then !   if(IOS > 0) then !     write(6,*) 'IOS = ',IOS !   elseif (IOS<0) then !     write(6,*) 'n =', n !   end if !   write(6,'(A,e20.12)') ' Reading t:', storetdriver(n) ! end if end do ! storetdriver = storetdriver + timee !tg3315 added in case using a warmstart... close ( unit = 11 ) ! write(*,*) 'storetdriver', storetdriver ! end if name = 'udriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cdriverid ! write (name(18:20)  ,'(i3.3)') filen write ( name ( 13 : 15 ) , '(i3.3)' ) driverjobnr !write(6,*) 'Reading Driver u-velocity: ', name ! inquire(file=name,recl=filesize) inquire ( iolength = filesize ) u0 ( ib ,:,:) !write(6,*) 'record length ',filesize open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'read' , access = 'direct' , recl = filesize ) do n = 1 , driverstore read ( 11 , rec = n ) (( storeu0driver ( j , k , n ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) ! if(myid==0) then ! write(6, '(A,e20.12)') 'Reading u(irecydriver, jb, kb)', storeu0driver(jb,kb,n) ! endif end do ! if(myid==0) then ! do k=ke,kb,-1 !   write(6, '(A,e20.12)') 'Reading u(ib,1,:)', storeu0driver(jb,k,1) ! end do ! end if close ( unit = 11 ) name = 'vdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cdriverid ! write (name(18:20)  ,'(i3.3)') filen write ( name ( 13 : 15 ) , '(i3.3)' ) driverjobnr !write(6,*) 'Reading Driver v-velocity: ', name ! inquire(file=name,recl=filesize) ! inquire(iolength=filesize)u0(ib,:,:) open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'read' , access = 'direct' , recl = filesize ) do n = 1 , driverstore read ( 11 , rec = n ) (( storev0driver ( j , k , n ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) end do close ( unit = 11 ) name = 'wdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cdriverid ! write (name(18:20)  ,'(i3.3)') filen write ( name ( 13 : 15 ) , '(i3.3)' ) driverjobnr !write(6,*) 'Reading Driver w-velocity: ', name ! inquire(file=name,recl=filesize) ! inquire(iolength=filesize)u0(ib,:,:) open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'read' , access = 'direct' , recl = filesize ) do n = 1 , driverstore read ( 11 , rec = n ) (( storew0driver ( j , k , n ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) end do close ( unit = 11 ) !name = 'edriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile ! name(9:11)= cmyid ! write (name(18:20)  ,'(i3.3)') filen ! write (name(13:15)   ,'(i3.3)') driverjobnr ! write(6,*) 'Reading Driver turbulent kinetic energy: ', name ! inquire(file=name,recl=filesize) ! inquire(iolength=filesize)u0(ib,:,:) ! open(unit=11,file=name,form='unformatted',status='old',action='read',access='direct',recl=filesize) ! do n = 1,driverstore ! read(11,rec=n)  ((storee120driver (j,k,n),j=jb-jh,je+jh),k=kb-kh,ke+kh) ! enddo ! close (unit=11) if ( ltempeq . and . lhdriver ) then name = 'hdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cdriverid ! write (name(18:20)  ,'(i3.3)') filen write ( name ( 13 : 15 ) , '(i3.3)' ) driverjobnr !write(6,*) 'Reading Driver temperature: ', name ! inquire(file=name,recl=filesize) open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'read' , access = 'direct' , recl = filesize ) do n = 1 , driverstore read ( 11 , rec = n ) (( storethl0driver ( j , k , n ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) end do !if(myid==0) then !  do k=ke,kb,-1 !    write(6, '(A,e20.12)') 'Reading thl0(ib,1,:)', storethl0driver(jb,k,1) !  end do !end if close ( unit = 11 ) end if if ( lmoist . and . lqdriver ) then name = 'qdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cdriverid ! write (name(18:20)  ,'(i3.3)') filen write ( name ( 13 : 15 ) , '(i3.3)' ) driverjobnr !write(6,*) 'Reading Driver moisture: ', name ! inquire(file=name,recl=filesize) open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'read' , access = 'direct' , recl = filesize ) do n = 1 , driverstore read ( 11 , rec = n ) (( storeqt0driver ( j , k , n ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) end do close ( unit = 11 ) end if if ( nsv > 0 . and . lsdriver ) then name = 'sdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cdriverid ! write (name(18:20)  ,'(i3.3)') filen write ( name ( 13 : 15 ) , '(i3.3)' ) driverjobnr !write(6,*) 'Reading Driver scalar: ', name ! inquire(file=name,recl=filesize) inquire ( iolength = filesizes ) sv0 ( ib ,:,:,:) open ( unit = 12 , file = name , form = 'unformatted' , status = 'old' , action = 'read' , access = 'direct' , recl = filesizes ) do n = 1 , driverstore read ( 12 , rec = n ) ((( storesv0driver ( j , k , m , n ), j = jb - jhc , je + jhc ), k = kb - khc , ke + khc ), m = 1 , nsv ) end do close ( unit = 12 ) end if end subroutine readdriverfile","tags":"","url":"proc/readdriverfile.html"},{"title":"readdriverfile_chunk – uDALES","text":"public  subroutine readdriverfile_chunk() Uses modinletdata modglobal modmpi modfields proc~~readdriverfile_chunk~~UsesGraph proc~readdriverfile_chunk readdriverfile_chunk module~modfields modfields proc~readdriverfile_chunk->module~modfields module~modglobal modglobal proc~readdriverfile_chunk->module~modglobal module~modinletdata modinletdata proc~readdriverfile_chunk->module~modinletdata module~modmpi modmpi proc~readdriverfile_chunk->module~modmpi decomp_2d decomp_2d module~modfields->decomp_2d mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~readdriverfile_chunk~~CalledByGraph proc~readdriverfile_chunk readdriverfile_chunk proc~driverchunkread driverchunkread proc~driverchunkread->proc~readdriverfile_chunk proc~readinitfiles readinitfiles proc~readinitfiles->proc~readdriverfile_chunk proc~boundary boundary proc~boundary->proc~driverchunkread program~dalesurban DALESURBAN program~dalesurban->proc~readinitfiles program~dalesurban->proc~boundary Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine readdriverfile_chunk use modfields , only : u0 , sv0 use modglobal , only : ib , jb , je , jmax , kb , ke , kh , jhc , khc , cexpnr , ifinput , driverstore , chunkread_size , ltempeq , lmoist , zh , jh , driverjobnr , cdriverjobnr , nsv , timee , tdriverstart , lhdriver , lqdriver , lsdriver , ibrank , iplanerank , driverid , cdriverid , lwarmstart use modmpi , only : cmyid , myid , nprocs , slabsum , excjs use modinletdata , only : storetdriver , storeu0driver , storev0driver , storew0driver , storethl0driver , storeqt0driver , storesv0driver , nfile , & chunkreadctr , chunkread_s , chunkread_e implicit none integer :: filen , filee integer :: fileid , IOS , filesize , filesizes integer :: j , k , m , n , js , jf , jfdum , jsdum character ( 24 ) :: name write ( cdriverjobnr , '(i3.3)' ) driverjobnr chunkread_s = ( chunkreadctr - 1 ) * chunkread_size + 1 chunkread_e = chunkreadctr * chunkread_size if ( chunkread_e > driverstore ) chunkread_e = driverstore if ( driverid == 0 ) then write ( * , * ) '========================================================================' write ( * , * ) '*** Reading precursor driver simulation field data chunk *** ' , chunkreadctr end if if ( chunkreadctr == 1 ) then if ( driverid == 0 ) then if (. not .( lwarmstart )) then write ( * , * ) \"NOTE: ensure ylen,ytot,nprocy == ylen,ytot,nprocy of driver case \" , cdriverjobnr , \", respectively\" write ( * , * ) \"NOTE: ensure ztot == ztot of driver case \" , cdriverjobnr write ( * , * ) \"NOTE: ensure z dircetion grid (i.e. zsize and other parameters if stretching) == z dircetion grid of driver case \" , cdriverjobnr write ( * , * ) \"NOTE: ensure driverstore <= last driver entry step count in driver case \" , cdriverjobnr , \", check corresponding simulation log.\" else ! if lwarmstart write ( * , * ) \"NOTE: ensure driverstore <= last driver entry step count in driver case \" , cdriverjobnr , \", check corresponding simulation log.\" end if end if name = 'tdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = '000' ! write (name(18:20)  ,'(i3.3)') filen write ( name ( 13 : 15 ) , '(i3.3)' ) driverjobnr inquire ( file = name , size = filesize ) ! if(driverid==0) then !   write(6,*) 'Reading time stamps: ', name !   write(6,*) 'driverstore: ', driverstore !   write(6,*) 'File size of time in bytes (/8) = ', filesize ! endif ! driverstore = driverstore/4. ! write(6,*) 'driverstore: ', driverstore inquire ( iolength = filesize )( timee - tdriverstart ) open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'read' , access = 'direct' , recl = filesize , IOSTAT = IOS ) if ( myid == 0 ) then if ( IOS > 0 ) then write ( 6 , * ) 'IOS = ' , IOS endif endif do n = 1 , driverstore read ( 11 , rec = n , IOSTAT = IOS ) storetdriver ( n ) if ( myid == 0 ) then ! if(IOS > 0) then !   write(6,*) 'IOS = ',IOS ! elseif (IOS<0) then !   write(6,*) 'n =', n ! end if ! write(6,'(A,e20.12)') ' Reading t:', storetdriver(n) end if end do close ( unit = 11 ) end if if ( driverid == 0 ) then write ( * , * ) 'Reading from driver step ' , chunkread_s , ' (time instant ' , storetdriver ( chunkread_s ), & ') to driver step ' , chunkread_e , ' (time instant ' , storetdriver ( chunkread_e ), ')' end if do k = kb - kh , ke + kh do j = jb - jh , je + jh storeu0driver ( j , k , 0 ) = storeu0driver ( j , k , chunkread_size ) end do end do name = 'udriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cdriverid ! write (name(18:20)  ,'(i3.3)') filen write ( name ( 13 : 15 ) , '(i3.3)' ) driverjobnr !write(6,*) 'Reading Driver u-velocity: ', name ! inquire(file=name,recl=filesize) inquire ( iolength = filesize ) u0 ( ib ,:,:) !write(6,*) 'record length ',filesize open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'read' , access = 'direct' , recl = filesize ) do n = chunkread_s , chunkread_e !1,driverstore !if(myid==0) write(6,*) 'reading u_driver at step = ',n,'(',n-chunkread_s+1,') time = ',storetdriver(n) read ( 11 , rec = n ) (( storeu0driver ( j , k , n - chunkread_s + 1 ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) ! if(myid==0) then ! write(6, '(A,e20.12)') 'Reading u(irecydriver, jb, kb)', storeu0driver(jb,kb,n) ! endif end do ! if(myid==0) then ! do k=ke,kb,-1 !   write(6, '(A,e20.12)') 'Reading u(ib,1,:)', storeu0driver(jb,k,1) ! end do ! end if close ( unit = 11 ) do k = kb - kh , ke + kh do j = jb - jh , je + jh storev0driver ( j , k , 0 ) = storev0driver ( j , k , chunkread_size ) end do end do name = 'vdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cdriverid ! write (name(18:20)  ,'(i3.3)') filen write ( name ( 13 : 15 ) , '(i3.3)' ) driverjobnr !write(6,*) 'Reading Driver v-velocity: ', name ! inquire(file=name,recl=filesize) ! inquire(iolength=filesize)u0(ib,:,:) open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'read' , access = 'direct' , recl = filesize ) do n = chunkread_s , chunkread_e !1,driverstore read ( 11 , rec = n ) (( storev0driver ( j , k , n - chunkread_s + 1 ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) end do close ( unit = 11 ) do k = kb - kh , ke + kh do j = jb - jh , je + jh storew0driver ( j , k , 0 ) = storew0driver ( j , k , chunkread_size ) end do end do name = 'wdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cdriverid ! write (name(18:20)  ,'(i3.3)') filen write ( name ( 13 : 15 ) , '(i3.3)' ) driverjobnr !write(6,*) 'Reading Driver w-velocity: ', name ! inquire(file=name,recl=filesize) ! inquire(iolength=filesize)u0(ib,:,:) open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'read' , access = 'direct' , recl = filesize ) do n = chunkread_s , chunkread_e !1,driverstore read ( 11 , rec = n ) (( storew0driver ( j , k , n - chunkread_s + 1 ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) end do close ( unit = 11 ) ! do k = kb-kh,ke+kh !   do j = jb-jh,je+jh !     storee120driver(j,k,0) = storee120driver (j,k,chunkread_size) !   end do ! end do ! name = 'edriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile ! name(9:11)= cmyid ! write (name(18:20)  ,'(i3.3)') filen ! write (name(13:15)   ,'(i3.3)') driverjobnr ! write(6,*) 'Reading Driver turbulent kinetic energy: ', name ! inquire(file=name,recl=filesize) ! inquire(iolength=filesize)u0(ib,:,:) ! open(unit=11,file=name,form='unformatted',status='old',action='read',access='direct',recl=filesize) ! do n = chunkread_s,chunkread_e!1,driverstore ! read(11,rec=n)  ((storee120driver (j,k,n-chunkread_s+1),j=jb-jh,je+jh),k=kb-kh,ke+kh) ! enddo ! close (unit=11) if ( ltempeq . and . lhdriver ) then do k = kb - kh , ke + kh do j = jb - jh , je + jh storethl0driver ( j , k , 0 ) = storethl0driver ( j , k , chunkread_size ) end do end do name = 'hdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cdriverid ! write (name(18:20)  ,'(i3.3)') filen write ( name ( 13 : 15 ) , '(i3.3)' ) driverjobnr !write(6,*) 'Reading Driver temperature: ', name ! inquire(file=name,recl=filesize) open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'read' , access = 'direct' , recl = filesize ) do n = chunkread_s , chunkread_e !1,driverstore read ( 11 , rec = n ) (( storethl0driver ( j , k , n - chunkread_s + 1 ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) end do !if(myid==0) then !  do k=ke,kb,-1 !    write(6, '(A,e20.12)') 'Reading thl0(ib,1,:)', storethl0driver(jb,k,1) !  end do !end if close ( unit = 11 ) end if if ( lmoist . and . lqdriver ) then do k = kb - kh , ke + kh do j = jb - jh , je + jh storeqt0driver ( j , k , 0 ) = storeqt0driver ( j , k , chunkread_size ) end do end do name = 'qdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cdriverid ! write (name(18:20)  ,'(i3.3)') filen write ( name ( 13 : 15 ) , '(i3.3)' ) driverjobnr !write(6,*) 'Reading Driver moisture: ', name ! inquire(file=name,recl=filesize) open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'read' , access = 'direct' , recl = filesize ) do n = chunkread_s , chunkread_e !1,driverstore read ( 11 , rec = n ) (( storeqt0driver ( j , k , n - chunkread_s + 1 ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) end do close ( unit = 11 ) end if if ( nsv > 0 . and . lsdriver ) then do m = 1 , nsv do k = kb - kh , ke + kh do j = jb - jh , je + jh storesv0driver ( j , k , m , 0 ) = storesv0driver ( j , k , m , chunkread_size ) end do end do end do name = 'sdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cdriverid ! write (name(18:20)  ,'(i3.3)') filen write ( name ( 13 : 15 ) , '(i3.3)' ) driverjobnr !write(6,*) 'Reading Driver scalar: ', name ! inquire(file=name,recl=filesize) inquire ( iolength = filesizes ) sv0 ( ib ,:,:,:) open ( unit = 12 , file = name , form = 'unformatted' , status = 'old' , action = 'read' , access = 'direct' , recl = filesizes ) do n = chunkread_s , chunkread_e !1,driverstore read ( 12 , rec = n ) ((( storesv0driver ( j , k , m , n - chunkread_s + 1 ), j = jb - jhc , je + jhc ), k = kb - khc , ke + khc ), m = 1 , nsv ) end do close ( unit = 12 ) end if chunkreadctr = chunkreadctr + 1 end subroutine readdriverfile_chunk","tags":"","url":"proc/readdriverfile_chunk.html"},{"title":"driverchunkread – uDALES","text":"public  subroutine driverchunkread() Uses modinletdata modmpi modglobal proc~~driverchunkread~~UsesGraph proc~driverchunkread driverchunkread module~modglobal modglobal proc~driverchunkread->module~modglobal module~modinletdata modinletdata proc~driverchunkread->module~modinletdata module~modmpi modmpi proc~driverchunkread->module~modmpi mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~driverchunkread~~CallsGraph proc~driverchunkread driverchunkread proc~readdriverfile_chunk readdriverfile_chunk proc~driverchunkread->proc~readdriverfile_chunk Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~driverchunkread~~CalledByGraph proc~driverchunkread driverchunkread proc~boundary boundary proc~boundary->proc~driverchunkread program~dalesurban DALESURBAN program~dalesurban->proc~boundary Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine driverchunkread use modglobal , only : timee , ibrank , idriver , lchunkread use modinletdata , only : storetdriver , chunkread_e use modmpi , only : myid ! if (idriver==2 .and. lchunkread .and. timee > storetdriver(chunkread_e)) then !   if (myid==0) then !     write(6,*) 'Current timee = ', timee, '; last read storetdriver = ', storetdriver(chunkread_e), & !                'at driver step = ',chunkread_e,'. Hence, next driver chunk will be read now.' !   end if !   if (ibrank) call readdriverfile_chunk ! end if do while ( timee > storetdriver ( chunkread_e )) if ( myid == 0 ) then write ( 6 , * ) 'Current timee = ' , timee , '; last read storetdriver = ' , storetdriver ( chunkread_e ), & 'at driver step = ' , chunkread_e , '. Hence, next driver chunk will be read now.' end if if ( ibrank ) call readdriverfile_chunk end do end subroutine driverchunkread","tags":"","url":"proc/driverchunkread.html"},{"title":"exitdriver – uDALES","text":"public  subroutine exitdriver() Uses modglobal proc~~exitdriver~~UsesGraph proc~exitdriver exitdriver module~modglobal modglobal proc~exitdriver->module~modglobal Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Source Code subroutine exitdriver use modglobal , only : idriver , lstoreplane , ltempeq , lmoist , nsv , lhdriver , lqdriver , lsdriver , ibrank , iplanerank if ( idriver == 1 . and . iplanerank ) then !if (lstoreplane ) then deallocate ( storetdriver , storeu0driver , storev0driver , storew0driver ) !,storee120driver) if ( ltempeq ) then deallocate ( storethl0driver ) end if if ( lmoist ) then deallocate ( storeqt0driver ) end if if ( nsv > 0 ) then deallocate ( storesv0driver ) end if !end if else if ( idriver == 2 . and . ibrank ) then deallocate ( storetdriver , storeu0driver , storev0driver , storew0driver , u0driver , v0driver , w0driver ) !,e120driver,storee120driver) if ( ltempeq . and . lhdriver ) then deallocate ( storethl0driver , thl0driver ) end if if ( lmoist . and . lqdriver ) then deallocate ( storeqt0driver , qt0driver ) end if if ( nsv > 0 . and . lsdriver ) then deallocate ( storesv0driver , sv0driver ) end if end if end subroutine exitdriver","tags":"","url":"proc/exitdriver.html"},{"title":"initstat_nc – uDALES","text":"public  subroutine initstat_nc() Uses modmpi modglobal proc~~initstat_nc~~UsesGraph proc~initstat_nc initstat_nc module~modglobal modglobal proc~initstat_nc->module~modglobal module~modmpi modmpi proc~initstat_nc->module~modmpi mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~initstat_nc~~CalledByGraph proc~initstat_nc initstat_nc program~dalesurban DALESURBAN program~dalesurban->proc~initstat_nc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine initstat_nc use modglobal , only : kmax , ifnamopt , fname_options , iexpnr use modmpi , only : mpierr , mpi_logical , comm3d , myid implicit none integer :: ierr end subroutine initstat_nc","tags":"","url":"proc/initstat_nc.html"},{"title":"open_nc – uDALES","text":"public  subroutine open_nc(fname, ncid, nrec, n1, n2, n3, ns, nfcts, nlyrs) Uses modglobal proc~~open_nc~~UsesGraph proc~open_nc open_nc module~modglobal modglobal proc~open_nc->module~modglobal Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name character(len=40), intent(in) :: fname integer, intent(out) :: ncid integer, intent(out) :: nrec integer, intent(in), optional :: n1 integer, intent(in), optional :: n2 integer, intent(in), optional :: n3 integer, intent(in), optional :: ns integer, intent(in), optional :: nfcts integer, intent(in), optional :: nlyrs Calls proc~~open_nc~~CallsGraph proc~open_nc open_nc nf90_create nf90_create proc~open_nc->nf90_create nf90_def_dim nf90_def_dim proc~open_nc->nf90_def_dim nf90_def_var nf90_def_var proc~open_nc->nf90_def_var nf90_enddef nf90_enddef proc~open_nc->nf90_enddef nf90_get_var nf90_get_var proc~open_nc->nf90_get_var nf90_inq_dimid nf90_inq_dimid proc~open_nc->nf90_inq_dimid nf90_inq_varid nf90_inq_varid proc~open_nc->nf90_inq_varid nf90_inquire nf90_inquire proc~open_nc->nf90_inquire nf90_inquire_dimension nf90_inquire_dimension proc~open_nc->nf90_inquire_dimension nf90_open nf90_open proc~open_nc->nf90_open nf90_put_att nf90_put_att proc~open_nc->nf90_put_att nf90_sync nf90_sync proc~open_nc->nf90_sync Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~open_nc~~CalledByGraph proc~open_nc open_nc proc~initeb initEB proc~initeb->proc~open_nc proc~initfielddump initfielddump proc~initfielddump->proc~open_nc proc~initibm initibm proc~initibm->proc~open_nc proc~initstatsdump initstatsdump proc~initstatsdump->proc~open_nc program~dalesurban DALESURBAN program~dalesurban->proc~initeb program~dalesurban->proc~initfielddump program~dalesurban->proc~initibm program~dalesurban->proc~initstatsdump Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine open_nc ( fname , ncid , nrec , n1 , n2 , n3 , ns , nfcts , nlyrs ) use modglobal , only : author , version , timee implicit none integer , intent ( out ) :: ncid , nrec integer , optional , intent ( in ) :: n1 , n2 , n3 , ns , nfcts , nlyrs character ( len = 40 ), intent ( in ) :: fname character ( len = 12 ) :: date = '' , time = '' integer :: iret , varid , ncall , RecordDimID real , allocatable :: xtimes (:) logical :: exans inquire ( file = trim ( fname ), exist = exans ) !write(*,*) 'opennc' ncall = 0 if (. not . exans ) then call date_and_time ( date , time ) !iret = nf90_create(fname,NF90_SHARE,ncid) iret = nf90_create ( fname , IOR ( NF90_NETCDF4 , NF90_SHARE ), ncid ) iret = nf90_put_att ( ncid , NF90_GLOBAL , 'title' , fname ) iret = nf90_put_att ( ncid , NF90_GLOBAL , 'history' , 'Created on ' // trim ( date ) // ' at ' // trim ( time )) iret = nf90_put_att ( ncid , NF90_GLOBAL , 'Source' , trim ( version )) iret = nf90_put_att ( ncid , NF90_GLOBAL , 'Author' , trim ( author )) iret = nf90_def_dim ( ncID , 'time' , NF90_UNLIMITED , timeID ) if ( present ( n1 )) then iret = nf90_def_dim ( ncID , 'xt' , n1 , xtID ) iret = nf90_def_dim ( ncID , 'xm' , n1 , xmID ) iret = nf90_def_var ( ncID , 'xt' , NF90_FLOAT ,( / xtID / ) , VarID ) iret = nf90_put_att ( ncID , VarID , 'longname' , 'West-East displacement of cell centers' ) iret = nf90_put_att ( ncID , VarID , 'units' , 'm' ) iret = nf90_def_var ( ncID , 'xm' , NF90_FLOAT ,( / xmID / ), VarID ) iret = nf90_put_att ( ncID , VarID , 'longname' , 'West-East displacement of cell edges' ) iret = nf90_put_att ( ncID , VarID , 'units' , 'm' ) end if if ( present ( n2 )) then iret = nf90_def_dim ( ncID , 'yt' , n2 , ytID ) iret = nf90_def_dim ( ncID , 'ym' , n2 , ymID ) iret = nf90_def_var ( ncID , 'yt' , NF90_FLOAT , ytID , VarID ) iret = nf90_put_att ( ncID , VarID , 'longname' , 'South-North displacement of cell centers' ) iret = nf90_put_att ( ncID , VarID , 'units' , 'm' ) iret = nf90_def_var ( ncID , 'ym' , NF90_FLOAT , ymID , VarID ) iret = nf90_put_att ( ncID , VarID , 'longname' , 'South-North displacement of cell edges' ) iret = nf90_put_att ( ncID , VarID , 'units' , 'm' ) end if if ( present ( n3 )) then iret = nf90_def_dim ( ncID , 'zt' , n3 , ztID ) iret = nf90_def_dim ( ncID , 'zm' , n3 , zmID ) iret = nf90_def_var ( ncID , 'zt' , NF90_FLOAT ,( / ztID / ) , VarID ) iret = nf90_put_att ( ncID , VarID , 'longname' , 'Vertical displacement of cell centers' ) iret = nf90_put_att ( ncID , VarID , 'units' , 'm' ) iret = nf90_def_var ( ncID , 'zm' , NF90_FLOAT ,( / zmID / ), VarID ) iret = nf90_put_att ( ncID , VarID , 'longname' , 'Vertical displacement of cell edges' ) iret = nf90_put_att ( ncID , VarID , 'units' , 'm' ) end if if ( present ( ns )) then iret = nf90_def_dim ( ncID , 'zts' , ns , ztsID ) iret = nf90_def_var ( ncID , 'zts' , NF90_FLOAT ,( / ztsID / ) , VarID ) iret = nf90_put_att ( ncID , VarID , 'longname' , 'Soil level depth of cell centers' ) iret = nf90_put_att ( ncID , VarID , 'units' , 'm' ) end if if ( present ( nfcts )) then iret = nf90_def_dim ( ncID , 'fct' , nfcts , fctID ) iret = nf90_def_var ( ncID , 'fct' , NF90_INT ,( / fctID / ) , VarID ) iret = nf90_put_att ( ncID , VarID , 'longname' , 'Facet number' ) end if if ( present ( nlyrs )) then iret = nf90_def_dim ( ncID , 'lyr' , nlyrs , lyrID ) iret = nf90_def_var ( ncID , 'lyr' , NF90_INT ,( / lyrID / ) , VarID ) iret = nf90_put_att ( ncID , VarID , 'longname' , 'Number of wall layers' ) end if else nrec = 0 ncall = 0 iret = nf90_open ( trim ( fname ), NF90_WRITE , ncid ) iret = nf90_inquire ( ncid , unlimitedDimId = RecordDimID ) iret = nf90_inquire_dimension ( ncid , RecordDimID , len = nrec ) if ( nrec > 0 ) then iret = nf90_inq_varid ( ncid , 'time' , timeID ) allocate ( xtimes ( nrec )) iret = nf90_get_var ( ncid , timeId , xtimes ( 1 : nrec )) do while ( xtimes ( ncall + 1 ) < timee - spacing ( 1. )) ncall = ncall + 1 if ( ncall >= nrec ) exit end do deallocate ( xtimes ) end if if ( present ( n1 )) then iret = nf90_inq_dimid ( ncid , 'xt' , xtId ) iret = nf90_inq_dimid ( ncid , 'xm' , xmId ) end if if ( present ( n2 )) then iret = nf90_inq_dimid ( ncid , 'yt' , ytId ) iret = nf90_inq_dimid ( ncid , 'ym' , ymId ) end if if ( present ( n3 )) then iret = nf90_inq_dimid ( ncid , 'zt' , ztId ) iret = nf90_inq_dimid ( ncid , 'zm' , zmId ) end if if ( present ( ns )) then iret = nf90_inq_dimid ( ncid , 'zts' , ztsId ) end if if ( present ( nfcts )) then iret = nf90_inq_dimid ( ncid , 'fct' , fctId ) end if end if nrec = ncall iret = nf90_sync ( ncid ) iret = nf90_enddef ( ncID ) end subroutine open_nc","tags":"","url":"proc/open_nc.html"},{"title":"define_nc – uDALES","text":"public  subroutine define_nc(ncID, nVar, sx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncID integer, intent(in) :: nVar character(len=*), intent(in) :: sx (nVar,4) Calls proc~~define_nc~~CallsGraph proc~define_nc define_nc nf90_def_var nf90_def_var proc~define_nc->nf90_def_var nf90_enddef nf90_enddef proc~define_nc->nf90_enddef nf90_inq_dimid nf90_inq_dimid proc~define_nc->nf90_inq_dimid nf90_inq_varid nf90_inq_varid proc~define_nc->nf90_inq_varid nf90_put_att nf90_put_att proc~define_nc->nf90_put_att nf90_redef nf90_redef proc~define_nc->nf90_redef proc~nchandle_error nchandle_error proc~define_nc->proc~nchandle_error nf90_strerror nf90_strerror proc~nchandle_error->nf90_strerror Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~define_nc~~CalledByGraph proc~define_nc define_nc proc~initeb initEB proc~initeb->proc~define_nc proc~initfielddump initfielddump proc~initfielddump->proc~define_nc proc~initibm initibm proc~initibm->proc~define_nc proc~initstatsdump initstatsdump proc~initstatsdump->proc~define_nc program~dalesurban DALESURBAN program~dalesurban->proc~initeb program~dalesurban->proc~initfielddump program~dalesurban->proc~initibm program~dalesurban->proc~initstatsdump Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine define_nc ( ncID , nVar , sx ) implicit none integer , intent ( in ) :: nVar , ncID character ( * ), intent ( in ) :: sx ( nVar , 4 ) integer , save :: dim_mttt ( 4 ) = 0 , dim_tmtt ( 4 ) = 0 , dim_ttmt ( 4 ) = 0 , dim_tttt ( 4 ) = 0 , & dim_tt ( 2 ) = 0 , dim_mt ( 2 ) = 0 , dim_t0tt ( 3 ) = 0 , dim_m0tt ( 3 ) = 0 , dim_t0mt ( 3 ) = 0 ,& dim_m0mt ( 3 ) = 0 , dim_tt0t ( 3 ) = 0 , & dim_mt0t ( 3 ) = 0 , dim_tm0t ( 3 ) = 0 , dim_0ttt ( 3 ) = 0 , dim_0mtt ( 3 ) = 0 , dim_0tmt ( 3 ) = 0 ,& dim_tts ( 2 ) = 0 , dim_t0tts ( 3 ) = 0 , dim_0ttts ( 3 ) = 0 , dim_tttts ( 4 ) = 0 , dim_ttt0 ( 3 ) = 0 ,& !tg3315 added last one dim_mtmt ( 4 ), dim_tmmt ( 4 ), dim_mmtt ( 4 ),& !bss116 dim_ft ( 2 ), dim_flt ( 3 ) !SO integer :: iret , n , VarID !write(*,*) 'definenc' iret = nf90_inq_dimid ( ncid , 'time' , timeId ) iret = nf90_inq_dimid ( ncid , 'xt' , xtId ) iret = nf90_inq_dimid ( ncid , 'xm' , xmId ) iret = nf90_inq_dimid ( ncid , 'yt' , ytId ) iret = nf90_inq_dimid ( ncid , 'ym' , ymId ) iret = nf90_inq_dimid ( ncid , 'zt' , ztId ) iret = nf90_inq_dimid ( ncid , 'zm' , zmId ) iret = nf90_inq_dimid ( ncid , 'zts' , ztsId ) iret = nf90_inq_dimid ( ncid , 'fct' , fctId ) ! so4718 for energy balance output iret = nf90_inq_dimid ( ncid , 'lyr' , lyrId ) ! so4718 for energy balance output iret = nf90_redef ( ncid ) dim_tt = ( / ztId , timeId / ) dim_mt = ( / zmId , timeId / ) dim_t0tt = ( / xtID , ztID , timeId / ) ! thermo point dim_t0mt = ( / xtID , zmID , timeId / ) ! zpoint dim_m0tt = ( / xmID , ztID , timeId / ) ! upoint dim_m0mt = ( / xmID , ztID , timeId / ) ! uw stats point dim_tt0t = ( / xtID , ytID , timeId / ) ! thermo point dim_tm0t = ( / xtID , ymID , timeId / ) ! vpoint dim_mt0t = ( / xmID , ytID , timeId / ) ! upoint dim_0ttt = ( / ytID , ztID , timeId / ) ! thermo point dim_0tmt = ( / ytID , zmID , timeId / ) ! wpoint dim_0mtt = ( / ymID , ztID , timeId / ) ! vpoint dim_tttt = ( / xtID , ytID , ztID , timeId / ) ! thermo point dim_ttmt = ( / xtID , ytID , zmID , timeId / ) ! zpoint dim_mttt = ( / xmID , ytID , ztID , timeId / ) ! upoint dim_tmtt = ( / xtID , ymID , ztId , timeId / ) ! ypoint dim_mtmt = ( / xmID , ytID , zmId , timeId / ) ! uw stats point bss116 dim_tmmt = ( / xtID , ymID , zmId , timeId / ) ! vw stats point bss116 dim_mmtt = ( / xmID , ymID , ztId , timeId / ) ! uv stats point bss116 dim_ttt0 = ( / xtID , ytID , ztID / ) ! stats point tg3315 dim_tts = ( / ztsId , timeId / ) dim_t0tts = ( / xtID , ztsID , timeId / ) ! thermo soil point dim_0ttts = ( / ytID , ztsID , timeId / ) ! thermo point dim_tttts = ( / xtID , ytID , ztsID , timeId / ) ! thermo point dim_ft = ( / fctID , timeId / ) dim_flt = ( / fctID , lyrID , timeId / ) do n = 1 , nVar !      write(*,*) 'n', n !      write(*,*) \"dummyline1\" !      write(*,*) 'sx1', sx(1,:) !      write(*,*) 'sx2', sx(2,:) !      write(*,*) \"dummyline2\" !      write(*,*) 'trim(sx(n,1))', trim(sx(n,1)) !      write(*,*) 'trim(sx(n,2))', trim(sx(n,2)) !      write(*,*) 'trim(sx(n,3))', trim(sx(n,3)) !      write(*,*) 'trim(sx(n,4))', trim(sx(n,4)) !      write (*,*) 'ncID', ncID iret = nf90_inq_varid ( ncid , trim ( sx ( n , 1 )), VarID ) if ( iret == 0 ) cycle select case ( trim ( sx ( n , 4 ))) case ( 'time' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT ,( / timeID / ) , VarID ) case ( 'tt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_tt , VarID ) case ( 'mt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_mt , VarID ) !2D Fields case ( 't0tt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_t0tt , VarID ) case ( 't0mt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_t0mt , VarID ) case ( 'm0tt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_m0tt , VarID ) case ( 'm0mt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_m0mt , VarID ) case ( 'tt0t' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_tt0t , VarID ) case ( 'tm0t' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_tm0t , VarID ) case ( 'mt0t' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_mt0t , VarID ) case ( '0ttt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_0ttt , VarID ) case ( '0tmt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_0tmt , VarID ) case ( '0mtt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_0mtt , VarID ) case ( 'ttt0' ) !tg3315 for uav,vav,wav etc. iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_ttt0 , VarID ) !3D Fields case ( 'tttt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_tttt , VarID ) case ( 'mttt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_mttt , VarID ) case ( 'tmtt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_tmtt , VarID ) case ( 'ttmt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_ttmt , VarID ) case ( 'mtmt' ) ! bss116 iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_mtmt , VarID ) case ( 'tmmt' ) ! bss116 iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_tmmt , VarID ) case ( 'mmtt' ) ! bss116 iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_mmtt , VarID ) !Soil fields case ( 'tts' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_tts , VarID ) case ( 't0tts' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_t0tts , VarID ) case ( '0ttts' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_0ttts , VarID ) case ( 'tttts' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_tttts , VarID ) !Facet information case ( 'ft' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_ft , VarID ) case ( 'flt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_flt , VarID ) case default write ( 0 , * ) 'nvar' , nvar , sx ( n ,:) write ( 0 , * ) 'ERROR: Bad dimensional information ' , sx ( n ,:) stop 1 ! call appl_abort(0) end select if ( iret /= 0 ) then !        write (*,*) 'nvar', nvar, sx(n,:) !        write (*,*) 'ncID', ncID call nchandle_error ( iret ) end if iret = nf90_put_att ( ncID , VarID , 'longname' , sx ( n , 2 )) iret = nf90_put_att ( ncID , VarID , 'units' , sx ( n , 3 )) iret = nf90_put_att ( ncid , VarID , '_FillValue' , nc_fillvalue ) end do iret = nf90_enddef ( ncID ) end subroutine define_nc","tags":"","url":"proc/define_nc.html"},{"title":"redefine_nc – uDALES","text":"public  subroutine redefine_nc(ncid) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid Calls proc~~redefine_nc~~CallsGraph proc~redefine_nc redefine_nc nf90_redef nf90_redef proc~redefine_nc->nf90_redef Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine redefine_nc ( ncid ) implicit none integer , intent ( in ) :: ncid integer :: iret iret = nf90_redef ( ncid ) end subroutine redefine_nc","tags":"","url":"proc/redefine_nc.html"},{"title":"exitstat_nc – uDALES","text":"public  subroutine exitstat_nc(ncid) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid Calls proc~~exitstat_nc~~CallsGraph proc~exitstat_nc exitstat_nc nf90_close nf90_close proc~exitstat_nc->nf90_close proc~nchandle_error nchandle_error proc~exitstat_nc->proc~nchandle_error nf90_strerror nf90_strerror proc~nchandle_error->nf90_strerror Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~exitstat_nc~~CalledByGraph proc~exitstat_nc exitstat_nc proc~exitfielddump exitfielddump proc~exitfielddump->proc~exitstat_nc program~dalesurban DALESURBAN program~dalesurban->proc~exitfielddump Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine exitstat_nc ( ncid ) implicit none integer , intent ( in ) :: ncid integer status status = nf90_close ( ncid ) if ( status /= nf90_noerr ) call nchandle_error ( status ) end subroutine exitstat_nc","tags":"","url":"proc/exitstat_nc.html"},{"title":"writestat_dims_nc – uDALES","text":"public  subroutine writestat_dims_nc(ncid) Uses modmpi modglobal proc~~writestat_dims_nc~~UsesGraph proc~writestat_dims_nc writestat_dims_nc module~modglobal modglobal proc~writestat_dims_nc->module~modglobal module~modmpi modmpi proc~writestat_dims_nc->module~modmpi mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid Calls proc~~writestat_dims_nc~~CallsGraph proc~writestat_dims_nc writestat_dims_nc nf90_inq_varid nf90_inq_varid proc~writestat_dims_nc->nf90_inq_varid nf90_inquire_dimension nf90_inquire_dimension proc~writestat_dims_nc->nf90_inquire_dimension nf90_put_var nf90_put_var proc~writestat_dims_nc->nf90_put_var Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~writestat_dims_nc~~CalledByGraph proc~writestat_dims_nc writestat_dims_nc proc~initeb initEB proc~initeb->proc~writestat_dims_nc proc~initfielddump initfielddump proc~initfielddump->proc~writestat_dims_nc proc~initibm initibm proc~initibm->proc~writestat_dims_nc proc~initstatsdump initstatsdump proc~initstatsdump->proc~writestat_dims_nc program~dalesurban DALESURBAN program~dalesurban->proc~initeb program~dalesurban->proc~initfielddump program~dalesurban->proc~initibm program~dalesurban->proc~initstatsdump Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine writestat_dims_nc ( ncid ) use modglobal , only : xf , xh , yf , yh , dy , zf , zh , jmax , imax , kb , dxh use modmpi , only : myidx , myidy implicit none integer , intent ( in ) :: ncid integer :: i = 0 , iret , length , varid integer :: dx dx = dxh ( 1 ) ! Assume equidistant grid !write(*,*) 'writestat_dims_nc' iret = nf90_inq_varid ( ncid , 'xt' , VarID ) if ( iret == 0 ) iret = nf90_inquire_dimension ( ncid , xtID , len = length ) !if (iret==0) iret = nf90_put_var(ncid, varID, xf(1:length),(/1/)) if ( iret == 0 ) iret = nf90_put_var ( ncid , varID , ( / ( xf ( i + imax * myidx ), i = 1 , length ) / ),( / 1 / )) !if (iret==0) iret = nf90_put_var(ncid, varID, (/(dx*(0.5+i)+myidx*imax*dx,i=0,length-1)/),(/1/)) iret = nf90_inq_varid ( ncid , 'xm' , VarID ) if ( iret == 0 ) iret = nf90_inquire_dimension ( ncid , xmID , len = length ) !if (iret==0) iret = nf90_put_var(ncid, varID, xh(1:length),(/1/)) if ( iret == 0 ) iret = nf90_put_var ( ncid , varID , ( / ( xh ( i + imax * myidx ), i = 1 , length ) / ),( / 1 / )) !if (iret==0) iret = nf90_put_var(ncid, varID, (/(dx*i+myidx*imax*dx,i=0,length-1)/),(/1/)) iret = nf90_inq_varid ( ncid , 'yt' , VarID ) if ( iret == 0 ) iret = nf90_inquire_dimension ( ncid , ytID , len = length ) !if (iret==0) iret = nf90_put_var(ncid, varID, (/(dy*(0.5+i)+myidy*jmax*dy,i=0,length-1)/),(/1/)) if ( iret == 0 ) iret = nf90_put_var ( ncid , varID , ( / ( yf ( i + jmax * myidy ), i = 1 , length ) / ),( / 1 / )) iret = nf90_inq_varid ( ncid , 'ym' , VarID ) if ( iret == 0 ) iret = nf90_inquire_dimension ( ncid , ymID , len = length ) !if (iret==0) iret = nf90_put_var(ncid, varID, (/(dy*i+myidy*jmax*dy,i=0,length-1)/),(/1/)) if ( iret == 0 ) iret = nf90_put_var ( ncid , varID , ( / ( yh ( i + jmax * myidy ), i = 1 , length ) / ),( / 1 / )) iret = nf90_inq_varid ( ncid , 'zt' , VarID ) if ( iret == 0 ) iret = nf90_inquire_dimension ( ncid , ztID , len = length ) if ( iret == 0 ) iret = nf90_put_var ( ncid , varID , zf ( 1 : length ),( / 1 / )) !ils13, 29.06.2017 zf starts at 0, not at 1 iret = nf90_inq_varid ( ncid , 'zm' , VarID ) if ( iret == 0 ) iret = nf90_inquire_dimension ( ncid , zmID , len = length ) if ( iret == 0 ) iret = nf90_put_var ( ncid , varID , zh ( 1 : length ),( / 1 / )) !same for zh !if (isurf==1) then !iret = nf90_inq_varid(ncid, 'zts', VarID) !if (iret==0) iret = nf90_inquire_dimension(ncid, ztsID, len=length) !if (iret==0) iret = nf90_put_var(ncid, varID, zsoilc(1:length),(/1/)) !end if end subroutine writestat_dims_nc","tags":"","url":"proc/writestat_dims_nc.html"},{"title":"writestat_time_nc – uDALES","text":"public  subroutine writestat_time_nc(ncid, nvar, ncname, vars, nrec, lraise) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(in) :: nvar character(len=*), intent(in), dimension(:,:) :: ncname real, intent(in), dimension(nvar) :: vars integer, intent(inout) :: nrec logical, intent(in) :: lraise Calls proc~~writestat_time_nc~~CallsGraph proc~writestat_time_nc writestat_time_nc nf90_inq_varid nf90_inq_varid proc~writestat_time_nc->nf90_inq_varid nf90_put_var nf90_put_var proc~writestat_time_nc->nf90_put_var nf90_sync nf90_sync proc~writestat_time_nc->nf90_sync Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~writestat_time_nc~~CalledByGraph proc~writestat_time_nc writestat_time_nc interface~writestat_nc writestat_nc interface~writestat_nc->proc~writestat_time_nc proc~eb EB proc~eb->interface~writestat_nc proc~fielddump fielddump proc~fielddump->interface~writestat_nc proc~ibmwallfun ibmwallfun proc~ibmwallfun->interface~writestat_nc proc~statsdump statsdump proc~statsdump->interface~writestat_nc program~dalesurban DALESURBAN program~dalesurban->proc~eb program~dalesurban->proc~fielddump program~dalesurban->proc~ibmwallfun program~dalesurban->proc~statsdump Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine writestat_time_nc ( ncid , nvar , ncname , vars , nrec , lraise ) implicit none integer , intent ( in ) :: ncid , nvar integer , intent ( inout ) :: nrec real , dimension ( nvar ), intent ( in ) :: vars character ( * ), dimension (:,:), intent ( in ) :: ncname logical , intent ( in ) :: lraise integer :: iret , n , varid !write(*,*) 'time-nc' if ( lraise ) then nrec = nrec + 1 end if do n = 1 , nvar iret = nf90_inq_varid ( ncid , ncname ( n , 1 ), VarID ) iret = nf90_put_var ( ncid , VarID , vars ( n ), start = ( / nrec / )) end do iret = nf90_sync ( ncid ) end subroutine writestat_time_nc","tags":"","url":"proc/writestat_time_nc.html"},{"title":"writestat_1D_nc – uDALES","text":"public  subroutine writestat_1D_nc(ncid, nvar, ncname, vars, nrec, dim1) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(in) :: nvar character(len=*), intent(in), dimension(:,:) :: ncname real, intent(in), dimension(dim1,nvar) :: vars integer, intent(in) :: nrec integer, intent(in) :: dim1 Calls proc~~writestat_1d_nc~~CallsGraph proc~writestat_1d_nc writestat_1D_nc nf90_inq_varid nf90_inq_varid proc~writestat_1d_nc->nf90_inq_varid nf90_put_var nf90_put_var proc~writestat_1d_nc->nf90_put_var nf90_sync nf90_sync proc~writestat_1d_nc->nf90_sync Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~writestat_1d_nc~~CalledByGraph proc~writestat_1d_nc writestat_1D_nc interface~writestat_nc writestat_nc interface~writestat_nc->proc~writestat_1d_nc proc~eb EB proc~eb->proc~writestat_1d_nc proc~eb->interface~writestat_nc proc~ibmwallfun ibmwallfun proc~ibmwallfun->proc~writestat_1d_nc proc~ibmwallfun->interface~writestat_nc proc~statsdump statsdump proc~statsdump->proc~writestat_1d_nc proc~statsdump->interface~writestat_nc proc~fielddump fielddump proc~fielddump->interface~writestat_nc program~dalesurban DALESURBAN program~dalesurban->proc~eb program~dalesurban->proc~ibmwallfun program~dalesurban->proc~statsdump program~dalesurban->proc~fielddump Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine writestat_1D_nc ( ncid , nvar , ncname , vars , nrec , dim1 ) implicit none integer , intent ( in ) :: ncid , nvar , dim1 integer , intent ( in ) :: nrec real , dimension ( dim1 , nvar ), intent ( in ) :: vars character ( * ), dimension (:,:), intent ( in ) :: ncname integer :: iret , n , varid do n = 1 , nvar iret = nf90_inq_varid ( ncid , ncname ( n , 1 ), VarID ) iret = nf90_put_var ( ncid , VarID , vars ( 1 : dim1 , n ),( / 1 , nrec / ),( / dim1 , 1 / )) end do iret = nf90_sync ( ncid ) end subroutine writestat_1D_nc","tags":"","url":"proc/writestat_1d_nc.html"},{"title":"writestat_2D_nc – uDALES","text":"public  subroutine writestat_2D_nc(ncid, nvar, ncname, vars, nrec, dim1, dim2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(in) :: nvar character(len=*), intent(in), dimension(:,:) :: ncname real, intent(in), dimension(:,:,:) :: vars integer, intent(in) :: nrec integer, intent(in) :: dim1 integer, intent(in) :: dim2 Calls proc~~writestat_2d_nc~~CallsGraph proc~writestat_2d_nc writestat_2D_nc nf90_inq_varid nf90_inq_varid proc~writestat_2d_nc->nf90_inq_varid nf90_put_var nf90_put_var proc~writestat_2d_nc->nf90_put_var nf90_sync nf90_sync proc~writestat_2d_nc->nf90_sync Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~writestat_2d_nc~~CalledByGraph proc~writestat_2d_nc writestat_2D_nc interface~writestat_nc writestat_nc interface~writestat_nc->proc~writestat_2d_nc proc~eb EB proc~eb->proc~writestat_2d_nc proc~eb->interface~writestat_nc proc~fielddump fielddump proc~fielddump->interface~writestat_nc proc~ibmwallfun ibmwallfun proc~ibmwallfun->interface~writestat_nc proc~statsdump statsdump proc~statsdump->interface~writestat_nc program~dalesurban DALESURBAN program~dalesurban->proc~eb program~dalesurban->proc~fielddump program~dalesurban->proc~ibmwallfun program~dalesurban->proc~statsdump Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine writestat_2D_nc ( ncid , nvar , ncname , vars , nrec , dim1 , dim2 ) implicit none integer , intent ( in ) :: ncid , nvar , dim1 , dim2 integer , intent ( in ) :: nrec real , dimension (:,:,:), intent ( in ) :: vars character ( * ), dimension (:,:), intent ( in ) :: ncname integer :: iret , n , varid do n = 1 , nvar iret = nf90_inq_varid ( ncid , ncname ( n , 1 ), VarID ) iret = nf90_put_var ( ncid , VarID , vars ( 1 : dim1 , 1 : dim2 , n ),( / 1 , 1 , nrec / ),( / dim1 , dim2 , 1 / )) end do iret = nf90_sync ( ncid ) end subroutine writestat_2D_nc","tags":"","url":"proc/writestat_2d_nc.html"},{"title":"writestat_3D_nc – uDALES","text":"public  subroutine writestat_3D_nc(ncid, nvar, ncname, vars, nrec, dim1, dim2, dim3) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(in) :: nvar character(len=*), intent(in), dimension(:,:) :: ncname real, intent(in) :: vars (0:dim1-1,0:dim2-1,0:dim3-1,nvar) integer, intent(in) :: nrec integer, intent(in) :: dim1 integer, intent(in) :: dim2 integer, intent(in) :: dim3 Calls proc~~writestat_3d_nc~~CallsGraph proc~writestat_3d_nc writestat_3D_nc nf90_inq_varid nf90_inq_varid proc~writestat_3d_nc->nf90_inq_varid nf90_put_var nf90_put_var proc~writestat_3d_nc->nf90_put_var nf90_sync nf90_sync proc~writestat_3d_nc->nf90_sync Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~writestat_3d_nc~~CalledByGraph proc~writestat_3d_nc writestat_3D_nc interface~writestat_nc writestat_nc interface~writestat_nc->proc~writestat_3d_nc proc~eb EB proc~eb->interface~writestat_nc proc~fielddump fielddump proc~fielddump->interface~writestat_nc proc~ibmwallfun ibmwallfun proc~ibmwallfun->interface~writestat_nc proc~statsdump statsdump proc~statsdump->interface~writestat_nc program~dalesurban DALESURBAN program~dalesurban->proc~eb program~dalesurban->proc~fielddump program~dalesurban->proc~ibmwallfun program~dalesurban->proc~statsdump Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine writestat_3D_nc ( ncid , nvar , ncname , vars , nrec , dim1 , dim2 , dim3 ) implicit none integer , intent ( in ) :: ncid , nvar , dim1 , dim2 , dim3 integer , intent ( in ) :: nrec !real,dimension(dim1,dim2,dim3,nvar),intent(in)       :: vars real , intent ( in ) :: vars ( 0 : dim1 - 1 , 0 : dim2 - 1 , 0 : dim3 - 1 , nvar ) character ( * ), dimension (:,:), intent ( in ) :: ncname integer :: iret , n , varid !write(*,*) 'write 3Dnc' do n = 1 , nvar iret = nf90_inq_varid ( ncid , ncname ( n , 1 ), VarID ) !write(*,*) 'MYID,.', myid !write(*,*) \"nth netcdf variable\",n !write(*,*) 'ncid',ncid !write(*,*) \"n\",n !write(*,*) 'ncname(n,1)',ncname(n,1) !write(*,*) 'VarID',VarID !write(*,*) 'nrec',nrec !write(*,*) 'imax',dim1 !write(*,*) 'jmax',dim2 !write(*,*) 'kmax',dim3 !write(*,*) 'shape(vars)',shape(vars) !iret = nf90_put_var(ncid, VarID, vars(1:dim1,1:dim2,1:dim3,n),(/1,1,1,nrec/),(/dim1,dim2,dim3,1/)) iret = nf90_put_var ( ncid , VarID , vars (:,:,:, n ),( / 1 , 1 , 1 , nrec / ),( / dim1 , dim2 , dim3 , 1 / )) end do iret = nf90_sync ( ncid ) end subroutine writestat_3D_nc","tags":"","url":"proc/writestat_3d_nc.html"},{"title":"writestat_3D_short_nc – uDALES","text":"public  subroutine writestat_3D_short_nc(ncid, nvar, ncname, vars, nrec, dim1, dim2, dim3) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(in) :: nvar character(len=*), intent(in), dimension(:,:) :: ncname integer(kind=selected_int_kind(4)), intent(in), dimension(dim1,dim2,dim3,nvar) :: vars integer, intent(in) :: nrec integer, intent(in) :: dim1 integer, intent(in) :: dim2 integer, intent(in) :: dim3 Calls proc~~writestat_3d_short_nc~~CallsGraph proc~writestat_3d_short_nc writestat_3D_short_nc nf90_inq_varid nf90_inq_varid proc~writestat_3d_short_nc->nf90_inq_varid nf90_put_var nf90_put_var proc~writestat_3d_short_nc->nf90_put_var nf90_sync nf90_sync proc~writestat_3d_short_nc->nf90_sync Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~writestat_3d_short_nc~~CalledByGraph proc~writestat_3d_short_nc writestat_3D_short_nc interface~writestat_nc writestat_nc interface~writestat_nc->proc~writestat_3d_short_nc proc~eb EB proc~eb->interface~writestat_nc proc~fielddump fielddump proc~fielddump->interface~writestat_nc proc~ibmwallfun ibmwallfun proc~ibmwallfun->interface~writestat_nc proc~statsdump statsdump proc~statsdump->interface~writestat_nc program~dalesurban DALESURBAN program~dalesurban->proc~eb program~dalesurban->proc~fielddump program~dalesurban->proc~ibmwallfun program~dalesurban->proc~statsdump Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine writestat_3D_short_nc ( ncid , nvar , ncname , vars , nrec , dim1 , dim2 , dim3 ) implicit none integer , intent ( in ) :: ncid , nvar , dim1 , dim2 , dim3 integer , intent ( in ) :: nrec integer ( KIND = selected_int_kind ( 4 )), dimension ( dim1 , dim2 , dim3 , nvar ), intent ( in ) :: vars character ( * ), dimension (:,:), intent ( in ) :: ncname integer :: iret , n , varid !write(*,*) '3Dnc short' do n = 1 , nvar iret = nf90_inq_varid ( ncid , ncname ( n , 1 ), VarID ) iret = nf90_put_var ( ncid , VarID , vars ( 1 : dim1 , 1 : dim2 , 1 : dim3 , n ),( / 1 , 1 , 1 , nrec / ),( / dim1 , dim2 , dim3 , 1 / )) end do iret = nf90_sync ( ncid ) end subroutine writestat_3D_short_nc","tags":"","url":"proc/writestat_3d_short_nc.html"},{"title":"ncinfo – uDALES","text":"public  subroutine ncinfo(out, in1, in2, in3, in4) Arguments Type Intent Optional Attributes Name character(len=*), intent(out), dimension(4) :: out character(len=*), intent(in) :: in1 character(len=*), intent(in) :: in2 character(len=*), intent(in) :: in3 character(len=*), intent(in) :: in4 Called by proc~~ncinfo~~CalledByGraph proc~ncinfo ncinfo proc~initeb initEB proc~initeb->proc~ncinfo proc~initfielddump initfielddump proc~initfielddump->proc~ncinfo proc~initibm initibm proc~initibm->proc~ncinfo proc~initstatsdump initstatsdump proc~initstatsdump->proc~ncinfo program~dalesurban DALESURBAN program~dalesurban->proc~initeb program~dalesurban->proc~initfielddump program~dalesurban->proc~initibm program~dalesurban->proc~initstatsdump Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine ncinfo ( out , in1 , in2 , in3 , in4 ) implicit none character ( * ), dimension ( 4 ), intent ( out ) :: out character ( * ), intent ( in ) :: in1 , in2 , in3 , in4 out ( 1 ) = in1 out ( 2 ) = in2 out ( 3 ) = in3 out ( 4 ) = in4 end subroutine ncinfo","tags":"","url":"proc/ncinfo.html"},{"title":"nchandle_error – uDALES","text":"public  subroutine nchandle_error(status) Uses netcdf proc~~nchandle_error~~UsesGraph proc~nchandle_error nchandle_error netcdf netcdf proc~nchandle_error->netcdf Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name integer, intent(in) :: status Calls proc~~nchandle_error~~CallsGraph proc~nchandle_error nchandle_error nf90_strerror nf90_strerror proc~nchandle_error->nf90_strerror Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~nchandle_error~~CalledByGraph proc~nchandle_error nchandle_error proc~define_nc define_nc proc~define_nc->proc~nchandle_error proc~exitstat_nc exitstat_nc proc~exitstat_nc->proc~nchandle_error proc~exitfielddump exitfielddump proc~exitfielddump->proc~exitstat_nc proc~initeb initEB proc~initeb->proc~define_nc proc~initfielddump initfielddump proc~initfielddump->proc~define_nc proc~initibm initibm proc~initibm->proc~define_nc proc~initstatsdump initstatsdump proc~initstatsdump->proc~define_nc program~dalesurban DALESURBAN program~dalesurban->proc~exitfielddump program~dalesurban->proc~initeb program~dalesurban->proc~initfielddump program~dalesurban->proc~initibm program~dalesurban->proc~initstatsdump Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine nchandle_error ( status ) use netcdf implicit none integer , intent ( in ) :: status if ( status /= nf90_noerr ) then write ( 0 , * ) trim ( nf90_strerror ( status )) write ( 0 , * ) 'ERROR: status' , status stop 1 end if end subroutine nchandle_error","tags":"","url":"proc/nchandle_error.html"},{"title":"writestat_nc – uDALES","text":"public interface writestat_nc Calls interface~~writestat_nc~~CallsGraph interface~writestat_nc writestat_nc proc~writestat_1d_nc writestat_1D_nc interface~writestat_nc->proc~writestat_1d_nc proc~writestat_2d_nc writestat_2D_nc interface~writestat_nc->proc~writestat_2d_nc proc~writestat_3d_nc writestat_3D_nc interface~writestat_nc->proc~writestat_3d_nc proc~writestat_3d_short_nc writestat_3D_short_nc interface~writestat_nc->proc~writestat_3d_short_nc proc~writestat_time_nc writestat_time_nc interface~writestat_nc->proc~writestat_time_nc nf90_inq_varid nf90_inq_varid proc~writestat_1d_nc->nf90_inq_varid nf90_put_var nf90_put_var proc~writestat_1d_nc->nf90_put_var nf90_sync nf90_sync proc~writestat_1d_nc->nf90_sync proc~writestat_2d_nc->nf90_inq_varid proc~writestat_2d_nc->nf90_put_var proc~writestat_2d_nc->nf90_sync proc~writestat_3d_nc->nf90_inq_varid proc~writestat_3d_nc->nf90_put_var proc~writestat_3d_nc->nf90_sync proc~writestat_3d_short_nc->nf90_inq_varid proc~writestat_3d_short_nc->nf90_put_var proc~writestat_3d_short_nc->nf90_sync proc~writestat_time_nc->nf90_inq_varid proc~writestat_time_nc->nf90_put_var proc~writestat_time_nc->nf90_sync Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~writestat_nc~~CalledByGraph interface~writestat_nc writestat_nc proc~eb EB proc~eb->interface~writestat_nc proc~fielddump fielddump proc~fielddump->interface~writestat_nc proc~ibmwallfun ibmwallfun proc~ibmwallfun->interface~writestat_nc proc~statsdump statsdump proc~statsdump->interface~writestat_nc program~dalesurban DALESURBAN program~dalesurban->proc~eb program~dalesurban->proc~fielddump program~dalesurban->proc~ibmwallfun program~dalesurban->proc~statsdump Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  subroutine writestat_time_nc (ncid, nvar, ncname, vars, nrec, lraise) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(in) :: nvar character(len=*), intent(in), dimension(:,:) :: ncname real, intent(in), dimension(nvar) :: vars integer, intent(inout) :: nrec logical, intent(in) :: lraise public  subroutine writestat_1D_nc (ncid, nvar, ncname, vars, nrec, dim1) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(in) :: nvar character(len=*), intent(in), dimension(:,:) :: ncname real, intent(in), dimension(dim1,nvar) :: vars integer, intent(in) :: nrec integer, intent(in) :: dim1 public  subroutine writestat_2D_nc (ncid, nvar, ncname, vars, nrec, dim1, dim2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(in) :: nvar character(len=*), intent(in), dimension(:,:) :: ncname real, intent(in), dimension(:,:,:) :: vars integer, intent(in) :: nrec integer, intent(in) :: dim1 integer, intent(in) :: dim2 public  subroutine writestat_3D_nc (ncid, nvar, ncname, vars, nrec, dim1, dim2, dim3) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(in) :: nvar character(len=*), intent(in), dimension(:,:) :: ncname real, intent(in) :: vars (0:dim1-1,0:dim2-1,0:dim3-1,nvar) integer, intent(in) :: nrec integer, intent(in) :: dim1 integer, intent(in) :: dim2 integer, intent(in) :: dim3 public  subroutine writestat_3D_short_nc (ncid, nvar, ncname, vars, nrec, dim1, dim2, dim3) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(in) :: nvar character(len=*), intent(in), dimension(:,:) :: ncname integer(kind=selected_int_kind(4)), intent(in), dimension(dim1,dim2,dim3,nvar) :: vars integer, intent(in) :: nrec integer, intent(in) :: dim1 integer, intent(in) :: dim2 integer, intent(in) :: dim3","tags":"","url":"interface/writestat_nc.html"},{"title":"chem – uDALES","text":"public  subroutine chem() Uses modfields modglobal proc~~chem~~UsesGraph proc~chem chem module~modfields modfields proc~chem->module~modfields module~modglobal modglobal proc~chem->module~modglobal decomp_2d decomp_2d module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~chem~~CalledByGraph proc~chem chem proc~tstep_integrate tstep_integrate proc~tstep_integrate->proc~chem Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine chem use modglobal , only : lchem , k1 , JNO2 , dt , rk3step , ib , ie , ihc , ih , jb , je , jhc , jh , kb , ke , khc , kh use modfields , only : svp , svm , sv0 , IIc implicit none real , dimension ( ib - ihc : ie + ihc , jb - jhc : je + jhc , kb : ke + khc ) :: dummyNO , dummyNO2 , dummyO3 if ( lchem . eqv . . false .) return ! forward Euler ! [NO] !    svp(:,:,:,1) = svp(:,:,:,1) + 30.006 * ( JNO2 * (svm(:,:,:,2)/46.005) - k1 * (svm(:,:,:,1) / 30.006) * (svm(:,:,:,3)/47.997) ) ! [NO2] !    svp(:,:,:,2) = svp(:,:,:,2) + 46.005 * (-JNO2 * (svm(:,:,:,2)/46.005) + k1 * (svm(:,:,:,1) / 30.006) * (svm(:,:,:,3)/47.997) ) ! [O3] !    svp(:,:,:,3) = svp(:,:,:,3) + 47.997 * ( JNO2 * (svm(:,:,:,2)/46.005) - k1 * (svm(:,:,:,1) / 30.006) * (svm(:,:,:,3)/47.997) ) if (. not . rk3step == 3 ) return ! convert into mol/m&#94;3 dummyNO = IIc * sv0 (:,:, kb : ke + khc , 1 ) / 3 0.006 dummyNO2 = IIc * sv0 (:,:, kb : ke + khc , 2 ) / 4 6.005 dummyO3 = IIc * sv0 (:,:, kb : ke + khc , 3 ) / 4 7.997 !backward Euler, semi-implicit !    sv0(:,:,kb:ke+khc,1) = 30.006 * ( ( (sv0(:,:,kb:ke+khc,1)/30.006) + JNO2 * dummyNO2 * dt) / (1. + k1 * dummyO3 * dt) ) !    sv0(:,:,kb:ke+khc,2) = 46.005 * ( ( (sv0(:,:,kb:ke+khc,2)/46.005) + k1 * dummyNO * dummyO3 * dt )  / (1. + JNO2 * dt) ) !    sv0(:,:,kb:ke+khc,3) = 47.997 * ( ( (sv0(:,:,kb:ke+khc,3)/47.997) + JNO2 * dummyNO2 * dt) / (1. + k1 * dummyNO * dt) ) !backward Euler, fully implicit. Derivation at (/projects/Chemistry/FullyImplicit.mw) sv0 (:,:, kb : ke + khc , 1 ) = 3 0.006 * ( ( sv0 (:,:, kb : ke + khc , 1 ) / 3 0.006 ) + ( dt * ( - k1 * dummyNO * dummyO3 + JNO2 * dummyNO2 ) ) / & ( 1. + ( ( dummyNO + dummyO3 ) * k1 + JNO2 ) * dt ) ) sv0 (:,:, kb : ke + khc , 2 ) = 4 6.005 * ( ( sv0 (:,:, kb : ke + khc , 2 ) / 4 6.005 ) - ( dt * ( - k1 * dummyNO * dummyO3 + JNO2 * dummyNO2 ) ) / & ( 1. + ( ( dummyNO + dummyO3 ) * k1 + JNO2 ) * dt ) ) sv0 (:,:, kb : ke + khc , 3 ) = 4 7.997 * ( ( sv0 (:,:, kb : ke + khc , 3 ) / 4 7.997 ) + ( dt * ( - k1 * dummyNO * dummyO3 + JNO2 * dummyNO2 ) ) / & ( 1. + ( ( dummyNO + dummyO3 ) * k1 + JNO2 ) * dt ) ) ! alternative method in Zhong 2017 eqn. 7, analytical solution! end subroutine chem","tags":"","url":"proc/chem.html"},{"title":"createpurifiers – uDALES","text":"public  subroutine createpurifiers() Uses modmpi modglobal proc~~createpurifiers~~UsesGraph proc~createpurifiers createpurifiers module~modglobal modglobal proc~createpurifiers->module~modglobal module~modmpi modmpi proc~createpurifiers->module~modmpi mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~createpurifiers~~CallsGraph proc~createpurifiers createpurifiers mpi_bcast mpi_bcast proc~createpurifiers->mpi_bcast Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~createpurifiers~~CalledByGraph proc~createpurifiers createpurifiers program~dalesurban DALESURBAN program~dalesurban->proc~createpurifiers Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine createpurifiers use modglobal , only : lpurif , npurif , purif , cexpnr , ifinput use modmpi , only : myid , comm3d , mpierr implicit none integer :: n character ( 80 ) chmess if ( lpurif . eqv . . false .) return allocate ( purif ( npurif , 7 )) ! read global purifiers if ( myid == 0 ) then ! write(*,*) '1, myid, npurif, lpurif, cexpnr', myid, npurif, lpurif, cexpnr if ( npurif > 0 ) then open ( ifinput , file = 'purifs.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess read ( ifinput , '(a80)' ) chmess do n = 1 , npurif read ( ifinput , * ) & purif ( n , 1 ), & purif ( n , 2 ), & purif ( n , 3 ), & purif ( n , 4 ), & purif ( n , 5 ), & purif ( n , 6 ), & purif ( n , 7 ) end do ! write (6,*) 'Purifier number,  il, iu, jl, ju, kl, ku, ipu ' ! do n=1,npurif !   write (6,*) & !         n , & !         purif(n,1), & !         purif(n,2), & !         purif(n,3), & !         purif(n,4), & !         purif(n,5), & !         purif(n,6), & !         purif(n,7) ! end do end if ! write(*,*) 'Finished determining purifiers on myid == 0' end if ! end if myid==0 call MPI_BCAST ( purif , 7 * npurif , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( npurif , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) end subroutine createpurifiers","tags":"","url":"proc/createpurifiers.html"},{"title":"purifiers – uDALES","text":"public  subroutine purifiers() Uses modfields modmpi modglobal proc~~purifiers~~UsesGraph proc~purifiers purifiers module~modfields modfields proc~purifiers->module~modfields module~modglobal modglobal proc~purifiers->module~modglobal module~modmpi modmpi proc~purifiers->module~modmpi decomp_2d decomp_2d module~modfields->decomp_2d mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~purifiers~~CalledByGraph proc~purifiers purifiers program~dalesurban DALESURBAN program~dalesurban->proc~purifiers Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine purifiers use modglobal , only : ib , ie , jb , je , kb , ke , ih , xf , xh , zh , purif , npurif , lpurif , itot , jtot , Qpu , epu , dy , nsv use modfields , only : um , vm , wm , u0 , v0 , w0 , up , vp , wp , svp , svm , sv0 use modmpi , only : myidx , myidy , nprocx , nprocy implicit none integer :: i , j , k , n , il , iu , jl , ju , kl , ku real :: Apu , dpu , upu , vpu , wpu , udpu real , allocatable :: inpu (:,:,:,:) if ( lpurif . eqv . . false .) return do n = 1 , npurif upu = 0. vpu = 0. wpu = 0. ! Determine flow direction through purifier= select case ( purif ( n , 7 )) ! calculate cross-sectional area, length of purifier and flow speed case ( 1 ) Apu = ( purif ( n , 4 ) - purif ( n , 3 ) + 1 ) * dy * ( zh ( purif ( n , 6 ) + 1 ) - zh ( purif ( n , 5 ))) dpu = xh ( purif ( n , 2 ) + 1 ) - xh ( purif ( n , 1 )) upu = Qpu / Apu case ( 2 ) Apu = ( purif ( n , 4 ) - purif ( n , 3 ) + 1 ) * dy * ( zh ( purif ( n , 6 ) + 1 ) - zh ( purif ( n , 5 ))) dpu = xh ( purif ( n , 2 ) + 1 ) - xh ( purif ( n , 1 )) upu = - Qpu / Apu case ( 3 ) Apu = ( xh ( purif ( n , 2 ) + 1 ) - xh ( purif ( n , 1 ))) * ( zh ( purif ( n , 6 ) + 1 ) - zh ( purif ( n , 5 ))) dpu = ( purif ( n , 4 ) - purif ( n , 3 ) + 1 ) * dy vpu = Qpu / Apu case ( 4 ) Apu = ( xh ( purif ( n , 2 ) + 1 ) - xh ( purif ( n , 1 ))) * ( zh ( purif ( n , 6 ) + 1 ) - zh ( purif ( n , 5 ))) dpu = ( purif ( n , 4 ) - purif ( n , 3 ) + 1 ) * dy vpu = - Qpu / Apu case ( 5 ) Apu = ( purif ( n , 4 ) - purif ( n , 3 ) + 1 ) * dy * ( xh ( purif ( n , 2 ) + 1 ) - xh ( purif ( n , 1 ))) dpu = zh ( purif ( n , 6 ) + 1 ) - zh ( purif ( n , 5 )) wpu = Qpu / Apu case ( 6 ) Apu = ( purif ( n , 4 ) - purif ( n , 3 ) + 1 ) * dy * ( xh ( purif ( n , 2 ) + 1 ) - xh ( purif ( n , 1 ))) dpu = zh ( purif ( n , 6 ) + 1 ) - zh ( purif ( n , 5 )) wpu = - Qpu / Apu case ( 7 ) ! purifier that takes from above and below and feeds outwards Apu = ( purif ( n , 4 ) - purif ( n , 3 ) + 1 ) * dy * ( xh ( purif ( n , 2 ) + 1 ) - xh ( purif ( n , 1 ))) * 2 ! *2 due to geometry of purifier dpu = zh ( purif ( n , 6 ) + 1 ) - zh ( purif ( n , 5 )) / 2 ! half distance to travel before purification? udpu = Qpu / Apu ! new term to be used at purifier faces case ( 8 ) ! one cell purifier that intakes from all side and outputs upwards Apu = 2 * ( purif ( n , 4 ) - purif ( n , 3 ) + 1 ) * dy * ( xh ( purif ( n , 2 ) + 1 ) - xh ( purif ( n , 1 ))) + & 2 * ( xh ( purif ( n , 2 ) + 1 ) - xh ( purif ( n , 1 ))) * ( zh ( purif ( n , 6 ) + 1 ) - zh ( purif ( n , 5 ))) ! sum up 4 horizontal cell faces dpu = 0.5 * ( ( purif ( n , 4 ) - purif ( n , 3 ) + 1 ) * dy + xh ( purif ( n , 2 ) + 1 ) - xh ( purif ( n , 1 )) ) ! average distance from outside cell to centre cell in horizontal directions udpu = Qpu / Apu ! new term to be used at purifier faces end select ! enforce flowrate ! u flowrate il = purif ( n , 1 ) - myidx * itot / nprocx iu = purif ( n , 2 ) + 1 - myidx * itot / nprocx kl = purif ( n , 5 ) ku = purif ( n , 6 ) jl = purif ( n , 3 ) - myidy * jtot / nprocy ju = purif ( n , 4 ) - myidy * jtot / nprocy if ( iu < ib . or . il > ie . or . ju < jb . or . jl > je ) then cycle else if ( iu > ie ) iu = ie if ( il < ib ) il = ib if ( ju > je ) ju = je if ( jl < jb ) jl = jb up ( il : iu , jl : ju , kl : ku ) = 0. um ( il : iu , jl : ju , kl : ku ) = upu u0 ( il : iu , jl : ju , kl : ku ) = upu ! tg3315 !WARNING changed these to u0 as realised RK3... change back to um if not working... !tg3315 14.05.18 have made it do both due to role in RK3, ..m is more crucial to change and may need ..0 end if ! v flowrate il = purif ( n , 1 ) - myidx * itot / nprocx iu = purif ( n , 2 ) - myidx * itot / nprocx kl = purif ( n , 5 ) ku = purif ( n , 6 ) jl = purif ( n , 3 ) - myidy * jtot / nprocy ju = purif ( n , 4 ) + 1 - myidy * jtot / nprocy if ( iu < ib . or . il > ie . or . ju < jb . or . jl > je ) then cycle else if ( iu > ie ) iu = ie if ( il < ib ) il = ib if ( ju > je ) ju = je if ( jl < jb ) jl = jb vp ( il : iu , jl : ju , kl : ku ) = 0. vm ( il : iu , jl : ju , kl : ku ) = vpu v0 ( il : iu , jl : ju , kl : ku ) = vpu end if ! w flowrate il = purif ( n , 1 ) - myidx * itot / nprocx iu = purif ( n , 2 ) - myidx * itot / nprocx kl = purif ( n , 5 ) ku = purif ( n , 6 ) + 1 jl = purif ( n , 3 ) - myidy * jtot / nprocy ju = purif ( n , 4 ) - myidy * jtot / nprocy if ( iu < ib . or . il > ie . or . ju < jb . or . jl > je ) then cycle else if ( iu > ie ) iu = ie if ( il < ib ) il = ib if ( ju > je ) ju = je if ( jl < jb ) jl = jb wp ( il : iu , jl : ju , kl : ku ) = 0. wm ( il : iu , jl : ju , kl : ku ) = wpu w0 ( il : iu , jl : ju , kl : ku ) = wpu end if ! Scalars il = purif ( n , 1 ) - myidx * itot / nprocx iu = purif ( n , 2 ) - myidx * itot / nprocx kl = purif ( n , 5 ) ku = purif ( n , 6 ) jl = purif ( n , 3 ) - myidy * jtot / nprocy ju = purif ( n , 4 ) - myidy * jtot / nprocy if ( iu < ib . or . il > ie . or . ju < jb . or . jl > je ) then cycle else if ( iu > ie ) iu = ie if ( il < ib ) il = ib if ( ju > je ) ju = je if ( jl < jb ) jl = jb where ( sv0 (:,:,:, 1 ) < 0. ) sv0 (:,:,:, 1 ) = 0. !must do this in tstep after svo = ... ! calculate concentration at purifier inlet allocate ( inpu ( il : iu , jl : ju , kl : ku , 1 : nsv )) inpu = 0. select case ( purif ( n , 7 )) case ( 1 ) do i = il , iu inpu ( i ,:,:,:) = svm ( il - 1 , jl : ju , kl : ku ,:) !tg3315 also changed svm -> sv0 change back if stops working ! tg3315 14.05.18 I have undone this now as believe that ..m represents the latest confirmed value whilst ..0 is updated through RK3 timestep. If causes issues then stop! end do case ( 2 ) do i = il , iu inpu ( i ,:,:,:) = svm ( iu + 1 , jl : ju , kl : ku ,:) end do case ( 3 ) do j = jl , ju inpu (:, j ,:,:) = svm ( il : iu , jl - 1 , kl : ku ,:) end do case ( 4 ) do j = jl , ju inpu (:, j ,:,:) = svm ( il : iu , ju + 1 , kl : ku ,:) end do case ( 5 ) do k = kl , ku inpu (:,:, k ,:) = svm ( il : iu , jl : ju , kl - 1 ,:) end do case ( 6 ) do k = kl , ku inpu (:,:, k ,:) = svm ( il : iu , jl : ju , ku + 1 ,:) end do case ( 7 ) inpu (:,:, ku ,:) = svm ( il : iu , jl : ju , ku + 1 ,:) inpu (:,:, kl ,:) = svm ( il : iu , jl : ju , kl - 1 ,:) wm ( il : iu , jl : ju , ku + 1 ) = - udpu w0 ( il : iu , jl : ju , ku + 1 ) = - udpu wm ( il : iu , jl : ju , kl ) = udpu w0 ( il : iu , jl : ju , kl ) = udpu case ( 8 ) !> initially coded for purifiers of cell size = 1 (il=iu,jl=ju,kl=ku) inpu ( il , jl ,:,:) = 0.25 * ( svm ( il - 1 , jl , kl : ku ,:) + svm ( iu + 1 , jl , kl : ku ,:) + svm ( il , jl - 1 , kl : ku ,:) + svm ( il , ju + 1 , kl : ku ,:) ) um ( il , jl : ju , kl : ku ) = udpu u0 ( il , jl : ju , kl : ku ) = udpu vm ( il : iu , jl , kl : ku ) = udpu v0 ( il : iu , jl , kl : ku ) = udpu um ( iu + 1 , jl : ju , kl : ku ) = - udpu u0 ( iu + 1 , jl : ju , kl : ku ) = - udpu vm ( il : iu , ju + 1 , kl : ku ) = - udpu v0 ( il : iu , ju + 1 , kl : ku ) = - udpu end select ! apply sink term to purify at given efficiency svp ( il : iu , jl : ju , kl : ku , 1 ) = svp ( il : iu , jl : ju , kl : ku , 1 ) - & ( Qpu / Apu ) * epu * inpu (:,:,:, 1 ) / dpu if ( nsv > 1 ) then svp ( il : iu , jl : ju , kl : ku , 2 ) = svp ( il : iu , jl : ju , kl : ku , 2 ) - & ( Qpu / Apu ) * 0.7 * inpu (:,:,:, 2 ) / dpu end if if ( nsv > 3 ) then svp ( il : iu , jl : ju , kl : ku , 4 ) = svp ( il : iu , jl : ju , kl : ku , 4 ) - & ( Qpu / Apu ) * 0.65 * inpu (:,:,:, 4 ) / dpu end if deallocate ( inpu ) end if end do ! npurif end subroutine purifiers","tags":"","url":"proc/purifiers.html"},{"title":"readnamelists – uDALES","text":"public  subroutine readnamelists() Uses modtimedep modmpi modboundary modsurfdata decomp_2d moddriver modpois modthermodynamics modibmdata modinletdata modglobal modibm modinlet modsubgrid modforces modfields proc~~readnamelists~~UsesGraph proc~readnamelists readnamelists decomp_2d decomp_2d proc~readnamelists->decomp_2d modpois modpois proc~readnamelists->modpois module~modboundary modboundary proc~readnamelists->module~modboundary module~moddriver moddriver proc~readnamelists->module~moddriver module~modfields modfields proc~readnamelists->module~modfields module~modforces modforces proc~readnamelists->module~modforces module~modglobal modglobal proc~readnamelists->module~modglobal module~modibm modibm proc~readnamelists->module~modibm module~modibmdata modibmdata proc~readnamelists->module~modibmdata module~modinlet modinlet proc~readnamelists->module~modinlet module~modinletdata modinletdata proc~readnamelists->module~modinletdata module~modmpi modmpi proc~readnamelists->module~modmpi module~modsubgrid modsubgrid proc~readnamelists->module~modsubgrid module~modsurfdata modsurfdata proc~readnamelists->module~modsurfdata module~modthermodynamics modthermodynamics proc~readnamelists->module~modthermodynamics module~modtimedep modtimedep proc~readnamelists->module~modtimedep mpi mpi module~modboundary->mpi module~moddriver->module~modinletdata module~modfields->decomp_2d module~modibm->module~modibmdata module~modibm->mpi module~modinlet->module~modinletdata module~modinlet->mpi module~modmpi->mpi module~modsubgriddata modsubgriddata module~modsubgrid->module~modsubgriddata module~modsubgrid->mpi module~modtimedep->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~readnamelists~~CallsGraph proc~readnamelists readnamelists mpi_bcast mpi_bcast proc~readnamelists->mpi_bcast Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~readnamelists~~CalledByGraph proc~readnamelists readnamelists program~dalesurban DALESURBAN program~dalesurban->proc~readnamelists Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Namelists Namelist RUN Variables Name Type Default Description iexpnr integer 0 lwarmstart logical .false. lstratstart logical .false. startfile character(len=90) '' runtime real 300. dtmax real 20. trestart real 10000. ladaptive logical .false. irandom integer(kind=selected_int_kind(6)) 43 randu real 0.01 randthl real 0.0 randqt real 0.0 krand integer huge(0) courant real -1. diffnr real 0.25 author character(len=80) '' libm logical .true. lles logical .true. lper2inout logical .false. lwalldist logical .false. lreadmean logical .false. nprocx integer None nprocy integer None lrandomize logical .true. Namelist DOMAIN Variables Name Type Default Description itot integer 96 jtot integer 96 ktot integer 96 xlen real -1. ylen real -1. xlat real 52. xlon real 0. xday real 1. xtime real 0. ksp integer -1 Namelist PHYSICS Variables Name Type Default Description ps real 101325. igrw_damp integer 0 lmoist logical .false. lcoriol logical .false. lbuoyancy logical .false. ltempeq logical .false. lprofforc logical .false. ifixuinf integer 0 lvinf logical .false. tscale real None dpdx real 0. luoutflowr logical .false. lvoutflowr logical .false. luvolflowr logical .false. lvvolflowr logical .false. uflowrate real 1. vflowrate real 1. lnudge logical .false. lnudgevel logical .true. tnudge real 60. nnudge integer 0 ltimedepsurf logical .false. ntimedepsurf integer None ltimedepnudge logical .false. ntimedepnudge integer None ltimedeplw logical .false. ntimedeplw integer None ltimedepsw logical .false. ntimedepsw integer None Namelist DYNAMICS Variables Name Type Default Description lqlnr logical .false. ipoiss integer POISS_FFT2D iadv_mom integer 2 iadv_tke integer -1 iadv_thl integer -1 iadv_qt integer -1 iadv_sv integer -1 Namelist BC Variables Name Type Default Description BCxm integer BCxm_periodic BCxT integer BCxT_periodic BCxq integer BCxq_periodic BCxs integer BCxs_periodic BCym integer BCym_periodic BCyT integer BCyT_periodic BCyq integer BCyq_periodic BCys integer BCys_periodic BCtopm integer BCtopm_freeslip BCtopT integer BCtopT_flux BCtopq integer BCtopq_flux BCtops integer BCtops_flux BCbotm integer BCbotm_wf BCbotT integer BCbotT_flux BCbotq integer BCbotq_flux BCbots integer BCbots_flux bctfxm real 0. bctfxp real 0. bctfym real 0. bctfyp real 0. bctfz real 0. bcqfxm real 0. bcqfxp real 0. bcqfym real 0. bcqfyp real 0. bcqfz real 0. wttop real 0. thl_top real -1. qt_top real -1. qts real -1. wsvsurfdum real 0. wsvtopdum real 0. wtsurf real -1. wqsurf real -1. thls real -1. z0 real -1. z0h real -1. BCzp integer 1 ds real 0 Namelist INLET Variables Name Type Default Description Uinf real 0. Vinf real 0. di real 0.09 dti real None inletav real 0. linletRA logical .false. lstoreplane logical .false. lreadminl logical .false. lfixinlet logical .false. lfixutauin logical .false. lwallfunc logical .true. Namelist DRIVER Variables Name Type Default Description idriver integer 0 tdriverstart real 0. driverjobnr integer None dtdriver real 0.1 driverstore integer None iplane integer None iangledeg real 0. lchunkread logical .false. chunkread_size integer 100 Namelist WALLS Variables Name Type Default Description nblocks integer 0 nfcts integer -1 iwallmom integer 2 iwalltemp integer 1 iwallmoist integer 1 iwallscal integer 1 nsolpts_u integer None nsolpts_v integer None nsolpts_w integer None nsolpts_c integer None nbndpts_u integer None nbndpts_v integer None nbndpts_w integer None nbndpts_c integer None nfctsecs_u integer None nfctsecs_v integer None nfctsecs_w integer None nfctsecs_c integer None lbottom logical .false. lnorec logical .false. prandtlturb real prandtlmol fkar real 0.41 lwritefac logical .false. dtfac real 10. Namelist ENERGYBALANCE Variables Name Type Default Description lEB logical .false. lwriteEBfiles logical .false. lperiodicEBcorr logical .false. sinkbase integer 0 lconstW logical .false. dtEB real 10. bldT real 0. flrT real 0. wsoil real 0. wgrmax real 450. wwilt real 171. wfc real 313. skyLW real 0. GRLAI real 2. rsmin real 110. nfaclyrs integer 3 lfacTlyrs logical .false. lvfsparse logical .false. nnz integer None fraction real 1 Namelist SCALARS Variables Name Type Default Description lreadscal logical .false. lscasrc logical .false. lscasrcl logical .false. lscasrcr logical .false. nsv integer 0 nscasrc integer 0 nscasrcl integer 0 Namelist CHEMISTRY Variables Name Type Default Description lchem logical .false. k1 real 0. JNO2 real 0. Namelist OUTPUT Variables Name Type Default Description lfielddump logical .false. tfielddump real 10000. fieldvars character(len=50) '' ltdump logical .false. lydump logical .false. lytdump logical .false. lxydump logical .false. lxytdump logical .false. lmintdump logical .false. lkslicedump logical .false. kslice integer 1 lislicedump logical .false. islice integer 1 ljslicedump logical .false. jslice integer 1 ltkedump logical .false. tstatsdump real 10000. tsample real 5. tstatstart real 0. Namelist TREES Variables Name Type Default Description ltrees logical .false. ntrees integer 0 cd real 0. dec real 0. ud real 0. lad real 0. Qstar real 0. dQdt real 0. lsize real 0. r_s real 0. ltreedump logical .false. Namelist PURIFS Variables Name Type Default Description lpurif logical .false. npurif integer 0 Qpu real 0. epu real 0. Namelist HEATPUMP Variables Name Type Default Description lheatpump logical .false. lfan_hp logical .true. nhppoints integer 0 Q_dot_hp real 0. QH_dot_hp real 0. Source Code subroutine readnamelists !-----------------------------------------------------------------| !                                                                 | !     Reads all general options from namoptions                   | !                                                                 | !      Jasper Tomas                 31/03/2014                    | !      Chiel van Heerwaarden        15/06/2007                    | !      Thijs Heus                   15/06/2007                    | !-----------------------------------------------------------------| use modglobal , only : initglobal , iexpnr , runtime , dtmax , & lwarmstart , lstratstart , lfielddump , lreadscal , startfile , tfielddump , fieldvars , tsample , tstatsdump , tstatstart , trestart , & nsv , itot , jtot , ktot , xlen , ylen , xlat , xlon , xday , xtime , lwalldist , & lmoist , lcoriol , igrw_damp , geodamptime , ifnamopt , fname_options , & nscasrc , nscasrcl , iwallmom , iwalltemp , iwallmoist , iwallscal , ipoiss , iadv_mom , iadv_tke , iadv_thl , iadv_qt , iadv_sv , courant , diffnr , ladaptive , author ,& linoutflow , lper2inout , libm , lnudge , lnudgevel , tnudge , nnudge , lles , luoutflowr , lvoutflowr , luvolflowr , lvvolflowr , & uflowrate , vflowrate , lstoreplane , iplane , & lreadmean , iinletgen , inletav , lreadminl , Uinf , Vinf , linletRA , nblocks , & lscalrec , lSIRANEinout , lscasrc , lscasrcl , lscasrcr , lydump , lytdump , lxydump , lxytdump , ltdump , lmintdump , ltkedump , lzerogradtop ,& lkslicedump , lislicedump , ljslicedump , kslice , islice , jslice ,& lzerogradtopscal , lbuoyancy , ltempeq , & lfixinlet , lfixutauin , pi , & thlsrc , ifixuinf , lvinf , tscale , ltempinout , lmoistinout , & lwallfunc , lprofforc , lchem , k1 , JNO2 , rv , rd , tnextEB , tEB , dtEB , bldT , flrT , lperiodicEBcorr , fraction , sinkbase , wsoil , wgrmax , wwilt , wfc , skyLW , GRLAI , rsmin , nfcts , lEB , lwriteEBfiles , nfaclyrs , lconstW , lvfsparse , nnz , lfacTlyrs , & BCxm , BCxT , BCxq , BCxs , BCym , BCyT , BCyq , BCys , BCzp , ds , & BCtopm , BCtopT , BCtopq , BCtops , BCbotm , BCbotT , BCbotq , BCbots , & BCxm_periodic , BCym_periodic , & idriver , tdriverstart , driverjobnr , dtdriver , driverstore , lchunkread , chunkread_size , & lrandomize , prandtlturb , fkar , lwritefac , dtfac , tfac , tnextfac , & ltrees , ntrees , Qstar , dQdt , lad , lsize , r_s , cd , dec , ud , ltreedump , & lpurif , npurif , Qpu , epu , & lheatpump , lfan_hp , nhppoints , Q_dot_hp , QH_dot_hp use modsurfdata , only : z0 , z0h , wtsurf , wttop , wqtop , wqsurf , wsvsurf , wsvtop , wsvsurfdum , wsvtopdum , ps , thvs , thls , thl_top , qt_top , qts use modfields , only : initfields , dpdx , ncname use modpois , only : initpois use modboundary , only : initboundary , ksp use modthermodynamics , only : initthermodynamics , lqlnr , chi_half use modsubgrid , only : initsubgrid use modmpi , only : comm3d , myid , myidx , myidy , cmyid , cmyidx , cmyidy , mpi_integer , mpi_logical , my_real , mpierr , mpi_character , nprocx , nprocy , nbreast , nbrwest , nbrnorth , nbrsouth use modinlet , only : initinlet use modinletdata , only : di , dr , di_test , dti , iangledeg , iangle use modibmdata , only : bctfxm , bctfxp , bctfym , bctfyp , bctfz , bcqfxm , bcqfxp , bcqfym , bcqfyp , bcqfz use modforces , only : calcfluidvolumes use moddriver , only : initdriver use modtimedep , only : ltimedepsurf , ntimedepsurf , ltimedepnudge , ntimedepnudge , & ltimedeplw , ntimedeplw , ltimedepsw , ntimedepsw use modibm , only : nsolpts_u , nsolpts_v , nsolpts_w , nsolpts_c , & nbndpts_u , nbndpts_v , nbndpts_w , nbndpts_c , & nfctsecs_u , nfctsecs_v , nfctsecs_w , nfctsecs_c , & createmasks , lbottom , lnorec use decomp_2d implicit none integer :: ierr logical , dimension ( 3 ) :: periodic_bc integer , dimension ( 2 ) :: myids !declare namelists namelist / RUN / & iexpnr , lwarmstart , lstratstart , startfile , & runtime , dtmax , trestart , ladaptive , & irandom , randu , randthl , randqt , krand , & courant , diffnr , author , & libm , lles , & lper2inout , lwalldist , & lreadmean , & nprocx , nprocy , & lrandomize namelist / DOMAIN / & itot , jtot , ktot , xlen , ylen , & xlat , xlon , xday , xtime , ksp namelist / PHYSICS / & ps , igrw_damp , lmoist , lcoriol , lbuoyancy , ltempeq , & lprofforc , ifixuinf , lvinf , tscale , dpdx , & luoutflowr , lvoutflowr , luvolflowr , lvvolflowr , & uflowrate , vflowrate , & lnudge , lnudgevel , tnudge , nnudge , & ltimedepsurf , ntimedepsurf , ltimedepnudge , ntimedepnudge , & ltimedeplw , ntimedeplw , ltimedepsw , ntimedepsw namelist / DYNAMICS / & lqlnr , ipoiss , & iadv_mom , iadv_tke , iadv_thl , iadv_qt , iadv_sv namelist / BC / & BCxm , BCxT , BCxq , BCxs , & BCym , BCyT , BCyq , BCys , & BCtopm , BCtopT , BCtopq , BCtops , & BCbotm , BCbotT , BCbotq , BCbots , & bctfxm , bctfxp , bctfym , bctfyp , bctfz , & bcqfxm , bcqfxp , bcqfym , bcqfyp , bcqfz , & wttop , thl_top , qt_top , qts , wsvsurfdum , wsvtopdum , & wtsurf , wqsurf , thls , z0 , z0h , BCzp , ds namelist / INLET / & Uinf , Vinf , di , dti , inletav , linletRA , & lstoreplane , lreadminl , lfixinlet , lfixutauin , & lwallfunc namelist / DRIVER / & idriver , tdriverstart , driverjobnr , dtdriver , & driverstore , iplane , iangledeg , & lchunkread , chunkread_size namelist / WALLS / & nblocks , nfcts , iwallmom , iwalltemp , iwallmoist , iwallscal , & nsolpts_u , nsolpts_v , nsolpts_w , nsolpts_c , & nbndpts_u , nbndpts_v , nbndpts_w , nbndpts_c , & nfctsecs_u , nfctsecs_v , nfctsecs_w , nfctsecs_c , lbottom , lnorec , & prandtlturb , fkar , lwritefac , dtfac namelist / ENERGYBALANCE / & lEB , lwriteEBfiles , lperiodicEBcorr , sinkbase , lconstW , dtEB , bldT , flrT , wsoil , wgrmax , wwilt , wfc , & skyLW , GRLAI , rsmin , nfaclyrs , lfacTlyrs , lvfsparse , nnz , fraction namelist / SCALARS / & lreadscal , lscasrc , lscasrcl , lscasrcr , & nsv , nscasrc , nscasrcl !!xS, yS, zS, SS, sigS namelist / CHEMISTRY / & lchem , k1 , JNO2 namelist / OUTPUT / & lfielddump , tfielddump , fieldvars , & ltdump , lydump , lytdump , lxydump , lxytdump , lmintdump , & lkslicedump , kslice , lislicedump , islice , ljslicedump , jslice , ltkedump , tstatsdump , tsample , & tstatstart namelist / TREES / & ltrees , ntrees , cd , dec , ud , lad , Qstar , dQdt , lsize , r_s , ltreedump namelist / PURIFS / & lpurif , npurif , Qpu , epu namelist / HEATPUMP / & lheatpump , lfan_hp , nhppoints , Q_dot_hp , QH_dot_hp if ( myid == 0 ) then if ( command_argument_count () >= 1 ) then call get_command_argument ( 1 , fname_options ) end if !write (*, *) fname_options open ( ifnamopt , file = fname_options , status = 'old' , iostat = ierr ) if ( ierr /= 0 ) then write ( 0 , * ) 'ERROR: Namoptions does not exist' write ( 0 , * ) 'iostat error: ' , ierr stop 1 end if read ( ifnamopt , RUN , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions RUN' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif !write (6, RUN) rewind ( ifnamopt ) read ( ifnamopt , DOMAIN , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions DOMAIN' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif !write (6, DOMAIN) rewind ( ifnamopt ) read ( ifnamopt , PHYSICS , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions PHYSICS' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif !write (6, PHYSICS) rewind ( ifnamopt ) read ( ifnamopt , DYNAMICS , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions DYNAMICS' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif !write (6, DYNAMICS) rewind ( ifnamopt ) read ( ifnamopt , BC , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions BC' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif !write (6, BC) rewind ( ifnamopt ) read ( ifnamopt , INLET , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions INLET' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif !write (6, INLET) rewind ( ifnamopt ) read ( ifnamopt , DRIVER , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'Problem in namoptions DRIVER' write ( 0 , * ) 'iostat error: ' , ierr stop 'ERROR: Problem in namoptions DRIVER' endif !write (6, DRIVER) rewind ( ifnamopt ) read ( ifnamopt , WALLS , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions WALLS' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif !write (6, WALLS) rewind ( ifnamopt ) read ( ifnamopt , ENERGYBALANCE , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions EB' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif !write (6, ENERGYBALANCE) rewind ( ifnamopt ) read ( ifnamopt , SCALARS , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions SCALARS' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif !write (6, SCALARS) rewind ( ifnamopt ) read ( ifnamopt , CHEMISTRY , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions CHEMISTRY' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif !write (6, CHEMISTRY) rewind ( ifnamopt ) read ( ifnamopt , TREES , iostat = ierr ) if ( ierr > 0 ) then print * , 'ERROR: Problem in namoptions TREES' print * , 'iostat error: ' , ierr stop 1 endif !write (6, TREES) rewind ( ifnamopt ) read ( ifnamopt , PURIFS , iostat = ierr ) if ( ierr > 0 ) then print * , 'ERROR: Problem in namoptions PURIFS' print * , 'iostat error: ' , ierr stop 1 endif !write (6, PURIFS) rewind ( ifnamopt ) read ( ifnamopt , HEATPUMP , iostat = ierr ) if ( ierr > 0 ) then print * , 'ERROR: Problem in namoptions HEATPUMP' print * , 'iostat error: ' , ierr stop 1 endif !write (6, HEATPUMP) rewind ( ifnamopt ) read ( ifnamopt , OUTPUT , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions OUTPUT' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif !write (6, OUTPUT) close ( ifnamopt ) end if call MPI_BCAST ( itot , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( jtot , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( ktot , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( nprocx , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( nprocy , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCxm , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCym , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCzp , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) ! if (BCxm .eq. BCxm_periodic .and. nprocx > 1) then !   periodic_bc(1) = .true. ! else !   periodic_bc(1) = .false. ! end if ! ! if (BCym .eq. BCym_periodic .and. nprocy > 1) then !   periodic_bc(2) = .true. ! else !   periodic_bc(2) = .false. ! end if ! ! periodic_bc(3) = .false. ! call decomp_2d_init(itot,jtot,ktot,nprocx,nprocy,periodic_bc) ! !myid = nrank ! !write(cmyid,'(i3.3)') myid ! ! comm3d = DECOMP_2D_COMM_CART_Z ! !write(*,*) \"myid\", myid ! call MPI_CART_COORDS(comm3d,myid,2,myids,mpierr) ! !write(*,*) \"myids\", myids ! myidx = myids(1) ! myidy = myids(2) ! ! write(*,*) \"myid\", \" myids\", myid, myids' ! ! write(cmyidx,'(i3.3)') myidx ! write(cmyidy,'(i3.3)') myidy ! ! call MPI_CART_SHIFT(comm3d, 0,  1, nbrwest,  nbreast ,   mpierr) ! call MPI_CART_SHIFT(comm3d, 1,  1, nbrsouth, nbrnorth,   mpierr) !call init2decomp !write (*, *) \"starting broadcast\" call MPI_BCAST ( iexpnr , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( lwarmstart , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lstratstart , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lfielddump , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lreadscal , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch to read scalar pollutant fields (warm start) call MPI_BCAST ( lscasrc , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! tg3315 call MPI_BCAST ( lscasrcl , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! tg3315 call MPI_BCAST ( lscasrcr , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! tg3315 call MPI_BCAST ( lbuoyancy , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for buoyancy force in modforces call MPI_BCAST ( ltempeq , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for solving adv/diff equation for temperature call MPI_BCAST ( lper2inout , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for restart periodic flow to inoutflow call MPI_BCAST ( libm , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for turning on/off IBM method call MPI_BCAST ( lnudge , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lnudgevel , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( nnudge , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( tnudge , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( ltimedepsurf , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( ltimedepnudge , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( ltimedeplw , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( ltimedepsw , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( ntimedepsurf , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( ntimedepnudge , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( ntimedeplw , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( ntimedepsw , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( lwalldist , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for computing wall distances call MPI_BCAST ( lles , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for turning on/off LES functionality (subgrid model) call MPI_BCAST ( linletRA , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for turning on/off Running Average in inletgenerator call MPI_BCAST ( lfixinlet , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for keeping average inlet velocit and temp fixed at inlet (iinletgen=1,2) call MPI_BCAST ( lfixutauin , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for keeping utau fixed at inlet (iinletgen=1,2) !call MPI_BCAST(xS, 1, MY_REAL, 0, comm3d, mpierr) !call MPI_BCAST(yS, 1, MY_REAL, 0, comm3d, mpierr) !call MPI_BCAST(zS, 1, MY_REAL, 0, comm3d, mpierr) !call MPI_BCAST(SS, 1, MY_REAL, 0, comm3d, mpierr) !call MPI_BCAST(sigS, 1, MY_REAL, 0, comm3d, mpierr) call MPI_BCAST ( idriver , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) ! ae1212: Added switch for driver inlet simulation call MPI_BCAST ( tdriverstart , 1 , MY_REAL , 0 , comm3d , mpierr ) ! ae1212 call MPI_BCAST ( driverjobnr , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) ! ae1212 call MPI_BCAST ( dtdriver , 1 , MY_REAL , 0 , comm3d , mpierr ) ! ae1212 call MPI_BCAST ( driverstore , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( lchunkread , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( chunkread_size , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) !call MPI_BCAST(BCxm, 1, MPI_INTEGER, 0, comm3d, mpierr) call MPI_BCAST ( BCxT , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCxq , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCxs , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) !call MPI_BCAST(BCym, 1, MPI_INTEGER, 0, comm3d, mpierr) call MPI_BCAST ( BCyT , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCyq , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCys , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCtopm , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCtopT , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCtopq , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCtops , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCbotm , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCbotT , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCbotq , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCbots , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( ds , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lwallfunc , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for reading mean inlet/recycle plane profiles (Uinl,Urec,Wrec) call MPI_BCAST ( lreadminl , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for reading mean inlet/recycle plane profiles (Uinl,Urec,Wrec) call MPI_BCAST ( iwalltemp , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) ! case (integer) for wall treatment for temperature (1=no wall function/fixed flux, 2=no wall function/fixed value, 3=uno) call MPI_BCAST ( iwallmoist , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) ! case (integer) for wall treatment for moisture (1=no wall function/fixed flux, 2=no wall function/fixed value, 3=uno) call MPI_BCAST ( iwallscal , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( iwallmom , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) ! case (integer) for wall treatment for momentum (1=no wall function, 2=werner-wengle, 3=uno) call MPI_BCAST ( nsolpts_u , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( nsolpts_v , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( nsolpts_w , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( nsolpts_c , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( nbndpts_u , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( nbndpts_v , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( nbndpts_w , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( nbndpts_c , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( nfctsecs_u , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( nfctsecs_v , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( nfctsecs_w , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( nfctsecs_c , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( lbottom , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lnorec , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lwritefac , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( tfac , 1 , MY_REAL , 0 , comm3d , mpierr ) tnextfac = dtfac call MPI_BCAST ( tnextfac , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( luoutflowr , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for turning on/off u-velocity correction for fixed mass outflow rate call MPI_BCAST ( lvoutflowr , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! tg3315: added switch for turning on/off v-velocity correction for fixed mass outflow rate call MPI_BCAST ( luvolflowr , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! bss166: added switch for turning on/off u-velocity correction for fixed volume flow rate call MPI_BCAST ( lvvolflowr , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! bss116: added switch for turning on/off v-velocity correction for fixed volume flow rate call MPI_BCAST ( lstoreplane , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for turning on/off for storing i-plane data to serve as inlet for future sim. call MPI_BCAST ( lreadmean , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for reading mean variables from means#MYID#.#EXPNR# call MPI_BCAST ( lydump , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! tg3315 added switch for writing statistics files call MPI_BCAST ( lytdump , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! tg3315 added switch for writing statistics files call MPI_BCAST ( lxydump , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! tg3315 added switch for writing statistics files call MPI_BCAST ( lxytdump , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! tg3315 added switch for writing statistics files call MPI_BCAST ( lkslicedump , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lislicedump , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( ljslicedump , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( kslice , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( islice , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( jslice , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( ltdump , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! tg3315 added switch for writing statistics files call MPI_BCAST ( lmintdump , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! tg3315 added switch for writing statistics files call MPI_BCAST ( ltkedump , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! tg3315 added switch for writing tke budget files call MPI_BCAST ( iplane , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) ! J.Tomas: ib+iplane is the i-plane that is stored if lstoreplane is .true. call MPI_BCAST ( startfile , 50 , MPI_CHARACTER , 0 , comm3d , mpierr ) call MPI_BCAST ( author , 80 , MPI_CHARACTER , 0 , comm3d , mpierr ) call MPI_BCAST ( runtime , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( trestart , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( tfielddump , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( tsample , 1 , MY_REAL , 0 , comm3d , mpierr ) !tg3315 call MPI_BCAST ( tstatsdump , 1 , MY_REAL , 0 , comm3d , mpierr ) !tg3315 call MPI_BCAST ( tstatstart , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( tEB , 1 , MY_REAL , 0 , comm3d , mpierr ) tnextEB = dtEB call MPI_BCAST ( tnextEB , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( dtmax , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( nsv , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( nscasrc , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( nscasrcl , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( fieldvars , 50 , MPI_CHARACTER , 0 , comm3d , mpierr ) !call MPI_BCAST(nstat      ,1,MPI_INTEGER,0,comm3d,mpierr) !tg3315 !call MPI_BCAST(ncstat     ,80,MPI_CHARACTER,0,comm3d,mpierr) !tg3315 call MPI_BCAST ( ifixuinf , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( lvinf , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( dpdx , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( tscale , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( itot , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( jtot , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( ktot , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( xlen , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( ylen , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( xlat , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( xlon , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( xday , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( xtime , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( z0 , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( z0h , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( bctfxm , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( bctfxp , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( bctfym , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( bctfyp , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( bctfz , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( bcqfxm , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( bcqfxp , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( bcqfym , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( bcqfyp , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( bcqfz , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( wtsurf , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( wqsurf , 1 , MY_REAL , 0 , comm3d , mpierr ) allocate ( wsvsurf ( 1 : nsv )) wsvsurf = wsvsurfdum ( 1 : nsv ) call MPI_BCAST ( wsvsurf ( 1 : nsv ), nsv , MY_REAL , 0 , comm3d , mpierr ) allocate ( wsvtop ( 1 : nsv )) wsvtop = wsvtopdum ( 1 : nsv ) call MPI_BCAST ( wsvtop ( 1 : nsv ), nsv , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( ps , 1 , MY_REAL , 0 , comm3d , mpierr ) thvs = thls * ( 1. + ( rv / rd - 1. ) * qts ) call MPI_BCAST ( thvs , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( thls , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( thl_top , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( qt_top , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( qts , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lmoist , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lcoriol , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lprofforc , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lchem , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( k1 , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( JNO2 , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( igrw_damp , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( geodamptime , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( wttop , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( wqtop , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( thlsrc , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( uflowrate , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( vflowrate , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( Uinf , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( Vinf , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( di , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( dti , 1 , MY_REAL , 0 , comm3d , mpierr ) dr = di ! initial value is needed di_test = di ! initial value is needed call MPI_BCAST ( iangledeg , 1 , MY_REAL , 0 , comm3d , mpierr ) iangle = iangledeg * pi / 18 0. call MPI_BCAST ( inletav , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lqlnr , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( ksp , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( nblocks , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) ! no. of blocks used in IBM call MPI_BCAST ( nfcts , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( lconstW , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lEB , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lwriteEBfiles , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( wsoil , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( wgrmax , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( wwilt , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( wfc , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( dtEB , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( bldT , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( flrT , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lperiodicEBcorr , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( sinkbase , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( fraction , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( skyLW , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( GRLAI , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( rsmin , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( nfaclyrs , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( lfacTlyrs , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lvfsparse , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( nnz , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( irandom , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( krand , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( randthl , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( randu , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( randqt , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( ladaptive , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( courant , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( diffnr , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( ipoiss , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( iadv_mom , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( iadv_tke , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( iadv_thl , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( iadv_qt , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( iadv_sv ( 1 : nsv ), nsv , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( lrandomize , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( prandtlturb , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( fkar , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( ltrees , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( ntrees , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( ltreedump , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( Qstar , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( dQdt , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lsize , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lad , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( r_s , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( cd , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( dec , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( ud , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lpurif , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( npurif , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( Qpu , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( epu , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lheatpump , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lfan_hp , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( nhppoints , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( Q_dot_hp , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( QH_dot_hp , 1 , MY_REAL , 0 , comm3d , mpierr ) ! ! Allocate and initialize core modules ! call initglobal ! !write (*, *) \"done initglobal\" ! call initfields ! !write (*, *) \"done initfields\" ! call initboundary ! !write (*, *) \"done initboundary\" ! call initthermodynamics ! ! write (*, *) \"done initthermodynamics\" ! ! !!depreated!! ! ! ! call initsurface ! ! write (*, *) \"done initsurface\" ! call initsubgrid ! !write (*, *) \"done initsubgrid\" ! ! call initpois ! ! write (*, *) \"done initpois\" ! ! call initinlet ! added by J. Tomas: initialize inlet generator ! ! write (*, *) \"done initinlet\" ! call initdriver  ! added by ae1212: initialise driver inlet ! ! write(*,*) \"done initdriver\" ! call checkinitvalues ! !write (*, *) \"done checkinitvalues\" ! call initpois ! !write (*, *) \"done initpois\" ! ! write (6, *) 'Determine masking matrices' ! call createmasks ! determine walls/blocks ! ! write (6, *) 'Finished determining masking matrices' ! ! ! calculate fluid volume and outlet areas, needs masking matrices ! call calcfluidvolumes ! ! ! call readinitfiles ! !write (*, *) \"done readinitfiles\" ! ! write (*, *) \"done startup\" ! ! ! ! call createscals ! ! write (*, *) \"done create scals\" end subroutine readnamelists","tags":"","url":"proc/readnamelists.html"},{"title":"init2decomp – uDALES","text":"public  subroutine init2decomp() Uses decomp_2d modmpi modglobal proc~~init2decomp~~UsesGraph proc~init2decomp init2decomp decomp_2d decomp_2d proc~init2decomp->decomp_2d module~modglobal modglobal proc~init2decomp->module~modglobal module~modmpi modmpi proc~init2decomp->module~modmpi mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~init2decomp~~CallsGraph proc~init2decomp init2decomp decomp_2d_init decomp_2d_init proc~init2decomp->decomp_2d_init mpi_cart_coords mpi_cart_coords proc~init2decomp->mpi_cart_coords mpi_cart_shift mpi_cart_shift proc~init2decomp->mpi_cart_shift Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~init2decomp~~CalledByGraph proc~init2decomp init2decomp program~dalesurban DALESURBAN program~dalesurban->proc~init2decomp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine init2decomp use decomp_2d use modglobal , only : itot , jtot , ktot , BCxm , BCym , BCxm_periodic , Bcym_periodic use modmpi , only : comm3d , myid , myidx , myidy , cmyidx , cmyidy , nprocx , nprocy , & nbreast , nbrwest , nbrnorth , nbrsouth , mpierr implicit none logical , dimension ( 3 ) :: periodic_bc integer , dimension ( 2 ) :: myids if ( BCxm . eq . BCxm_periodic . and . nprocx > 1 ) then periodic_bc ( 1 ) = . true . else periodic_bc ( 1 ) = . false . end if if ( BCym . eq . BCym_periodic . and . nprocy > 1 ) then periodic_bc ( 2 ) = . true . else periodic_bc ( 2 ) = . false . end if periodic_bc ( 3 ) = . false . call decomp_2d_init ( itot , jtot , ktot , nprocx , nprocy , periodic_bc ) comm3d = DECOMP_2D_COMM_CART_Z call MPI_CART_COORDS ( comm3d , myid , 2 , myids , mpierr ) myidx = myids ( 1 ) myidy = myids ( 2 ) write ( cmyidx , '(i3.3)' ) myidx write ( cmyidy , '(i3.3)' ) myidy call MPI_CART_SHIFT ( comm3d , 0 , 1 , nbrwest , nbreast , mpierr ) call MPI_CART_SHIFT ( comm3d , 1 , 1 , nbrsouth , nbrnorth , mpierr ) end subroutine init2decomp","tags":"","url":"proc/init2decomp.html"},{"title":"checkinitvalues – uDALES","text":"public  subroutine checkinitvalues() Uses modglobal modmpi modsurfdata proc~~checkinitvalues~~UsesGraph proc~checkinitvalues checkinitvalues module~modglobal modglobal proc~checkinitvalues->module~modglobal module~modmpi modmpi proc~checkinitvalues->module~modmpi module~modsurfdata modsurfdata proc~checkinitvalues->module~modsurfdata mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~checkinitvalues~~CallsGraph proc~checkinitvalues checkinitvalues mpi_bcast mpi_bcast proc~checkinitvalues->mpi_bcast mpi_finalize mpi_finalize proc~checkinitvalues->mpi_finalize Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~checkinitvalues~~CalledByGraph proc~checkinitvalues checkinitvalues program~dalesurban DALESURBAN program~dalesurban->proc~checkinitvalues Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine checkinitvalues !-----------------------------------------------------------------| !                                                                 | !      Thijs Heus   TU Delft  9/2/2006                            | !                                                                 | !     purpose.                                                    | !     --------                                                    | !                                                                 | !      checks whether crucial parameters are set correctly        | !                                                                 | !     interface.                                                  | !     ----------                                                  | !                                                                 | !     *checkinitvalues* is called from *program*.                 | !                                                                 | !-----------------------------------------------------------------| use modsurfdata , only : wtsurf , wqsurf , qts , ps use modglobal , only : itot , ktot , jtot , ylen , xlen , ib , ie , dtmax , runtime , & startfile , lwarmstart , lstratstart , lmoist , nsv , & BCxm , BCxT , BCxq , BCxs , BCym , BCyT , BCyq , BCys , BCtopm , BCbotm , & BCbotm_wfneutral , BCtopm_pressure , & BCxm_periodic , BCxT_periodic , BCxq_periodic , & BCxm_profile , BCxT_profile , BCxq_profile , & BCxm_driver , BCxT_driver , BCxq_driver , BCxs_driver , & BCym_periodic , BCym_profile , BCyT_periodic , BCyT_profile , & BCyq_periodic , BCyq_profile , & iinletgen , linoutflow , ltempeq , iwalltemp , iwallmom ,& ipoiss , POISS_FFT2D , POISS_FFT3D , POISS_CYC ,& lydump , lytdump , luoutflowr , lvoutflowr ,& lhdriver , lqdriver , lsdriver use modmpi , only : myid , comm3d , mpierr , nprocx , nprocy use modglobal , only : idriver implicit none real :: d ( 1 : itot - 1 ) logical :: inequi if ( mod ( jtot , nprocy ) /= 0 ) then if ( myid == 0 ) then write ( 0 , * ) 'STOP ERROR IN NUMBER OF PROCESSORS' write ( 0 , * ) 'nprocy must divide jtot!!! ' write ( 0 , * ) 'nprocy and jtot are: ' , nprocy , jtot end if call MPI_FINALIZE ( mpierr ) stop 1 end if if ( ipoiss == POISS_FFT2D ) then if ( mod ( itot , nprocx ) /= 0 ) then if ( myid == 0 ) then write ( 0 , * ) 'STOP ERROR IN NUMBER OF PROCESSORS' write ( 0 , * ) 'nprocx must divide itot!!! ' write ( 0 , * ) 'nprocx and itot are: ' , nprocx , itot end if call MPI_FINALIZE ( mpierr ) stop 1 end if end if if ( mod ( ktot , nprocy ) /= 0 ) then ! Only when doing CR if ( myid == 0 ) then write ( 0 , * ) 'STOP ERROR IN NUMBER OF PROCESSORS' write ( 0 , * ) 'nprocs must divide ktot!!! ' write ( 0 , * ) 'nprocs and ktot are: ' , nprocy , ktot end if call MPI_FINALIZE ( mpierr ) stop 1 end if !Check Namoptions if ( runtime < 0 ) then write ( 0 , * ) 'ERROR: runtime out of range/not set' stop 1 end if if ( dtmax < 0 ) then write ( 0 , * ) 'ERROR: dtmax out of range/not set' stop 1 end if if ( ps < 0 ) then write ( 0 , * ) 'ERROR: psout of range/not set' stop 1 end if if ( xlen < 0 ) then write ( 0 , * ) 'ERROR: xlen out of range/not set' stop 1 end if if ( ylen < 0 ) then write ( 0 , * ) 'ERROR: ylen out of range/not set' stop 1 end if if (( lwarmstart ) . or . ( lstratstart )) then if ( startfile == '' ) then write ( 0 , * ) 'ERROR: no restartfile set' stop 1 end if end if ! Call neutral wall function when air temperature not evolved or if constant heat flux. if ((( ltempeq . eqv . . false .) . or . ( iwalltemp == 1 )) . and . ( iwallmom == 2 )) then if ( myid == 0 ) write ( * , * ) \"Changing to neutral wall function\" iwallmom = 3 BCbotm = BCbotm_wfneutral end if select case ( BCxm ) case ( BCxm_periodic ) !if (myid == 0) write(*,*) \"Periodic boundary conditions for velocity in x direction\" if ( ltempeq . and . ( BCxT . ne . BCxT_periodic ) . and . ( myid == 0 )) then write ( * , * ) \"Warning: temperature not periodic in x, consider setting BCxT = \" , BCxT_periodic end if if ( lmoist . and . ( BCxq . ne . BCxq_periodic ) . and . ( myid == 0 )) then write ( * , * ) \"Warning: moisture not periodic in x, consider setting BCxq = \" , BCxq_periodic end if case ( BCxm_profile ) linoutflow = . true . call MPI_BCAST ( linoutflow , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) !if (myid == 0) write(*, *) \"x inflow velocity given by profile\" if ( ltempeq . and . ( BCxT . ne . BCxT_profile ) . and . ( myid == 0 )) then write ( * , * ) \"Warning: x inflow temperature not given by profile, & &consider setting BCxT = \" , BCxT_profile end if if ( lmoist . and . ( BCxq . ne . BCxq_profile ) . and . ( myid == 0 )) then write ( * , * ) \"Warning: x inflow moisture not given by profile, & &consider setting BCxq = \" , BCxq_profile end if if ( BCtopm . ne . BCtopm_pressure ) then if ( myid == 0 ) write ( * , * ) \"inflow-outflow: allowing vertical velocity at top, setting BCtopm = 3\" BCtopm = BCtopm_pressure end if case ( BCxm_driver ) linoutflow = . true . idriver = 2 call MPI_BCAST ( linoutflow , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( idriver , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) !if (myid == 0) write (*, *) \"x inflow velocity given by file from precursor simulation\" if ( ltempeq ) then if ( BCxT == BCxT_driver ) then lhdriver = . true . else lhdriver = . false . if ( myid == 0 ) write ( * , * ) \"Warning: x inflow temperature not given by precursor.\" end if end if if ( lmoist ) then if ( BCxq == BCxq_driver ) then lqdriver = . true . else lqdriver = . false . if ( myid == 0 ) write ( * , * ) \"Warning: x inflow humidity not given by precursor.\" end if end if if ( nsv > 0 ) then if ( BCxs == BCxs_driver ) then lsdriver = . true . else lsdriver = . false . if ( myid == 0 ) write ( * , * ) \"Warning: x inflow scalars not given by precursor.\" end if end if if ( BCtopm . ne . BCtopm_pressure ) then if ( myid == 0 ) write ( * , * ) \"inflow-outflow: allowing vertical velocity at top, setting BCtopm = 3\" BCtopm = BCtopm_pressure end if end select select case ( BCym ) case ( BCym_periodic ) !if (myid == 0) write(*,*) \"Periodic boundary conditions for velocity in y direction\" if ( ltempeq . and . ( BCyT . ne . BCyT_periodic ) . and . ( myid == 0 )) then write ( * , * ) \"Warning: temperature not periodic in y, consider setting BCxT = \" , BCxT_periodic end if if ( lmoist . and . ( BCyq . ne . BCyq_periodic ) . and . ( myid == 0 )) then write ( * , * ) \"Warning: moisture not periodic in y, consider setting BCxq = \" , BCxq_periodic end if case ( BCym_profile ) linoutflow = . true . call MPI_BCAST ( linoutflow , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) !if (myid == 0) write(*, *) \"y inflow velocity given by profile\" if ( ltempeq . and . ( BCyT . ne . BCyT_profile ) . and . ( myid == 0 )) then write ( * , * ) \"Warning: y inflow temperature not given by profile, & &consider setting BCyT = \" , BCyT_profile end if if ( lmoist . and . ( BCyq . ne . BCyq_profile ) . and . ( myid == 0 )) then write ( * , * ) \"Warning: y inflow moisture not given by profile, & &consider setting BCyq = \" , BCyq_profile end if if ( BCtopm . ne . BCtopm_pressure . and . ( myid == 0 )) then write ( * , * ) \"Warning: allowing vertical velocity at top might be necessary, & &consider setting BCtopm = \" , BCtopm_pressure end if end select if (( lydump . or . lytdump ) . and . ( nprocx > 1 )) then write ( * , * ) \"Error: y-averaged statistics not currently implemented for nprocx > 1.\" stop 1 end if if (( luoutflowr ) . and . ( nprocx > 1 )) then write ( * , * ) \"Error: constant x outflow only possible for nprocx = 1.\" stop 1 end if if (( lvoutflowr ) . and . ( nprocy > 1 )) then write ( * , * ) \"Error: constant y outflow only possible for nprocy = 1.\" stop 1 end if end subroutine checkinitvalues","tags":"","url":"proc/checkinitvalues.html"},{"title":"readinitfiles – uDALES","text":"public  subroutine readinitfiles() Uses modmpi modsubgriddata modsurfdata modboundary modfields moddriver decomp_2d modthermodynamics modinletdata modinlet modglobal proc~~readinitfiles~~UsesGraph proc~readinitfiles readinitfiles decomp_2d decomp_2d proc~readinitfiles->decomp_2d module~modboundary modboundary proc~readinitfiles->module~modboundary module~moddriver moddriver proc~readinitfiles->module~moddriver module~modfields modfields proc~readinitfiles->module~modfields module~modglobal modglobal proc~readinitfiles->module~modglobal module~modinlet modinlet proc~readinitfiles->module~modinlet module~modinletdata modinletdata proc~readinitfiles->module~modinletdata module~modmpi modmpi proc~readinitfiles->module~modmpi module~modsubgriddata modsubgriddata proc~readinitfiles->module~modsubgriddata module~modsurfdata modsurfdata proc~readinitfiles->module~modsurfdata module~modthermodynamics modthermodynamics proc~readinitfiles->module~modthermodynamics mpi mpi module~modboundary->mpi module~moddriver->module~modinletdata module~modfields->decomp_2d module~modinlet->module~modinletdata module~modinlet->mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~readinitfiles~~CallsGraph proc~readinitfiles readinitfiles mpi_bcast mpi_bcast proc~readinitfiles->mpi_bcast proc~avexy_ibm avexy_ibm proc~readinitfiles->proc~avexy_ibm proc~calc_halflev calc_halflev proc~readinitfiles->proc~calc_halflev proc~drivergen drivergen proc~readinitfiles->proc~drivergen proc~halos halos proc~readinitfiles->proc~halos proc~randomnize randomnize proc~readinitfiles->proc~randomnize proc~readdriverfile readdriverfile proc~readinitfiles->proc~readdriverfile proc~readdriverfile_chunk readdriverfile_chunk proc~readinitfiles->proc~readdriverfile_chunk proc~readinletfile readinletfile proc~readinitfiles->proc~readinletfile proc~readrestartfiles readrestartfiles proc~readinitfiles->proc~readrestartfiles proc~slabsum slabsum proc~readinitfiles->proc~slabsum proc~thermodynamics thermodynamics proc~readinitfiles->proc~thermodynamics mpi_allreduce mpi_allreduce proc~avexy_ibm->mpi_allreduce proc~writedriverfile writedriverfile proc~drivergen->proc~writedriverfile exchange_halo_z exchange_halo_z proc~halos->exchange_halo_z proc~xm_periodic xm_periodic proc~halos->proc~xm_periodic proc~xq_periodic xq_periodic proc~halos->proc~xq_periodic proc~xs_periodic xs_periodic proc~halos->proc~xs_periodic proc~xt_periodic xT_periodic proc~halos->proc~xt_periodic proc~ym_periodic ym_periodic proc~halos->proc~ym_periodic proc~yq_periodic yq_periodic proc~halos->proc~yq_periodic proc~ys_periodic ys_periodic proc~halos->proc~ys_periodic proc~yt_periodic yT_periodic proc~halos->proc~yt_periodic proc~excjs excjs proc~readinletfile->proc~excjs proc~yinterpolate yinterpolate proc~readinletfile->proc~yinterpolate proc~zinterpolate zinterpolate proc~readinletfile->proc~zinterpolate proc~zinterpolatet zinterpolatet proc~readinletfile->proc~zinterpolatet proc~zinterpolatew zinterpolatew proc~readinletfile->proc~zinterpolatew proc~zinterpolate1d zinterpolate1d proc~readrestartfiles->proc~zinterpolate1d proc~zinterpolate2d zinterpolate2d proc~readrestartfiles->proc~zinterpolate2d proc~zinterpolatet1d zinterpolatet1d proc~readrestartfiles->proc~zinterpolatet1d proc~zinterpolatew1d zinterpolatew1d proc~readrestartfiles->proc~zinterpolatew1d proc~slabsum->mpi_allreduce proc~thermodynamics->proc~avexy_ibm proc~thermodynamics->proc~calc_halflev proc~calthv calthv proc~thermodynamics->proc~calthv proc~diagfld diagfld proc~thermodynamics->proc~diagfld proc~thermo thermo proc~thermodynamics->proc~thermo proc~diagfld->proc~avexy_ibm proc~fromztop fromztop proc~diagfld->proc~fromztop mpi_isend mpi_isend proc~excjs->mpi_isend mpi_recv mpi_recv proc~excjs->mpi_recv mpi_wait mpi_wait proc~excjs->mpi_wait Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~readinitfiles~~CalledByGraph proc~readinitfiles readinitfiles program~dalesurban DALESURBAN program~dalesurban->proc~readinitfiles Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine readinitfiles use modfields , only : u0 , v0 , w0 , um , vm , wm , thlm , thl0 , thl0h , qtm , qt0 , qt0h , uinit , vinit , & ql0 , ql0h , thv0h , sv0 , svm , e12m , e120 , & dudxls , dudyls , dvdxls , dvdyls , dthldxls , dthldyls , & dqtdxls , dqtdyls , dqtdtls , dpdx , dpdxl , dpdyl , & wfls , whls , ug , vg , pgx , pgy , uprof , vprof , thlprof , qtprof , e12prof , svprof , & v0av , u0av , qt0av , ql0av , thl0av , qt0av , sv0av , exnf , exnh , presf , presh , rhof , & thlpcar , uav , thvh , thvf , IIc , IIcs , IIu , IIus , IIv , IIvs , IIw , IIws , u0h , thl0c use modglobal , only : ib , ie , ih , ihc , jb , je , jh , jhc , kb , ke , kh , khc , kmax , dtmax , dt , runtime , timeleft , timee , ntimee , ntrun , btime , dt_lim , nsv ,& zf , zh , dzf , dzh , rv , rd , grav , cp , rlv , pref0 , om23_gs , jgb , jge , Uinf , Vinf , dy , & rslabs , e12min , dzh , dtheta , dqt , dsv , cexpnr , ifinput , lwarmstart , lstratstart , trestart , numol , & ladaptive , tnextrestart , jmax , imax , xh , xf , linoutflow , lper2inout , iinletgen , lreadminl , & uflowrate , vflowrate , ltempeq , prandtlmoli , freestreamav , & tnextfielddump , tfielddump , tsample , tstatsdump , startfile , lprofforc , lchem , k1 , JNO2 ,& idriver , dtdriver , driverstore , tdriverstart , tdriverstart_cold , tdriverdump , lchunkread , xlen , ylen , itot , jtot , ibrank , ierank , jbrank , jerank , BCxm , BCym , lrandomize , BCxq , BCxs , BCxT , BCyq , BCys , BCyT , BCxm_driver ,& tEB , tnextEB , dtEB , BCxs_custom , lEB , lfacTlyrs , tfac , tnextfac , dtfac use modsubgriddata , only : ekm , ekh , loneeqn use modsurfdata , only : wtsurf , wqsurf , wsvsurf , & thls , thvs , ps , qts , svs , sv_top ! use modsurface,        only : surface,dthldz use modboundary , only : boundary , tqaver , halos use modmpi , only : slabsum , myid , comm3d , mpierr , my_real , avexy_ibm , myidx , myidy use modthermodynamics , only : thermodynamics , calc_halflev use modinletdata , only : Uinl , Urec , Wrec , u0inletbc , v0inletbc , w0inletbc , ubulk , vbulk , irecy , Utav , Ttav , & uminletbc , vminletbc , wminletbc , u0inletbcold , v0inletbcold , w0inletbcold , & storeu0inletbc , storev0inletbc , storew0inletbc , nstepread , nfile , Tinl , & Trec , tminletbc , t0inletbcold , t0inletbc , storet0inletbc , utaui , ttaui , iangle ,& u0driver , umdriver , v0driver , vmdriver , w0driver , e120driver , tdriver , thl0driver , qt0driver , storetdriver ,& storeu0driver , storeumdriver , storev0driver , storew0driver , storee120driver , storethl0driver , storeqt0driver ,& nstepreaddriver use modinlet , only : readinletfile use moddriver , only : readdriverfile , initdriver , drivergen , readdriverfile_chunk use decomp_2d , only : exchange_halo_z , update_halo , decomp_main integer i , j , k , n real , allocatable :: height (:), th0av (:) real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ) :: thv0 real , dimension ( kb : ke ) :: uaverage ! volume averaged u-velocity real , dimension ( kb : ke ) :: vaverage ! volume averaged v-velocity real , dimension ( kb : ke ) :: uaverager ! recycle plane real , dimension ( kb : ke ) :: uaveragei ! inlet plane real , dimension ( kb : ke ) :: taverager ! recycle plane real , dimension ( kb : ke ) :: taveragei ! inlet plane real , dimension ( kb : ke + 1 ) :: waverage real , dimension ( kb : ke + 1 ) :: uprofrot real , dimension ( kb : ke + 1 ) :: vprofrot real , dimension ( kb : ke + kh ) :: u_init , v_init , thl_init , qt_init real tv , ran , ran1 character ( 80 ) chmess allocate ( height ( kb : ke + kh )) allocate ( th0av ( kb : ke + kh )) if ( lstratstart ) then ! Switch ! Read restart files as in lwarmstart call readrestartfiles um = u0 vm = v0 wm = w0 thlm = thl0 !do this before or just not? qtm = qt0 svm = sv0 e12m = e120 ! Overwrite thlm, thl0, qtm, qt0 from prof.inp.xxx if ( myid == 0 ) then open ( ifinput , file = 'prof.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess !write (*, '(a80)') chmess read ( ifinput , '(a80)' ) chmess do k = kb , ke read ( ifinput , * ) & height ( k ), & thlprof ( k ), & qtprof ( k ), & uprof ( k ), & vprof ( k ), & e12prof ( k ) end do close ( ifinput ) ! write (*, *) 'height    thl     qt      u      v     e12' ! do k = ke, kb, -1 !    write (*, '(f7.1,2f8.1,3f7.1)') & !       height(k), & !       thlprof(k), & !       qtprof(k), & !       uprof(k), & !       vprof(k), & !       e12prof(k) ! ! end do end if !myid=0 ! MPI broadcast thl and qt call MPI_BCAST ( thlprof , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( qtprof , kmax , MY_REAL , 0 , comm3d , mpierr ) do k = kb , ke do j = jb - 1 , je + 1 do i = ib - 1 , ie + 1 thl0 ( i , j , k ) = thlprof ( k ) thlm ( i , j , k ) = thlprof ( k ) qt0 ( i , j , k ) = qtprof ( k ) qtm ( i , j , k ) = qtprof ( k ) end do end do end do !ILS13 reintroduced thv !tg3315 this part may wrong, could need to use call calc_halflev ! exnf = (presf/pref0)**(rd/cp)  !exner functions not in restart files ! anymore.. or at least not read ! exnh = (presh/pref0)**(rd/cp) !   write(*,*) \"exnf\",enf !   write(*,*) \"exnh\",exnh do k = kb , ke + kh do j = jb , je do i = ib , ie !write(*,*) \"thl0h\",thl0h(i,j,k) thv0h ( i , j , k ) = ( thl0h ( i , j , k ) + rlv * ql0h ( i , j , k ) / ( cp )) & * ( 1 + ( rv / rd - 1 ) * qt0h ( i , j , k ) - rv / rd * ql0h ( i , j , k )) end do end do end do do j = j , je do i = ib , ie do k = kb , ke + kh thv0 ( i , j , k ) = ( thl0 ( i , j , k ) + rlv * ql0 ( i , j , k ) / ( cp )) & * ( 1 + ( rv / rd - 1 ) * qt0 ( i , j , k ) - rv / rd * ql0 ( i , j , k )) end do end do end do thvh = 0. ! call slabsum(thvh,kb,ke,thv0h,ib-ih,ie+ih,jb-jh,je+jh,kb-kh,ke+kh,ib,ie,jb,je,kb,ke) ! redefine halflevel thv using calculated thv call avexy_ibm ( thvh ( kb : ke + kh ), thv0h ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIw ( ib : ie , jb : je , kb : ke + kh ), IIws ( kb : ke + kh ),. false .) ! thvh = thvh/rslabs thvf = 0.0 call avexy_ibm ( thvf ( kb : ke + kh ), thv0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) ! call slabsum(thvf,kb,ke,thv0,ib-ih,ie+ih,jb-jh,je+jh,kb-kh,ke+kh,ib,ie,jb,je,kb,ke) ! thvf = thvf/rslabs else !if not lstratstart if (. not . lwarmstart ) then !******************************************************************** !    1.0 prepare initial fields from files 'prof.inp' and 'scalar.inp' !    ---------------------------------------------------------------- !-------------------------------------------------------------------- !    1.1 read fields !----------------------------------------------------------------- dt = dtmax / 10 0. timee = 0. if ( myid == 0 ) then open ( ifinput , file = 'prof.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess !write (*, '(a80)') chmess read ( ifinput , '(a80)' ) chmess do k = kb , ke read ( ifinput , * ) & height ( k ), & thlprof ( k ), & qtprof ( k ), & uprof ( k ), & vprof ( k ), & e12prof ( k ) end do ! Apply rotation in horizontal !write (6, *) 'iangle = ', iangle !uprofrot = uprof*cos(iangle) - vprof*sin(iangle) !vprofrot = vprof*cos(iangle) + uprof*sin(iangle) !uprof = uprofrot !vprof = vprofrot close ( ifinput ) ! write (*, *) 'height    thl     qt      u      v     e12' ! do k = ke, kb, -1 !    !write (*, '(f7.1,2f8.1,3f7.1)') & !    write (*, *) & !       height(k), & !       thlprof(k), & !       qtprof(k), & !       uprof(k), & !       vprof(k), & !       e12prof(k) ! ! end do if ( loneeqn ) then if ( minval ( e12prof ( kb : ke )) < e12min ) then write ( * , * ) 'e12 value is zero (or less) in prof.inp' do k = kb , ke e12prof ( k ) = max ( e12prof ( k ), e12min ) end do end if end if end if ! end if myid==0 ! MPI broadcast numbers reading call MPI_BCAST ( thlprof , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( qtprof , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( uprof , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( vprof , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( e12prof , kmax , MY_REAL , 0 , comm3d , mpierr ) do k = kb , ke do j = jb - 1 , je + 1 do i = ib - 1 , ie + 1 thl0 ( i , j , k ) = thlprof ( k ) thlm ( i , j , k ) = thlprof ( k ) qt0 ( i , j , k ) = qtprof ( k ) qtm ( i , j , k ) = qtprof ( k ) u0 ( i , j , k ) = uprof ( k ) um ( i , j , k ) = uprof ( k ) v0 ( i , j , k ) = vprof ( k ) vm ( i , j , k ) = vprof ( k ) w0 ( i , j , k ) = 0.0 wm ( i , j , k ) = 0.0 e120 ( i , j , k ) = e12prof ( k ) e12m ( i , j , k ) = e12prof ( k ) !        ekm (i,j,k) = 0.0 !        ekh (i,j,k) = 0.0 ekm ( i , j , k ) = numol ekh ( i , j , k ) = numol end do end do end do do k = kb , ke do j = jb - jhc , je + jhc do i = ib - ihc , ie + ihc thl0c ( i , j , k ) = thlprof ( k ) end do end do end do ! if (ibrank) then ! do j=jb-1,je+1 !   um(ib,j,kb:ke) = uprof !   um(ib-1,j,kb:ke) = uprof ! end do ! end if ! ! if (ierank) then ! do j=jb-1,je+1 !   !um(ie,j,kb:ke) = uprof !   um(ie+1,j,kb:ke) = uprof ! end do ! end if ekh (:, :, ke + 1 ) = ekh (:, :, ke ) ! also for start up ! ILS13 30.11.17, added, not sure if necessary ! ILS13 30.11.1, commented do j = jb - jh , je + jh do i = ib - ih , ie + ih thl0 ( i , j , ke + 1 ) = thl0 ( i , j , ke ) thl0 ( i , j , kb - 1 ) = thl0 ( i , j , kb ) end do end do if ( lrandomize ) then !! add random fluctuations krand = min ( krand , ke ) do k = kb , krand call randomnize ( um , k , randu , irandom , ih , jh ) end do do k = kb , krand call randomnize ( vm , k , randu , irandom , ih , jh ) end do do k = kb , krand call randomnize ( wm , k , randu , irandom , ih , jh ) end do end if !       do k=kb+1,ke-1 !       do j=jb,je !       do i=ib+1,ie-1 !         call random_number(ran) !         ran1 = -1. +2.*ran !         wm(i,j,k)=wm(i,j,k)+ 0.1*Uinf*ran1 !       end do !       end do !       end do ! !       do k=kb+1,ke-1 !       do j=jb,je !       do i=ib+2,ie-1 !         call random_number(ran) !         ran1 = -1. +2.*ran !         um(i,j,k)=um(i,j,k)+ 0.1*Uinf*ran1 !       end do !       end do !       end do ! !       do k=kb+1,ke-1 !       do j=jb,je !       do i=ib+1,ie-1 !         call random_number(ran) !         ran1 = -1. +2.*ran !         vm(i,j,k)=vm(i,j,k)+ 0.1*Uinf*ran1 !       end do !       end do !       end do ! SO: Manually override fields ! if (((BCxm == 1) .and. (BCym == 1)) .or. ((BCxm == 6) .and. (BCym == 6))) then !   ! TGV (assumes equidistant x grid) !   do i = ib-1,ie+1 !     do j = jb-1,je+1 !       do k = kb-1,ke+1 !         um(i,j,k) = 1. * sin(4.*atan(1.) * 2. * (dx*((i-1)+myidx*imax)) / ylen) & !         * cos(4.*atan(1.) * 2. * (dy*((0.5+(j-1))+myidy*jmax)) / ylen) !& !         !* cos(4.*atan(1.) * 2. * zf(k) / ylen) !         vm(i,j,k) = 1. *-cos(4.*atan(1.) * 2. * (dx*((0.5+(i-1))+myidx*imax)) / ylen)  & !         * sin(4.*atan(1.) * 2. * (dy*((j-1)+myidy*jmax)) / ylen) !& !         !* cos(4.*atan(1.) * 2. * zf(k) / ylen) !         wm(i,j,k) = 0. !       end do !     end do !   end do ! end if ! ! For shear case ! um(:,:,ke+1) = um(:,:,ke) ! um(ib-1,:,:) = um(ib,:,:) ! um(ie-1,:,:) = um(ie,:,:) ! um(:,jb-1,:) = um(:,jb,:) ! um(:,je+1,:) = um(:,je,:) u0 = um v0 = vm w0 = wm call halos uinit = um vinit = vm ! ! zeros ! do i = ib,ie !   do j = jb,je !     do k = kb,ke !       um(i,j,k) = 0. !       u0(i,j,k) = um(i,j,k) !       uinit(i,j,k) = um(i,j,k) !       vm(i,j,k) = 0. !       v0(i,j,k) = vm(i,j,k) !       vinit(i,j,k) = vm(i,j,k) !       wm(i,j,k) = 0. !       w0(i,j,k) = 0. !     end do !   end do ! end do ! ! ones ! do i = ib,ie !   do j = jb,je !     do k = kb,ke !       um(i,j,k) = 1. !       u0(i,j,k) = um(i,j,k) !       uinit(i,j,k) = um(i,j,k) !       vm(i,j,k) = 1. !       v0(i,j,k) = vm(i,j,k) !       vinit(i,j,k) = vm(i,j,k) !       wm(i,j,k) = 0. !       w0(i,j,k) = 0. !     end do !   end do ! end do ! do i = ib,ie !   do j = jb,je !     do k = kb,ke !       um(i,j,k) = (i + myidx*imax) * (j + myidy*jmax) !       u0(i,j,k) = (i + myidx*imax) * (j + myidy*jmax) !       vm(i,j,k) = 0. !       v0(i,j,k) = 0. !       wm(i,j,k) = 0. !       w0(i,j,k) = 0. !     end do !   end do ! end do uaverage = 0. ! call slabsum(uaverage, kb, ke, um, ib - 1, ie + 1, jb - 1, je + 1, kb - 1, ke + 1, ib, ie, jb, je, kb, ke) do k = kb , ke uaverage ( k ) = uprof ( k ) * dzf ( k ) end do ubulk = sum ( uaverage ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) ! averaged u-velocity inflow profile !write (6, *) 'Modstartup: ubulk=', ubulk vaverage = 0. ! call slabsum(vaverage, kb, ke, vm, ib - 1, ie + 1, jb - 1, je + 1, kb - 1, ke + 1, ib, ie, jb, je, kb, ke) do k = kb , ke vaverage ( k ) = vprof ( k ) * dzf ( k ) end do vbulk = sum ( vaverage ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) ! averaged u-velocity inflow profile ! Set average inlet profile to initial inlet profile in case of inletgenerator mode if ( iinletgen == 1 ) then uaverage = 0. call slabsum ( uaverage , kb , ke , um , ib - 1 , ie + 1 , jb - 1 , je + 1 , kb - 1 , ke + 1 , ib , ie , jb , je , kb , ke ) do k = kb , ke uaverage ( k ) = uprof ( k ) * dzf ( k ) end do ubulk = sum ( uaverage ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) ! volume-averaged u-velocity write ( 6 , * ) 'Modstartup: ubulk=' , ubulk Utav ( ib : ie , kb : ke ) = um ( ib : ie , jb , kb : ke ) Uinl = um ( ib , jb , kb : ke ) ! set the initial time-averaged inlet profile equal to um Urec = um ( ib , jb , kb : ke ) ! set the initial time-averaged inlet profile equal to um Wrec ( kb : ke + 1 ) = wm ( ib , jb , kb : ke + 1 ) ! set the initial time-averaged inlet profile equal to mean w-profile u0inletbcold ( jb : je , kb : ke ) = um ( ib , jb : je , kb : ke ) v0inletbcold ( jb : je , kb : ke ) = vm ( ib - 1 , jb : je , kb : ke ) w0inletbcold ( jb : je , kb : ke + 1 ) = wm ( ib - 1 , jb : je , kb : ke + 1 ) uminletbc ( jb : je , kb : ke ) = um ( ib , jb : je , kb : ke ) vminletbc ( jb : je , kb : ke ) = vm ( ib - 1 , jb : je , kb : ke ) wminletbc ( jb : je , kb : ke ) = wm ( ib - 1 , jb : je , kb : ke ) u0inletbc ( jb : je , kb : ke ) = um ( ib , jb : je , kb : ke ) v0inletbc ( jb : je , kb : ke ) = vm ( ib - 1 , jb : je , kb : ke ) w0inletbc ( jb : je , kb : ke + 1 ) = wm ( ib - 1 , jb : je , kb : ke + 1 ) utaui = sqrt ( abs ( 2 * numol * Uinl ( kb ) / dzf ( kb ))) ! average streamwise friction at inlet (need for first time step) if ( ltempeq ) then Ttav ( ib : ie , kb : ke ) = thlm ( ib : ie , jb , kb : ke ) ! set the initial time-averaged inlet profile equal to thlm Tinl = thlm ( ib , jb , kb : ke ) ! set the initial time-averaged inlet profile equal to thlm Trec = thlm ( ib , jb , kb : ke ) ! set the initial time-averaged inlet profile equal to thlm t0inletbcold ( jb : je , kb : ke ) = thlm ( ib - 1 , jb : je , kb : ke ) t0inletbc ( jb : je , kb : ke ) = thl0 ( ib - 1 , jb : je , kb : ke ) tminletbc ( jb : je , kb : ke ) = thlm ( ib - 1 , jb : je , kb : ke ) ttaui = numol * prandtlmoli * 2. * ( Tinl ( kb ) - thls ) / ( dzf ( kb ) * utaui ) ! average friction temp. at inlet (need for first time step) end if ! add random perturbations if ( myid == 0 ) then call random_number ( ran ) ran1 = - 1. + 2. * ran write ( 6 , * ) 'random=' , ran , ran1 call random_number ( ran ) ran1 = - 1. + 2. * ran write ( 6 , * ) 'random=' , ran , ran1 call random_number ( ran ) ran1 = - 1. + 2. * ran write ( 6 , * ) 'random=' , ran , ran1 call random_number ( ran ) ran1 = - 1. + 2. * ran write ( 6 , * ) 'random=' , ran , ran1 call random_number ( ran ) ran1 = - 1. + 2. * ran write ( 6 , * ) 'random=' , ran , ran1 call random_number ( ran ) ran1 = - 1. + 2. * ran write ( 6 , * ) 'random=' , ran , ran1 end if do k = kb + 1 , kb + 48 do j = jb , je do i = ib + 1 , ie - 1 call random_number ( ran ) ran1 = - 1. + 2. * ran wm ( i , j , k ) = wm ( i , j , k ) + 0.1 * Uinf * ran1 end do end do end do !       do k=kb+1,ke-1 do k = kb + 1 , kb + 48 do j = jb , je do i = ib + 2 , ie - 1 call random_number ( ran ) ran1 = - 1. + 2. * ran um ( i , j , k ) = um ( i , j , k ) + 0.1 * Uinf * ran1 end do end do end do !       do k=kb+1,ke-1 do k = kb + 1 , kb + 48 do j = jb , je do i = ib + 1 , ie - 1 call random_number ( ran ) ran1 = - 1. + 2. * ran vm ( i , j , k ) = vm ( i , j , k ) + 0.1 * Uinf * ran1 end do end do end do u0 = um v0 = vm w0 = wm else if ( iinletgen == 2 ) then nfile = nfile + 1 call readinletfile u0inletbc (:, :) = storeu0inletbc (:, :, nstepread ) v0inletbc (:, :) = storev0inletbc (:, :, nstepread ) w0inletbc (:, :) = storew0inletbc (:, :, nstepread ) uminletbc (:, :) = storeu0inletbc (:, :, nstepread ) vminletbc (:, :) = storev0inletbc (:, :, nstepread ) wminletbc (:, :) = storew0inletbc (:, :, nstepread ) ! determine bulk velocity call slabsum ( uaverage , kb , ke , u0 , ib - 1 , ie + 1 , jb - 1 , je + 1 , kb - 1 , ke + 1 , ib , ie , jb , je , kb , ke ) uaverage = uaverage / (( ie - ib + 1 ) * ( jge - jgb + 1 )) ! this gives the i-j-averaged velocity (only correct for equidistant grid?) do k = kb , ke uaverage ( k ) = uaverage ( k ) * dzf ( k ) end do ubulk = sum ( uaverage ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) ! volume-averaged u-velocity write ( 6 , * ) 'Modstartup: ubulk=' , ubulk elseif ( idriver == 2 ) then ! idriver if ( ibrank ) then if ( lchunkread ) then call readdriverfile_chunk else call readdriverfile end if call drivergen end if ! do k = kb, ke !    do j = jb-1, je+1 !       do i = ib-1, ie+1 !          u0(i, j, k) = u0driver(j, k) !          um(i, j, k) = umdriver(j, k) !          v0(i, j, k) = v0driver(j, k) !          vm(i, j, k) = vmdriver(j, k) !       end do !    end do ! end do ! if(myid==0) then ! write(*,*) 'Driver inlet velocity' ! do n=1,driverstore ! write (*,'(f9.2,e20.12)') storetdriver(n),     storeu0driver(1,32,n) ! end do ! endif ! call slabsum(uaverage,kb,ke,u0,ib-1,ie+1,jb-1,je+1,kb-1,ke+1,ib,ie,jb,je,kb,ke) ! uaverage = uaverage / ((ie-ib+1)*(jge-jgb+1))  ! this gives the i-j-averaged velocity (only correct for equidistant grid?) ! call avexy_ibm(uaverage(kb:ke),u0(ib:ie,jb:je,kb:ke),ib,ie,jb,je,kb,ke,ih,jh,kh,IIu(ib:ie,jb:je,kb:ke),IIus(kb:ke),.false.) ! do k=kb,ke !   uaverage(k) = uaverage(k)*dzf(k) ! end do ubulk = sum ( uaverage ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) !volume-averaged u-velocity ! if (myid==0) then !    write(6,*) 'Modstartup: ubulk=',ubulk ! end if elseif ( idriver == 1 ) then if ( runtime < tdriverstart ) then if ( myid == 0 ) write ( * , * ) 'Warning! No driver files will be written as runtime < tdriverstart.' else if ( trestart /= ( tdriverstart + ( driverstore - 1 ) * dtdriver )) then trestart = ( tdriverstart + ( driverstore - 1 ) * dtdriver ) end if if ( myid == 0 ) then write ( * , '(A,F15.5)' ) 'Warning! for driver simulation, trestart gets set as & (tdriverstart + (driverstore-1)*dtdriver), ignoring the & trestart mentioned in namoptions. Hence, trestart = ' ,( tdriverstart + ( driverstore - 1 ) * dtdriver ) if ( runtime >= tdriverstart . and . runtime + 1e-10 < ( tdriverstart + ( driverstore - 1 ) * dtdriver )) then write ( * , * ) 'Warning! Driver files cannot be written upto ' , driverstore , ' steps. & &Consider taking runtime >= (tdriverstart + (driverstore-1)*dtdriver).' end if end if end if call drivergen end if !--------------------------------------------------------------- !  1.2 randomnize fields !--------------------------------------------------------------- !     if (iinletgen /= 2 .and. iinletgen /= 1) then !       write(6,*) 'randomnizing temperature!' !       krand  = min(krand,ke) !        do k = kb,ke !edited tg3315 krand --> ke !          call randomnize(thlm,k,randthl,irandom,ih,jh) !          call randomnize(thl0,k,randthl,irandom,ih,jh) !        end do !       end if svprof = 0. if ( myid == 0 ) then if ( nsv > 0 ) then open ( ifinput , file = 'scalar.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess read ( ifinput , '(a80)' ) chmess do k = kb , ke read ( ifinput , * ) & height ( k ), & ( svprof ( k , n ), n = 1 , nsv ) end do ! open (ifinput, file='scalar.inp.'//cexpnr) ! write (6, *) 'height   sv(1) --------- sv(nsv) ' ! do k = ke, kb, -1 !    write (6, *) & !       height(k), & !       (svprof(k, n), n=1, nsv) ! end do end if end if ! end if myid==0 call MPI_BCAST ( svprof , ( ke + kh - ( kb - kh )) * nsv , MY_REAL , 0 , comm3d , mpierr ) if ( BCxs /= BCxs_custom ) then do k = kb , ke do j = jb - 1 , je + 1 do i = ib - 1 , ie + 1 do n = 1 , nsv sv0 ( i , j , k , n ) = svprof ( k , n ) svm ( i , j , k , n ) = svprof ( k , n ) end do end do end do end do end if if ( nsv > 0 ) then !tg3315 set these variables here for now and repeat for warmstart allocate ( sv_top ( 1 : nsv )) sv_top (:) = svprof ( ke , 1 : nsv ) call MPI_BCAST ( sv_top , nsv , MY_REAL , 0 , comm3d , mpierr ) !write(*,*) 'svprof', svprof !write(*,*) 'sv_top', sv_top end if !do n = 1,nsv !  do j = jb - jhc, je + jhc !    do i = ib - ihc, ie + ihc !      svm(i, j, ke + 1, n) = svm(i, j, ke) !      sv0(i, j, kb - 1, n) = sv0(i, j, kb) !    end do !  end do !end do !----------------------------------------------------------------- !    2.2 Initialize surface layer !----------------------------------------------------------------- !ILS13 reintroduced thv !tg3315 this part may wrong, could need to use call calc_halflev ! exnf = (presf/pref0)**(rd/cp)  !exner functions not in restart files ! anymore.. or at least not read ! exnh = (presh/pref0)**(rd/cp) ! ! call boundary ! tg3315 17.10.17 having this in startup was causing issues for running with lmoist ! turned of when pot. temp = temp. ! SO: can't do this yet because uses u0 and it does not include halo cells call thermodynamics ! turned off when pot. temp = temp. ! !    call boundary !    call thermodynamics ! turned off when pot. temp = temp. else !if lwarmstart !write (*, *) \"doing warmstart\" call readrestartfiles ! average initial profiles call avexy_ibm ( u_init ( kb : ke + kh ), u0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIu ( ib : ie , jb : je , kb : ke + kh ), IIus ( kb : ke + kh ),. false .) call avexy_ibm ( v_init ( kb : ke + kh ), v0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIv ( ib : ie , jb : je , kb : ke + kh ), IIvs ( kb : ke + kh ),. false .) call avexy_ibm ( thl_init ( kb : ke + kh ), thl0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) call avexy_ibm ( qt_init ( kb : ke + kh ), qt0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) if ( myid == 0 ) then ! Read profiles from file (potentially for forcing) open ( ifinput , file = 'prof.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess !write (*, '(a80)') chmess read ( ifinput , '(a80)' ) chmess do k = kb , ke read ( ifinput , * ) & height ( k ), & thlprof ( k ), & qtprof ( k ), & uprof ( k ), & vprof ( k ), & e12prof ( k ) end do close ( ifinput ) ! Write initial profile open ( ifinput , file = 'prof_restart.' // cexpnr ) write ( ifinput , * ) '# SDBL flow' write ( ifinput , * ) '# z thl qt u v e12' do k = kb , ke write ( ifinput , '(f20.15,5f12.6)' ) & height ( k ), & thl_init ( k ), & qt_init ( k ), & u_init ( k ), & v_init ( k ), & e12prof ( k ) end do close ( ifinput ) ! Apply rotation in horizontal !write (6, *) 'iangle = ', iangle !uprofrot = uprof*cos(iangle) - vprof*sin(iangle) !vprofrot = vprof*cos(iangle) + uprof*sin(iangle) !uprof = uprofrot !vprof = vprofrot if ( loneeqn ) then if ( minval ( e12prof ( kb : ke )) < e12min ) then write ( * , * ) 'e12 value is zero (or less) in prof.inp' do k = kb , ke e12prof ( k ) = max ( e12prof ( k ), e12min ) end do end if end if end if ! end if myid==0 ! MPI broadcast numbers reading call MPI_BCAST ( thlprof , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( qtprof , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( uprof , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( vprof , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( e12prof , kmax , MY_REAL , 0 , comm3d , mpierr ) btime = timee um = u0 vm = v0 wm = w0 thlm = thl0 qtm = qt0 svm = sv0 ! What if nsv=0? e12m = e120 ekm (:, :, :) = numol ekh (:, :, :) = numol * prandtlmoli !tg3315 added because wttop using ekh in modboundary which is called in startup ekh (:, :, ke + 1 ) = ekh (:, :, ke ) ! also for start up if ( idriver == 1 ) then !driverstore = (timeleft - tdriverstart)/dtdriver + 1 !if(myid==0) then !  write(*,*) 'driverstore: ', driverstore !end if if ( timee >= tdriverstart ) then tdriverstart_cold = tdriverstart tdriverstart = timee if ( trestart /= ( driverstore - 1 ) * dtdriver ) then trestart = ( driverstore - 1 ) * dtdriver end if if ( myid == 0 ) then write ( * , '(A,F15.5)' ) \"Warning! during warmstart of driver simulat ion, tdriverstart & &gets overwritten by the time instant of initd restartfile, ignoring the & &tdriverstart mentioned in namoptions. Hence, tdriverstart = \" , timee write ( * , '(A,F15.5)' ) 'Warning! for this driver simulation, trestart gets set as & (driverstore-1)*dtdriver, ignoring the trestart mentioned & in namoptions. Hence, trestart = ' ,( driverstore - 1 ) * dtdriver if ( runtime < ( driverstore - 1 ) * dtdriver ) then write ( * , * ) 'Warning! Driver files cannot be written upto ' , driverstore , ' steps. & &Consider taking runtime >= (driverstore-1)*dtdriver).' end if end if else ! if (timee<tdriverstart) if ( trestart /= ( tdriverstart + ( driverstore - 1 ) * dtdriver - btime )) then trestart = ( tdriverstart + ( driverstore - 1 ) * dtdriver ) - btime end if if ( myid == 0 ) then write ( * , '(A,F15.5)' ) 'Warning! for this driver simulation, trestart gets set as & (tdriverstart + (driverstore-1)*dtdriver - btime), ignoring the & trestart mentioned in namoptions. Hence, trestart = ' ,( tdriverstart + ( driverstore - 1 ) * dtdriver ) - btime if ( ( timee + runtime ) < ( tdriverstart + ( driverstore - 1 ) * dtdriver ) ) then write ( * , * ) 'Warning! Driver files cannot be written upto ' , driverstore , ' steps. & &Consider taking runtime + ' , timee , ' >= (tdriverstart + (driverstore-1)*dtdriver).' end if end if end if call drivergen tdriverdump = tdriverstart endif !ILS13 reintroduced thv call calc_halflev ! exnf = (presf/pref0)**(rd/cp)  !exner functions not in restart files ! anymore.. or at least not read ! exnh = (presh/pref0)**(rd/cp) !   write(*,*) \"exnf\",enf !   write(*,*) \"exnh\",exnh do j = jb , je do i = ib , ie do k = kb , ke + kh !write(*,*) \"thl0h\",thl0h(i,j,k) thv0h ( i , j , k ) = ( thl0h ( i , j , k ) + rlv * ql0h ( i , j , k ) / ( cp )) & * ( 1 + ( rv / rd - 1 ) * qt0h ( i , j , k ) - rv / rd * ql0h ( i , j , k )) end do end do end do do j = j , je do i = ib , ie do k = kb , ke + kh thv0 ( i , j , k ) = ( thl0 ( i , j , k ) + rlv * ql0 ( i , j , k ) / ( cp )) & * ( 1 + ( rv / rd - 1 ) * qt0 ( i , j , k ) - rv / rd * ql0 ( i , j , k )) end do end do end do thvh = 0. ! call slabsum(thvh,kb,ke,thv0h,ib-ih,ie+ih,jb-jh,je+jh,kb-kh,ke+kh,ib,ie,jb,je,kb,ke) ! redefine halflevel thv using calculated thv call avexy_ibm ( thvh ( kb : ke + kh ), thv0h ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIw ( ib : ie , jb : je , kb : ke + kh ), IIws ( kb : ke + kh ),. false .) ! thvh = thvh/rslabs thvf = 0.0 call avexy_ibm ( thvf ( kb : ke + kh ), thv0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) ! call slabsum(thvf,kb,ke,thv0,ib-ih,ie+ih,jb-jh,je+jh,kb-kh,ke+kh,ib,ie,jb,je,kb,ke) ! thvf = thvf/rslabs ! Set average inlet profile to initial inlet profile in case of inletgenerator mode uaverage = 0. uaveragei = 0. uaverager = 0. waverage = 0. taveragei = 0. taverager = 0. if ( iinletgen == 1 ) then call slabsum ( uaveragei , kb , ke , u0 , ib - 1 , ie + 1 , jb - 1 , je + 1 , kb - 1 , ke + 1 , ib , ib , jb , je , kb , ke ) call slabsum ( uaverager , kb , ke , u0 , ib - 1 , ie + 1 , jb - 1 , je + 1 , kb - 1 , ke + 1 , irecy , irecy , jb , je , kb , ke ) call slabsum ( waverage , kb , ke + 1 , w0 , ib - 1 , ie + 1 , jb - 1 , je + 1 , kb - 1 , ke + 1 , ib , ie , jb , je , kb , ke + 1 ) call slabsum ( uaverage , kb , ke , u0 , ib - 1 , ie + 1 , jb - 1 , je + 1 , kb - 1 , ke + 1 , ib , ie , jb , je , kb , ke ) uaverage = uaverage / (( ie - ib + 1 ) * ( jge - jgb + 1 )) ! this gives the i-j-averaged velocity (only correct for equidistant grid?) uaveragei = uaveragei / ( jge - jgb + 1 ) ! this gives the j-averaged u-velocity at the inlet uaverager = uaverager / ( jge - jgb + 1 ) ! this gives the j-averaged u-velocity at the recycle plane waverage = waverage / (( ie - ib + 1 ) * ( jge - jgb + 1 )) ! this gives the i-j-averaged w-velocity (only correct for equidistant grid?) if ( ltempeq ) then call slabsum ( taveragei , kb , ke , thl0 , ib - 1 , ie + 1 , jb - 1 , je + 1 , kb - 1 , ke + 1 , ib , ie , jb , je , kb , ke ) call slabsum ( taverager , kb , ke , thl0 , ib - 1 , ie + 1 , jb - 1 , je + 1 , kb - 1 , ke + 1 , irecy - 1 , irecy - 1 , jb , je , kb , ke ) taveragei = taveragei / (( ie - ib + 1 ) * ( jge - jgb + 1 )) ! this gives the j-averaged temperature at the inlet taverager = taverager / ( jge - jgb + 1 ) ! this gives the j-averaged temperature at the recycle plane end if if (. not . lreadminl ) then if ( myid == 0 ) then write ( 6 , * ) 'uaverage(kb)=' , uaverage ( kb ) write ( 6 , * ) 'uaverage(ke)=' , uaverage ( ke ) write ( 6 , * ) 'waverage(ke)=' , waverage ( ke ) write ( 6 , * ) 'waverage(ke-20)=' , waverage ( ke - 20 ) write ( 6 , * ) 'taveragei(kb)=' , taveragei ( kb ) write ( 6 , * ) 'taveragei(ke)=' , taveragei ( ke ) end if Utav = 0. do i = ib , ie Utav ( i , :) = uaverage end do Uinl = uaverage ! set the initial time-averaged inlet profile equal to mean u-profile read from means write ( 6 , * ) 'Uinl(kb+10)=' , Uinl ( kb + 10 ) utaui = sqrt ( abs ( 2 * numol * Uinl ( kb ) / dzf ( kb ))) ! average streamwise friction at inlet (need for first time step) Urec = uaverage ! set the initial time-averaged inlet profile equal to mean u-profile Wrec ( kb : ke + 1 ) = waverage ( kb : ke + 1 ) ! set the initial time-averaged inlet profile equal to mean w-profile Wrec ( kb ) = 0. ! set the initial time-averaged inlet profile equal to zero if ( ltempeq ) then Ttav = 0. do i = ib , ie Ttav ( i , :) = taveragei (:) end do Tinl = taveragei Trec = taveragei ttaui = numol * prandtlmoli * 2. * ( Tinl ( kb ) - thls ) / ( dzf ( kb ) * utaui ) ! friction temp. at inlet (need at first time step) end if else ! -> lreadminl -> Uinl, Urec, Wrec already read call slabsum ( uaverage , kb , ke , u0 , ib - 1 , ie + 1 , jb - 1 , je + 1 , kb - 1 , ke + 1 , ib , ie , jb , je , kb , ke ) uaverage = uaverage / (( ie - ib + 1 ) * ( jge - jgb + 1 )) ! this gives the i-j-averaged velocity (only correct for equidistant grid?) end if ! determine bulk velocity do k = kb , ke uaverage ( k ) = uaverage ( k ) * dzf ( k ) end do ubulk = sum ( uaverage ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) ! volume-averaged u-velocity write ( 6 , * ) 'Modstartup: ubulk=' , ubulk do k = kb , ke do j = jb , je uminletbc ( j , k ) = um ( ib , j , k ) vminletbc ( j , k ) = vm ( ib - 1 , j , k ) u0inletbcold ( j , k ) = um ( ib , j , k ) v0inletbcold ( j , k ) = vm ( ib - 1 , j , k ) u0inletbc ( j , k ) = um ( ib , j , k ) v0inletbc ( j , k ) = vm ( ib - 1 , j , k ) end do end do do k = kb , ke + 1 do j = jb , je wminletbc ( j , k ) = wm ( ib - 1 , j , k ) w0inletbcold ( j , k ) = wm ( ib - 1 , j , k ) w0inletbc ( j , k ) = wm ( ib - 1 , j , k ) end do end do if ( ltempeq ) then do k = kb , ke do j = jb , je tminletbc ( j , k ) = thlm ( ib - 1 , j , k ) t0inletbcold ( j , k ) = thlm ( ib - 1 , j , k ) t0inletbc ( j , k ) = thlm ( ib - 1 , j , k ) end do end do end if write ( 6 , * ) 'uminletbc(jb,kb),um(ib,jb,kb)=' , uminletbc ( jb , kb ), um ( ib , jb , kb ) write ( 6 , * ) 'uminletbc(jb+1,kb+10),um(ib,jb+1,kb+10)=' , uminletbc ( jb + 1 , kb + 10 ), um ( ib , jb + 1 , kb + 10 ) write ( 6 , * ) 'uminletbc(je,kb+10),um(ib,je,kb+10)=' , uminletbc ( je , kb + 10 ), um ( ib , je , kb + 10 ) else if ( iinletgen == 2 ) then nfile = nfile + 1 write ( 6 , * ) 'Loading inletfile' call readinletfile u0inletbc (:, :) = storeu0inletbc (:, :, nstepread ) v0inletbc (:, :) = storev0inletbc (:, :, nstepread ) w0inletbc (:, :) = storew0inletbc (:, :, nstepread ) uminletbc (:, :) = storeu0inletbc (:, :, nstepread ) vminletbc (:, :) = storev0inletbc (:, :, nstepread ) wminletbc (:, :) = storew0inletbc (:, :, nstepread ) if ( ltempeq ) then t0inletbc (:, :) = storet0inletbc (:, :, nstepread ) tminletbc (:, :) = storet0inletbc (:, :, nstepread ) end if ! determine bulk velocity call slabsum ( uaverage , kb , ke , u0 , ib - 1 , ie + 1 , jb - 1 , je + 1 , kb - 1 , ke + 1 , ib , ie , jb , je , kb , ke ) uaverage = uaverage / (( ie - ib + 1 ) * ( jge - jgb + 1 )) ! this gives the i-j-averaged velocity (only correct for equidistant grid?) do k = kb , ke uaverage ( k ) = uaverage ( k ) * dzf ( k ) end do ubulk = sum ( uaverage ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) ! volume-averaged u-velocity write ( 6 , * ) 'Modstartup: ubulk=' , ubulk elseif ( idriver == 2 ) then ! idriver if ( ibrank ) then if ( lchunkread ) then call readdriverfile_chunk else call readdriverfile end if call drivergen end if !call slabsum(uaverage,kb,ke,u0,ib-1,ie+1,jb-1,je+1,kb-1,ke+1,ib,ie,jb,je,kb,ke) !uaverage = uaverage / ((ie-ib+1)*(jge-jgb+1))  ! this gives the i-j-averaged velocity (only correct for equidistant grid?) ! call avexy_ibm(uaverage(kb:ke),u0(ib:ie,jb:je,kb:ke),ib,ie,jb,je,kb,ke,ih,jh,kh,IIu(ib:ie,jb:je,kb:ke),IIus(kb:ke),.false.) ! do k=kb,ke !   uaverage(k) = uaverage(k)*dzf(k) ! end do ! ubulk = sum(uaverage(kb:ke))/(zh(ke+1)-zh(kb)) !volume-averaged u-velocity ! if (myid==0) then !    write(6,*) 'Modstartup: ubulk=',ubulk ! end if end if ! iinletgen/idriver if ( lper2inout ) then ! if the restart starts from a periodic simulation to in/outflow, lper2inout should be set to .true. if ( myid == 0 ) then write ( 6 , * ) 'per2inout=.true. -> reading inlet profile from prof.inp.XXX and scalar.inp.XXX' open ( ifinput , file = 'prof.inp.' // cexpnr ) !  read the inlet profile from prof.inp read ( ifinput , '(a80)' ) chmess write ( * , '(a80)' ) chmess read ( ifinput , '(a80)' ) chmess do k = kb , ke read ( ifinput , * ) & height ( k ), & thlprof ( k ), & qtprof ( k ), & uprof ( k ), & vprof ( k ), & e12prof ( k ) end do svprof = 0. if ( nsv > 0 ) then open ( ifinput , file = 'scalar.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess read ( ifinput , '(a80)' ) chmess do k = kb , ke read ( ifinput , * ) & height ( k ), & ( svprof ( k , n ), n = 1 , nsv ) end do open ( ifinput , file = 'scalar.inp.' // cexpnr ) write ( 6 , * ) 'height   sv(1) --------- sv(nsv) ' do k = ke , kb , - 1 write ( 6 , * ) & height ( k ), & ( svprof ( k , n ), n = 1 , nsv ) end do end if end if ! end if myid==0 ! MPI broadcast numbers reading call MPI_BCAST ( thlprof , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( uprof , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( vprof , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( e12prof , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( qtprof , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( svprof , ( ke + kh - ( kb - kh )) * nsv , MY_REAL , 0 , comm3d , mpierr ) else if ( linoutflow ) then ! restart of inoutflow simulation: reproduce inlet boundary condition from restartfile do j = jb - 1 , je + 1 do k = kb , ke + 1 uprof ( k ) = u0 ( ib , j , k ) vprof ( k ) = ( v0 ( ib - 1 , j , k ) + v0 ( ib , j , k )) / 2 thlprof ( k ) = ( thl0 ( ib - 1 , j , k ) + thl0 ( ib , j , k )) / 2 qtprof ( k ) = ( qt0 ( ib - 1 , j , k ) + qt0 ( ib , j , k )) / 2 e12prof ( k ) = ( e120 ( ib - 1 , j , k ) + e120 ( ib , j , k )) / 2 do n = 1 , nsv svprof ( k , n ) = ( sv0 ( ib - 1 , j , k , n ) + sv0 ( ib , j , k , n )) / 2 enddo enddo enddo ! outlet bulk velocity call slabsum ( uaverage , kb , ke , u0 , ib - 1 , ie + 1 , jb - 1 , je + 1 , kb - 1 , ke + 1 , ib , ie , jb , je , kb , ke ) uaverage = uaverage / (( ie - ib + 1 ) * ( jge - jgb + 1 )) ! this gives the i-j-averaged velocity (only correct for equidistant grid?) ! determine bulk velocity do k = kb , ke uaverage ( k ) = uaverage ( k ) * dzf ( k ) end do ubulk = sum ( uaverage ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) ! volume-averaged u-velocity write ( 6 , * ) 'Modstartup: ubulk=' , ubulk else ! else per2per... read svprof regardless... ! tg3315 read svprof (but do not use regardless of above...) svprof = 0. if ( myid == 0 ) then if ( nsv > 0 ) then open ( ifinput , file = 'scalar.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess read ( ifinput , '(a80)' ) chmess do k = kb , ke read ( ifinput , * ) & height ( k ), & ( svprof ( k , n ), n = 1 , nsv ) end do open ( ifinput , file = 'scalar.inp.' // cexpnr ) write ( 6 , * ) 'height   sv(1) --------- sv(nsv) ' do k = ke , kb , - 1 write ( 6 , * ) & height ( k ), & ( svprof ( k , n ), n = 1 , nsv ) end do end if end if ! end if myid==0 call MPI_BCAST ( svprof , ( ke + kh - ( kb - kh )) * nsv , MY_REAL , 0 , comm3d , mpierr ) if ( nsv > 0 ) then !tg3315 set these variables here for now and repeat for warmstart allocate ( sv_top ( 1 : nsv )) sv_top (:) = svprof ( ke , 1 : nsv ) call MPI_BCAST ( sv_top , nsv , MY_REAL , 0 , comm3d , mpierr ) end if end if ! end if lper2inout u0av = 0.0 v0av = 0.0 thl0av = 0.0 qt0av = 0.0 th0av = 0.0 sv0av = 0. ! call slabsum(u0av  ,kb,ke+kh,u0(:,:,kb:ke+kh)  ,ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) call avexy_ibm ( u0av ( kb : ke + kh ), u0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIu ( ib : ie , jb : je , kb : ke + kh ), IIus ( kb : ke + kh ),. false .) ! call slabsum(v0av  ,kb,ke+kh,v0(:,:,kb:ke+kh)  ,ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) call avexy_ibm ( v0av ( kb : ke + kh ), v0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIv ( ib : ie , jb : je , kb : ke + kh ), IIvs ( kb : ke + kh ),. false .) ! call slabsum(thl0av,kb,ke+kh,thl0(:,:,kb:ke+kh),ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) call avexy_ibm ( thl0av ( kb : ke + kh ), thl0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) ! call slabsum(qt0av,kb,ke+kh,qt0(:,:,kb:ke+kh),ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) call avexy_ibm ( qt0av ( kb : ke + kh ), qt0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) do n = 1 , nsv ! call slabsum(sv0av(kb,n),kb,ke+kh,sv0(ib-ih,jb-jh,kb,n),ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) call avexy_ibm ( sv0av ( kb : ke + khc , n ), sv0 ( ib : ie , jb : je , kb : ke + khc , n ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + khc ), IIcs ( kb : ke + khc ),. false .) end do ! CvH - only do this for fixed timestepping. In adaptive dt comes from restartfile if (. not . ladaptive ) dt = dtmax !  call boundary if ( lEB . and . ( lfacTlyrs . eqv . . false .)) then if ( myid == 0 ) write ( * , * ) \"Warmstarting an EB simulation - consider setting internal facet temperatures\" end if end if ! lwarmstart end if ! not lstratstart !----------------------------------------------------------------- !    2.1 read and initialise fields !----------------------------------------------------------------- if ( myid == 0 ) then open ( ifinput , file = 'lscale.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess read ( ifinput , '(a80)' ) chmess ! write (6, *) ' height  u_geo  v_geo  pgx  pgy  subs     ' & !    , '   dqtdx      dqtdy        dqtdtls     thl_rad ' do k = kb , ke read ( ifinput , * ) & height ( k ), & ug ( k ), & vg ( k ), & pgx ( k ), & pgy ( k ), & wfls ( k ), & dqtdxls ( k ), & dqtdyls ( k ), & dqtdtls ( k ), & thlpcar ( k ) end do close ( ifinput ) ! do k = ke, kb, -1 !    write (6, '(3f7.1,5e12.4)') & !       height(k), & !       ug(k), & !       vg(k), & !       pgx(k), & !       pgy(k), & !       wfls(k), & !       dqtdxls(k), & !       dqtdyls(k), & !       dqtdtls(k), & !       thlpcar(k) ! end do end if ! end myid==0 ! MPI broadcast variables read in call MPI_BCAST ( ug , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( vg , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( pgx , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( pgy , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( wfls , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( dqtdxls , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( dqtdyls , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( dqtdtls , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( thlpcar , kmax , MY_REAL , 0 , comm3d , mpierr ) !----------------------------------------------------------------- !    2.3 make large-scale horizontal pressure gradient !----------------------------------------------------------------- !******include rho if rho = rho(z) /= 1.0 *********** if ( lprofforc ) then !tg3315 do k = kb , ke dpdxl ( k ) = - pgx ( k ) - dpdx !-om23_gs*ug(k)-pgx(k)-dpdx dpdyl ( k ) = - pgy ( k ) end do else do k = kb , ke !dpdxl(k) =  om23_gs*vg(k) !dpdyl(k) = -om23_gs*ug(k) !dpdxl(k) =  -ug(k) !dpdyl(k) =  -vg(k) dpdxl ( k ) = om23_gs * vg ( k ) - pgx ( k ) - dpdx !corriolis forcing and pressure gradient dpdyl ( k ) = - om23_gs * ug ( k ) - pgy ( k ) end do endif !----------------------------------------------------------------- !    2.4 large-scale subsidence, reintroduced ILS13 05.06.2014 !----------------------------------------------------------------- whls ( kb ) = 0.0 do k = kb + 1 , ke whls ( k ) = ( wfls ( k ) * dzf ( k - 1 ) + wfls ( k - 1 ) * dzf ( k )) / ( 2 * dzh ( k )) end do whls ( ke + 1 ) = ( wfls ( ke ) + dzf ( ke ) * ( wfls ( ke ) - wfls ( ke - 1 )) / dzh ( ke )) ! tg3315 31/07/18 removed a 0.5 !    idtmax = floor(dtmax/tres) btime = timee !    timeleft=ceiling(runtime/tres) timeleft = runtime dt_lim = timeleft !    write(6,*) 'real(dt)*tres= ',rdt, ' dtmax/100= ',dtmax/100 if (( lwarmstart ) . or . ( lstratstart )) then ! tg3315 to have cumulative number on restart files read ( startfile ( 6 : 13 ), '(i8)' ) ntrun ! ntrun = ichar(startfile(6:13)) else ntrun = 0 end if ntimee = nint ( timee / dtmax ) tnextrestart = btime + trestart tnextfielddump = btime + tfielddump tEB = btime tnextEB = btime + dtEB tfac = btime tnextfac = btime + dtfac deallocate ( height , th0av ) !    call boundary end subroutine readinitfiles","tags":"","url":"proc/readinitfiles.html"},{"title":"readrestartfiles – uDALES","text":"public  subroutine readrestartfiles() Uses modmpi modsubgriddata modsurfdata modglobal modinlet modfields proc~~readrestartfiles~~UsesGraph proc~readrestartfiles readrestartfiles module~modfields modfields proc~readrestartfiles->module~modfields module~modglobal modglobal proc~readrestartfiles->module~modglobal module~modinlet modinlet proc~readrestartfiles->module~modinlet module~modmpi modmpi proc~readrestartfiles->module~modmpi module~modsubgriddata modsubgriddata proc~readrestartfiles->module~modsubgriddata module~modsurfdata modsurfdata proc~readrestartfiles->module~modsurfdata decomp_2d decomp_2d module~modfields->decomp_2d module~modinletdata modinletdata module~modinlet->module~modinletdata mpi mpi module~modinlet->mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~readrestartfiles~~CallsGraph proc~readrestartfiles readrestartfiles proc~zinterpolate1d zinterpolate1d proc~readrestartfiles->proc~zinterpolate1d proc~zinterpolate2d zinterpolate2d proc~readrestartfiles->proc~zinterpolate2d proc~zinterpolatet1d zinterpolatet1d proc~readrestartfiles->proc~zinterpolatet1d proc~zinterpolatew1d zinterpolatew1d proc~readrestartfiles->proc~zinterpolatew1d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~readrestartfiles~~CalledByGraph proc~readrestartfiles readrestartfiles proc~readinitfiles readinitfiles proc~readinitfiles->proc~readrestartfiles program~dalesurban DALESURBAN program~dalesurban->proc~readinitfiles Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine readrestartfiles use modsurfdata , only : ustar , thlflux , qtflux , svflux , dudz , dvdz , dthldz , dqtdz , ps , thls , qts , thvs , oblav , & wtsurf use modfields , only : u0 , v0 , w0 , thl0 , qt0 , ql0 , ql0h , qtav , qlav , e120 , dthvdz , presf , presh , sv0 , mindist , wall , & uav , vav , wav , uuav , vvav , wwav , uvav , uwav , vwav , svav , thlav , thl2av , sv2av , pres0 , svm , & svprof , viscratioav , thluav , thlvav , thlwav , svuav , svvav , svwav , presav , & uusgsav , vvsgsav , wwsgsav , uwsgsav , thlusgsav , thlwsgsav , svusgsav , svwsgsav , tkesgsav , & strain2av , nusgsav use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , dtheta , dqt , dsv , startfile , timee , totavtime , runavtime , & iexpnr , ntimee , rk3step , ifinput , nsv , runtime , dt , cexpnr , lreadmean , lreadminl , & totinletav , lreadscal , ltempeq , dzf , numol , prandtlmoli use modmpi , only : cmyid , cmyidx , cmyidy , myid use modsubgriddata , only : ekm use modinlet , only : zinterpolate1d , zinterpolatet1d , zinterpolatew1d , zinterpolate2d , & Uinl , Urec , Wrec , Utav , Tinl , Trec , & kbin , kein , lzinzsim , utaui , Ttav , ttaui real , dimension ( ib : ie , jb : je , kb : ke ) :: dummy3d real , dimension ( ib : ie , kbin : kein ) :: Utavin real , dimension ( ib : ie , kbin : kein ) :: Ttavin real , dimension ( kbin : kein ) :: Uinlin real , dimension ( kbin : kein ) :: Urecin real , dimension ( kbin : kein ) :: Tinlin real , dimension ( kbin : kein ) :: Trecin real , dimension ( kbin : kein + 1 ) :: Wrecin character ( 50 ) :: name , name2 , name4 real dummy integer i , j , k , n !******************************************************************** !    1.0 Read initfiles !----------------------------------------------------------------- name = startfile name ( 5 : 5 ) = 'd' name ( 15 : 17 ) = cmyidx name ( 19 : 21 ) = cmyidy !write (6, *) 'loading ', name open ( unit = ifinput , file = name , form = 'unformatted' , status = 'old' ) read ( ifinput ) ((( mindist ( i , j , k ), i = ib , ie ), j = jb , je ), k = kb , ke ) read ( ifinput ) (((( wall ( i , j , k , n ), i = ib , ie ), j = jb , je ), k = kb , ke ), n = 1 , 5 ) read ( ifinput ) ((( u0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) read ( ifinput ) ((( v0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) read ( ifinput ) ((( w0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) read ( ifinput ) ((( pres0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) read ( ifinput ) ((( thl0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) read ( ifinput ) ((( e120 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) read ( ifinput ) ((( ekm ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) read ( ifinput ) ((( qt0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) read ( ifinput ) ((( ql0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) read ( ifinput ) ((( ql0h ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) read ( ifinput ) timee , dt close ( ifinput ) !write (6, *) 'finished loading ', name if (( nsv > 0 ) . and . ( lreadscal )) then name ( 5 : 5 ) = 's' !write (6, *) 'loading ', name open ( unit = ifinput , file = name , form = 'unformatted' ) read ( ifinput ) (((( sv0 ( i , j , k , n ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ), n = 1 , nsv ) read ( ifinput ) timee close ( ifinput ) !write (6, *) 'finished loading ', name elseif (( nsv > 0 ) . and . (. not . lreadscal )) then sv0 = 0. svprof = 0. end if ! read mean variables if asked for by lreadmean name2 = 'means   .' name2 ( 6 : 8 ) = cmyid name2 ( 10 : 12 ) = cexpnr if ( lreadmean ) then write ( 6 , * ) 'Reading meansXXX.XXX, proc = ' , myid open ( unit = ifinput , file = name2 , form = 'unformatted' ) read ( ifinput ) totavtime , nsv read ( ifinput ) ((( uav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) ((( vav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) ((( wav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) ((( thlav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) ((( qtav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) ((( qlav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) ((( presav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) (((( svav ( i , j , k , n ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ), n = 1 , nsv ) read ( ifinput ) ((( viscratioav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) ((( uuav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) ((( vvav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) ((( wwav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) ((( thl2av ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) (((( sv2av ( i , j , k , n ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ), n = 1 , nsv ) read ( ifinput ) ((( uvav ( i , j , k ), i = ib , ie + ih ), j = jb , je + jh ), k = kb , ke ) read ( ifinput ) ((( uwav ( i , j , k ), i = ib , ie + ih ), j = jb , je ), k = kb , ke + kh ) read ( ifinput ) ((( vwav ( i , j , k ), i = ib , ie ), j = jb , je + jh ), k = kb , ke + kh ) read ( ifinput ) ((( thluav ( i , j , k ), i = ib , ie ), j = jb , je ), k = kb , ke ) read ( ifinput ) ((( thlvav ( i , j , k ), i = ib , ie ), j = jb , je + jh ), k = kb , ke ) read ( ifinput ) ((( thlwav ( i , j , k ), i = ib , ie ), j = jb , je ), k = kb , ke + kh ) read ( ifinput ) (((( svuav ( i , j , k , n ), i = ib , ie ), j = jb , je ), k = kb , ke ), n = 1 , nsv ) read ( ifinput ) (((( svvav ( i , j , k , n ), i = ib , ie ), j = jb , je + jh ), k = kb , ke ), n = 1 , nsv ) read ( ifinput ) (((( svwav ( i , j , k , n ), i = ib , ie ), j = jb , je ), k = kb , ke + kh ), n = 1 , nsv ) close ( ifinput ) write ( 6 , * ) 'Total averaging time so far: ' , totavtime ! read <x'y'>_SGS to file. name2 = 'SGS__   .' name2 ( 6 : 8 ) = cmyid name2 ( 10 : 12 ) = cexpnr open ( unit = ifinput , file = name2 , form = 'unformatted' ) read ( ifinput ) dummy , dummy read ( ifinput ) ((( uusgsav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) ((( vvsgsav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) ((( wwsgsav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) ((( uwsgsav ( i , j , k ), i = ib , ie + ih ), j = jb , je ), k = kb , ke + kh ) read ( ifinput ) ((( dummy3d ( i , j , k ), i = ib , ie ), j = jb , je ), k = kb , ke ) ! this is dissresav, which will be computed using other mean quantities read ( ifinput ) ((( tkesgsav ( i , j , k ), i = ib , ie ), j = jb , je ), k = kb , ke ) read ( ifinput ) ((( dummy3d ( i , j , k ), i = ib , ie ), j = jb , je ), k = kb , ke ) ! this is disssgsav, which will be computed using other mean quantities read ( ifinput ) ((( strain2av ( i , j , k ), i = ib , ie ), j = jb , je ), k = kb , ke ) ! <SijSij> (NOT <Sij><Sij> !!) (average over time) read ( ifinput ) ((( nusgsav ( i , j , k ), i = ib , ie ), j = jb , je ), k = kb , ke ) ! <nu_sgs> (average over time) read ( ifinput ) ((( thlusgsav ( i , j , k ), i = ib , ie + ih ), j = jb , je ), k = kb , ke ) read ( ifinput ) ((( thlwsgsav ( i , j , k ), i = ib , ie ), j = jb , je ), k = kb , ke + kh ) read ( ifinput ) (((( svusgsav ( i , j , k , n ), i = ib , ie + ih ), j = jb , je ), k = kb , ke ), n = 1 , nsv ) read ( ifinput ) (((( svwsgsav ( i , j , k , n ), i = ib , ie ), j = jb , je ), k = kb , ke + kh ), n = 1 , nsv ) close ( ifinput ) end if ! read mean profiles for inlet generator if ( lreadminl ) then if (. not . lzinzsim ) then name4 = 'meaninlet.   ' name4 ( 11 : 13 ) = cexpnr open ( unit = ifinput , file = name4 , form = 'unformatted' ) read ( ifinput ) totinletav ! interval of time-average read ( ifinput ) ( Uinlin ( k ), k = kbin , kein ) read ( ifinput ) ( Urecin ( k ), k = kbin , kein ) read ( ifinput ) ( Wrecin ( k ), k = kbin , kein + 1 ) read ( ifinput ) (( Utavin ( i , k ), i = ib , ie ), k = kbin , kein ) close ( ifinput ) call zinterpolate1d ( Uinlin , Uinl ) ! interpolate inlet profile to zgrid call zinterpolate1d ( Urecin , Urec ) call zinterpolatew1d ( Wrecin , Wrec ) call zinterpolate2d ( Utavin , Utav ) if ( ltempeq ) then name4 = 'tempinlet.   ' name4 ( 11 : 13 ) = cexpnr open ( unit = ifinput , file = name4 , form = 'unformatted' ) read ( ifinput ) totinletav ! interval of time-average read ( ifinput ) ( Tinlin ( k ), k = kbin , kein ) read ( ifinput ) ( Trecin ( k ), k = kbin , kein ) read ( ifinput ) (( Ttavin ( i , k ), i = ib , ie ), k = kbin , kein ) close ( ifinput ) call zinterpolatet1d ( Tinlin , Tinl ) call zinterpolatet1d ( Trecin , Trec ) call zinterpolate2d ( Ttavin , Ttav ) end if ! ltempeq else !lzinzsim=.true. -> inlet grid equals sim grid name4 = 'meaninlet.   ' name4 ( 11 : 13 ) = cexpnr open ( unit = ifinput , file = name4 , form = 'unformatted' ) read ( ifinput ) totinletav ! interval of time-average read ( ifinput ) ( Uinl ( k ), k = kb , ke ) read ( ifinput ) ( Urec ( k ), k = kb , ke ) read ( ifinput ) ( Wrec ( k ), k = kb , ke + 1 ) read ( ifinput ) (( Utav ( i , k ), i = ib , ie ), k = kb , ke ) close ( ifinput ) if ( ltempeq ) then name4 = 'tempinlet.   ' name4 ( 11 : 13 ) = cexpnr open ( unit = ifinput , file = name4 , form = 'unformatted' ) read ( ifinput ) totinletav ! interval of time-average read ( ifinput ) ( Tinl ( k ), k = kb , ke ) read ( ifinput ) ( Trec ( k ), k = kb , ke ) read ( ifinput ) (( Ttav ( i , k ), i = ib , ie ), k = kb , ke ) close ( ifinput ) end if ! ltempeq end if ! lzinzsim utaui = sqrt ( abs ( 2 * numol * Uinl ( kb ) / dzf ( kb ))) ! average streamwise friction at inlet (need for first time step) if ( ltempeq ) then ttaui = numol * prandtlmoli * 2. * ( Tinl ( kb ) - thls ) / ( dzf ( kb ) * utaui ) end if end if !(lreadminl) end subroutine readrestartfiles","tags":"","url":"proc/readrestartfiles.html"},{"title":"exitmodules – uDALES","text":"public  subroutine exitmodules() Uses modmpi modfields modpois modthermodynamics modinlet modsubgrid modglobal proc~~exitmodules~~UsesGraph proc~exitmodules exitmodules modpois modpois proc~exitmodules->modpois module~modfields modfields proc~exitmodules->module~modfields module~modglobal modglobal proc~exitmodules->module~modglobal module~modinlet modinlet proc~exitmodules->module~modinlet module~modmpi modmpi proc~exitmodules->module~modmpi module~modsubgrid modsubgrid proc~exitmodules->module~modsubgrid module~modthermodynamics modthermodynamics proc~exitmodules->module~modthermodynamics decomp_2d decomp_2d module~modfields->decomp_2d module~modinletdata modinletdata module~modinlet->module~modinletdata mpi mpi module~modinlet->mpi module~modmpi->mpi module~modsubgriddata modsubgriddata module~modsubgrid->module~modsubgriddata module~modsubgrid->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~exitmodules~~CallsGraph proc~exitmodules exitmodules exitpois exitpois proc~exitmodules->exitpois proc~exitfields exitfields proc~exitmodules->proc~exitfields proc~exitglobal exitglobal proc~exitmodules->proc~exitglobal proc~exitinlet exitinlet proc~exitmodules->proc~exitinlet proc~exitmpi exitmpi proc~exitmodules->proc~exitmpi proc~exitsubgrid exitsubgrid proc~exitmodules->proc~exitsubgrid proc~exitthermodynamics exitthermodynamics proc~exitmodules->proc~exitthermodynamics decomp_2d_finalize decomp_2d_finalize proc~exitmpi->decomp_2d_finalize mpi_finalize mpi_finalize proc~exitmpi->mpi_finalize mpi_wtime mpi_wtime proc~exitmpi->mpi_wtime Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine exitmodules use modfields , only : exitfields use modglobal , only : exitglobal use modmpi , only : exitmpi use modpois , only : exitpois use modsubgrid , only : exitsubgrid use modthermodynamics , only : exitthermodynamics use modinlet , only : exitinlet call exitthermodynamics call exitsubgrid call exitpois call exitfields call exitglobal call exitinlet call exitmpi end subroutine exitmodules","tags":"","url":"proc/exitmodules.html"},{"title":"randomnize – uDALES","text":"public  subroutine randomnize(field, klev, ampl, ir, ihl, jhl) Uses modmpi modglobal proc~~randomnize~~UsesGraph proc~randomnize randomnize module~modglobal modglobal proc~randomnize->module~modglobal module~modmpi modmpi proc~randomnize->module~modmpi mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real :: field (ib-ihl:ie+ihl,jb-jhl:je+jhl,kb-kh:ke+kh) integer :: klev real :: ampl integer(kind=selected_int_kind(6)) :: ir integer :: ihl integer :: jhl Called by proc~~randomnize~~CalledByGraph proc~randomnize randomnize proc~readinitfiles readinitfiles proc~readinitfiles->proc~randomnize program~dalesurban DALESURBAN program~dalesurban->proc~readinitfiles Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine randomnize ( field , klev , ampl , ir , ihl , jhl ) use modmpi , only : myid , nprocs use modglobal , only : ib , ie , imax , jmax , jb , je , kb , ke , kh , ierank , BCxm integer ( KIND = selected_int_kind ( 6 )) :: imm , ia , ic , ir integer ihl , jhl integer i , j , klev integer m , mfac real ran , ampl real field ( ib - ihl : ie + ihl , jb - jhl : je + jhl , kb - kh : ke + kh ) parameter ( imm = 134456 , ia = 8121 , ic = 28411 ) if ( myid > 0 ) then mfac = myid * jmax * imax do m = 1 , mfac ir = mod (( ir ) * ia + ic , imm ) end do end if ! if (ierank .and. BCxm > 1) then !   do j = jb, je !     do i = ib, ie-1 !       ir = mod((ir)*ia + ic, imm) !       ran = real(ir)/real(imm) !       field(i, j, klev) = field(i, j, klev) + (ran - 0.5)*2.0*ampl !     end do !   end do ! else do j = jb , je do i = ib , ie ir = mod (( ir ) * ia + ic , imm ) ran = real ( ir ) / real ( imm ) field ( i , j , klev ) = field ( i , j , klev ) + ( ran - 0.5 ) * 2.0 * ampl end do end do !end if if ( nprocs - 1 - myid > 0 ) then mfac = ( nprocs - 1 - myid ) * imax * jmax do m = 1 , mfac ir = mod (( ir ) * ia + ic , imm ) end do end if return end subroutine randomnize","tags":"","url":"proc/randomnize.html"},{"title":"forces – uDALES","text":"public  subroutine forces() Uses modmpi modsurfdata modibmdata modglobal modfields proc~~forces~~UsesGraph proc~forces forces module~modfields modfields proc~forces->module~modfields module~modglobal modglobal proc~forces->module~modglobal module~modibmdata modibmdata proc~forces->module~modibmdata module~modmpi modmpi proc~forces->module~modmpi module~modsurfdata modsurfdata proc~forces->module~modsurfdata decomp_2d decomp_2d module~modfields->decomp_2d mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~forces~~CalledByGraph proc~forces forces program~dalesurban DALESURBAN program~dalesurban->proc~forces Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine forces !-----------------------------------------------------------------| !                                                                 | !      Hans Cuijpers   I.M.A.U.                                   | !      Pier Siebesma   K.N.M.I.     06/01/1995                    | !                                                                 | !     purpose.                                                    | !     --------                                                    | !                                                                 | !      Calculates all other terms in the N-S equation,            | !      except for the diffusion and advection terms.              | !                                                                 | !**   interface.                                                  | !     ----------                                                  | !                                                                 | !     *forces* is called from *program*.                          | !                                                                 | !-----------------------------------------------------------------| !  use modglobal, only : i1,j1,kmax,dzh,dzf,grav use modglobal , only : ib , ie , jb , je , kb , ke , kh , dzhi , dzf , grav , lbuoyancy use modfields , only : u0 , v0 , w0 , up , vp , wp , thv0h , dpdxl , dpdyl , thlp , thlpcar , thvh use modibmdata , only : nxwallsnorm , xwallsnorm use modsurfdata , only : thvs use modmpi , only : myid implicit none real thvsi integer i , j , k , n , jm , jp , km , kp if ( lbuoyancy ) then !ILS13 replace thvsi by thvh ! thvsi = 1./thvsi do k = kb + 1 , ke do j = jb , je do i = ib , ie up ( i , j , k ) = up ( i , j , k ) - dpdxl ( k ) vp ( i , j , k ) = vp ( i , j , k ) - dpdyl ( k ) wp ( i , j , k ) = wp ( i , j , k ) + grav * ( thv0h ( i , j , k ) - thvh ( k )) / thvh ( k ) end do end do end do else do k = kb + 1 , ke do j = jb , je do i = ib , ie up ( i , j , k ) = up ( i , j , k ) - dpdxl ( k ) vp ( i , j , k ) = vp ( i , j , k ) - dpdyl ( k ) ! IS+HJ      wp(i,j,k) = wp(i,j,k) end do end do end do end if !     ---------------------------------------------- !     add radiative heating to potential temperature !     ---------------------------------------------- do k = kb , ke do j = jb , je do i = ib , ie thlp ( i , j , k ) = thlp ( i , j , k ) + thlpcar ( k ) end do end do end do !     -------------------------------------------- !     special treatment for lowest full level: k=1 !     -------------------------------------------- do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie up ( i , j , kb ) = up ( i , j , kb ) - dpdxl ( kb ) vp ( i , j , kb ) = vp ( i , j , kb ) - dpdyl ( kb ) wp ( i , j , kb ) = 0.0 end do end do !     ----------------------------------------------end i,j-loop return end subroutine forces","tags":"","url":"proc/forces.html"},{"title":"detfreestream – uDALES","text":"public  subroutine detfreestream(freestream) Uses modfields modmpi modglobal proc~~detfreestream~~UsesGraph proc~detfreestream detfreestream module~modfields modfields proc~detfreestream->module~modfields module~modglobal modglobal proc~detfreestream->module~modglobal module~modmpi modmpi proc~detfreestream->module~modmpi decomp_2d decomp_2d module~modfields->decomp_2d mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(out) :: freestream Called by proc~~detfreestream~~CalledByGraph proc~detfreestream detfreestream proc~fixuinf2 fixuinf2 proc~fixuinf2->proc~detfreestream program~dalesurban DALESURBAN program~dalesurban->proc~fixuinf2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine detfreestream ( freestream ) use modglobal , only : ib , ie , jb , je , kb , ke , kh , dxf , xh , dt ,& Uinf , Vinf , lvinf , dy use modfields , only : u0 , dpdxl , dgdt , dpdx , v0 , u0av , v0av use modmpi , only : myid , comm3d , mpierr , mpi_sum , my_real , nprocs implicit none real , intent ( out ) :: freestream real utop , vtop , dum integer i , j if ( lvinf ) then freestream = v0av ( ke ) else freestream = u0av ( ke ) end if end subroutine detfreestream","tags":"","url":"proc/detfreestream.html"},{"title":"detfreestrtmp – uDALES","text":"public  subroutine detfreestrtmp(freestrtmp) Uses modfields modmpi modglobal proc~~detfreestrtmp~~UsesGraph proc~detfreestrtmp detfreestrtmp module~modfields modfields proc~detfreestrtmp->module~modfields module~modglobal modglobal proc~detfreestrtmp->module~modglobal module~modmpi modmpi proc~detfreestrtmp->module~modmpi decomp_2d decomp_2d module~modfields->decomp_2d mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(out) :: freestrtmp Calls proc~~detfreestrtmp~~CallsGraph proc~detfreestrtmp detfreestrtmp mpi_allreduce mpi_allreduce proc~detfreestrtmp->mpi_allreduce Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine detfreestrtmp ( freestrtmp ) use modglobal , only : ib , ie , jb , je , kb , ke , kh , dxf , xh , dt ,& Uinf use modfields , only : thl0 , dpdxl , dgdt , dpdx use modmpi , only : myid , comm3d , mpierr , mpi_sum , my_real , nprocs implicit none real , intent ( out ) :: freestrtmp real ttop integer i , j ttop = 0. do j = jb , je do i = ib , ie ttop = ttop + thl0 ( i , j , ke ) * dxf ( i ) end do end do ttop = ttop / ( ( je - jb + 1 ) * ( xh ( ie + 1 ) - xh ( ib ) ) ) call MPI_ALLREDUCE ( ttop , freestrtmp , 1 , MY_REAL , MPI_SUM , comm3d , mpierr ) freestrtmp = freestrtmp / nprocs end subroutine detfreestrtmp","tags":"","url":"proc/detfreestrtmp.html"},{"title":"fixuinf2 – uDALES","text":"public  subroutine fixuinf2() Uses modfields modsurfdata modmpi modglobal proc~~fixuinf2~~UsesGraph proc~fixuinf2 fixuinf2 module~modfields modfields proc~fixuinf2->module~modfields module~modglobal modglobal proc~fixuinf2->module~modglobal module~modmpi modmpi proc~fixuinf2->module~modmpi module~modsurfdata modsurfdata proc~fixuinf2->module~modsurfdata decomp_2d decomp_2d module~modfields->decomp_2d mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~fixuinf2~~CallsGraph proc~fixuinf2 fixuinf2 proc~detfreestream detfreestream proc~fixuinf2->proc~detfreestream Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~fixuinf2~~CalledByGraph proc~fixuinf2 fixuinf2 program~dalesurban DALESURBAN program~dalesurban->proc~fixuinf2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine fixuinf2 use modglobal , only : ib , ie , jb , je , kb , ke , kh , dxf , xh , dt ,& Uinf , ifixuinf , tscale , timee , rk3step , inletav ,& freestreamav , freestrtmpav , ltempeq use modsurfdata , only : thl_top use modfields , only : u0 , thl0 , dpdxl , dgdt , dpdx , thlsrcdt use modmpi , only : myid , comm3d , mpierr , mpi_sum , my_real , nprocs implicit none real utop , freestream , freestrtmp , rk3coef integer i , j utop = 0. if (( ifixuinf == 2 ) . and . ( rk3step == 3 )) then call detfreestream ( freestream ) freestreamav = freestream * dt / inletav + ( 1. - dt / inletav ) * freestreamav ! Write some statistics to monitoring file ! if (myid==0) then !   open(unit=11,file='freestr.txt',position='append') !   write(11,3002) timee,freestream,freestreamav !   3002      format (13(6e14.6)) !   close(11) ! endif !    dgdt =  (1./tscale) * (freestream - Uinf) !    dgdt =  (1./dt) * (freestreamav - Uinf) dgdt = ( 1. / tscale ) * ( freestreamav - Uinf ) ! plus sign because dpdx is SUBTRACTED from Navier-Stokes eqs !    dgdt =  (1./inletav) * (freestreamav - Uinf) !    if (ltempeq) then  !tg3315 commented !      call detfreestrtmp(freestrtmp) !      freestrtmpav=  freestrtmp*dt/inletav + (1.-dt/inletav)*freestrtmpav !      thlsrcdt = -(1./tscale) * (freestrtmpav - thl_top)   ! minus sign because thlsr is ADDED to Navier-Stokes eqs. !      if (myid==0) then !        open(unit=11,file='theta_top.txt',position='append') !        write(11,3009) timee,freestrtmp,freestrtmpav !3009    format (13(6e20.12)) !        close(11) !      endif !    end if end if end subroutine fixuinf2","tags":"","url":"proc/fixuinf2.html"},{"title":"fixuinf1 – uDALES","text":"public  subroutine fixuinf1() Uses modfields modmpi modglobal proc~~fixuinf1~~UsesGraph proc~fixuinf1 fixuinf1 module~modfields modfields proc~fixuinf1->module~modfields module~modglobal modglobal proc~fixuinf1->module~modglobal module~modmpi modmpi proc~fixuinf1->module~modmpi decomp_2d decomp_2d module~modfields->decomp_2d mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~fixuinf1~~CalledByGraph proc~fixuinf1 fixuinf1 program~dalesurban DALESURBAN program~dalesurban->proc~fixuinf1 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine fixuinf1 use modglobal , only : ib , ie , jb , je , kb , ke , kh , dxf , xh , dt ,& Uinf , Vinf , ifixuinf , tscale , timee , rk3step , inletav ,& freestreamav , lvinf use modfields , only : u0 , dpdxl , dgdt , dpdx , up , vp , u0av , v0av use modmpi , only : myid , comm3d , mpierr , mpi_sum , my_real , nprocs implicit none real utop , freestream , rk3coef integer i , j , k utop = 0. if (( ifixuinf == 1 ) . and . ( rk3step == 3 )) then ! rk3coef = dt / (4. - dble(rk3step)) ! do j =jb,je !   do i =ib,ie !     utop = utop + 0.5*(u0(i,j,ke)+u0(i+1,j,ke))*dxf(i) !   end do ! end do ! utop = utop / ( (je-jb+1)*(xh(ie+1)-xh(ib) ) ) ! call MPI_ALLREDUCE(utop,    freestream,1,MY_REAL,MPI_SUM,comm3d,mpierr) ! freestream = freestream / nprocs ! Write some statistics to monitoring file ! if (myid==0 .and. rk3step==3) then ! ! dpdxl(:) = dpdx + (1./rk3coef) * (freestream - Uinf) ! dpdxl(:) = dpdx + (1./dt) * (freestream - Uinf) !call detfreestream(freestream) ! write(*,*) \"freestream\",freestream if ( lvinf ) then do k = kb , ke do i = ib , ie do j = jb , je vp ( i , j , k ) = vp ( i , j , k ) - ( 1. / dt ) * ( v0av ( ke ) - Vinf ) enddo enddo enddo end if !else do k = kb , ke do j = jb , je do i = ib , ie up ( i , j , k ) = up ( i , j , k ) - ( 1. / dt ) * ( u0av ( ke ) - Uinf ) enddo enddo enddo !endif ! if (myid==0) then !   write(*,*), \"freestream\", freestream !   write(*,*), \"Uinf\", Uinf !   open(unit=11,file='freestr.txt',position='append') !   write(11,3003) timee,freestream !   3003    format (13(6e20.12)) !   close(11) !   open(unit=11,file='dpdx___.txt',position='append') !   write(11,3002) timee,dpdxl(kb),dpdxl(kb)-dpdx !   3002    format (13(6e20.12)) !   close(11) ! endif end if end subroutine fixuinf1","tags":"","url":"proc/fixuinf1.html"},{"title":"fixthetainf – uDALES","text":"public  subroutine fixthetainf() Uses modsurfdata modfields modmpi modglobal proc~~fixthetainf~~UsesGraph proc~fixthetainf fixthetainf module~modfields modfields proc~fixthetainf->module~modfields module~modglobal modglobal proc~fixthetainf->module~modglobal module~modmpi modmpi proc~fixthetainf->module~modmpi module~modsurfdata modsurfdata proc~fixthetainf->module~modsurfdata decomp_2d decomp_2d module~modfields->decomp_2d mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Source Code subroutine fixthetainf use modglobal , only : ib , ie , jb , je , kb , ke , kh , dxf , xh , dt ,& Uinf , ifixuinf , tscale , timee , rk3step , inletav ,& freestreamav , thlsrc , ltempeq use modfields , only : thl0 use modmpi , only : myid , comm3d , mpierr , mpi_sum , my_real , nprocs use modsurfdata , only : thl_top implicit none real ttop , freestreamtheta , rk3coef integer i , j ttop = 0. ! if (ifixuinf==1 .and. rk3step==3 .and. ltempeq) then !tg3315 commented !   rk3coef = dt / (4. - dble(rk3step)) !   do j =jb,je !     do i =ib,ie !       ttop = ttop + thl0(i,j,ke)*dxf(i) !     end do !   end do !   ttop = ttop / ( (je-jb+1)*(xh(ie+1)-xh(ib) ) ) !   call MPI_ALLREDUCE(ttop,    freestreamtheta,1,MY_REAL,MPI_SUM,comm3d,mpierr) !   freestreamtheta = freestreamtheta / nprocs !   thlsrc = -(1./dt) * (freestreamtheta - thl_top) !     if (myid==0) then !       open(unit=11,file='theta_top.txt',position='append') !       write(11,3003) timee,freestreamtheta !       3003    format (13(6e20.12)) !       close(11) !       open(unit=11,file='thlsrc.txt',position='append') !       write(11,3002) timee,thlsrc !       3002    format (13(6e20.12)) !       close(11) !     endif ! end if end subroutine fixthetainf","tags":"","url":"proc/fixthetainf.html"},{"title":"masscorr – uDALES","text":"public  subroutine masscorr() Uses modfields modmpi modglobal proc~~masscorr~~UsesGraph proc~masscorr masscorr module~modfields modfields proc~masscorr->module~modfields module~modglobal modglobal proc~masscorr->module~modglobal module~modmpi modmpi proc~masscorr->module~modmpi decomp_2d decomp_2d module~modfields->decomp_2d mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~masscorr~~CallsGraph proc~masscorr masscorr proc~avexy_ibm avexy_ibm proc~masscorr->proc~avexy_ibm proc~sumy_ibm sumy_ibm proc~masscorr->proc~sumy_ibm mpi_allreduce mpi_allreduce proc~avexy_ibm->mpi_allreduce proc~sumy_ibm->mpi_allreduce Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~masscorr~~CalledByGraph proc~masscorr masscorr program~dalesurban DALESURBAN program~dalesurban->proc~masscorr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine masscorr !> correct the velocities to get prescribed flow rate use modglobal , only : ib , ie , jb , je , ih , jh , kb , ke , kh , dzf , dxf , dy , zh , dt , rk3step ,& uflowrate , vflowrate , linoutflow ,& luoutflowr , lvoutflowr , luvolflowr , lvvolflowr use modfields , only : um , up , vm , vp , uouttot , udef , vouttot , vdef ,& uoutarea , voutarea , fluidvol , IIu , IIv , IIus , IIvs use modmpi , only : myid , comm3d , mpierr , nprocs , MY_REAL , sumy_ibm , sumx_ibm , avexy_ibm real , dimension ( kb : ke + kh ) :: uvol real , dimension ( kb : ke + kh ) :: vvol real , dimension ( kb : ke + kh ) :: uvolold real , dimension ( kb : ke + kh ) :: vvolold real , dimension ( kb : ke ) :: uout real , dimension ( kb : ke ) :: vout real , dimension ( kb : ke ) :: uoutold real , dimension ( kb : ke ) :: voutold real rk3coef , rk3coefi ,& uoutflow , voutflow ,& uflowrateold , vflowrateold integer i , j , k if ((. not . linoutflow ) . and . ( luoutflowr )) then rk3coef = dt / ( 4. - dble ( rk3step )) rk3coefi = 1 / rk3coef ! Assumes ie=itot udef = 0. uout = 0. uoutflow = 0. uoutold = 0. ! integrate u fixed at outlet ie along y call sumy_ibm ( uout , up ( ie , jb : je , kb : ke ) * dy , ie , ie , jb , je , kb , ke , IIu ( ie , jb : je , kb : ke )) ! u tendency at previous time step call sumy_ibm ( uoutold , um ( ie , jb : je , kb : ke ) * dy , ie , ie , jb , je , kb , ke , IIu ( ie , jb : je , kb : ke )) ! u at previous time step ! integrate u in z do k = kb , ke uout ( k ) = rk3coef * uout ( k ) * dzf ( k ) uoutold ( k ) = uoutold ( k ) * dzf ( k ) end do uoutflow = sum ( uout ( kb : ke )) uflowrateold = sum ( uoutold ( kb : ke )) ! average over outflow area uoutflow = uoutflow / uoutarea uflowrateold = uflowrateold / uoutarea ! flow correction to match outflow rate udef = uflowrate - ( uoutflow + uflowrateold ) do k = kb , ke do j = jb , je do i = ib , ie up ( i , j , k ) = up ( i , j , k ) + udef * rk3coefi end do end do end do ! bss116 calculate uouttot which is used in modboundary. ! this really should be in the routine directly! uouttot = sum ( uout ( kb : ke )) ! mass flow rate at outlet elseif ((. not . linoutflow ) . and . ( luvolflowr )) then rk3coef = dt / ( 4. - dble ( rk3step )) rk3coefi = 1 / rk3coef udef = 0. uoutflow = 0. uvol = 0. uvolold = 0. ! Assumes equidistant grid call avexy_ibm ( uvol ( kb : ke + kh ), up ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIu ( ib : ie , jb : je , kb : ke + kh ), IIus ( kb : ke + kh ),. false .) call avexy_ibm ( uvolold ( kb : ke + kh ), um ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIu ( ib : ie , jb : je , kb : ke + kh ), IIus ( kb : ke + kh ),. false .) ! average over fluid volume uoutflow = rk3coef * sum ( uvol ( kb : ke ) * dzf ( kb : ke )) / zh ( ke + 1 ) uflowrateold = sum ( uvolold ( kb : ke ) * dzf ( kb : ke )) / zh ( ke + 1 ) ! flow correction to match outflow rate udef = uflowrate - ( uoutflow + uflowrateold ) do k = kb , ke do j = jb , je do i = ib , ie up ( i , j , k ) = up ( i , j , k ) + udef * rk3coefi end do end do end do end if if ((. not . linoutflow ) . and . ( lvoutflowr )) then rk3coef = dt / ( 4. - dble ( rk3step )) rk3coefi = 1 / rk3coef ! Assumes je=jtot vdef = 0. vout = 0. voutflow = 0. voutold = 0. ! integrate v fixed at outlet je along x ! if (myid==nprocs-1) then !    do k=kb,ke !       vout(k) = sum(vp(ib:ie,je,k)*IIv(ib:ie,je,k)*dxf(ib:ie))  ! v tendency at previous time step !       voutold(k) = sum(vm(ib:ie,je,k)*IIv(ib:ie,je,k)*dxf(ib:ie))  ! v at previous time step !    end do ! end if call sumy_ibm ( vout , vp ( ib : je , je , kb : ke ) * dxf ( 1 ), ib , ie , je , je , kb , ke , IIv ( ib : ie , je , kb : ke )) ! v tendency at previous time step call sumy_ibm ( voutold , vm ( ib : ie , je , kb : ke ) * dxf ( 1 ), ib , ie , je , je , kb , ke , IIv ( ib : ie , je , kb : ke )) ! v at previous time step ! integrate v in z do k = kb , ke vout ( k ) = rk3coef * vout ( k ) * dzf ( k ) voutold ( k ) = voutold ( k ) * dzf ( k ) end do voutflow = sum ( vout ( kb : ke )) vflowrateold = sum ( voutold ( kb : ke )) ! average over outflow area voutflow = voutflow / voutarea vflowrateold = vflowrateold / voutarea ! flow correction to match outflow rate vdef = vflowrate - ( voutflow + vflowrateold ) do k = kb , ke do j = jb , je do i = ib , ie vp ( i , j , k ) = vp ( i , j , k ) + vdef * rk3coefi end do end do end do elseif ((. not . linoutflow ) . and . ( lvvolflowr )) then rk3coef = dt / ( 4. - dble ( rk3step )) rk3coefi = 1 / rk3coef vdef = 0. voutflow = 0. vvol = 0. vvolold = 0. ! Assumes equidistant grid call avexy_ibm ( vvol ( kb : ke + kh ), vp ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIv ( ib : ie , jb : je , kb : ke + kh ), IIvs ( kb : ke + kh ),. false .) call avexy_ibm ( vvolold ( kb : ke + kh ), vm ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIv ( ib : ie , jb : je , kb : ke + kh ), IIvs ( kb : ke + kh ),. false .) ! average over fluid volume voutflow = rk3coef * sum ( vvol ( kb : ke ) * dzf ( kb : ke )) / zh ( ke + 1 ) vflowrateold = sum ( vvolold ( kb : ke ) * dzf ( kb : ke )) / zh ( ke + 1 ) ! flow correction to match outflow rate vdef = vflowrate - ( voutflow + vflowrateold ) do k = kb , ke do j = jb , je do i = ib , ie vp ( i , j , k ) = vp ( i , j , k ) + vdef * rk3coefi end do end do end do end if end subroutine masscorr","tags":"","url":"proc/masscorr.html"},{"title":"uoutletarea – uDALES","text":"public  subroutine uoutletarea(area) Uses modfields modmpi modglobal proc~~uoutletarea~~UsesGraph proc~uoutletarea uoutletarea module~modfields modfields proc~uoutletarea->module~modfields module~modglobal modglobal proc~uoutletarea->module~modglobal module~modmpi modmpi proc~uoutletarea->module~modmpi decomp_2d decomp_2d module~modfields->decomp_2d mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(out) :: area Calls proc~~uoutletarea~~CallsGraph proc~uoutletarea uoutletarea proc~sumy_ibm sumy_ibm proc~uoutletarea->proc~sumy_ibm mpi_allreduce mpi_allreduce proc~sumy_ibm->mpi_allreduce Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~uoutletarea~~CalledByGraph proc~uoutletarea uoutletarea proc~calcfluidvolumes calcfluidvolumes proc~calcfluidvolumes->proc~uoutletarea program~dalesurban DALESURBAN program~dalesurban->proc~calcfluidvolumes Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine uoutletarea ( area ) ! calculates outlet area of domain for u-velocity excluding blocks use modglobal , only : ib , ie , jb , je , kb , ke , dy , dzf , ierank use modfields , only : IIc use modmpi , only : sumy_ibm implicit none real , intent ( out ) :: area real , dimension ( kb : ke ) :: sumy integer k sumy = 0. ! integrate fluid area at outflow plane in y ! Assumes ie=itot call sumy_ibm ( sumy , IIc ( ie , jb : je , kb : ke ) * dy , ie , ie , jb , je , kb , ke , IIc ( ie , jb : je , kb : ke )) ! integrate fluid area at outflow plane in z do k = kb , ke sumy ( k ) = sumy ( k ) * dzf ( k ) end do area = sum ( sumy ( kb : ke )) end subroutine uoutletarea","tags":"","url":"proc/uoutletarea.html"},{"title":"voutletarea – uDALES","text":"public  subroutine voutletarea(area) Uses modfields modmpi modglobal proc~~voutletarea~~UsesGraph proc~voutletarea voutletarea module~modfields modfields proc~voutletarea->module~modfields module~modglobal modglobal proc~voutletarea->module~modglobal module~modmpi modmpi proc~voutletarea->module~modmpi decomp_2d decomp_2d module~modfields->decomp_2d mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(out) :: area Calls proc~~voutletarea~~CallsGraph proc~voutletarea voutletarea proc~sumx_ibm sumx_ibm proc~voutletarea->proc~sumx_ibm mpi_allreduce mpi_allreduce proc~sumx_ibm->mpi_allreduce Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~voutletarea~~CalledByGraph proc~voutletarea voutletarea proc~calcfluidvolumes calcfluidvolumes proc~calcfluidvolumes->proc~voutletarea program~dalesurban DALESURBAN program~dalesurban->proc~calcfluidvolumes Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine voutletarea ( area ) ! calculates outlet area of domain for v-velocity excluding blocks use modglobal , only : ib , ie , jb , je , kb , ke , dxf , dzf , jerank use modfields , only : IIc use modmpi , only : sumx_ibm implicit none real , intent ( out ) :: area real , dimension ( kb : ke ) :: sumx integer k sumx = 0. ! integrate fluid area at outflow plane in x ! Assumes je=jtot call sumx_ibm ( sumx , IIc ( ib : ie , je , kb : ke ) * dxf ( 1 ), ib , ie , je , je , kb , ke , IIc ( ib : ie , je , kb : ke )) ! integrate fluid area at outflow plane in z do k = kb , ke sumx ( k ) = sumx ( k ) * dzf ( k ) end do area = sum ( sumx ( kb : ke )) end subroutine voutletarea","tags":"","url":"proc/voutletarea.html"},{"title":"fluidvolume – uDALES","text":"public  subroutine fluidvolume(volume) Uses modfields modmpi modglobal proc~~fluidvolume~~UsesGraph proc~fluidvolume fluidvolume module~modfields modfields proc~fluidvolume->module~modfields module~modglobal modglobal proc~fluidvolume->module~modglobal module~modmpi modmpi proc~fluidvolume->module~modmpi decomp_2d decomp_2d module~modfields->decomp_2d mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(out) :: volume Calls proc~~fluidvolume~~CallsGraph proc~fluidvolume fluidvolume proc~avexy_ibm avexy_ibm proc~fluidvolume->proc~avexy_ibm mpi_allreduce mpi_allreduce proc~avexy_ibm->mpi_allreduce Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~fluidvolume~~CalledByGraph proc~fluidvolume fluidvolume proc~calcfluidvolumes calcfluidvolumes proc~calcfluidvolumes->proc~fluidvolume program~dalesurban DALESURBAN program~dalesurban->proc~calcfluidvolumes Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine fluidvolume ( volume ) ! calculates fluid volume of domain excluding blocks use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , dy , dxf , dzf use modfields , only : IIc , IIcs use modmpi , only : sumy_ibm , avexy_ibm implicit none real , intent ( out ) :: volume real , dimension ( ib : ie , kb : ke ) :: sumy real , dimension ( kb : ke + kh ) :: sumxy integer k sumy = 0. sumxy = 0. ! ! integrate fluid volume in y ! call sumy_ibm(sumy,IIc(ib:ie,jb:je,kb:ke)*dy,ib,ie,jb,je,kb,ke,IIc(ib:ie,jb:je,kb:ke)) ! ! ! integrate fluid area in x ! do k=kb,ke !   sumxy(k) = sum(sumy(ib:ie,k)*dxf(ib:ie)) ! end do ! Equidistant x call avexy_ibm ( sumxy ( kb : ke + kh ), IIc ( ib : ie , jb : je , kb : ke + kh ) * dxf ( 1 ) * dy , ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) ! integrate fluid area in z volume = sum ( sumxy ( kb : ke ) * dzf ( kb : ke )) end subroutine fluidvolume","tags":"","url":"proc/fluidvolume.html"},{"title":"calcfluidvolumes – uDALES","text":"public  subroutine calcfluidvolumes() Uses modfields proc~~calcfluidvolumes~~UsesGraph proc~calcfluidvolumes calcfluidvolumes module~modfields modfields proc~calcfluidvolumes->module~modfields decomp_2d decomp_2d module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~calcfluidvolumes~~CallsGraph proc~calcfluidvolumes calcfluidvolumes proc~fluidvolume fluidvolume proc~calcfluidvolumes->proc~fluidvolume proc~uoutletarea uoutletarea proc~calcfluidvolumes->proc~uoutletarea proc~voutletarea voutletarea proc~calcfluidvolumes->proc~voutletarea proc~avexy_ibm avexy_ibm proc~fluidvolume->proc~avexy_ibm proc~sumy_ibm sumy_ibm proc~uoutletarea->proc~sumy_ibm proc~sumx_ibm sumx_ibm proc~voutletarea->proc~sumx_ibm mpi_allreduce mpi_allreduce proc~avexy_ibm->mpi_allreduce proc~sumx_ibm->mpi_allreduce proc~sumy_ibm->mpi_allreduce Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~calcfluidvolumes~~CalledByGraph proc~calcfluidvolumes calcfluidvolumes program~dalesurban DALESURBAN program~dalesurban->proc~calcfluidvolumes Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine calcfluidvolumes !> calculates fluid volume and outlet areas, excluding blocks !> and saves it to variables from modfields use modfields , only : uoutarea , voutarea , fluidvol implicit none real :: volume ! calculate outlet area call uoutletarea ( volume ) uoutarea = volume ! calculate outlet area call voutletarea ( volume ) voutarea = volume ! calculate fluid volume call fluidvolume ( volume ) fluidvol = volume end subroutine calcfluidvolumes","tags":"","url":"proc/calcfluidvolumes.html"},{"title":"coriolis – uDALES","text":"public  subroutine coriolis() Uses modfields modmpi modglobal proc~~coriolis~~UsesGraph proc~coriolis coriolis module~modfields modfields proc~coriolis->module~modfields module~modglobal modglobal proc~coriolis->module~modglobal module~modmpi modmpi proc~coriolis->module~modmpi decomp_2d decomp_2d module~modfields->decomp_2d mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~coriolis~~CalledByGraph proc~coriolis coriolis program~dalesurban DALESURBAN program~dalesurban->proc~coriolis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine coriolis !-----------------------------------------------------------------| !                                                                 | !      Thijs Heus TU Delft                                        | !                                                                 | !     purpose.                                                    | !     --------                                                    | !                                                                 | !      Calculates the Coriolis force.                             | !                                                                 | !**   interface.                                                  | !     ----------                                                  | !                                                                 | !     *coriolis* is called from *program*.                        | !                                                                 | !-----------------------------------------------------------------| ! use modglobal, only : i1,j1,kmax,dzh,dzf,om22,om23 use modglobal , only : ib , ie , jb , je , kb , ke , kh , dzh , dzf , om22 , om23 , lcoriol , lprofforc , timee use modfields , only : u0 , v0 , w0 , up , vp , wp , ug , vg use modmpi , only : myid implicit none integer i , j , k , jm , jp , km , kp real , dimension ( kb : ke + kh ) :: ugg real om23g if ( lcoriol ) then ! if (myid==0) then !   write(*,*) \"up before coriol\",up(3,3,ke) ! end if do k = kb + 1 , ke kp = k + 1 km = k - 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie up ( i , j , k ) = up ( i , j , k ) & + (( v0 ( i , j , k ) + v0 ( i , jp , k ) + v0 ( i - 1 , j , k ) + v0 ( i - 1 , jp , k )) * om23 * 0.25 ) & - (( w0 ( i , j , k ) + w0 ( i , j , kp ) + w0 ( i - 1 , j , kp ) + w0 ( i - 1 , j , k )) * om22 * 0.25 ) vp ( i , j , k ) = vp ( i , j , k ) & - (( u0 ( i , j , k ) + u0 ( i , jm , k ) + u0 ( i + 1 , jm , k ) + u0 ( i + 1 , j , k )) * om23 * 0.25 ) wp ( i , j , k ) = wp ( i , j , k ) + (( ( dzf ( km ) * ( u0 ( i , j , k ) + u0 ( i + 1 , j , k ) ) & + dzf ( k ) * ( u0 ( i , j , km ) + u0 ( i + 1 , j , km )) ) / dzh ( k ) ) & * om22 * 0.25 ) end do end do ! -------------------------------------------end i&j-loop end do ! -------------------------------------------end k-loop ! -------------------------------------------- ! special treatment for lowest full level: k=1 ! -------------------------------------------- do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie up ( i , j , kb ) = up ( i , j , kb ) & + ( v0 ( i , j , kb ) + v0 ( i , jp , kb ) + v0 ( i - 1 , j , kb ) + v0 ( i - 1 , jp , kb )) * om23 * 0.25 & - ( w0 ( i , j , kb ) + w0 ( i , j , kb + 1 ) + w0 ( i - 1 , j , kb + 1 ) + w0 ( i - 1 , j , kb )) * om22 * 0.25 vp ( i , j , kb ) = vp ( i , j , kb ) & - ( u0 ( i , j , kb ) + u0 ( i , jm , kb ) + u0 ( i + 1 , jm , kb ) + u0 ( i + 1 , j , kb )) * om23 * 0.25 wp ( i , j , kb ) = 0.0 end do end do ! ----------------------------------------------end i,j-loop ! if (myid==0) then !   write(*,*) \"up after coriol\",up(3,3,ke) ! end if elseif ( lprofforc ) then ugg (:) = ug (:) om23g = om23 do k = kb + 1 , ke do j = jb , je do i = ib , ie up ( i , j , k ) = up ( i , j , k ) + om23g * ( ugg ( k ) - u0 ( i , j , k )) enddo enddo enddo ! -------------------------------------------- ! special treatment for lowest full level: k=1 ! -------------------------------------------- do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie up ( i , j , kb ) = up ( i , j , kb ) + om23g * ( ugg ( kb ) - u0 ( i , j , kb )) enddo enddo ! if (myid==0) then !   write(*,*) \"up after profforc\",up(3,3,ke) ! end if endif !lcoriol and lprofforc return end subroutine coriolis","tags":"","url":"proc/coriolis.html"},{"title":"lstend – uDALES","text":"public  subroutine lstend() Uses modfields modmpi modglobal proc~~lstend~~UsesGraph proc~lstend lstend module~modfields modfields proc~lstend->module~modfields module~modglobal modglobal proc~lstend->module~modglobal module~modmpi modmpi proc~lstend->module~modmpi decomp_2d decomp_2d module~modfields->decomp_2d mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~lstend~~CalledByGraph proc~lstend lstend program~dalesurban DALESURBAN program~dalesurban->proc~lstend Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine lstend !-----------------------------------------------------------------| !                                                                 | !*** *lstend*  calculates large-scale tendencies                  | !                                                                 | !      Pier Siebesma   K.N.M.I.     06/01/1995                    | !                                                                 | !     purpose.                                                    | !     --------                                                    | !                                                                 | !     calculates and adds large-scale tendencies due to           | !     large scale advection and subsidence.                       | !                                                                 | !**   interface.                                                  | !     ----------                                                  | !                                                                 | !             *lstend* is called from *program*.                  | !                                                                 | !-----------------------------------------------------------------| use modglobal , only : ib , ie , jb , je , kb , ke , kh , dzh , nsv , lmomsubs use modfields , only : up , vp , thlp , qtp , svp ,& whls , u0av , v0av , thl0av , qt0av , sv0av ,& dudxls , dudyls , dvdxls , dvdyls , dthldxls , dthldyls , dqtdxls , dqtdyls , dqtdtls use modmpi , only : myid implicit none integer k , n real subs_thl , subs_qt , subs_u , subs_v , subs_sv ! if (ltimedep) then !   ! call ls ! end if ! if (myid==0) then !   write(*,*) \"up before lstend\",up(3,3,ke) ! end if ! 1. DETERMINE LARGE SCALE TENDENCIES !    -------------------------------- ! 1.1 lowest model level above surface : only downward component subs_u = 0. subs_v = 0. subs_thl = 0. subs_qt = 0. subs_sv = 0. k = kb if ( whls ( k + 1 ). lt . 0 ) then !neglect effect of mean ascending on tendencies at the lowest full level subs_thl = whls ( k + 1 ) * ( thl0av ( k + 1 ) - thl0av ( k )) / dzh ( k + 1 ) ! tg3315 ils13 bss116 31/07/18 Dales 4.0 multiplies these by 0.5. To reduce subsidence towards the ground? Have removed subs_qt = whls ( k + 1 ) * ( qt0av ( k + 1 ) - qt0av ( k ) ) / dzh ( k + 1 ) if ( lmomsubs ) then subs_u = whls ( k + 1 ) * ( u0av ( k + 1 ) - u0av ( k ) ) / dzh ( k + 1 ) subs_v = whls ( k + 1 ) * ( v0av ( k + 1 ) - v0av ( k ) ) / dzh ( k + 1 ) endif do n = 1 , nsv subs_sv = whls ( k + 1 ) * ( sv0av ( k + 1 , n ) - sv0av ( k , n ) ) / dzh ( k + 1 ) ! svp(2:i1,2:j1,1,n) = svp(2:i1,2:j1,1,n)-subs_sv svp ( ib : ie , jb : je , kb , n ) = svp ( ib : ie , jb : je , kb , n ) - subs_sv enddo endif thlp ( ib : ie , jb : je , k ) = thlp ( ib : ie , jb : je , k ) - u0av ( k ) * dthldxls ( k ) - v0av ( k ) * dthldyls ( k ) - subs_thl qtp ( ib : ie , jb : je , k ) = qtp ( ib : ie , jb : je , k ) - u0av ( k ) * dqtdxls ( k ) - v0av ( k ) * dqtdyls ( k ) - subs_qt + dqtdtls ( k ) up ( ib : ie , jb : je , k ) = up ( ib : ie , jb : je , k ) - u0av ( k ) * dudxls ( k ) - v0av ( k ) * dudyls ( k ) - subs_u vp ( ib : ie , jb : je , k ) = vp ( ib : ie , jb : je , k ) - u0av ( k ) * dvdxls ( k ) - v0av ( k ) * dvdyls ( k ) - subs_v ! 1.2 other model levels twostream do k = kb + 1 , ke if ( whls ( k + 1 ). lt . 0 ) then !downwind scheme for subsidence subs_thl = whls ( k + 1 ) * ( thl0av ( k + 1 ) - thl0av ( k )) / dzh ( k + 1 ) subs_qt = whls ( k + 1 ) * ( qt0av ( k + 1 ) - qt0av ( k )) / dzh ( k + 1 ) do n = 1 , nsv subs_sv = whls ( k + 1 ) * ( sv0av ( k + 1 , n ) - sv0av ( k , n )) / dzh ( k + 1 ) svp ( ib : ie , jb : je , k , n ) = svp ( ib : ie , jb : je , k , n ) - subs_sv enddo if ( lmomsubs ) then subs_u = whls ( k + 1 ) * ( u0av ( k + 1 ) - u0av ( k )) / dzh ( k + 1 ) subs_v = whls ( k + 1 ) * ( v0av ( k + 1 ) - v0av ( k )) / dzh ( k + 1 ) endif else !downwind scheme for mean upward motions subs_thl = whls ( k ) * ( thl0av ( k ) - thl0av ( k - 1 )) / dzh ( k ) subs_qt = whls ( k ) * ( qt0av ( k ) - qt0av ( k - 1 )) / dzh ( k ) do n = 1 , nsv subs_sv = whls ( k ) * ( sv0av ( k , n ) - sv0av ( k - 1 , n )) / dzh ( k ) svp ( ib : ie , jb : je , k , n ) = svp ( ib : ie , jb : je , k , n ) - subs_sv enddo if ( lmomsubs ) then subs_u = whls ( k ) * ( u0av ( k ) - u0av ( k - 1 )) / dzh ( k ) subs_v = whls ( k ) * ( v0av ( k ) - v0av ( k - 1 )) / dzh ( k ) endif endif thlp ( ib : ie , jb : je , k ) = thlp ( ib : ie , jb : je , k ) - u0av ( k ) * dthldxls ( k ) - v0av ( k ) * dthldyls ( k ) - subs_thl qtp ( ib : ie , jb : je , k ) = qtp ( ib : ie , jb : je , k ) - u0av ( k ) * dqtdxls ( k ) - v0av ( k ) * dqtdyls ( k ) - subs_qt + dqtdtls ( k ) up ( ib : ie , jb : je , k ) = up ( ib : ie , jb : je , k ) - u0av ( k ) * dudxls ( k ) - v0av ( k ) * dudyls ( k ) - subs_u vp ( ib : ie , jb : je , k ) = vp ( ib : ie , jb : je , k ) - u0av ( k ) * dvdxls ( k ) - v0av ( k ) * dvdyls ( k ) - subs_v enddo return end subroutine lstend","tags":"","url":"proc/lstend.html"},{"title":"nudge – uDALES","text":"public  subroutine nudge() Uses modfields modmpi modglobal proc~~nudge~~UsesGraph proc~nudge nudge module~modfields modfields proc~nudge->module~modfields module~modglobal modglobal proc~nudge->module~modglobal module~modmpi modmpi proc~nudge->module~modmpi decomp_2d decomp_2d module~modfields->decomp_2d mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~nudge~~CalledByGraph proc~nudge nudge program~dalesurban DALESURBAN program~dalesurban->proc~nudge Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine nudge use modglobal , only : kb , ke , lmoist , ltempeq , lnudge , lnudgevel , tnudge , nnudge , numol , nsv use modfields , only : thlp , qtp , svp , sv0av , thl0av , qt0av , up , vp , u0av , v0av , uprof , vprof , thlprof , qtprof , svprof use modmpi , only : myid implicit none integer :: k , n if ( lnudge . eqv . . false .) return if ( lnudgevel ) then do k = kb + nnudge , ke up (:,:, k ) = up (:,:, k ) - ( u0av ( k ) - uprof ( k )) / tnudge vp (:,:, k ) = vp (:,:, k ) - ( v0av ( k ) - vprof ( k )) / tnudge end do end if do n = 1 , nsv do k = kb + nnudge , ke svp (:,:, k , n ) = svp (:,:, k , n ) - ( sv0av ( k , n ) - svprof ( k , n )) / tnudge end do end do if ( ltempeq ) then do k = kb + nnudge , ke thlp (:,:, k ) = thlp (:,:, k ) - ( thl0av ( k ) - thlprof ( k )) / tnudge end do end if !ltempeq if ( lmoist ) then do k = kb + nnudge , ke qtp (:,:, k ) = qtp (:,:, k ) - ( qt0av ( k ) - qtprof ( k )) / tnudge end do end if !lmoist end subroutine nudge","tags":"","url":"proc/nudge.html"},{"title":"periodicEBcorr – uDALES","text":"public  subroutine periodicEBcorr() Uses modglobal modmpi modfields proc~~periodicebcorr~~UsesGraph proc~periodicebcorr periodicEBcorr module~modfields modfields proc~periodicebcorr->module~modfields module~modglobal modglobal proc~periodicebcorr->module~modglobal module~modmpi modmpi proc~periodicebcorr->module~modmpi decomp_2d decomp_2d module~modfields->decomp_2d mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~periodicebcorr~~CallsGraph proc~periodicebcorr periodicEBcorr mpi_allreduce mpi_allreduce proc~periodicebcorr->mpi_allreduce Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~periodicebcorr~~CalledByGraph proc~periodicebcorr periodicEBcorr program~dalesurban DALESURBAN program~dalesurban->proc~periodicebcorr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine periodicEBcorr ! added by cew216 ! ! use a volume sink to counter a  heat/moisture flux from the SEB ! ! sink acts above buildings ! ! use initfac, only :  max_height_index use modfields , only : thlp , qtp !use modglobal, only: ltempeq, lperiodicEBcorr, ib, ie, jb, je, kb, ke, imax, jtot use modglobal , only : ltempeq , lmoist , lperiodicEBcorr , ib , ie , jb , je , kb , ke ,& itot , jtot , totheatflux , sinkbase , totqflux , & zh , dx , dy , dzh , fraction use modmpi , only : comm3d , mpierr , MY_REAL , myid , MPI_SUM ! integer :: i , j , k , n , M real :: tot_Tflux , tot_qflux , sensible_heat_out , latent_heat_out , R_theta , R_q , H_proj , E_proj , R_theta_scaled , R_q_scaled , abl_height , phi_theta_t , phi_q_t !, !tot_qflux !, sink_points ! !write(*,*) 'lperiodicEBcorr ', lperiodicEBcorr !write(*,*) 'fraction', fraction if ( lperiodicEBcorr . eqv . . false .) return ! !call MPI_ALLREDUCE(bctfluxsum,   tot_Tflux,1,MY_REAL,MPI_SUM,comm3d,mpierr) !call MPI_ALLREDUCE(bcqfluxsum,   tot_qflux,1,MY_REAL,MPI_SUM,comm3d,mpierr) call MPI_ALLREDUCE ( totheatflux , tot_Tflux , 1 , MY_REAL , MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( totqflux , tot_qflux , 1 , MY_REAL , MPI_SUM , comm3d , mpierr ) ! Grylls 2021;  R=(phitop-phibot)/l= -phibot/hABL ! Since tot_Tflux = phibot/LxLydeltaV ! according to  M if use new tot_Tflux then we have phibot = tot_heatflux/lxly ! then define phitop = (1-frac)phibot ! R = frac*(phitop-phibot)/l ! then needs scaling because of the sink based! code this and comment it. !name sinkbase with a k so we now its a vertical index !!!! The point is to define phitop phibot and R above the loop so the stuff in the loop looks like the eqns. ! Do the same for humidity ! This follows the work in Grylls 2021 H_proj = tot_Tflux / ( itot * jtot ) ! [Kms&#94;-1]This is total heat flux in divided by the domain cross section. E_proj = tot_qflux / ( itot * jtot ) abl_height = ke / fraction ! We reverse engineer the ABL height from domain height and fraction R_theta = H_proj / abl_height ![Ks&#94;-1] This is the forcing F\\theta from Grylls 2021 R_q = E_proj / abl_height ! Ke is the number of points in the vertical over which we would apply R if we included the canopy M = ke - ( sinkbase + 1 ) + 1 ! The number of points over which we will apply rscaled. We only apply the forcing above the canopy so it has to be made bigger. R_theta_scaled = R_theta * ke / ( M ) ! [Ks&#94;-1]The forcing is scaled up beacuse we do not apply it to the whole volume, only to points above the canopy. We add one to sinkbase to be above the buildings and add 1 to (ke-(sinkbase+1)) to correctly count the points. R_q_scaled = R_q * ke / ( M ) !phi_theta_t = 0 ! For debugging the flux profile !(1-fraction)*H_proj! The heat flux out the top of the domain. phi_theta_t = ( 1 - fraction ) * H_proj phi_q_t = ( 1 - fraction ) * E_proj if ( ltempeq ) then do i = ib , ie do j = jb , je do k = sinkbase + 1 , ke !max_height_index +1 , ke ! Only apply the correction over the volume above the buidlings !thlp(i,j,k) = thlp(i,j,k) + fraction*tot_Tflux*(zh(k+1)-zh(k))/(imax*jtot*(zh(ke+1) - zh(max_height_index+1))) !thlp(i,j,k) = thlp(i,j,k) - fraction*tot_Tflux/(itot*jtot*(ke-sinkbase)) ! Most recent working version pre M changes cew216 20240112 thlp ( i , j , k ) = thlp ( i , j , k ) + R_theta_scaled end do end do end do !end if !sensible_heat_out = (1-fraction)*tot_Tflux/(itot*jtot) do i = ib , ie do j = jb , je thlp ( i , j , ke ) = thlp ( i , j , ke ) + phi_theta_t end do end do end if ! ! ! if ( lmoist ) then do i = ib , ie do j = jb , je do k = sinkbase + 1 , ke ! Only apply the correction over the volume above the buidlings !qtp(i,j,k) = qtp(i,j,k) + fraction*tot_qflux*(zh(k+1)-zh(k))/(imax*jtot*(zh(ke+1) - zh(max_height_index+1))) !qtp(i,j,k) = qtp(i,j,k) - fraction*tot_qflux/(itot*jtot*(ke-sinkbase)) qtp ( i , j , k ) = qtp ( i , j , k ) + R_q_scaled end do end do end do latent_heat_out = ( 1 - fraction ) * tot_qflux / ( itot * jtot * ( zh ( ke + 1 ) - zh ( ke ))) do i = ib , ie do j = jb , je qtp ( i , j , ke ) = qtp ( i , j , ke ) + phi_q_t end do end do end if ! !write(*,*) 'fraction', fraction end subroutine periodicEBcorr","tags":"","url":"proc/periodicebcorr.html"},{"title":"shiftedPBCs – uDALES","text":"public  subroutine shiftedPBCs() Uses modfields decomp_2d modglobal proc~~shiftedpbcs~~UsesGraph proc~shiftedpbcs shiftedPBCs decomp_2d decomp_2d proc~shiftedpbcs->decomp_2d module~modfields modfields proc~shiftedpbcs->module~modfields module~modglobal modglobal proc~shiftedpbcs->module~modglobal module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~shiftedpbcs~~CallsGraph proc~shiftedpbcs shiftedPBCs zstart zstart proc~shiftedpbcs->zstart Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~shiftedpbcs~~CalledByGraph proc~shiftedpbcs shiftedPBCs program~dalesurban DALESURBAN program~dalesurban->proc~shiftedpbcs Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine shiftedPBCs ! Nudge the flow in a region near the outlet use modglobal , only : ib , itot , ie , jb , je , kb , ke , xh , ds , dyi , xlen , rk3step , dt , pi use modfields , only : u0 , v0 , w0 , u0av , up , vp , wp , vm use decomp_2d , only : zstart integer :: i , j , k , ig real :: vs , RHS , rk3coef if ( ds > 0 ) then rk3coef = dt / ( 4. - dble ( rk3step )) do i = ib , ie ig = i + zstart ( 1 ) - 1 ! global i position if ( ig > int ( itot / 2 )) then do j = jb , je do k = kb , ke vs = 0.5 * pi * ds / ( 0.5 * xlen ) * u0av ( k ) * sin ( pi * ( xh ( ig ) - xh ( int ( itot / 2 ))) / ( 0.5 * xlen )) up ( i , j , k ) = up ( i , j , k ) - vs * ( u0 ( i , j , k ) - u0 ( i , j - 1 , k )) * dyi vp ( i , j , k ) = vp ( i , j , k ) - vs * ( v0 ( i , j , k ) - v0 ( i , j - 1 , k )) * dyi wp ( i , j , k ) = wp ( i , j , k ) - vs * ( w0 ( i , j , k ) - w0 ( i , j - 1 , k )) * dyi end do end do end if end do end if end subroutine shiftedPBCs","tags":"","url":"proc/shiftedpbcs.html"},{"title":"writerestartfiles – uDALES","text":"public  subroutine writerestartfiles() Uses modmpi modsubgriddata modsurfdata mpi modfields initfac modibmdata modinletdata modglobal proc~~writerestartfiles~~UsesGraph proc~writerestartfiles writerestartfiles module~initfac initfac proc~writerestartfiles->module~initfac module~modfields modfields proc~writerestartfiles->module~modfields module~modglobal modglobal proc~writerestartfiles->module~modglobal module~modibmdata modibmdata proc~writerestartfiles->module~modibmdata module~modinletdata modinletdata proc~writerestartfiles->module~modinletdata module~modmpi modmpi proc~writerestartfiles->module~modmpi module~modsubgriddata modsubgriddata proc~writerestartfiles->module~modsubgriddata module~modsurfdata modsurfdata proc~writerestartfiles->module~modsurfdata mpi mpi proc~writerestartfiles->mpi module~initfac->module~modglobal module~initfac->module~modmpi module~initfac->mpi netcdf netcdf module~initfac->netcdf decomp_2d decomp_2d module~modfields->decomp_2d module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~writerestartfiles~~CallsGraph proc~writerestartfiles writerestartfiles mpi_abort mpi_abort proc~writerestartfiles->mpi_abort mpi_bcast mpi_bcast proc~writerestartfiles->mpi_bcast Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~writerestartfiles~~CalledByGraph proc~writerestartfiles writerestartfiles proc~inletgen inletgen proc~inletgen->proc~writerestartfiles proc~inletgennotemp inletgennotemp proc~inletgennotemp->proc~writerestartfiles program~dalesurban DALESURBAN program~dalesurban->proc~writerestartfiles Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine writerestartfiles use mpi use modsurfdata , only : ustar , thlflux , qtflux , svflux , dudz , dvdz , dthldz , dqtdz , ps , thls , qts , thvs , oblav use modfields , only : u0 , v0 , w0 , thl0 , qt0 , ql0 , ql0h , e120 , dthvdz , presf , presh , sv0 , mindist , wall ,& uav , vav , wav , uuav , vvav , wwav , uvav , uwav , vwav , thlav , thl2av , qtav , qlav , ql2av , qt2av , svav , sv2av , momthick ,& friction , displthick , pres0 , viscratioav , thluav , thlvav , thlwav , qtuav , qtvav , qtwav , qluav , qlvav , qlwav , svuav , svvav , svwav ,& upupav , vpvpav , wpwpav , thlpthlpav , qlpqlpav , qtpqtpav , svpsvpav , upvpav , upwpav , vpwpav , thlpupav , thlpvpav ,& thlpwpav , qlpupav , qlpvpav , qlpwpav , qtpupav , qtpvpav , qtpwpav , svpupav , svpvpav , svpwpav , presav ,& uusgsav , vvsgsav , wwsgsav , uwsgsav , thlusgsav , thlwsgsav , qlusgsav , qlwsgsav , qtusgsav , qtwsgsav , svusgsav , svwsgsav , tkesgsav ,& strain2av , disssgsav , t_vav , tvmx , tvmy , tvmz , tsgsmx1 , tsgsmx2 , tsgsmy1 , tsgsmy2 , tsgsmz1 ,& tsgsmz2 , t_sgsav , nusgsav , tpm , t_pav , ttmx , ttmy , ttmz , t_tav , p_bav , d_sgsav , p_tav , tkeadv use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , trestart , tnextrestart , dt_lim , timee , btime , xh ,& cexpnr , ntimee , rk3step , ifoutput , nsv , timeleft , dt , ntrun , totavtime ,& iinletgen , timee , runavtime , inletav , totinletav , linletRA , ltempeq , lmoist ,& dzf , dzfi , dzhi , dxf , dxfi , dyi , dxhi , nstore , numol , dy2i , grav , libm , jmax , nblocks use modmpi , only : cmyid , cmyidx , cmyidy , myid , slabsum , excjs , comm3d use modsubgriddata , only : ekm use modibmdata , only : ibmxforcevol use initfac , only : block use modinletdata , only : Urec , Wrec , Uinl , Utav , QLinl , QTinl , QLrec , QTrec , QTtav , QLtav , Ttav , upupavinl , vpvpavinl , wpwpavinl , upwpavinl ,& thlpthlpavinl , thlpupavinl , thlpwpavinl , qlpqlpavinl , qlpupavinl , qlpwpavinl , qtpqtpavinl , qtpupavinl , qtpwpavinl , Tinl , Trec , nstepread implicit none logical :: lexitnow = . false . integer imin , ihour integer i , j , k , n , im , ip , jm , jp , jpp , km , kp , kpp , il , iu , jl , ju , kl , ku character ( 25 ) name , name2 , name3 , name4 , linkname integer :: ierr , err_code if ( timee == 0 ) return !    if (rk3step /=3) return if (( iinletgen == 2 ) . and . ( nstepread == nstore )) then ! This overrules the need for rk3step to be 3 in case of reading inletfiles write ( 6 , * ) 'Writing restartfiles after reading in new inletfiles' else if ( rk3step /= 3 ) return ! Normal check end if if ( myid == 0 ) then name = 'exit_now.' // cexpnr inquire ( file = trim ( name ), EXIST = lexitnow ) end if call MPI_Bcast ( lexitnow , 1 , MPI_LOGICAL , 0 , comm3d , ierr ) if ( ierr /= 0 ) then if ( myid == 0 ) then print * , \"Error in MPI Broadcast!\" end if err_code = ierr call MPI_Abort ( MPI_COMM_WORLD , err_code , ierr ) end if if ((( timee >= tnextrestart )) . or . (( lexitnow ) . or . ( nstepread == nstore + 1 ))) then tnextrestart = tnextrestart + trestart name = 'initd        _   _   .' write ( name ( 6 : 13 ) , '(i8.8)' ) ntrun name ( 15 : 17 ) = cmyidx name ( 19 : 21 ) = cmyidy name ( 23 : 25 ) = cexpnr open ( ifoutput , file = name , form = 'unformatted' , status = 'replace' ) write ( ifoutput ) ((( mindist ( i , j , k ), i = ib , ie ), j = jb , je ), k = kb , ke ) write ( ifoutput ) (((( wall ( i , j , k , n ), i = ib , ie ), j = jb , je ), k = kb , ke ), n = 1 , 5 ) write ( ifoutput ) ((( u0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) write ( ifoutput ) ((( v0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) write ( ifoutput ) ((( w0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) write ( ifoutput ) ((( pres0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) write ( ifoutput ) ((( thl0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) write ( ifoutput ) ((( e120 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) write ( ifoutput ) ((( ekm ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) write ( ifoutput ) ((( qt0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) write ( ifoutput ) ((( ql0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) write ( ifoutput ) ((( ql0h ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) write ( ifoutput ) timee , dt if ( myid == 0 ) then write ( * , * ) '-------------------------' write ( * , * ) 'Saving initd restart file' write ( * , * ) 'ntrun ::: ' , ntrun write ( * , * ) 'timee ::: ' , timee write ( * , * ) '-------------------------' endif close ( ifoutput ) if ( nsv > 0 ) then name = 'inits        _   _   .' write ( name ( 6 : 13 ) , '(i8.8)' ) ntrun name ( 15 : 17 ) = cmyidx name ( 19 : 21 ) = cmyidy name ( 23 : 25 ) = cexpnr open ( ifoutput , file = name , form = 'unformatted' ) write ( ifoutput ) (((( sv0 ( i , j , k , n ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ), n = 1 , nsv ) write ( ifoutput ) timee close ( ifoutput ) end if if ( myid == 0 ) then write ( * , '(A,F15.7,A,I4)' ) 'dump at time = ' , timee , ' unit = ' , ifoutput end if end if end subroutine writerestartfiles","tags":"","url":"proc/writerestartfiles.html"},{"title":"initchecksim – uDALES","text":"public  subroutine initchecksim() Uses modmpi modglobal proc~~initchecksim~~UsesGraph proc~initchecksim initchecksim module~modglobal modglobal proc~initchecksim->module~modglobal module~modmpi modmpi proc~initchecksim->module~modmpi mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~initchecksim~~CallsGraph proc~initchecksim initchecksim mpi_bcast mpi_bcast proc~initchecksim->mpi_bcast Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~initchecksim~~CalledByGraph proc~initchecksim initchecksim program~dalesurban DALESURBAN program~dalesurban->proc~initchecksim Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Namelists Namelist NAMCHECKSIM Variables Name Type Default Description tcheck real 0. Source Code subroutine initchecksim use modglobal , only : ifnamopt , fname_options , dtmax , ladaptive , btime use modmpi , only : myid , my_real , comm3d , mpierr implicit none integer :: ierr namelist / NAMCHECKSIM / & tcheck if ( myid == 0 ) then open ( ifnamopt , file = fname_options , status = 'old' , iostat = ierr ) read ( ifnamopt , NAMCHECKSIM , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions NAMCHECKSIM' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif !write(6 ,NAMCHECKSIM) close ( ifnamopt ) if ((. not . ladaptive ) . and . ( tcheck < dtmax )) then tcheck = dtmax end if end if call MPI_BCAST ( tcheck , 1 , MY_REAL , 0 , comm3d , mpierr ) !    itcheck = floor(tcheck/tres) tnext = tcheck + btime end subroutine initchecksim","tags":"","url":"proc/initchecksim.html"},{"title":"checksim – uDALES","text":"public  subroutine checksim() Uses modmpi modglobal proc~~checksim~~UsesGraph proc~checksim checksim module~modglobal modglobal proc~checksim->module~modglobal module~modmpi modmpi proc~checksim->module~modmpi mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~checksim~~CallsGraph proc~checksim checksim proc~calccourant calccourant proc~checksim->proc~calccourant proc~calcdiffnr calcdiffnr proc~checksim->proc~calcdiffnr proc~chkdiv chkdiv proc~checksim->proc~chkdiv mpi_allreduce mpi_allreduce proc~calccourant->mpi_allreduce proc~calcdiffnr->mpi_allreduce proc~chkdiv->mpi_allreduce Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~checksim~~CalledByGraph proc~checksim checksim program~dalesurban DALESURBAN program~dalesurban->proc~checksim Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine checksim use modglobal , only : timee , rk3step , dt_lim , dt use modmpi , only : myid implicit none character ( 20 ) :: timeday if ( timee == 0.0 ) return if ( rk3step /= 3 ) return dtmn = dtmn + dt ; ndt = ndt + 1. if ( timee < tnext ) return tnext = tnext + tcheck dtmn = dtmn / ndt if ( myid == 0 ) then call date_and_time ( time = timeday ) write ( * , * ) '=================================================================' write ( * , '(3A,F15.5,A,F12.9)' ) 'Time of Day: ' , timeday ( 1 : 10 ), '    Time of Simulation: ' , timee , '    dt: ' , dtmn end if call calccourant call calcdiffnr call chkdiv dtmn = 0. ndt = 0. end subroutine checksim","tags":"","url":"proc/checksim.html"},{"title":"calccourant – uDALES","text":"private  subroutine calccourant() Uses modfields modmpi modglobal proc~~calccourant~~UsesGraph proc~calccourant calccourant module~modfields modfields proc~calccourant->module~modfields module~modglobal modglobal proc~calccourant->module~modglobal module~modmpi modmpi proc~calccourant->module~modmpi decomp_2d decomp_2d module~modfields->decomp_2d mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~calccourant~~CallsGraph proc~calccourant calccourant mpi_allreduce mpi_allreduce proc~calccourant->mpi_allreduce Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~calccourant~~CalledByGraph proc~calccourant calccourant proc~checksim checksim proc~checksim->proc~calccourant program~dalesurban DALESURBAN program~dalesurban->proc~checksim Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine calccourant use modglobal , only : ib , ie , jb , je , kb , ke , kh , dxhi , dyi , dzhi , dt , timee use modfields , only : um , vm , wm use modmpi , only : myid , comm3d , mpierr , mpi_max , my_real implicit none real :: courtotl , courtot integer :: i , j , k courtotl = 0.0 courtot = 0.0 do k = kb , ke do j = jb , je do i = ib , ie courtotl = max ( courtotl ,( um ( i , j , k ) * dxhi ( i ) + vm ( i , j , k ) * dyi + wm ( i , j , k ) * dzhi ( k )) * dtmn ) end do end do end do call MPI_ALLREDUCE ( courtotl , courtot , 1 , MY_REAL , MPI_MAX , comm3d , mpierr ) if ( myid == 0 ) then write ( * , '(A,ES10.2)' ) 'Courant numbers (x,y,z,tot):' , courtot end if return end subroutine calccourant","tags":"","url":"proc/calccourant.html"},{"title":"calcdiffnr – uDALES","text":"private  subroutine calcdiffnr() Uses modmpi modsubgriddata modglobal proc~~calcdiffnr~~UsesGraph proc~calcdiffnr calcdiffnr module~modglobal modglobal proc~calcdiffnr->module~modglobal module~modmpi modmpi proc~calcdiffnr->module~modmpi module~modsubgriddata modsubgriddata proc~calcdiffnr->module~modsubgriddata mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~calcdiffnr~~CallsGraph proc~calcdiffnr calcdiffnr mpi_allreduce mpi_allreduce proc~calcdiffnr->mpi_allreduce Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~calcdiffnr~~CalledByGraph proc~calcdiffnr calcdiffnr proc~checksim checksim proc~checksim->proc~calcdiffnr program~dalesurban DALESURBAN program~dalesurban->proc~checksim Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine calcdiffnr use modglobal , only : ib , ie , jb , je , kb , ke , kh , dxh2i , dy2i , dzh , dt , timee use modsubgriddata , only : ekm , ekh use modmpi , only : myid , comm3d , mpierr , mpi_max , my_real implicit none real diffnrtotl , diffnrtot integer :: i , j , k diffnrtotl = 0. diffnrtot = 0. do k = kb , ke do j = jb , je do i = ib , ie !      diffnrtotl = max(diffnrtotl,  ekm(i,j,k)*(1/dzh(k)**2 + dxh2i(i) + dy2i)*dtmn )  ! or should I interpolate ekm to the correct position? diffnrtotl = max ( diffnrtotl , ekm ( i , j , k ) * ( 1 / dzh ( k ) ** 2 + dxh2i ( i ) + dy2i ) * dtmn , & ekh ( i , j , k ) * ( 1 / dzh ( k ) ** 2 + dxh2i ( i ) + dy2i ) * dtmn ) ! or should I interpolate ekm to the correct position? end do end do end do call MPI_ALLREDUCE ( diffnrtotl , diffnrtot , 1 , MY_REAL , MPI_MAX , comm3d , mpierr ) if ( myid == 0 ) then write ( 6 , '(A,ES10.2)' ) 'Diffusion number:' , diffnrtot end if return end subroutine calcdiffnr","tags":"","url":"proc/calcdiffnr.html"},{"title":"calcreyn – uDALES","text":"private  subroutine calcreyn() Uses modfields modmpi modsubgriddata modglobal proc~~calcreyn~~UsesGraph proc~calcreyn calcreyn module~modfields modfields proc~calcreyn->module~modfields module~modglobal modglobal proc~calcreyn->module~modglobal module~modmpi modmpi proc~calcreyn->module~modmpi module~modsubgriddata modsubgriddata proc~calcreyn->module~modsubgriddata decomp_2d decomp_2d module~modfields->decomp_2d mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~calcreyn~~CallsGraph proc~calcreyn calcreyn mpi_allreduce mpi_allreduce proc~calcreyn->mpi_allreduce Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine calcreyn use modglobal , only : ib , ie , jb , je , ke , kb , dy , dxh , dzh use modfields , only : u0 , v0 , w0 use modmpi , only : myid , comm3d , mpi_sum , mpi_max , my_real , mpierr use modsubgriddata , only : ekm , ekh implicit none real reyntotl , reyntot integer :: i , j , k reyntotl = 0. reyntot = 0. do k = kb , ke do j = jb , je do i = ib , ie reyntotl = max ( reyntotl , u0 ( i , j , k ) * dxh ( i ) / ekm ( i , j , k ), v0 ( i , j , k ) * dy / ekm ( i , j , k ), & w0 ( i , j , k ) * dzh ( k ) / ekm ( i , j , k )) ! or should I interpolate ekm to the correct position? end do end do end do call MPI_ALLREDUCE ( reyntotl , reyntot , 1 , MY_REAL , MPI_MAX , comm3d , mpierr ) if ( myid == 0 ) then write ( 6 , '(A,ES10.2)' ) 'Cell Reynolds number:' , reyntot end if end subroutine calcreyn","tags":"","url":"proc/calcreyn.html"},{"title":"chkdiv – uDALES","text":"private  subroutine chkdiv() Uses modfields modmpi modglobal proc~~chkdiv~~UsesGraph proc~chkdiv chkdiv module~modfields modfields proc~chkdiv->module~modfields module~modglobal modglobal proc~chkdiv->module~modglobal module~modmpi modmpi proc~chkdiv->module~modmpi decomp_2d decomp_2d module~modfields->decomp_2d mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~chkdiv~~CallsGraph proc~chkdiv chkdiv mpi_allreduce mpi_allreduce proc~chkdiv->mpi_allreduce Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~chkdiv~~CalledByGraph proc~chkdiv chkdiv proc~checksim checksim proc~checksim->proc~chkdiv program~dalesurban DALESURBAN program~dalesurban->proc~checksim Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine chkdiv use modglobal , only : ib , ie , jb , je , ke , kb , dx , dxi , dy , dyi , dzf , dzfi use modfields , only : u0 , v0 , w0 !,divergentie use modmpi , only : myid , comm3d , mpi_sum , mpi_max , my_real , mpierr implicit none real div , divmax , divtot real divmaxl , divtotl integer i , j , k divmax = 0. divtot = 0. divmaxl = 0. divtotl = 0. do k = kb , ke do j = jb , je do i = ib , ie div = & ( u0 ( i + 1 , j , k ) - u0 ( i , j , k ) ) * dxi + & ( v0 ( i , j + 1 , k ) - v0 ( i , j , k ) ) * dyi + & ( w0 ( i , j , k + 1 ) - w0 ( i , j , k ) ) * dzfi ( k ) !      divergentie(i,j,k)=div divmaxl = max ( divmaxl , abs ( div )) divtotl = divtotl + div * dx * dy * dzf ( k ) end do end do end do call MPI_ALLREDUCE ( divtotl , divtot , 1 , MY_REAL , & MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( divmaxl , divmax , 1 , MY_REAL , & MPI_MAX , comm3d , mpierr ) if ( myid == 0 ) then write ( 6 , '(A,2ES11.2)' ) 'divmax, divtot = ' , divmax , divtot end if return end subroutine chkdiv","tags":"","url":"proc/chkdiv.html"},{"title":"inittest – uDALES","text":"public  subroutine inittest() Arguments None Calls proc~~inittest~~CallsGraph proc~inittest inittest decomp_2d_init decomp_2d_init proc~inittest->decomp_2d_init mpi_init mpi_init proc~inittest->mpi_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine inittest integer :: nx = 64 , ny = 64 , nz = 64 !integer :: p_row=2, p_col=2 integer :: p_row = 0 , p_col = 0 integer :: ierror call MPI_INIT ( ierror ) !call MPI_COMM_RANK(MPI_COMM_WORLD,nrank,ierr) !call MPI_COMM_SIZE(MPI_COMM_WORLD,nproc,ierr) !call decomp_2d_init(nx,ny,nz,p_row,p_col) call decomp_2d_init ( nx , ny , nz , p_row , p_col ) write ( * , * ) xstart write ( * , * ) ystart write ( * , * ) zstart write ( * , * ) xend write ( * , * ) yend write ( * , * ) zend write ( * , * ) xsize write ( * , * ) ysize write ( * , * ) zsize end subroutine inittest","tags":"","url":"proc/inittest.html"},{"title":"exittest – uDALES","text":"public  subroutine exittest() Arguments None Calls proc~~exittest~~CallsGraph proc~exittest exittest decomp_2d_finalize decomp_2d_finalize proc~exittest->decomp_2d_finalize mpi_finalize mpi_finalize proc~exittest->mpi_finalize Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine exittest integer :: ierror call decomp_2d_finalize call MPI_FINALIZE ( ierror ) end subroutine exittest","tags":"","url":"proc/exittest.html"},{"title":"initinlet – uDALES","text":"public  subroutine initinlet() Uses modfields modmpi modglobal proc~~initinlet~~UsesGraph proc~initinlet initinlet module~modfields modfields proc~initinlet->module~modfields module~modglobal modglobal proc~initinlet->module~modglobal module~modmpi modmpi proc~initinlet->module~modmpi decomp_2d decomp_2d module~modfields->decomp_2d mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~initinlet~~CallsGraph proc~initinlet initinlet proc~readzincoord readzincoord proc~initinlet->proc~readzincoord mpi_bcast mpi_bcast proc~readzincoord->mpi_bcast Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine initinlet use modglobal , only : ih , ib , ie , jh , jb , je , kb , ke , kh , iinletgen , iplane , xf , lstoreplane , nstore , Uinf , ltempeq , pi , zf , zh use modfields , only : um use modmpi , only : myid , nprocs implicit none real :: pfi , epsi integer :: k if ( iinletgen == 1 ) then allocate ( Utav ( ib : ie , kb : ke )) allocate ( Uinl ( kb : ke )) allocate ( Winl ( kb : ke + 1 )) allocate ( Urec ( kb : ke )) allocate ( Wrec ( kb : ke + 1 )) allocate ( u0inletbc ( jb : je , kb : ke )) allocate ( v0inletbc ( jb : je , kb : ke )) allocate ( w0inletbc ( jb : je , kb : ke + 1 )) allocate ( u0inletbcold ( jb : je , kb : ke )) allocate ( v0inletbcold ( jb : je , kb : ke )) allocate ( w0inletbcold ( jb : je , kb : ke + 1 )) allocate ( uminletbc ( jb : je , kb : ke )) allocate ( vminletbc ( jb : je , kb : ke )) allocate ( wminletbc ( jb : je , kb : ke + 1 )) allocate ( uaver ( ib : ie , kb : ke )) allocate ( zirf ( kb : ke )) allocate ( ziif ( kb : ke )) allocate ( zirh ( kb : ke + 1 )) allocate ( ziih ( kb : ke + 1 )) allocate ( zorf ( kb : ke )) allocate ( zoif ( kb : ke )) allocate ( zorh ( kb : ke + 1 )) allocate ( zoih ( kb : ke + 1 )) allocate ( loclowif ( kb : ke )) allocate ( locupif ( kb : ke )) allocate ( loclowih ( kb : ke + 1 )) allocate ( locupih ( kb : ke + 1 )) allocate ( loclowof ( kb : ke )) allocate ( locupof ( kb : ke )) allocate ( loclowoh ( kb : ke + 1 )) allocate ( locupoh ( kb : ke + 1 )) allocate ( displ ( ib : ie )) allocate ( displold ( ib : ie )) allocate ( upupavinl ( kb : ke )) allocate ( vpvpavinl ( kb : ke )) allocate ( wpwpavinl ( kb : ke )) allocate ( upwpavinl ( kb : ke )) allocate ( thlpthlpavinl ( kb : ke )) allocate ( thlpupavinl ( kb : ke )) allocate ( thlpwpavinl ( kb : ke )) allocate ( heavif ( kb : ke )) allocate ( heavih ( kb : ke + 1 )) if ( lstoreplane ) then allocate ( storeu0inletbc ( jb : je , kb : ke , 1 : nstore )) allocate ( storev0inletbc ( jb : je , kb : ke , 1 : nstore )) allocate ( storew0inletbc ( jb : je , kb : ke + 1 , 1 : nstore )) end if epsi = 0.25 * di do k = kb , ke pfi = zf ( k ) - 1.2 * di - epsi if ( pfi < - epsi ) then heavif ( k ) = 1. elseif ( pfi <= epsi ) then heavif ( k ) = 0.5 * ( 1. - ( pfi / epsi ) - ( 1. / pi ) * sin ( pi * pfi / epsi )) elseif ( pfi > epsi ) then heavif ( k ) = 0. end if end do do k = kb , ke + 1 pfi = zh ( k ) - 1.2 * di - epsi if ( pfi < - epsi ) then heavih ( k ) = 1. elseif ( pfi <= epsi ) then heavih ( k ) = 0.5 * ( 1. - ( pfi / epsi ) - ( 1. / pi ) * sin ( pi * pfi / epsi )) elseif ( pfi > epsi ) then heavih ( k ) = 0. end if end do if ( ltempeq ) then allocate ( Ttav ( ib : ie , kb : ke )) allocate ( taver ( ib : ie , kb : ke )) allocate ( Tinl ( kb : ke )) allocate ( Trec ( kb : ke )) allocate ( t0inletbc ( jb : je , kb : ke )) allocate ( t0inletbcold ( jb : je , kb : ke )) allocate ( tminletbc ( jb : je , kb : ke )) allocate ( zotr ( kb : ke )) allocate ( zoti ( kb : ke )) allocate ( loclowot ( kb : ke )) allocate ( locupot ( kb : ke )) allocate ( heavit ( kb : ke )) if ( lstoreplane ) then allocate ( storet0inletbc ( jb : je , kb : ke , 1 : nstore )) end if ! Heaviside function for temperature epsi = 0.25 * dti do k = kb , ke pfi = zf ( k ) - 1.2 * dti - epsi if ( pfi < - epsi ) then heavit ( k ) = 1. elseif ( pfi <= epsi ) then heavit ( k ) = 0.5 * ( 1. - ( pfi / epsi ) - ( 1. / pi ) * sin ( pi * pfi / epsi )) elseif ( pfi > epsi ) then heavit ( k ) = 0. end if end do end if displ = 0. displold = 0. irecy = ib + iplane ! index of recycle plane equals iplane (read from namoptions) xfm = sum ( xf ( ib : ie )) / ( ie - ib + 1 ) ! mean(xf) xf2m = sum ( xf ( ib : ie ) ** 2. ) / ( ie - ib + 1 ) ! mean(xf&#94;2) !  btime = timee                              ! this is done to make sure btime is set when avint is computed correctly at startup (only for RA) else if ( iinletgen == 2 ) then allocate ( storeu0inletbc ( jb : je , kb : ke , 1 : nstore )) allocate ( storev0inletbc ( jb : je , kb : ke , 1 : nstore )) allocate ( storew0inletbc ( jb : je , kb : ke + 1 , 1 : nstore )) allocate ( u0rot ( 1 : nstore , jb - jh : je + jh , kb : ke )) allocate ( v0rot ( 1 : nstore , jb - jh : je + jh , kb : ke )) allocate ( u0inletbc ( jb : je , kb : ke )) allocate ( v0inletbc ( jb : je , kb : ke )) allocate ( w0inletbc ( jb : je , kb : ke + 1 )) allocate ( u0inletbcold ( jb : je , kb : ke )) allocate ( v0inletbcold ( jb : je , kb : ke )) allocate ( w0inletbcold ( jb : je , kb : ke + 1 )) allocate ( uminletbc ( jb : je , kb : ke )) allocate ( vminletbc ( jb : je , kb : ke )) allocate ( wminletbc ( jb : je , kb : ke + 1 )) if ( ltempeq ) then allocate ( storet0inletbc ( jb : je , kb : ke , 1 : nstore )) allocate ( t0inletbc ( jb : je , kb : ke )) allocate ( t0inletbcold ( jb : je , kb : ke )) allocate ( tminletbc ( jb : je , kb : ke )) end if !iangle = iangledeg * pi / 180.  ! convert degrees to radians irecy = ib + iplane ! read coordinates of inletprofile call readzincoord !    ddispdx      = 0.00038/Uinf        ! this value should becomputed from the w0 computed in the inletgenerator ddispdx = wtop / Uinf ! wtop is read from zgrid.inf ddispdxold = ddispdx ! this value should becomputed from the w0 computed in the inletgenerator !    inlfactor    = nprocs/nprocsinl     ! nprocs should be larger or equal to nprocsin! !    write(6,*) 'inlfactor= ',inlfactor else return end if end subroutine initinlet","tags":"","url":"proc/initinlet.html"},{"title":"inletgen – uDALES","text":"public  subroutine inletgen() Uses modmpi modsurfdata modsave modglobal modfields proc~~inletgen~~UsesGraph proc~inletgen inletgen module~modfields modfields proc~inletgen->module~modfields module~modglobal modglobal proc~inletgen->module~modglobal module~modmpi modmpi proc~inletgen->module~modmpi module~modsave modsave proc~inletgen->module~modsave module~modsurfdata modsurfdata proc~inletgen->module~modsurfdata decomp_2d decomp_2d module~modfields->decomp_2d mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~inletgen~~CallsGraph proc~inletgen inletgen proc~blthicknesst blthicknesst proc~inletgen->proc~blthicknesst proc~dispthicknessexp dispthicknessexp proc~inletgen->proc~dispthicknessexp proc~enthalpythickness enthalpythickness proc~inletgen->proc~enthalpythickness proc~momentumthicknessexp momentumthicknessexp proc~inletgen->proc~momentumthicknessexp proc~readinletfile readinletfile proc~inletgen->proc~readinletfile proc~slabsum slabsum proc~inletgen->proc~slabsum proc~wallawinlet wallawinlet proc~inletgen->proc~wallawinlet proc~writeinletfile writeinletfile proc~inletgen->proc~writeinletfile proc~writerestartfiles writerestartfiles proc~inletgen->proc~writerestartfiles proc~excjs excjs proc~readinletfile->proc~excjs proc~yinterpolate yinterpolate proc~readinletfile->proc~yinterpolate proc~zinterpolate zinterpolate proc~readinletfile->proc~zinterpolate proc~zinterpolatet zinterpolatet proc~readinletfile->proc~zinterpolatet proc~zinterpolatew zinterpolatew proc~readinletfile->proc~zinterpolatew mpi_allreduce mpi_allreduce proc~slabsum->mpi_allreduce mpi_abort mpi_abort proc~writerestartfiles->mpi_abort mpi_bcast mpi_bcast proc~writerestartfiles->mpi_bcast mpi_isend mpi_isend proc~excjs->mpi_isend mpi_recv mpi_recv proc~excjs->mpi_recv mpi_wait mpi_wait proc~excjs->mpi_wait Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine inletgen use modglobal , only : ib , ie , jb , je , jtot , kb , ke , zf , zh , dzf , dzhi , timee , btime , totavtime , rk3step , dt , numol , iplane , lles , iinletgen , inletav , runavtime , Uinf , lwallfunc , linletRA , totinletav , lstoreplane , nstore , prandtlmoli , numol , grav , lbuoyancy , lfixinlet , luvolflowr , lfixutauin use modfields , only : u0 , v0 , w0 , thl0 , wm , uprof use modsurfdata , only : thls , thl_top use modsave , only : writerestartfiles use modmpi , only : slabsum , myid implicit none real , dimension ( ib : ib , jb : je , kb : ke ) :: uinletbc2 ! dummy variable real , dimension ( ib : ib , jb : je , kb : ke ) :: tinletbc2 ! dummy variable real , dimension ( jb : je , kb : ke ) :: uprec ! velocity fluctuation (up_rec = u0 - Urec) real , dimension ( jb : je , kb : ke ) :: vprec ! velocity fluctuation (vp_rec = v0 - 0) real , dimension ( jb : je , kb : ke + 1 ) :: wprec ! velocity fluctuation (wp_rec = w0 - Wrec) real , dimension ( jb : je , kb : ke ) :: tprec ! temperature fluctuation (tp_rec = t0 - Trec) real , dimension ( jb : je , kb : ke ) :: upinli , vpinli ! = gamma * (uprec,v interpolated to zii grid) real , dimension ( jb : je , kb : ke ) :: tpinli ! = lambda  * (tprec   interpolated to zii grid) real , dimension ( jb : je , kb : ke ) :: upinlo , vpinlo ! = gamma * (uprec,v interpolated to zoi grid) real , dimension ( jb : je , kb : ke ) :: tpinlo ! = lambda  * (tprec   interpolated to zoti grid) real , dimension ( jb : je , kb : ke + 1 ) :: wpinli ! = gamma * (wprec   interpolated to zii grid) real , dimension ( jb : je , kb : ke + 1 ) :: wpinlo ! = gamma * (wprec   interpolated to zoi grid) real , dimension ( kb : ke ) :: udiff ! difference between Uinl and Urec !    real,dimension(kb:ke)   :: Urecdiff                ! difference between Urec new and old real , dimension ( kb : ke ) :: urav ! j-averaged u-velocity (not time-averaged) real , dimension ( kb : ke ) :: trav ! j-averaged temperature (not time-averaged) real , dimension ( kb : ke ) :: uravdzf ! j-averaged u-velocity (not time-averaged) times dzf real , dimension ( kb : ke ) :: uinldzf ! j-averaged u-velocity (not time-averaged) times dzf real , dimension ( kb : ke ) :: Urecdzf ! Urec times dzf real , dimension ( kb : ke + 1 ) :: wrav ! j-averaged w-velocity (not time-averaged) real , dimension ( kb : ke ) :: Uinli ! = gamma * (Urec interpolated to ziif grid points) real , dimension ( kb : ke + 1 ) :: Winli ! = gamma * (Wrec interpolated to ziih grid points) real , dimension ( kb : ke ) :: Tinli ! = lambda  * (Trec interpolated to ziif grid points) real , dimension ( kb : ke ) :: Uinlo ! = gamma * (Urec interpolated to zioif grid points) real , dimension ( kb : ke + 1 ) :: Winlo ! = gamma * (Wrec interpolated to zoih grid points) real , dimension ( kb : ke ) :: Tinlo ! = lambda  * (Trec interpolated to zoti grid points) real , dimension ( kb : ke ) :: wfuncf ! weight function at full level real , dimension ( kb : ke + 1 ) :: wfunch ! weight function at half level real , dimension ( kb : ke ) :: wfunct ! weight function at full level real :: utaur2 , utaui2 ! (utau)&#94;2 at recycle station and inlet real :: gamm ! utaui / utaur real :: lamb ! ttaui / ttaur real :: avint , avinti ! avering interval real :: alpha , beta ! factors used in the Weight function !    real                    :: totalu                  ! total u-velocity at outlet real :: Urectot ! total u-velocity at recycle plane real :: rk3coef !    real                    :: di_test                 ! BL thickness as measured from Uinl real :: utop ! j-averaged top velocity real :: interval real :: dtinrk ! RK time step in inlet data real :: rk3coefin ! Cumulative RK time step in inlet data real :: dr_old real :: scalef ! scale factor to scale instantaneous velocity profile with to get constant mass flux real :: totaluinl ! bulk velocity at the inlet !    real                    :: q0                      ! heat flux integer i , j , k , kk , kdamp if ( iinletgen == 1 ) then u0inletbcold = u0inletbc v0inletbcold = v0inletbc w0inletbcold = w0inletbc t0inletbcold = t0inletbc ! temperature totaluold = totalu displold = displ ddispdxold = ddispdx ! compute time-average velocities rk3coef = dt / ( 4. - dble ( rk3step )) if ( rk3step == 1 ) then deltat = rk3coef elseif ( rk3step == 2 ) then deltat = rk3coef - ( dt / 3. ) elseif ( rk3step == 3 ) then deltat = rk3coef - ( dt / 2. ) end if if ( linletRA ) then ! this is a switch to use 'running average' avint = totinletav + timee - btime ! runav interval = averaging interval previuous sim  + current elapsed sim time else avint = inletav end if avinti = 1. / avint uaver = 0. taver = 0. do i = ib , ie call slabsum ( uaver ( i ,:), kb , ke , u0 ( i : i , jb : je , kb : ke ), i , i , jb , je , kb , ke , i , i , jb , je , kb , ke ) call slabsum ( taver ( i ,:), kb , ke , thl0 ( i : i , jb : je , kb : ke ), i , i , jb , je , kb , ke , i , i , jb , je , kb , ke ) end do wrav = 0. call slabsum ( wrav ( kb : ke + 1 ), kb , ke , w0 ( irecy - 1 : irecy - 1 , jb : je , kb : ke + 1 ), irecy - 1 , irecy - 1 , jb , je , kb , ke + 1 , irecy - 1 , irecy - 1 , jb , je , kb , ke + 1 ) trav = 0. call slabsum ( trav ( kb : ke ), kb , ke , thl0 ( irecy - 1 : irecy - 1 , jb : je , kb : ke ), irecy - 1 , irecy - 1 , jb , je , kb , ke , irecy - 1 , irecy - 1 , jb , je , kb , ke ) uaver = uaver / jtot ! average over j-direction taver = taver / jtot ! average over j-direction urav = uaver ( irecy ,:) wrav = wrav / jtot ! average over j-direction trav = trav / jtot ! average over j-direction do k = kb , ke Urec ( k ) = urav ( k ) * deltat * avinti + ( 1. - deltat * avinti ) * Urec ( k ) Trec ( k ) = trav ( k ) * deltat * avinti + ( 1. - deltat * avinti ) * Trec ( k ) end do do k = kb , ke + 1 Wrec ( k ) = wrav ( k ) * deltat * avinti + ( 1. - deltat * avinti ) * Wrec ( k ) end do do k = kb , ke do i = ib , ie Utav ( i , k ) = uaver ( i , k ) * deltat * avinti + ( 1. - deltat * avinti ) * Utav ( i , k ) Ttav ( i , k ) = taver ( i , k ) * deltat * avinti + ( 1. - deltat * avinti ) * Ttav ( i , k ) end do end do !    Urec = Urec +(Uinf-Urec(ke))     ! make sure at the recycle plane the top velocity equals Uinf !    Urecdiff = Urecdiff - Urec !    if (myid==0) then !      write(6,*) 'Urec_old - Urec_new (kb+40)=',Urecdiff(kb+40) !    end if !! check if Urec contains NaN !    if (myid==0) then !      write(6,*) 'Checking Urec for NaN' !      do k=kb,ke !        if (ISNAN(Urec(k))) then !          write(6,*) 'Urec(k)=NaN at k=kb+', k-kb !        end if !      end do !      write(6,*) 'Finished checking Urec for NaN' !    end if !    if (myid==0) then !      write(6,*) 'myid, Urec(ke)=',myid, Urec(ke) !      write(6,*) 'wrav(ke), Wrec(ke)=',wrav(ke), Wrec(ke) !      write(6,*) 'wrav(ke-1), Wrec(ke-1)=',wrav(ke-1), Wrec(ke-1) !      write(6,*) 'wrav(ke-10), Wrec(ke-10)=',wrav(ke-10), Wrec(ke-10) !      write(6,*) 'wrav(ke-30), Wrec(ke-30)=',wrav(ke-30), Wrec(ke-30) !      write(6,*) 'wrav(kb+10), Wrec(kb+10)=',wrav(kb+10), Wrec(kb+10) !      write(6,*) 'wrav(kb+11), Wrec(kb+11)=',wrav(kb+11), Wrec(kb+11) !    end if ! compute velocity fluctuation at recycle station do k = kb , ke do j = jb , je uprec ( j , k ) = u0 ( irecy , j , k ) - Urec ( k ) vprec ( j , k ) = v0 ( irecy - 1 , j , k ) ! mean v is zero tprec ( j , k ) = thl0 ( irecy - 1 , j , k ) - Trec ( k ) end do end do do k = kb , ke + 1 do j = jb , je wprec ( j , k ) = w0 ( irecy - 1 , j , k ) - Wrec ( k ) ! note that w-velocity is taken at i=irecy-1 !! end do end do if ( lwallfunc ) then call wallawinlet ( Urec ( kb ), dzf ( kb ), numol , utaur2 ) ! compute wall shear stress at recycle station else utaur2 = 2. * numol * Urec ( kb ) / dzf ( kb ) end if utaur = sqrt ( abs ( utaur2 )) ! compute utau at recycle station ! heat flux at recycle station (isothermal wall) q = alpha * dT/dz = (nu/prandtl) * dT/dz !    q0 = numol*prandtlmoli*(Trec(kb) - Trec(kb-1)) * dzhi(kb) q0 = numol * prandtlmoli * 2 * ( Trec ( kb ) - thls ) / dzf ( kb ) ttaur = q0 / utaur ! ttau = q/(rho*cp*utau) =  (alpha *dT/dz) / utau ! compute momentum thickness at inlet and recycle plane if ( lbuoyancy ) then lmor = ( thls * utaur ** 2 ) / ( 0.41 * grav * ttaur ) ! L = -T0*utau&#94;3 / kappa*g*<w'T'> = !     write(6,*) 'Initial dr,myid, utaur, ttaur, Lmor =', dr,myid,utaur,ttaur,lmor !     lmor = 0.3; lmoi = ( thls * utaui ** 2 ) / ( 0.41 * grav * ttaui ) ! L = -T0*utau&#94;3 / kappa*g*<w'T'> = !     lmoi = 0.3; !     write(6,*) 'Initial di_test,myid, utaui, ttaui, Lmoi =', di_test,myid,utaui,ttaui,lmoi dr_old = dr !     call blthicknessmo(dr,utaur,lmor)                    ! Also needed for momentumthickness call blthicknesst ( dr , Urec , 0.99 ) ! changed back to this one (instead of the above) !     call momentumthicknessmo(thetai,utaui,di,lmoi) !     call momentumthicknessmo(thetar,utaur,dr,lmor) call momentumthicknessexp ( thetai , Uinl ) call momentumthicknessexp ( thetar , Urec ) else !     call blthickness(dr,utaur)                           ! Also needed for momentumthickness call blthicknesst ( dr , Urec , 0.99 ) !     call momentumthickness(thetai,utaui,di) !     call momentumthickness(thetar,utaur,dr) call momentumthicknessexp ( thetai , Uinl ) call momentumthicknessexp ( thetar , Urec ) end if call enthalpythickness ( thetati , Tinl , Uinl ) call enthalpythickness ( thetatr , Trec , Urec ) !   call blthickness(dr,utaur) call blthicknesst ( dtr , Trec - thls , 0.99 ) ! compute utau at inlet from interior field !    if (thetai == 0.) then !      write(6,*) '!!! thetai = 0, myid=',myid !    else if (thetar == 0.) then !      write(6,*) '!!! thetar = 0, myid=',myid !      thetar=0.00001 !    else !      utaui = utaur* (thetar/thetai)**(1./8.)    ! See Lund (1998): 'Similar to Ludwig-Tillmann correlation' if (. not . lfixutauin ) then utaui = utaur * abs ( thetar / thetai ) ** ( 1. / 8. ) ! See Lund (1998): 'Similar to Ludwig-Tillmann correlation' end if if ( thetati == 0. ) then thetati = 0.0000001 end if ttaui = ttaur * abs ( thetatr / thetati ) ** ( 1. / 8. ) ! See Kong (2000): !    end if gamm = utaui / utaur ! Gamma in Lund (1998) if ( ttaur == 0. ) then ttaur = 0.0000001 end if lamb = ttaui / ttaur ! Lambda in Kong (2000) ! compute inner scaling coordinates zirf = utaur * zf / numol ! inner scaling zf-coordinate at recycle station zirh = utaur * zh / numol ! inner scaling zh-coordinate at recycle station ziif = utaui * zf / numol ! inner scaling zf-coordinate at inlet station ziih = utaui * zh / numol ! inner scaling zh-coordinate at inlet station ! compute outer scaling coordinates zorf = zf / dr ! outer scaling zf-coor as measured from Uinldinate at recycle station zorh = zh / dr ! outer scaling zh-coordinate at recycle station zoif = zf / di ! outer scaling zf-coordinate at inlet station  (could be done once, actually..) zoih = zh / di ! outer scaling zf-coordinate at inlet station  (could be done once, actually..) zotr = zf / dtr ! temperature outer scaling zf-coordinate at recycle station zoti = zf / dti ! temperature outer scaling zf-coordinate at inlet station !!!!! Interpolation starts here !!! First inner coordinates ! determine which elements are needed when recycle velocity profile is interpolated on inlet plane ! for u(,v)-components (zf) do k = kb , ke do kk = kb , ke if ( zirf ( kk ) >= ziif ( k )) then locupif ( k ) = kk loclowif ( k ) = kk - 1 exit elseif ( kk == ke ) then locupif ( k ) = ke + 1 ! this means extrapolation! loclowif ( k ) = ke - 1 ! waarom niet ke? of wordt dit niet gebruikt? end if end do end do ! for w-components (zh) do k = kb , ke + 1 do kk = kb , ke + 1 if ( zirh ( kk ) >= ziih ( k )) then locupih ( k ) = kk loclowih ( k ) = kk - 1 exit elseif ( kk == ke + 1 ) then locupih ( k ) = ke + 2 ! this means extrapolation! loclowih ( k ) = ke end if end do end do !!! Finished with inner coordinates !!! Do the same trick for outer coordinates ! determine which elements are needed when recycle velocity profile is interpolated on inlet plane ! for u(,v)-components (zf) do k = kb , ke do kk = kb , ke if ( zorf ( kk ) >= zoif ( k )) then locupof ( k ) = kk loclowof ( k ) = kk - 1 exit elseif ( kk == ke ) then locupof ( k ) = ke + 1 ! this means extrapolation! loclowof ( k ) = ke - 1 end if end do end do ! for w-components (zh) do k = kb , ke + 1 do kk = kb , ke + 1 if ( zorh ( kk ) >= zoih ( k )) then locupoh ( k ) = kk loclowoh ( k ) = kk - 1 exit elseif ( kk == ke + 1 ) then locupoh ( k ) = ke + 2 ! this means extrapolation! loclowoh ( k ) = ke end if end do end do !!! Finished with outer coordinates !!! Outer coordinates for temperature do k = kb , ke do kk = kb , ke if ( zotr ( kk ) >= zoti ( k )) then locupot ( k ) = kk loclowot ( k ) = kk - 1 exit elseif ( kk == ke ) then locupot ( k ) = ke + 1 ! this means extrapolation! loclowot ( k ) = ke - 1 end if end do end do !!! Finished with outer coordinates temperature !!! Now really interpolate !!! First inner coordinates ! compute Urec on zii grid do k = kb , ke if ( locupif ( k ) == ke + 1 ) then ! indicator for extrapolation! !        Uinli(k) = Urec(ke) + (Urec(ke) - Urec(ke-1)) / (zirf(ke)-zirf(ke-1)) * (ziif(k)-zirf(ke)) Uinli ( k ) = Urec ( ke ) Tinli ( k ) = Trec ( ke ) elseif ( loclowif ( k ) == kb - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) Uinli ( k ) = Urec ( kb ) / zirf ( kb ) * ziif ( k ) !        Tinli(k) = thls + Trec(kb)/zirf(kb)*ziif(k) !        Tinli(k) = (Trec(kb)-thls)/zirf(kb)*ziif(k) Tinli ( k ) = thls + ( Trec ( kb ) - thls ) / zirf ( kb ) * ziif ( k ) else ! normal interpolation Uinli ( k ) = Urec ( loclowif ( k )) + ( Urec ( locupif ( k )) - Urec ( loclowif ( k ))) / ( zirf ( locupif ( k )) - zirf ( loclowif ( k ))) * ( ziif ( k ) - zirf ( loclowif ( k ))) Tinli ( k ) = Trec ( loclowif ( k )) + ( Trec ( locupif ( k )) - Trec ( loclowif ( k ))) / ( zirf ( locupif ( k )) - zirf ( loclowif ( k ))) * ( ziif ( k ) - zirf ( loclowif ( k ))) if (( ziif ( k ) . gt . zirf ( locupif ( k ))) . or . ( ziif ( k ) . lt . zirf ( loclowif ( k )))) then write ( 6 , * ) '!!!Mistake in Interpolation !!!!' end if end if end do ! compute Wrec on zii grid Winli ( kb ) = 0.0 ! corresponds to ground level do k = kb + 1 , ke + 1 if ( locupih ( k ) == ke + 2 ) then ! indicator for extrapolation! !        Winli(k) = Wrec(ke+1) + (Wrec(ke+1) - Wrec(ke)) / (zirh(ke+1)-zirh(ke)) * (ziih(k)-zirh(ke+1)) Winli ( k ) = Wrec ( ke + 1 ) else ! normal interpolation Winli ( k ) = Wrec ( loclowih ( k )) + ( Wrec ( locupih ( k )) - Wrec ( loclowih ( k ))) / ( zirh ( locupih ( k )) - zirh ( loclowih ( k ))) * ( ziih ( k ) - zirh ( loclowih ( k ))) end if end do ! compute u- and v- and t-fluctuation on zii grid do k = kb , ke if ( locupif ( k ) == ke + 1 ) then ! indicator for extrapolation! !        upinli(:,k) = uprec(:,ke) + (uprec(:,ke) - uprec(:,ke-1)) / (zirf(ke)-zirf(ke-1)) * (ziif(k)-zirf(ke)) upinli (:, k ) = 0. vpinli (:, k ) = 0. tpinli (:, k ) = 0. elseif ( loclowif ( k ) == kb - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) upinli (:, k ) = uprec (:, kb ) / zirf ( kb ) * ziif ( k ) vpinli (:, k ) = vprec (:, kb ) / zirf ( kb ) * ziif ( k ) tpinli (:, k ) = tprec (:, kb ) / zirf ( kb ) * ziif ( k ) else ! normal interpolation upinli (:, k ) = uprec (:, loclowif ( k )) + ( uprec (:, locupif ( k )) - uprec (:, loclowif ( k ))) / ( zirf ( locupif ( k )) - zirf ( loclowif ( k ))) * ( ziif ( k ) - zirf ( loclowif ( k ))) vpinli (:, k ) = vprec (:, loclowif ( k )) + ( vprec (:, locupif ( k )) - vprec (:, loclowif ( k ))) / ( zirf ( locupif ( k )) - zirf ( loclowif ( k ))) * ( ziif ( k ) - zirf ( loclowif ( k ))) tpinli (:, k ) = tprec (:, loclowif ( k )) + ( tprec (:, locupif ( k )) - tprec (:, loclowif ( k ))) / ( zirf ( locupif ( k )) - zirf ( loclowif ( k ))) * ( ziif ( k ) - zirf ( loclowif ( k ))) end if end do ! compute w-fluctuation on zii grid do k = kb + 1 , ke + 1 !      if (locupih(k) == ke+1) then      ! indicator for extrapolation! if ( locupih ( k ) == ke + 2 ) then ! indicator for extrapolation! !        wpinli(:,k) = wprec(:,ke+1) + (wprec(:,ke+1) - wprec(:,ke)) / (zirh(ke+1)-zirh(ke)) * (ziih(k)-zirh(ke+1)) wpinli (:, k ) = 0. else ! normal interpolation wpinli (:, k ) = wprec (:, loclowih ( k )) + ( wprec (:, locupih ( k )) - wprec (:, loclowih ( k ))) / ( zirh ( locupih ( k )) - zirh ( loclowih ( k ))) * ( ziih ( k ) - zirh ( loclowih ( k ))) end if end do !! Finished with interpolating inner variables !! Continue with interpolating outer variables ! compute Urec on zoi grid do k = kb , ke if ( locupof ( k ) == ke + 1 ) then ! indicator for extrapolation! !        Uinlo(k) = Urec(ke) + (Urec(ke) - Urec(ke-1)) / (zorf(ke)-zorf(ke-1)) * (zoif(k)-zorf(ke)) !        Uinlo(k) = Urec(ke) Uinlo ( k ) = Uinf elseif ( loclowof ( k ) == kb - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) Uinlo ( k ) = Urec ( kb ) / zorf ( kb ) * zoif ( k ) else ! normal interpolation Uinlo ( k ) = Urec ( loclowof ( k )) + ( Urec ( locupof ( k )) - Urec ( loclowof ( k ))) / ( zorf ( locupof ( k )) - zorf ( loclowof ( k ))) * ( zoif ( k ) - zorf ( loclowof ( k ))) end if end do ! compute Wrec on zii grid Winlo ( kb ) = 0.0 ! corresponds to ground level do k = kb + 1 , ke + 1 if ( locupoh ( k ) == ke + 2 ) then ! indicator for extrapolation! !        Winlo(k) = Wrec(ke+1) + (Wrec(ke+1) - Wrec(ke)) / (zorh(ke+1)-zorh(ke)) * (zoih(k)-zorh(ke+1)) Winlo ( k ) = Wrec ( ke + 1 ) else ! normal interpolation Winlo ( k ) = Wrec ( loclowoh ( k )) + ( Wrec ( locupoh ( k )) - Wrec ( loclowoh ( k ))) / ( zorh ( locupoh ( k )) - zorh ( loclowoh ( k ))) * ( zoih ( k ) - zorh ( loclowoh ( k ))) end if end do ! compute u- and v-fluctuation on zoi grid do k = kb , ke if ( locupof ( k ) == ke + 1 ) then ! indicator for extrapolation! !        upinlo(:,k) = uprec(:,ke) + (uprec(:,ke) - uprec(:,ke-1)) / (zorf(ke)-zorf(ke-1)) * (zoif(k)-zorf(ke)) upinlo (:, k ) = 0. vpinlo (:, k ) = 0. elseif ( loclowof ( k ) == kb - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) upinlo (:, k ) = uprec (:, kb ) / zorf ( kb ) * zoif ( k ) vpinlo (:, k ) = vprec (:, kb ) / zorf ( kb ) * zoif ( k ) else ! normal interpolation upinlo (:, k ) = uprec (:, loclowof ( k )) + ( uprec (:, locupof ( k )) - uprec (:, loclowof ( k ))) / ( zorf ( locupof ( k )) - zorf ( loclowof ( k ))) * ( zoif ( k ) - zorf ( loclowof ( k ))) vpinlo (:, k ) = vprec (:, loclowof ( k )) + ( vprec (:, locupof ( k )) - vprec (:, loclowof ( k ))) / ( zorf ( locupof ( k )) - zorf ( loclowof ( k ))) * ( zoif ( k ) - zorf ( loclowof ( k ))) end if end do ! compute w-fluctuation on zoi grid do k = kb + 1 , ke + 1 if ( locupoh ( k ) == ke + 2 ) then ! indicator for extrapolation! !        wpinlo(:,k) = wprec(:,ke+1) + (wprec(:,ke+1) - wprec(:,ke)) / (zorh(ke+1)-zorh(ke)) * (zoih(k)-zorh(ke+1)) wpinlo (:, k ) = 0. else ! normal interpolation wpinlo (:, k ) = wprec (:, loclowoh ( k )) + ( wprec (:, locupoh ( k )) - wprec (:, loclowoh ( k ))) / ( zorh ( locupoh ( k )) - zorh ( loclowoh ( k ))) * ( zoih ( k ) - zorh ( loclowoh ( k ))) end if end do !! Finished interpolating outer velocity variables !! Interpolating outer temperature ! mean temperature do k = kb , ke if ( locupot ( k ) == ke + 1 ) then ! indicator for extrapolation! Tinlo ( k ) = thl_top elseif ( loclowot ( k ) == kb - 1 ) then ! interprets this as extrapolation to bottom (use Tinlo=thls at z+=0) !        Tinlo(k) = Trec(kb)/zotr(kb) * zoti(k) !        Tinlo(k) = (Trec(kb)-thls)/zotr(kb) * zoti(k) Tinlo ( k ) = thls + ( Trec ( kb ) - thls ) / zotr ( kb ) * zoti ( k ) else ! normal interpolation Tinlo ( k ) = Trec ( loclowot ( k )) + ( Trec ( locupot ( k )) - Trec ( loclowot ( k ))) / ( zotr ( locupot ( k )) - zotr ( loclowot ( k ))) * ( zoti ( k ) - zotr ( loclowot ( k ))) end if end do ! fluctuating temperature do k = kb , ke if ( locupot ( k ) == ke + 1 ) then ! indicator for extrapolation! !        upinlo(:,k) = uprec(:,ke) + (uprec(:,ke) - uprec(:,ke-1)) / (zorf(ke)-zorf(ke-1)) * (zoif(k)-zorf(ke)) tpinlo (:, k ) = 0. elseif ( loclowot ( k ) == kb - 1 ) then ! interprets this as extrapolation to bottom (use t=0 at z+=0) tpinlo (:, k ) = tprec (:, kb ) / zotr ( kb ) * zoti ( k ) else ! normal interpolation tpinlo (:, k ) = tprec (:, loclowot ( k )) + ( tprec (:, locupot ( k )) - tprec (:, loclowot ( k ))) / ( zotr ( locupot ( k )) - zotr ( loclowot ( k ))) * ( zoti ( k ) - zotr ( loclowot ( k ))) end if end do !! Finished interpolating out temperature !!!!! Finished Interpolation! !!!!! ! compute rescaled inner variables ! Winli = Winli (interpolation is enough) Uinli = gamm * Uinli Tinli = lamb * Tinli + ( 1. - lamb ) * thls ! this is different for isoflux wall! upinli = gamm * upinli vpinli = gamm * vpinli wpinli = gamm * wpinli tpinli = lamb * tpinli ! See Kong (2000) ! compute rescaled outer variables ! Winlo = Winlo (interpolation is enough) Uinlo = gamm * Uinlo + ( 1. - gamm ) * Uinf Tinlo = lamb * Tinlo + ( 1. - lamb ) * thl_top !    Uinlo = gamm* Uinlo  + (1.- gamm)*Urec(ke) upinlo = gamm * upinlo vpinlo = gamm * vpinlo wpinlo = gamm * wpinlo tpinlo = lamb * tpinlo ! See Kong (2000) !    utop = Uinlo(ke) !    Uinlo = Uinlo +(Uinf-utop)     ! make sure at the inlet the mean top velocity equals Uinf !! add defect velocity to make sure the j-averaged velocity at the top equals Uinf !    utop = Uinlo(ke) !    do k=kb,ke !        Uinlo(k) = Uinlo(k)*Uinf/utop !    end do ! Compute weight function (alpha=4, b=0.2) alpha = 4. beta = 0.2 wfuncf = 0.5 * ( 1. + tanh ( alpha * ( zoif - beta ) / (( 1. - 2. * beta ) * zoif + beta ) ) / tanh ( alpha ) ) ! for full level height wfunch = 0.5 * ( 1. + tanh ( alpha * ( zoih - beta ) / (( 1. - 2. * beta ) * zoih + beta ) ) / tanh ( alpha ) ) ! for half level height wfunct = 0.5 * ( 1. + tanh ( alpha * ( zoti - beta ) / (( 1. - 2. * beta ) * zoti + beta ) ) / tanh ( alpha ) ) ! for temperature (full level height) do k = kb , ke if ( wfuncf ( k ) . gt . 1. ) then wfuncf ( k ) = 1. end if if ( wfunct ( k ) . gt . 1. ) then wfunct ( k ) = 1. end if end do do k = kb , ke + 1 if ( wfunch ( k ) . gt . 1. ) then wfunch ( k ) = 1. end if end do !    write(6,*) 'maxval(wfuncf)=', maxval(wfuncf) !    write(6,*) 'maxval(wfunch)=', maxval(wfunch) ! Compute the velocity components for the inlet BC do k = kb , ke do j = jb , je !      u0inletbc(j,k) = (Uinli(k)+ upinli(j,k))*(1.-wfuncf(k)) +  (Uinlo(k) + upinlo(j,k))* wfuncf(k) !      v0inletbc(j,k) =            vpinli(j,k) *(1.-wfuncf(k)) +              vpinlo(j,k) * wfuncf(k) !      t0inletbc(j,k) = (Tinli(k)+ tpinli(j,k))*(1.-wfunct(k)) +  (Tinlo(k) + tpinlo(j,k))* wfunct(k) u0inletbc ( j , k ) = ( Uinli ( k ) + upinli ( j , k ) * heavif ( k )) * ( 1. - wfuncf ( k )) + ( Uinlo ( k ) + upinlo ( j , k ) * heavif ( k )) * wfuncf ( k ) v0inletbc ( j , k ) = vpinli ( j , k ) * heavif ( k ) * ( 1. - wfuncf ( k )) + vpinlo ( j , k ) * heavif ( k ) * wfuncf ( k ) t0inletbc ( j , k ) = ( Tinli ( k ) + tpinli ( j , k ) * heavit ( k )) * ( 1. - wfunct ( k )) + ( Tinlo ( k ) + tpinlo ( j , k ) * heavit ( k )) * wfunct ( k ) end do end do do k = kb , ke + 1 do j = jb , je w0inletbc ( j , k ) = ( Winli ( k ) + wpinli ( j , k ) * heavih ( k )) * ( 1 - wfunch ( k )) + ( Winlo ( k ) + wpinlo ( j , k ) * heavih ( k )) * wfunch ( k ) end do end do w0inletbc (:, kb ) = 0. w0inletbc (:, ke + 1 ) = 0. !!    kdamp = kb + floor(0.75*(ke-kb+1)) !    kdamp = kb + 144  ! => zf = 2.24 !    do k=kdamp,ke !    do j=jb,je !      if (u0inletbc(j,k) > Uinf) then !        u0inletbc(j,k) = Uinf !      end if !    end do !    end do ! Compute j-averaged inlet U  (used for compute thetai) uinletbc2 ( ib , jb : je , kb : ke ) = u0inletbc ( jb : je , kb : ke ) ! this is just a dummy variable to give uninletbc the right dimension in slabsum tinletbc2 ( ib , jb : je , kb : ke ) = t0inletbc ( jb : je , kb : ke ) ! this is just a dummy variable to give tninletbc the right dimension in slabsum urav = 0. trav = 0. call slabsum ( urav , kb , ke , uinletbc2 , ib , ib , jb , je , kb , ke , ib , ib , jb , je , kb , ke ) call slabsum ( trav , kb , ke , tinletbc2 , ib , ib , jb , je , kb , ke , ib , ib , jb , je , kb , ke ) !    call slabsum(urav  ,kb,ke,u0 ,ib-1,ie+1,jb-1,je+1,kb-1,ke+1,ib,ib,jb,je,kb,ke) urav = urav / jtot ! average over j-direction trav = trav / jtot ! average over j-direction ! determine bulk velocity of new profile do k = kb , ke uravdzf ( k ) = urav ( k ) * dzf ( k ) end do totalu = sum ( uravdzf ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) ! Area-averaged outflow velocity ! rescale the instantaneous profile to keep mass flux constant (tot avoid pressure fluctuations) if ( luvolflowr ) then do k = kb , ke uinldzf ( k ) = Uinl ( k ) * dzf ( k ) end do totaluinl = sum ( uinldzf ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) ! Area-averaged inflow velocity scalef = totaluinl / totalu ! compute factor to scale the velocity profile with u0inletbc (:,:) = u0inletbc (:,:) * scalef ! rescale the velocity profile to have constant mass-flux urav (:) = urav (:) * scalef ! also rescale the part that is added to the mean end if !! add defect velocity to make sure the mass flow is the same as the initial mass flow !   u0inletbc = u0inletbc + (ubulk-totalu) !   urav      = urav      + (ubulk-totalu) !! add defect velocity to make sure the j-averaged velocity at the top equals Uinf !    utop = urav(ke) !    do k=kb,ke !      do j=jb,je !        u0inletbc(j,k) = u0inletbc(j,k)*Uinf/utop !      end do !      urav(k) = urav(k)*Uinf/utop !    end do !    u0inletbc = u0inletbc + (Uinf-utop) !    urav      = urav      + (Uinf-utop) !    if (myid==0) then !    write(6,*) 'u0inletbc(jb+2,ke)', u0inletbc !    end if ! Compute j- and time-averaged  inlet U  (used for compute thetai) if (. not . lfixinlet ) then ! only update the average inlet profiles when lfixinlet .eqv..false. do k = kb , ke Uinl ( k ) = urav ( k ) * deltat * avinti + ( 1. - deltat * avinti ) * Uinl ( k ) end do end if do k = kb , ke Tinl ( k ) = trav ( k ) * deltat * avinti + ( 1. - deltat * avinti ) * Tinl ( k ) end do !    utop = Uinl(ke) !    Uinl = Uinl +(Uinf-utop)     ! make sure at the inlet the mean top velocity equals Uinf !    uminletbc = uminletbc + (Uinf-utop) ! write inletplane to array (and to file after 1000 time steps) if ( lstoreplane ) then storeu0inletbc (:,:, nstepread ) = u0inletbc (:,:) storev0inletbc (:,:, nstepread ) = v0inletbc (:,:) storew0inletbc (:,:, nstepread ) = w0inletbc (:,:) storet0inletbc (:,:, nstepread ) = t0inletbc (:,:) nstepread = nstepread + 1 if ( nstepread == nstore + 1 ) then nfile = nfile + 1 ! next file number call writeinletfile ! write 1000 time steps to file call writerestartfiles nstepread = 1 ! reset counter end if ! nstepread == 1001 end if ! lstoreplane if ( rk3step == 1 ) then uminletbc = u0inletbc vminletbc = v0inletbc wminletbc = w0inletbc tminletbc = t0inletbc end if if ( lbuoyancy ) then !     call blthicknessmo(di_test,utaui,lmoi) call blthicknesst ( di_test , Uinl , 0.99 ) !     call dispthicknessmo(displ)  ! needed in top BC call dispthicknessexp ( displ ) else !     call blthickness(di_test,utaui) call blthicknesst ( di_test , Uinl , 0.99 ) !     call dispthickness(displ)  ! needed in top BC call dispthicknessexp ( displ ) end if call blthicknesst ( dti_test , Tinl - thls , 0.99 ) if (( myid == 0 ) . and . ( rk3step == 3 )) then write ( 6 , * ) 'Inlet Gen: gamma,lambda=' , gamm , lamb write ( 6 , * ) 'Inlet Gen: Uinl(ke),Tinl(ke)=' , Uinl ( ke ), Tinl ( ke ) write ( 6 , * ) 'Inlet Gen: utaui,utaur =' , utaui , utaur write ( 6 , * ) 'Inlet Gen: ttaui,ttaur =' , ttaui , ttaur write ( 6 , * ) 'Inlet Gen: Lmoi,Lmor =' , lmoi , lmor write ( 6 , * ) 'Inlet Gen: deltar, deltai_test' , dr , di_test write ( 6 , * ) 'Inlet Gen: deltatr, deltati_test' , dtr , dti_test write ( 6 , * ) 'Inlet Gen: d*i, d*r=' , displ ( ib ), displ ( irecy ) write ( 6 , * ) 'Inlet Gen: thetai,thetar' , thetai , thetar write ( 6 , * ) 'Inlet Gen: thetati,thetatr' , thetati , thetatr if ( luvolflowr ) then write ( 6 , * ) 'Inlet Gen: mass flux correction factor = ' , scalef !       write(6,*) 'Inlet Gen: mass flux                   = ',totalreadu write ( 6 , * ) 'Inlet Gen: mass flux                   = ' , totaluinl end if end if elseif ( iinletgen == 2 ) then if ( myid == 0 ) then write ( 6 , * ) 'nstepread=' , nstepread end if u0inletbcold = u0inletbc v0inletbcold = v0inletbc w0inletbcold = w0inletbc t0inletbcold = t0inletbc ! determine time step interval in simulation rk3coef = dt / ( 4. - dble ( rk3step )) if ( rk3step == 1 ) then deltat = rk3coef elseif ( rk3step == 2 ) then deltat = rk3coef - ( dt / 3. ) elseif ( rk3step == 3 ) then deltat = rk3coef - ( dt / 2. ) end if ! determine time step interval in inlet data rk3coefin = dtin / ( 4. - dble ( rk3stepin )) if ( rk3stepin == 1 ) then dtinrk = rk3coefin elseif ( rk3stepin == 2 ) then dtinrk = rk3coefin - ( dtin / 3. ) elseif ( rk3stepin == 3 ) then dtinrk = rk3coefin - ( dtin / 2. ) end if interval = dtinrk - elapstep elapstep = elapstep + deltat if ( elapstep > dtinrk ) then ! use new value at next time step nstepread = nstepread + 1 elapstep = mod ( elapstep , dtinrk ) rk3stepin = mod ( rk3stepin , 3 ) + 1 rk3coefin = dtin / ( 4. - dble ( rk3stepin )) if ( rk3stepin == 1 ) then dtinrk = rk3coefin elseif ( rk3stepin == 2 ) then dtinrk = rk3coefin - ( dtin / 3. ) elseif ( rk3stepin == 3 ) then dtinrk = rk3coefin - ( dtin / 2. ) end if u0inletbc (:,:) = storeu0inletbc (:,:, nstepread ) v0inletbc (:,:) = storev0inletbc (:,:, nstepread ) w0inletbc (:,:) = storew0inletbc (:,:, nstepread ) t0inletbc (:,:) = storet0inletbc (:,:, nstepread ) if ( nstepread == nstore ) then nfile = nfile + 1 call readinletfile call writerestartfiles nstepread = 0 end if interval = dtinrk deltat = elapstep !        write(6,*) 'dtinrk,deltat=', dtinrk,deltat end if u0inletbc (:,:) = ( 1. - deltat / interval ) * u0inletbc (:,:) + ( deltat / interval ) * storeu0inletbc (:,:, nstepread + 1 ) v0inletbc (:,:) = ( 1. - deltat / interval ) * v0inletbc (:,:) + ( deltat / interval ) * storev0inletbc (:,:, nstepread + 1 ) w0inletbc (:,:) = ( 1. - deltat / interval ) * w0inletbc (:,:) + ( deltat / interval ) * storew0inletbc (:,:, nstepread + 1 ) t0inletbc (:,:) = ( 1. - deltat / interval ) * t0inletbc (:,:) + ( deltat / interval ) * storet0inletbc (:,:, nstepread + 1 ) !! massflow correction uinletbc2 ( ib , jb : je , kb : ke ) = u0inletbc ( jb : je , kb : ke ) ! this is just a dummy variable to give uninletbc the right dimension in slabsum urav = 0. call slabsum ( urav , kb , ke , uinletbc2 , ib , ib , jb , je , kb , ke , ib , ib , jb , je , kb , ke ) urav = urav / jtot ! average over j-direction ! determine bulk velocity of new (interpolated) profile do k = kb , ke uravdzf ( k ) = urav ( k ) * dzf ( k ) end do totalu = sum ( uravdzf ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) ! Area-averaged outflow velocity ! rescale the instantaneous profile to keep mass flux constant (tot avoid pressure fluctuations) scalef = totalreadu / totalu ! compute factor to scale the velocity profile with u0inletbc (:,:) = u0inletbc (:,:) * scalef ! rescale the velocity profile to have constant mass-flux !! end of massflow correction of interpolated streamwise velocity if ( rk3step == 1 ) then uminletbc = u0inletbc vminletbc = v0inletbc wminletbc = w0inletbc tminletbc = t0inletbc end if end if ! iinletgen end subroutine inletgen","tags":"","url":"proc/inletgen.html"},{"title":"inletgennotemp – uDALES","text":"public  subroutine inletgennotemp() Uses modfields modmpi modsave modglobal proc~~inletgennotemp~~UsesGraph proc~inletgennotemp inletgennotemp module~modfields modfields proc~inletgennotemp->module~modfields module~modglobal modglobal proc~inletgennotemp->module~modglobal module~modmpi modmpi proc~inletgennotemp->module~modmpi module~modsave modsave proc~inletgennotemp->module~modsave decomp_2d decomp_2d module~modfields->decomp_2d mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~inletgennotemp~~CallsGraph proc~inletgennotemp inletgennotemp proc~blthicknesst blthicknesst proc~inletgennotemp->proc~blthicknesst proc~dispthicknessexp dispthicknessexp proc~inletgennotemp->proc~dispthicknessexp proc~momentumthicknessexp momentumthicknessexp proc~inletgennotemp->proc~momentumthicknessexp proc~readinletfile readinletfile proc~inletgennotemp->proc~readinletfile proc~slabsum slabsum proc~inletgennotemp->proc~slabsum proc~wallawinlet wallawinlet proc~inletgennotemp->proc~wallawinlet proc~writeinletfile writeinletfile proc~inletgennotemp->proc~writeinletfile proc~writerestartfiles writerestartfiles proc~inletgennotemp->proc~writerestartfiles proc~excjs excjs proc~readinletfile->proc~excjs proc~yinterpolate yinterpolate proc~readinletfile->proc~yinterpolate proc~zinterpolate zinterpolate proc~readinletfile->proc~zinterpolate proc~zinterpolatet zinterpolatet proc~readinletfile->proc~zinterpolatet proc~zinterpolatew zinterpolatew proc~readinletfile->proc~zinterpolatew mpi_allreduce mpi_allreduce proc~slabsum->mpi_allreduce mpi_abort mpi_abort proc~writerestartfiles->mpi_abort mpi_bcast mpi_bcast proc~writerestartfiles->mpi_bcast mpi_isend mpi_isend proc~excjs->mpi_isend mpi_recv mpi_recv proc~excjs->mpi_recv mpi_wait mpi_wait proc~excjs->mpi_wait Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine inletgennotemp use modglobal , only : ib , ie , jb , je , jb , jtot , kb , ke , zf , zh , dzf , dzhi , timee , btime , totavtime , rk3step , dt , numol , iplane , lles , iinletgen , inletav , runavtime , Uinf , lwallfunc , linletRA , totinletav , lstoreplane , nstore , lfixinlet , lfixutauin , luvolflowr use modfields , only : u0 , v0 , w0 , wm , uprof use modsave , only : writerestartfiles use modmpi , only : slabsum , myid implicit none real , dimension ( ib : ib , jb : je , kb : ke ) :: uinletbc2 ! dummy variable real , dimension ( jb : je , kb : ke ) :: uprec ! velocity fluctuation (up_rec = u0 - Urec) real , dimension ( jb : je , kb : ke ) :: vprec ! velocity fluctuation (vp_rec = v0 - 0) real , dimension ( jb : je , kb : ke + 1 ) :: wprec ! velocity fluctuation (wp_rec = w0 - Wrec) real , dimension ( jb : je , kb : ke ) :: upinli , vpinli ! = gamma * (uprec,v interpolated to zii grid) real , dimension ( jb : je , kb : ke ) :: upinlo , vpinlo ! = gamma * (uprec,v interpolated to zoi grid) real , dimension ( jb : je , kb : ke + 1 ) :: wpinli ! = gamma * (wprec   interpolated to zii grid) real , dimension ( jb : je , kb : ke + 1 ) :: wpinlo ! = gamma * (wprec   interpolated to zoi grid) real , dimension ( kb : ke ) :: udiff ! difference between Uinl and Urec !    real,dimension(kb:ke)   :: Urecdiff                ! difference between Urec new and old real , dimension ( kb : ke ) :: urav ! j-averaged u-velocity (not time-averaged) real , dimension ( kb : ke ) :: uravdzf ! j-averaged u-velocity (not time-averaged) times dzf real , dimension ( kb : ke ) :: uinldzf ! j-averaged u-velocity (not time-averaged) times dzf real , dimension ( kb : ke ) :: Urecdzf ! Urec times dzf real , dimension ( kb : ke + 1 ) :: wrav ! j-averaged w-velocity (not time-averaged) real , dimension ( kb : ke ) :: Uinli ! = gamma * (Urec interpolated to ziif grid points) real , dimension ( kb : ke + 1 ) :: Winli ! = gamma * (Wrec interpolated to ziih grid points) real , dimension ( kb : ke ) :: Uinlo ! = gamma * (Urec interpolated to zioif grid points) real , dimension ( kb : ke + 1 ) :: Winlo ! = gamma * (Wrec interpolated to zoih grid points) real , dimension ( kb : ke ) :: wfuncf ! weight function at full level real , dimension ( kb : ke + 1 ) :: wfunch ! weight function at half level real :: utaur2 , utaui2 ! (utau)&#94;2 at recycle station and inlet real :: gamm ! utaui / utaur real :: avint , avinti ! avering interval real :: alpha , beta ! factors used in the Weight function !    real                    :: totalu                  ! total u-velocity at outlet real :: Urectot ! total u-velocity at recycle plane real :: rk3coef !    real                    :: di_test                 ! BL thickness as measured from Uinl real :: utop ! j-averaged top velocity real :: interval real :: dtinrk ! RK time step in inlet data real :: rk3coefin ! Cumulative RK time step in inlet data real :: dr_old real :: scalef ! scale factor to scale instantaneous velocity profile with to get constant mass flux real :: totaluinl ! bulk velocity at the inlet integer i , j , k , kk if ( iinletgen == 1 ) then u0inletbcold = u0inletbc v0inletbcold = v0inletbc w0inletbcold = w0inletbc totaluold = totalu displold = displ ddispdxold = ddispdx ! compute time-average velocities rk3coef = dt / ( 4. - dble ( rk3step )) if ( rk3step == 1 ) then deltat = rk3coef elseif ( rk3step == 2 ) then deltat = rk3coef - ( dt / 3. ) elseif ( rk3step == 3 ) then deltat = rk3coef - ( dt / 2. ) end if if ( linletRA ) then ! this is a switch to use 'running average' avint = totinletav + timee - btime ! runav interval = averaging interval previuous sim  + current elapsed sim time else avint = inletav end if avinti = 1. / avint uaver = 0. do i = ib , ie call slabsum ( uaver ( i ,:), kb , ke , u0 ( i : i , jb : je , kb : ke ), i , i , jb , je , kb , ke , i , i , jb , je , kb , ke ) end do wrav = 0. call slabsum ( wrav ( kb : ke + 1 ), kb , ke , w0 ( irecy - 1 : irecy - 1 , jb : je , kb : ke + 1 ), irecy - 1 , irecy - 1 , jb , je , kb , ke + 1 , irecy - 1 , irecy - 1 , jb , je , kb , ke + 1 ) uaver = uaver / jtot ! average over j-direction urav = uaver ( irecy ,:) wrav = wrav / jtot ! average over j-direction do k = kb , ke Urec ( k ) = urav ( k ) * deltat * avinti + ( 1. - deltat * avinti ) * Urec ( k ) end do do k = kb , ke + 1 Wrec ( k ) = wrav ( k ) * deltat * avinti + ( 1. - deltat * avinti ) * Wrec ( k ) end do do k = kb , ke do i = ib , ie Utav ( i , k ) = uaver ( i , k ) * deltat * avinti + ( 1. - deltat * avinti ) * Utav ( i , k ) end do end do ! compute velocity fluctuation at recycle station do k = kb , ke do j = jb , je uprec ( j , k ) = u0 ( irecy , j , k ) - Urec ( k ) vprec ( j , k ) = v0 ( irecy - 1 , j , k ) ! mean v is zero end do end do do k = kb , ke + 1 do j = jb , je wprec ( j , k ) = w0 ( irecy - 1 , j , k ) - Wrec ( k ) ! note that w-velocity is taken at i=irecy-1 !! end do end do if ( lwallfunc ) then call wallawinlet ( Urec ( kb ), dzf ( kb ), numol , utaur2 ) ! compute wall shear stress at recycle station else utaur2 = 2. * numol * Urec ( kb ) / dzf ( kb ) end if utaur = sqrt ( abs ( utaur2 )) ! compute utau at recycle station ! compute momentum thickness at inlet and recycle plane dr_old = dr !   call blthickness(dr,utaur)                     ! also needed for thetar call blthicknesst ( dr , Urec , 0.99 ) !   call momentumthickness(thetai,utaui,di)        ! di is kept fixed call momentumthicknessexp ( thetai , Uinl ) !   call momentumthickness(thetar,utaur,dr) call momentumthicknessexp ( thetar , Urec ) !   call blthickness(dr,utaur) if (. not . lfixutauin ) then utaui = utaur * abs ( thetar / thetai ) ** ( 1. / 8. ) ! See Lund (1998): 'Similar to Ludwig-Tillmann correlation' end if gamm = utaui / utaur ! Gamma in Lund (1998) ! compute inner scaling coordinates zirf = utaur * zf / numol ! inner scaling zf-coordinate at recycle station zirh = utaur * zh / numol ! inner scaling zh-coordinate at recycle station ziif = utaui * zf / numol ! inner scaling zf-coordinate at inlet station ziih = utaui * zh / numol ! inner scaling zh-coordinate at inlet station ! compute outer scaling coordinates zorf = zf / dr ! outer scaling zf-coor as measured from Uinldinate at recycle station zorh = zh / dr ! outer scaling zh-coordinate at recycle station zoif = zf / di ! outer scaling zf-coordinate at inlet station  (could be done once, actually..) zoih = zh / di ! outer scaling zf-coordinate at inlet station  (could be done once, actually..) !!!!! Interpolation starts here !!! First inner coordinates ! determine which elements are needed when recycle velocity profile is interpolated on inlet plane ! for u(,v)-components (zf) do k = kb , ke do kk = kb , ke if ( zirf ( kk ) >= ziif ( k )) then locupif ( k ) = kk loclowif ( k ) = kk - 1 exit elseif ( kk == ke ) then locupif ( k ) = ke + 1 ! this means extrapolation! loclowif ( k ) = ke - 1 ! waarom niet ke? of wordt dit niet gebruikt? end if end do end do ! for w-components (zh) do k = kb , ke + 1 do kk = kb , ke + 1 if ( zirh ( kk ) >= ziih ( k )) then locupih ( k ) = kk loclowih ( k ) = kk - 1 exit elseif ( kk == ke + 1 ) then locupih ( k ) = ke + 2 ! this means extrapolation! loclowih ( k ) = ke end if end do end do !!! Finished with inner coordinates !!! Do the same trick for outer coordinates ! determine which elements are needed when recycle velocity profile is interpolated on inlet plane ! for u(,v)-components (zf) do k = kb , ke do kk = kb , ke if ( zorf ( kk ) >= zoif ( k )) then locupof ( k ) = kk loclowof ( k ) = kk - 1 exit elseif ( kk == ke ) then locupof ( k ) = ke + 1 ! this means extrapolation! loclowof ( k ) = ke - 1 end if end do end do ! for w-components (zh) do k = kb , ke + 1 do kk = kb , ke + 1 if ( zorh ( kk ) >= zoih ( k )) then locupoh ( k ) = kk loclowoh ( k ) = kk - 1 exit elseif ( kk == ke + 1 ) then locupoh ( k ) = ke + 2 ! this means extrapolation! loclowoh ( k ) = ke end if end do end do !!! Finished with outer coordinates !!! Now really interpolate !!! First inner coordinates ! compute Urec on zii grid do k = kb , ke if ( locupif ( k ) == ke + 1 ) then ! indicator for extrapolation! !        Uinli(k) = Urec(ke) + (Urec(ke) - Urec(ke-1)) / (zirf(ke)-zirf(ke-1)) * (ziif(k)-zirf(ke)) Uinli ( k ) = Urec ( ke ) elseif ( loclowif ( k ) == kb - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) Uinli ( k ) = Urec ( kb ) / zirf ( kb ) * ziif ( k ) else ! normal interpolation Uinli ( k ) = Urec ( loclowif ( k )) + ( Urec ( locupif ( k )) - Urec ( loclowif ( k ))) / ( zirf ( locupif ( k )) - zirf ( loclowif ( k ))) * ( ziif ( k ) - zirf ( loclowif ( k ))) if (( ziif ( k ) . gt . zirf ( locupif ( k ))) . or . ( ziif ( k ) . lt . zirf ( loclowif ( k )))) then write ( 6 , * ) '!!!Mistake in Interpolation !!!!' end if end if end do ! compute Wrec on zii grid Winli ( kb ) = 0.0 ! corresponds to ground level do k = kb + 1 , ke + 1 if ( locupih ( k ) == ke + 2 ) then ! indicator for extrapolation! !        Winli(k) = Wrec(ke+1) + (Wrec(ke+1) - Wrec(ke)) / (zirh(ke+1)-zirh(ke)) * (ziih(k)-zirh(ke+1)) Winli ( k ) = Wrec ( ke + 1 ) else ! normal interpolation Winli ( k ) = Wrec ( loclowih ( k )) + ( Wrec ( locupih ( k )) - Wrec ( loclowih ( k ))) / ( zirh ( locupih ( k )) - zirh ( loclowih ( k ))) * ( ziih ( k ) - zirh ( loclowih ( k ))) end if end do ! compute u- and v- and t-fluctuation on zii grid do k = kb , ke if ( locupif ( k ) == ke + 1 ) then ! indicator for extrapolation! !        upinli(:,k) = uprec(:,ke) + (uprec(:,ke) - uprec(:,ke-1)) / (zirf(ke)-zirf(ke-1)) * (ziif(k)-zirf(ke)) upinli (:, k ) = 0. vpinli (:, k ) = 0. elseif ( loclowif ( k ) == kb - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) upinli (:, k ) = uprec (:, kb ) / zirf ( kb ) * ziif ( k ) vpinli (:, k ) = vprec (:, kb ) / zirf ( kb ) * ziif ( k ) else ! normal interpolation upinli (:, k ) = uprec (:, loclowif ( k )) + ( uprec (:, locupif ( k )) - uprec (:, loclowif ( k ))) / ( zirf ( locupif ( k )) - zirf ( loclowif ( k ))) * ( ziif ( k ) - zirf ( loclowif ( k ))) vpinli (:, k ) = vprec (:, loclowif ( k )) + ( vprec (:, locupif ( k )) - vprec (:, loclowif ( k ))) / ( zirf ( locupif ( k )) - zirf ( loclowif ( k ))) * ( ziif ( k ) - zirf ( loclowif ( k ))) end if end do ! compute w-fluctuation on zii grid do k = kb + 1 , ke + 1 !      if (locupih(k) == ke+1) then      ! indicator for extrapolation! if ( locupih ( k ) == ke + 2 ) then ! indicator for extrapolation! !        wpinli(:,k) = wprec(:,ke+1) + (wprec(:,ke+1) - wprec(:,ke)) / (zirh(ke+1)-zirh(ke)) * (ziih(k)-zirh(ke+1)) wpinli (:, k ) = 0. else ! normal interpolation wpinli (:, k ) = wprec (:, loclowih ( k )) + ( wprec (:, locupih ( k )) - wprec (:, loclowih ( k ))) / ( zirh ( locupih ( k )) - zirh ( loclowih ( k ))) * ( ziih ( k ) - zirh ( loclowih ( k ))) end if end do !! Finished with interpolating inner variables !! Continue with interpolating outer variables ! compute Urec on zoi grid do k = kb , ke if ( locupof ( k ) == ke + 1 ) then ! indicator for extrapolation! !        Uinlo(k) = Urec(ke) + (Urec(ke) - Urec(ke-1)) / (zorf(ke)-zorf(ke-1)) * (zoif(k)-zorf(ke)) !        Uinlo(k) = Urec(ke) Uinlo ( k ) = Uinf elseif ( loclowof ( k ) == kb - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) Uinlo ( k ) = Urec ( kb ) / zorf ( kb ) * zoif ( k ) else ! normal interpolation Uinlo ( k ) = Urec ( loclowof ( k )) + ( Urec ( locupof ( k )) - Urec ( loclowof ( k ))) / ( zorf ( locupof ( k )) - zorf ( loclowof ( k ))) * ( zoif ( k ) - zorf ( loclowof ( k ))) end if end do ! compute Wrec on zii grid Winlo ( kb ) = 0.0 ! corresponds to ground level do k = kb + 1 , ke + 1 if ( locupoh ( k ) == ke + 2 ) then ! indicator for extrapolation! !        Winlo(k) = Wrec(ke+1) + (Wrec(ke+1) - Wrec(ke)) / (zorh(ke+1)-zorh(ke)) * (zoih(k)-zorh(ke+1)) Winlo ( k ) = Wrec ( ke + 1 ) else ! normal interpolation Winlo ( k ) = Wrec ( loclowoh ( k )) + ( Wrec ( locupoh ( k )) - Wrec ( loclowoh ( k ))) / ( zorh ( locupoh ( k )) - zorh ( loclowoh ( k ))) * ( zoih ( k ) - zorh ( loclowoh ( k ))) end if end do ! compute u- and v-fluctuation on zoi grid do k = kb , ke if ( locupof ( k ) == ke + 1 ) then ! indicator for extrapolation! !        upinlo(:,k) = uprec(:,ke) + (uprec(:,ke) - uprec(:,ke-1)) / (zorf(ke)-zorf(ke-1)) * (zoif(k)-zorf(ke)) upinlo (:, k ) = 0. vpinlo (:, k ) = 0. elseif ( loclowof ( k ) == kb - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) upinlo (:, k ) = uprec (:, kb ) / zorf ( kb ) * zoif ( k ) vpinlo (:, k ) = vprec (:, kb ) / zorf ( kb ) * zoif ( k ) else ! normal interpolation upinlo (:, k ) = uprec (:, loclowof ( k )) + ( uprec (:, locupof ( k )) - uprec (:, loclowof ( k ))) / ( zorf ( locupof ( k )) - zorf ( loclowof ( k ))) * ( zoif ( k ) - zorf ( loclowof ( k ))) vpinlo (:, k ) = vprec (:, loclowof ( k )) + ( vprec (:, locupof ( k )) - vprec (:, loclowof ( k ))) / ( zorf ( locupof ( k )) - zorf ( loclowof ( k ))) * ( zoif ( k ) - zorf ( loclowof ( k ))) end if end do ! compute w-fluctuation on zoi grid do k = kb + 1 , ke + 1 if ( locupoh ( k ) == ke + 2 ) then ! indicator for extrapolation! !        wpinlo(:,k) = wprec(:,ke+1) + (wprec(:,ke+1) - wprec(:,ke)) / (zorh(ke+1)-zorh(ke)) * (zoih(k)-zorh(ke+1)) wpinlo (:, k ) = 0. else ! normal interpolation wpinlo (:, k ) = wprec (:, loclowoh ( k )) + ( wprec (:, locupoh ( k )) - wprec (:, loclowoh ( k ))) / ( zorh ( locupoh ( k )) - zorh ( loclowoh ( k ))) * ( zoih ( k ) - zorh ( loclowoh ( k ))) end if end do !! Finished interpolating outer velocity variables !!!!! Finished Interpolation! !!!!! ! compute rescaled inner variables ! Winli = Winli (interpolation is enough) Uinli = gamm * Uinli upinli = gamm * upinli vpinli = gamm * vpinli wpinli = gamm * wpinli ! compute rescaled outer variables ! Winlo = Winlo (interpolation is enough) Uinlo = gamm * Uinlo + ( 1. - gamm ) * Uinf !    Uinlo = gamm* Uinlo  + (1.- gamm)*Urec(ke) upinlo = gamm * upinlo vpinlo = gamm * vpinlo wpinlo = gamm * wpinlo ! Compute weight function (alpha=4, b=0.2) alpha = 4. beta = 0.2 wfuncf = 0.5 * ( 1. + tanh ( alpha * ( zoif - beta ) / (( 1. - 2. * beta ) * zoif + beta ) ) / tanh ( alpha ) ) ! for full level height wfunch = 0.5 * ( 1. + tanh ( alpha * ( zoih - beta ) / (( 1. - 2. * beta ) * zoih + beta ) ) / tanh ( alpha ) ) ! for half level height do k = kb , ke if ( wfuncf ( k ) . gt . 1. ) then wfuncf ( k ) = 1. end if end do do k = kb , ke + 1 if ( wfunch ( k ) . gt . 1. ) then wfunch ( k ) = 1. end if end do ! Compute the velocity components for the inlet BC do k = kb , ke do j = jb , je u0inletbc ( j , k ) = ( Uinli ( k ) + upinli ( j , k )) * ( 1. - wfuncf ( k )) + ( Uinlo ( k ) + upinlo ( j , k )) * wfuncf ( k ) v0inletbc ( j , k ) = vpinli ( j , k ) * ( 1. - wfuncf ( k )) + vpinlo ( j , k ) * wfuncf ( k ) end do end do do k = kb , ke + 1 do j = jb , je w0inletbc ( j , k ) = ( Winli ( k ) + wpinli ( j , k )) * ( 1 - wfunch ( k )) + ( Winlo ( k ) + wpinlo ( j , k )) * wfunch ( k ) end do end do w0inletbc (:, kb ) = 0. w0inletbc (:, ke + 1 ) = 0. ! Compute j-averaged inlet U  (used for compute thetai) uinletbc2 ( ib , jb : je , kb : ke ) = u0inletbc ( jb : je , kb : ke ) ! this is just a dummy variable to give uninletbc the right dimension in slabsum urav = 0. call slabsum ( urav , kb , ke , uinletbc2 , ib , ib , jb , je , kb , ke , ib , ib , jb , je , kb , ke ) urav = urav / jtot ! average over j-direction ! determine bulk velocity of new profile do k = kb , ke uravdzf ( k ) = urav ( k ) * dzf ( k ) end do totalu = sum ( uravdzf ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) ! Area-averaged outflow velocity ! correct instantaneous inflow velocity for constant mass-flux if ( luvolflowr ) then do k = kb , ke uinldzf ( k ) = Uinl ( k ) * dzf ( k ) end do totaluinl = sum ( uinldzf ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) ! Area-averaged inflow velocity that should be kept scalef = totaluinl / totalu ! compute factor to scale the velocity profile with u0inletbc (:,:) = u0inletbc (:,:) * scalef ! rescale the velocity profile to have constant mass-flux urav (:) = urav (:) * scalef ! also rescale the part that is added to the mean end if ! Compute j- and time-averaged  inlet U  (used for compute thetai) if (. not . lfixinlet ) then ! only update the average inlet profiles when lfixinlet .eqv..false. do k = kb , ke Uinl ( k ) = urav ( k ) * deltat * avinti + ( 1. - deltat * avinti ) * Uinl ( k ) end do end if ! write inletplane to array (and to file after 1000 time steps) if ( lstoreplane ) then storeu0inletbc (:,:, nstepread ) = u0inletbc (:,:) storev0inletbc (:,:, nstepread ) = v0inletbc (:,:) storew0inletbc (:,:, nstepread ) = w0inletbc (:,:) nstepread = nstepread + 1 if ( nstepread == nstore + 1 ) then nfile = nfile + 1 ! next file number call writeinletfile ! write 1000 time steps to file call writerestartfiles nstepread = 1 ! reset counter end if ! nstepread == 1001 end if ! lstoreplane if ( rk3step == 1 ) then uminletbc = u0inletbc vminletbc = v0inletbc wminletbc = w0inletbc end if !   call blthickness(di_test,utaui) call blthicknesst ( di_test , Uinl , 0.99 ) !   call dispthickness(displ)  ! needed in top BC call dispthicknessexp ( displ ) ! needed in top BC if (( myid == 0 ) . and . ( rk3step == 3 )) then write ( 6 , * ) 'Inlet Gen: gamma=' , gamm write ( 6 , * ) 'Inlet Gen: Uinl(ke)=' , Uinl ( ke ) write ( 6 , * ) 'Inlet Gen: utaui,utaur =' , utaui , utaur write ( 6 , * ) 'Inlet Gen: deltar, deltai_test' , dr , di_test write ( 6 , * ) 'Inlet Gen: d*i, d*r=' , displ ( ib ), displ ( irecy ) write ( 6 , * ) 'Inlet Gen: thetai,thetar' , thetai , thetar if ( luvolflowr ) then write ( 6 , * ) 'Inlet Gen: mass flux correction factor = ' , scalef !       write(6,*) 'Inlet Gen: mass flux                   = ',totalreadu write ( 6 , * ) 'Inlet Gen: mass flux                   = ' , totaluinl end if end if elseif ( iinletgen == 2 ) then if ( myid == 0 ) then write ( 6 , * ) 'nstepread=' , nstepread end if u0inletbcold = u0inletbc v0inletbcold = v0inletbc w0inletbcold = w0inletbc ! determine time step interval in simulation rk3coef = dt / ( 4. - dble ( rk3step )) if ( rk3step == 1 ) then deltat = rk3coef elseif ( rk3step == 2 ) then deltat = rk3coef - ( dt / 3. ) elseif ( rk3step == 3 ) then deltat = rk3coef - ( dt / 2. ) end if ! determine time step interval in inlet data rk3coefin = dtin / ( 4. - dble ( rk3stepin )) if ( rk3stepin == 1 ) then dtinrk = rk3coefin elseif ( rk3stepin == 2 ) then dtinrk = rk3coefin - ( dtin / 3. ) elseif ( rk3stepin == 3 ) then dtinrk = rk3coefin - ( dtin / 2. ) end if interval = dtinrk - elapstep elapstep = elapstep + deltat if ( elapstep > dtinrk ) then ! use new value at next time step nstepread = nstepread + 1 elapstep = mod ( elapstep , dtinrk ) rk3stepin = mod ( rk3stepin , 3 ) + 1 rk3coefin = dtin / ( 4. - dble ( rk3stepin )) if ( rk3stepin == 1 ) then dtinrk = rk3coefin elseif ( rk3stepin == 2 ) then dtinrk = rk3coefin - ( dtin / 3. ) elseif ( rk3stepin == 3 ) then dtinrk = rk3coefin - ( dtin / 2. ) end if u0inletbc (:,:) = storeu0inletbc (:,:, nstepread ) v0inletbc (:,:) = storev0inletbc (:,:, nstepread ) w0inletbc (:,:) = storew0inletbc (:,:, nstepread ) if ( nstepread == nstore ) then nfile = nfile + 1 call readinletfile call writerestartfiles nstepread = 0 end if interval = dtinrk deltat = elapstep !        write(6,*) 'dtinrk,deltat=', dtinrk,deltat end if u0inletbc (:,:) = ( 1. - deltat / interval ) * u0inletbc (:,:) + ( deltat / interval ) * storeu0inletbc (:,:, nstepread + 1 ) v0inletbc (:,:) = ( 1. - deltat / interval ) * v0inletbc (:,:) + ( deltat / interval ) * storev0inletbc (:,:, nstepread + 1 ) w0inletbc (:,:) = ( 1. - deltat / interval ) * w0inletbc (:,:) + ( deltat / interval ) * storew0inletbc (:,:, nstepread + 1 ) !! massflow correction uinletbc2 ( ib , jb : je , kb : ke ) = u0inletbc ( jb : je , kb : ke ) ! this is just a dummy variable to give uninletbc the right dimension in slabsum urav = 0. call slabsum ( urav , kb , ke , uinletbc2 , ib , ib , jb , je , kb , ke , ib , ib , jb , je , kb , ke ) urav = urav / jtot ! average over j-direction ! determine bulk velocity of new (interpolated) profile do k = kb , ke uravdzf ( k ) = urav ( k ) * dzf ( k ) end do totalu = sum ( uravdzf ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) ! Area-averaged outflow velocity ! rescale the instantaneous profile to keep mass flux constant (tot avoid pressure fluctuations) scalef = totalreadu / totalu ! compute factor to scale the velocity profile with u0inletbc (:,:) = u0inletbc (:,:) * scalef ! rescale the velocity profile to have constant mass-flux !! end of massflow correction of interpolated streamwise velocity if ( rk3step == 1 ) then uminletbc = u0inletbc vminletbc = v0inletbc wminletbc = w0inletbc end if end if ! iinletgen end subroutine inletgennotemp","tags":"","url":"proc/inletgennotemp.html"},{"title":"momentumthicknessexp – uDALES","text":"public  subroutine momentumthicknessexp(output, uinput) Uses modinletdata modmpi modglobal proc~~momentumthicknessexp~~UsesGraph proc~momentumthicknessexp momentumthicknessexp module~modglobal modglobal proc~momentumthicknessexp->module~modglobal module~modinletdata modinletdata proc~momentumthicknessexp->module~modinletdata module~modmpi modmpi proc~momentumthicknessexp->module~modmpi mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(out) :: output real, intent(in), dimension(kb:ke) :: uinput Called by proc~~momentumthicknessexp~~CalledByGraph proc~momentumthicknessexp momentumthicknessexp proc~inletgen inletgen proc~inletgen->proc~momentumthicknessexp proc~inletgennotemp inletgennotemp proc~inletgennotemp->proc~momentumthicknessexp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine momentumthicknessexp ( output , uinput ) use modglobal , only : jb , kb , ke , dzf !,Uinf use modinletdata , only : ubulk use modmpi , only : myid implicit none real , dimension ( kb : ke ), intent ( in ) :: uinput !< input velocity real , intent ( out ) :: output !< momentum thickness real , dimension ( kb : ke ) :: mthick !       real    :: umax integer :: k !      write(6,*) 'uinletbc(jb,ke),Uinl(ke)=', uinletbc(jb,ke),uinput(ke) !       umax = maxval(uinput) do k = kb , ke mthick ( k ) = (( uinput ( k ) / uinput ( ke )) - ( uinput ( k ) ** 2. / uinput ( ke ) ** 2. ) ) * dzf ( k ) !         mthick(k) = ((uinput(k)/umax) - (uinput(k)**2. / umax**2.) )*dzf(k) end do output = sum ( mthick ) ! momentum thickness end subroutine momentumthicknessexp","tags":"","url":"proc/momentumthicknessexp.html"},{"title":"momentumthickness – uDALES","text":"public  subroutine momentumthickness(output, ustar, blth) Uses modglobal proc~~momentumthickness~~UsesGraph proc~momentumthickness momentumthickness module~modglobal modglobal proc~momentumthickness->module~modglobal Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(out) :: output real, intent(in) :: ustar real, intent(in) :: blth Source Code subroutine momentumthickness ( output , ustar , blth ) use modglobal , only : pi , Uinf !    use modinletdata, only : ubulk !   use modmpi, only    : myid implicit none real , intent ( in ) :: ustar ! friction velocity real , intent ( in ) :: blth ! boundary layer thickness real , intent ( out ) :: output ! momentum thickness real :: B = 5.0 ! Wake parameter real :: C = 0.5 ! Coles parameter real :: kappa = 0.41 ! Von k�r�n constant real :: lam ! = Uinf/ustar lam = Uinf / ustar output = (( 1. + C ) / ( kappa * lam ) - ( 1. / (( kappa ** 2 ) * ( lam ** 2 ))) * ( 2. + 2. * C * ( 1.852 / pi + 1. ) + ( 3. / 2. ) * ( C ** 2 ))) * blth end subroutine momentumthickness","tags":"","url":"proc/momentumthickness.html"},{"title":"momentumthicknessmo – uDALES","text":"public  subroutine momentumthicknessmo(output, ustar, blth, lmo) Uses modglobal proc~~momentumthicknessmo~~UsesGraph proc~momentumthicknessmo momentumthicknessmo module~modglobal modglobal proc~momentumthicknessmo->module~modglobal Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(out) :: output real, intent(in) :: ustar real, intent(in) :: blth real, intent(in) :: lmo Source Code subroutine momentumthicknessmo ( output , ustar , blth , lmo ) use modglobal , only : pi , Uinf !    use modinletdata, only : ubulk !   use modmpi, only    : myid implicit none real , intent ( in ) :: ustar ! friction velocity real , intent ( in ) :: lmo ! Obukhov length real , intent ( in ) :: blth ! boundary layer thickness real , intent ( out ) :: output ! momentum thickness real :: B = 5.0 ! Wake parameter real :: C = 0.5 ! Coles parameter real :: kappa = 0.41 ! Von k�r�n constant real :: cmo = 0.702 ! constant in MO theory (0.135*5.2) real :: lam ! = Uinf/ustar lam = Uinf / ustar output = ( 1. + C + 0.5 * cmo * blth / lmo ) / ( kappa * lam ) - ( 1. / (( kappa ** 2 ) * ( lam ** 2 ))) * ( 2. + 2. * C * ( 1.852 / pi + 1. ) + ( 3. / 2. ) * ( C ** 2 ) + ( blth - 0.25 ) * 2. * cmo / lmo + ( 1. + 4. / pi ) * blth * C * cmo / lmo + ( 1. / 6. ) * (( cmo / lmo ) ** 2 ) * ( blth ** 2 ) ) * blth end subroutine momentumthicknessmo","tags":"","url":"proc/momentumthicknessmo.html"},{"title":"enthalpythickness – uDALES","text":"public  subroutine enthalpythickness(output, tinput, uinput) Uses modinletdata modsurfdata modmpi modglobal proc~~enthalpythickness~~UsesGraph proc~enthalpythickness enthalpythickness module~modglobal modglobal proc~enthalpythickness->module~modglobal module~modinletdata modinletdata proc~enthalpythickness->module~modinletdata module~modmpi modmpi proc~enthalpythickness->module~modmpi module~modsurfdata modsurfdata proc~enthalpythickness->module~modsurfdata mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(out) :: output real, intent(in), dimension(kb:ke) :: tinput real, intent(in), dimension(kb:ke) :: uinput Called by proc~~enthalpythickness~~CalledByGraph proc~enthalpythickness enthalpythickness proc~inletgen inletgen proc~inletgen->proc~enthalpythickness Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine enthalpythickness ( output , tinput , uinput ) use modglobal , only : jb , kb , ke , dzf !,Uinf use modinletdata , only : ubulk use modsurfdata , only : thls use modmpi , only : myid implicit none real , dimension ( kb : ke ), intent ( in ) :: tinput !< input temperature real , dimension ( kb : ke ), intent ( in ) :: uinput !< input velocity real , intent ( out ) :: output !< momentum thickness real , dimension ( kb : ke ) :: ethick real thlsdummy integer :: k thlsdummy = thls if ( tinput ( ke ) == thls ) then thlsdummy = thls - 0.000001 end if do k = kb , ke !         ethick(k) = (uinput(k)/uinput(ke)) * ((tinput(k) - tinput(ke)) /(thls - tinput(ke)) )*dzf(k) ethick ( k ) = ( uinput ( k ) / uinput ( ke )) * (( tinput ( k ) - tinput ( ke )) / ( thlsdummy - tinput ( ke )) ) * dzf ( k ) end do output = sum ( ethick ) ! enthalpy thickness if ( output == 0. ) then output = 0.000001 end if end subroutine enthalpythickness","tags":"","url":"proc/enthalpythickness.html"},{"title":"dispthicknessexp – uDALES","text":"public  subroutine dispthicknessexp(output) Uses modglobal proc~~dispthicknessexp~~UsesGraph proc~dispthicknessexp dispthicknessexp module~modglobal modglobal proc~dispthicknessexp->module~modglobal Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(out), dimension(ib:ie) :: output Called by proc~~dispthicknessexp~~CalledByGraph proc~dispthicknessexp dispthicknessexp proc~inletgen inletgen proc~inletgen->proc~dispthicknessexp proc~inletgennotemp inletgennotemp proc~inletgennotemp->proc~dispthicknessexp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine dispthicknessexp ( output ) ! output is an array of length (ib:ie)) containing displacement thickness values use modglobal , only : ib , ie , kb , ke , dzf , xf !,Uinf implicit none real , dimension ( ib : ie ), intent ( out ) :: output !< dispacement thickness real , dimension ( kb : ke ) :: dthick !       real    :: umax real :: dispm real :: disp2m real :: xfdispm integer :: i , k ! write(6,*) 'Uinl(ke)=', uinput(ke) do i = ib , ie !       umax = maxval(Utav(i,:)) do k = kb , ke dthick ( k ) = ( 1. - Utav ( i , k ) / Utav ( i , ke )) * dzf ( k ) ! time-averaged, j-averaged velocity !         dthick(k) = (1.- Utav(i,k)/ umax) *dzf(k)       ! time-averaged, j-averaged velocity end do output ( i ) = sum ( dthick ) ! displacement thickness end do dispm = sum ( output ( ib : ie )) / ( ie - ib + 1 ) ! mean(displacement) disp2m = sum ( output ( ib : ie ) ** 2. ) / ( ie - ib + 1 ) ! mean(displacement&#94;2) xfdispm = sum ( xf ( ib : ie ) * output ( ib : ie )) / ( ie - ib + 1 ) ! mean(xf*displ) ddispdx = ( xfdispm - ( xfm * dispm )) / ( xf2m - xfm ** 2. ) ! this is d/dx(delta*) !       ddispdx = 0.    ! for the test !       dinl    = dispm - ddispdx*xfm                         ! this is the starting value (delta* = dinl + d/dx(delta)*x) end subroutine dispthicknessexp","tags":"","url":"proc/dispthicknessexp.html"},{"title":"dispthickness – uDALES","text":"public  subroutine dispthickness(output) Uses modglobal proc~~dispthickness~~UsesGraph proc~dispthickness dispthickness module~modglobal modglobal proc~dispthickness->module~modglobal Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(out), dimension(ib:ie) :: output Source Code subroutine dispthickness ( output ) ! output is an array of length (ib:ie)) containing displacement thickness values use modglobal , only : ib , ie , kb , ke , dzf , xf , Uinf , numol implicit none real , dimension ( ib : ie ), intent ( out ) :: output !< dispacement thickness !       real, dimension(kb:ke)                    :: dthick real :: dispm real :: disp2m real :: xfdispm real :: ustar , blth real :: B = 5.0 ! Wake parameter real :: C = 0.5 ! Coles parameter real :: kappa = 0.41 ! Von k�r�n constant real :: lam ! = Uinf/ustar integer :: i do i = ib , ie ustar = sqrt ( abs ( 2 * numol * Utav ( i , kb ) / dzf ( kb ))) ! average streamwise friction lam = Uinf / ustar blth = ( lam * numol / Uinf ) * exp ( kappa * ( lam - B ) - 2. * C ) ! See App. Lund et al. output ( i ) = (( 1. + C ) / ( kappa * lam ) ) * blth end do dispm = sum ( output ( ib : ie )) / ( ie - ib + 1 ) ! mean(displacement) disp2m = sum ( output ( ib : ie ) ** 2. ) / ( ie - ib + 1 ) ! mean(displacement&#94;2) xfdispm = sum ( xf ( ib : ie ) * output ( ib : ie )) / ( ie - ib + 1 ) ! mean(xf*displ) ddispdx = ( xfdispm - ( xfm * dispm )) / ( xf2m - xfm ** 2. ) ! this is d/dx(delta*) end subroutine dispthickness","tags":"","url":"proc/dispthickness.html"},{"title":"dispthicknessmo – uDALES","text":"public  subroutine dispthicknessmo(output) Uses modsurfdata modglobal proc~~dispthicknessmo~~UsesGraph proc~dispthicknessmo dispthicknessmo module~modglobal modglobal proc~dispthicknessmo->module~modglobal module~modsurfdata modsurfdata proc~dispthicknessmo->module~modsurfdata Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(out), dimension(ib:ie) :: output Source Code subroutine dispthicknessmo ( output ) ! output is an array of length (ib:ie)) containing displacement thickness values use modglobal , only : ib , ie , kb , ke , dzf , xf , Uinf , numol , grav , prandtlmoli use modsurfdata , only : thls implicit none real , dimension ( ib : ie ), intent ( out ) :: output !< dispacement thickness !       real, dimension(kb:ke)                    :: dthick real :: dispm real :: disp2m real :: xfdispm real :: ustar , tstar , blth real :: B = 5.0 ! Wake parameter real :: C = 0.5 ! Coles parameter real :: kappa = 0.41 ! Von k�rm�n constant real :: cmo = 0.702 ! constant in MO theory (0.135*5.2) real :: lam ! = Uinf/ustar real :: func , dfunc , utaunu , lmo integer :: i , n blth = di ! initial value do i = ib , ie ustar = sqrt ( abs ( 2. * numol * Utav ( i , kb ) / dzf ( kb ))) ! average streamwise friction at x-location tstar = numol * prandtlmoli * 2. * ( Ttav ( i , kb ) - thls ) / ( dzf ( kb ) * ustar ) ! average shear temp. at x-location lmo = ( thls * ustar ** 2 ) / ( kappa * grav * tstar ) ! obukhov length at this x-location if (( lmo >= 1000 0. ) . or . ( lmo <= 0.01 )) then lmo = 100 0. end if !         lmo = 0.3  !! TEMPORARY utaunu = ustar / numol lam = Uinf / ustar do n = 1 , 10 ! Newton Raphson method to find BL height !           write(6,*) 'blth,ustar,tstar,Lmo =',blth,ustar,tstar,lmo func = log ( blth ) + ( cmo * blth / lmo ) + log ( utaunu ) - kappa * ( lam - B ) + 2. * C !           func   = log(blth) + log(utaunu) - kappa*(lam-B) +2.*C dfunc = 1. / blth + cmo / lmo blth = blth - ( func / dfunc ) if ( blth <= 0. ) then blth = di end if end do output ( i ) = (( 1. + C + 0.5 * cmo * blth / lmo ) / ( kappa * lam ) ) * blth end do dispm = sum ( output ( ib : ie )) / ( ie - ib + 1 ) ! mean(displacement) disp2m = sum ( output ( ib : ie ) ** 2. ) / ( ie - ib + 1 ) ! mean(displacement&#94;2) xfdispm = sum ( xf ( ib : ie ) * output ( ib : ie )) / ( ie - ib + 1 ) ! mean(xf*displ) ddispdx = ( xfdispm - ( xfm * dispm )) / ( xf2m - xfm ** 2. ) ! this is d/dx(delta*) end subroutine dispthicknessmo","tags":"","url":"proc/dispthicknessmo.html"},{"title":"blthicknesst – uDALES","text":"public  subroutine blthicknesst(output, uinput, criterion) Uses modglobal proc~~blthicknesst~~UsesGraph proc~blthicknesst blthicknesst module~modglobal modglobal proc~blthicknesst->module~modglobal Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(out) :: output real, intent(in), dimension(kb:ke) :: uinput real, intent(in) :: criterion Called by proc~~blthicknesst~~CalledByGraph proc~blthicknesst blthicknesst proc~inletgen inletgen proc~inletgen->proc~blthicknesst proc~inletgennotemp inletgennotemp proc~inletgennotemp->proc~blthicknesst Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine blthicknesst ( output , uinput , criterion ) use modglobal , only : kb , ke , zh , zf implicit none real , dimension ( kb : ke ), intent ( in ) :: uinput !< input velocity real , intent ( in ) :: criterion !< criterion for BL thickness computation (e.g. 0.95 or 0.99) real , intent ( out ) :: output !< BL thickness based on input criterion !       real, dimension(kb:ke)             :: mthick real :: ucrit !       real                               :: umax integer :: k !     umax = maxval(uinput) ucrit = uinput ( ke ) * criterion ! Velocity at which BL-thickness is reached !     ucrit = umax*criterion  ! Velocity at which BL-thickness is reached do k = kb , ke if ( uinput ( k ) . GT . criterion * uinput ( ke )) then if ( k == kb ) then output = zh ( kb ) + ( zf ( k ) - zh ( k )) / uinput ( k ) * ucrit ! interpolate z to BL-height exit else output = zf ( k - 1 ) + ( zf ( k ) - zf ( k - 1 )) / ( uinput ( k ) - uinput ( k - 1 )) * ( ucrit - uinput ( k - 1 )) !  interpolate z to BL-height exit end if else if ( k == ke ) then output = zf ( ke ) ! maximum BL thickness end if end do end subroutine blthicknesst","tags":"","url":"proc/blthicknesst.html"},{"title":"blthickness – uDALES","text":"public  subroutine blthickness(output, ustar) Uses modglobal proc~~blthickness~~UsesGraph proc~blthickness blthickness module~modglobal modglobal proc~blthickness->module~modglobal Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(out) :: output real, intent(in) :: ustar Source Code subroutine blthickness ( output , ustar ) use modglobal , only : numol , Uinf implicit none real , intent ( in ) :: ustar ! friction velocity real , intent ( out ) :: output !< BL thickness based on law of the wake !       real, dimension(kb:ke)             :: mthick !       real                               :: ucrit !       real                               :: umax !       integer :: k real :: B = 5.0 ! Wake parameter real :: C = 0.5 ! Coles parameter real :: kappa = 0.41 ! Von k�r�n constant real :: lam ! = Uinf/ustar lam = Uinf / ustar output = ( lam * numol / Uinf ) * exp ( kappa * ( lam - B ) - 2. * C ) ! See App. Lund et al. end subroutine blthickness","tags":"","url":"proc/blthickness.html"},{"title":"blthicknessmo – uDALES","text":"public  subroutine blthicknessmo(output, ustar, lmo) Uses modglobal proc~~blthicknessmo~~UsesGraph proc~blthicknessmo blthicknessmo module~modglobal modglobal proc~blthicknessmo->module~modglobal Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(inout) :: output real, intent(in) :: ustar real, intent(in) :: lmo Source Code subroutine blthicknessmo ( output , ustar , lmo ) ! This routine compute the BL thicknes for a buoyancy affected boundary layer: ! Newton-Raphson method is used use modglobal , only : numol , Uinf implicit none real , intent ( in ) :: ustar ! friction velocity real , intent ( in ) :: lmo ! Obukhov length real , intent ( inout ) :: output !< BL thickness based on law of the wake !       real, dimension(kb:ke)             :: mthick !       real                               :: ucrit !       real                               :: umax !       integer :: k real :: B = 5.0 ! Wake parameter real :: C = 0.5 ! Coles parameter real :: kappa = 0.41 ! Von k�r�n constant real :: cmo = 0.702 ! Constant in MO theory (0.135*5.2) real :: lam ! = Uinf/ustar real :: func , dfunc , utaunu integer :: n utaunu = ustar / numol lam = Uinf / ustar !       write(6,*) 'Initial delta, Lmo =', output,lmo do n = 1 , 10 func = log ( output ) + ( cmo * output / lmo ) + log ( utaunu ) - kappa * ( lam - B ) + 2. * C !         func   = log(output) + log(utaunu) - kappa*(lam-B) +2.*C dfunc = 1. / output + cmo / lmo output = output - ( func / dfunc ) if ( output <= 0. ) then output = di end if end do !       write(6,*) 'Computed delta, Lmo =', output,lmo end subroutine blthicknessmo","tags":"","url":"proc/blthicknessmo.html"},{"title":"wallawinlet – uDALES","text":"public  subroutine wallawinlet(utan, dx, visc, tau) Arguments Type Intent Optional Attributes Name real, intent(in) :: utan real, intent(in) :: dx real, intent(in) :: visc real, intent(out) :: tau Called by proc~~wallawinlet~~CalledByGraph proc~wallawinlet wallawinlet proc~inletgen inletgen proc~inletgen->proc~wallawinlet proc~inletgennotemp inletgennotemp proc~inletgennotemp->proc~wallawinlet Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine wallawinlet ( utan , dx , visc , tau ) ! this should be the same as wallaw in modboundary!!! This routine is just ! copied to avoid circular dependencies implicit none real , intent ( in ) :: utan , dx , visc real , intent ( out ) :: tau real const1 , const2 , const3 , const4 real tausub , taupow real sub , dutan , utankr , utanabs real aaa , bbb real dxi parameter ( aaa = 8.3 ) parameter ( bbb = 0.1428571429 ) dxi = 1. / dx const1 = 0.5 * ( 1. - bbb ) * aaa ** (( 1. + bbb ) / ( 1. - bbb )) const2 = ( 1. + bbb ) / aaa const3 = aaa ** ( 2. / ( 1. - bbb )) const4 = 2. / ( 1. + bbb ) utanabs = abs ( utan ) utankr = 0.5 * visc * dxi * const3 dutan = utankr - utanabs sub = max ( sign ( 1. , dutan ), 0. ) tausub = 2. * visc * utanabs * dxi !      taupow3   =   const1 * (visc * dxi)**(1.+bbb) + (const2 * (visc * !      dxi)**bbb) * utanabs taupow = ( const1 * ( visc * dxi ) ** ( 1. + bbb ) + ( const2 * ( visc * dxi ) ** bbb ) * utanabs ) ** const4 !      if (taupow3<=0) then !        write(6,*) 'taupow3 <=0!!!' !      end if tau = sub * tausub + ( 1. - sub ) * taupow tau = sign ( tau , utan ) ! give tau the same sign as utan return end subroutine wallawinlet","tags":"","url":"proc/wallawinlet.html"},{"title":"writeinletfile – uDALES","text":"public  subroutine writeinletfile() Uses modmpi modglobal proc~~writeinletfile~~UsesGraph proc~writeinletfile writeinletfile module~modglobal modglobal proc~writeinletfile->module~modglobal module~modmpi modmpi proc~writeinletfile->module~modmpi mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~writeinletfile~~CalledByGraph proc~writeinletfile writeinletfile proc~inletgen inletgen proc~inletgen->proc~writeinletfile proc~inletgennotemp inletgennotemp proc~inletgennotemp->proc~writeinletfile Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine writeinletfile use modglobal , only : jb , je , kb , ke , cexpnr , ifoutput , nstore , ltempeq use modmpi , only : cmyid , myid !    use modinletdata, only : storeu0inletbc,storev0inletbc,storew0inletbc,nfile implicit none integer fileid integer j , k , n character ( 24 ) name name = 'inlet/inlet_    k   .' write ( name ( 13 : 16 ) , '(i4.4)' ) nfile name ( 18 : 20 ) = cmyid name ( 22 : 24 ) = cexpnr write ( 6 , * ) 'Writing Inlet velocity: ' , name open ( ifoutput , file = name , form = 'unformatted' , position = 'append' ) write ( ifoutput ) ((( storeu0inletbc ( j , k , n ), j = jb , je ), k = kb , ke ), n = 1 , nstore ) write ( ifoutput ) ((( storev0inletbc ( j , k , n ), j = jb , je ), k = kb , ke ), n = 1 , nstore ) write ( ifoutput ) ((( storew0inletbc ( j , k , n ), j = jb , je ), k = kb , ke + 1 ), n = 1 , nstore ) close ( ifoutput ) if ( ltempeq ) then name = 'inlet/itemp_    k   .' write ( name ( 13 : 16 ) , '(i4.4)' ) nfile name ( 18 : 20 ) = cmyid name ( 22 : 24 ) = cexpnr write ( 6 , * ) 'Writing Inlet temperature: ' , name open ( ifoutput , file = name , form = 'unformatted' , position = 'append' ) write ( ifoutput ) ((( storet0inletbc ( j , k , n ), j = jb , je ), k = kb , ke ), n = 1 , nstore ) close ( ifoutput ) end if end subroutine writeinletfile","tags":"","url":"proc/writeinletfile.html"},{"title":"readinletfile – uDALES","text":"public  subroutine readinletfile() Uses modmpi modglobal proc~~readinletfile~~UsesGraph proc~readinletfile readinletfile module~modglobal modglobal proc~readinletfile->module~modglobal module~modmpi modmpi proc~readinletfile->module~modmpi mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~readinletfile~~CallsGraph proc~readinletfile readinletfile proc~excjs excjs proc~readinletfile->proc~excjs proc~yinterpolate yinterpolate proc~readinletfile->proc~yinterpolate proc~zinterpolate zinterpolate proc~readinletfile->proc~zinterpolate proc~zinterpolatet zinterpolatet proc~readinletfile->proc~zinterpolatet proc~zinterpolatew zinterpolatew proc~readinletfile->proc~zinterpolatew mpi_isend mpi_isend proc~excjs->mpi_isend mpi_recv mpi_recv proc~excjs->mpi_recv mpi_wait mpi_wait proc~excjs->mpi_wait Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~readinletfile~~CalledByGraph proc~readinletfile readinletfile proc~inletgen inletgen proc~inletgen->proc~readinletfile proc~inletgennotemp inletgennotemp proc~inletgennotemp->proc~readinletfile proc~readinitfiles readinitfiles proc~readinitfiles->proc~readinletfile program~dalesurban DALESURBAN program~dalesurban->proc~readinitfiles Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine readinletfile use modglobal , only : ib , jb , je , jmax , kb , ke , cexpnr , ifinput , nstore , ltempeq , ntrun , zh , jtot , jh use modmpi , only : cmyid , myid , nprocs , slabsum , excjs !    use modinletdata, only : storeu0inletbc,storev0inletbc,storew0inletbc,nfile implicit none real , dimension ( ib : ib , jb : jb + inlfactor * jmax - 1 , kbin : kein ) :: udummy real , dimension ( kbin : kein ) :: uread real , dimension ( kbin : kein ) :: ureaddzfin real , dimension ( jb : jb + jtotin - 1 , kbin : kein , 1 : nstore ) :: storeu0inold real , dimension ( jb : jb + jtotin - 1 , kbin : kein , 1 : nstore ) :: storev0inold real , dimension ( jb : jb + jtotin - 1 , kbin : kein + 1 , 1 : nstore ) :: storew0inold real , dimension ( jb : jb + jtotin - 1 , kbin : kein , 1 : nstore ) :: storet0inold real , dimension ( jb : jb + jtotdum - 1 , kbin : kein , 1 : nstore ) :: storeu0indum real , dimension ( jb : jb + jtotdum - 1 , kbin : kein , 1 : nstore ) :: storev0indum real , dimension ( jb : jb + jtotdum - 1 , kbin : kein + 1 , 1 : nstore ) :: storew0indum real , dimension ( jb : jb + jtotdum - 1 , kbin : kein , 1 : nstore ) :: storet0indum real , dimension ( jb : je , kbin : kein , 1 : nstore ) :: storeu0innew real , dimension ( jb : je , kbin : kein , 1 : nstore ) :: storev0innew real , dimension ( jb : je , kbin : kein + 1 , 1 : nstore ) :: storew0innew real , dimension ( jb : je , kbin : kein , 1 : nstore ) :: storet0innew integer filen , filee integer fileid integer j , k , n , js , jf , jfdum , jsdum character ( 24 ) name filen = - 5 ! should be checked carefully if in use ever jfdum = jbdum - 1 ! initial value do fileid = filenumstart , filenumstart + ( filestoread - 1 ) if ( filen == - 1 ) then filen = nprocsinl - 1 ! -1 means the last proc (periodic) else filen = fileid - floor ( real ( fileid ) / real ( nprocsinl )) * nprocsinl ! loop over proc's end if write ( 6 , * ) '!!!!! filen = ' , filen name = 'inlet/inlet_    k   .' write ( name ( 13 : 16 ) , '(i4.4)' ) nfile write ( name ( 18 : 20 ) , '(i3.3)' ) filen name ( 22 : 24 ) = cexpnr write ( 6 , * ) 'Reading Inlet velocity: ' , name open ( unit = ifinput , file = name , form = 'unformatted' ) read ( ifinput ) ((( storeu0inold ( j , k , n ), j = jbin , jein ), k = kbin , kein ), n = 1 , nstore ) read ( ifinput ) ((( storev0inold ( j , k , n ), j = jbin , jein ), k = kbin , kein ), n = 1 , nstore ) read ( ifinput ) ((( storew0inold ( j , k , n ), j = jbin , jein ), k = kbin , kein + 1 ), n = 1 , nstore ) close ( ifinput ) if ( ltempeq ) then name = 'inlet/itemp_    k   .' write ( name ( 13 : 16 ) , '(i4.4)' ) nfile write ( name ( 18 : 20 ) , '(i3.3)' ) filen name ( 22 : 24 ) = cexpnr write ( 6 , * ) 'Reading Inlet temperature: ' , name open ( unit = ifinput , file = name , form = 'unformatted' ) read ( ifinput ) ((( storet0inold ( j , k , n ), j = jbin , jein ), k = kbin , kein ), n = 1 , nstore ) close ( ifinput ) end if ! determine start and end indices if ( filen == procinlo ) then js = jbeg else js = jbin end if if ( filen == procinup ) then jf = jend else jf = jein end if jsdum = jfdum + 1 jfdum = jsdum + ( jf - js ) !        if (jsdum >= 3) write(6,*) 'myid, jsdum = ',myid, jsdum !        if (jfdum >= 3) write(6,*) 'myid, jfdum = ',myid, jfdum !!! put values from original in dummy variable storeu0indum ( jsdum : jfdum ,:,:) = storeu0inold ( js : jf ,:,:) ! s: start  f: final storev0indum ( jsdum : jfdum ,:,:) = storev0inold ( js : jf ,:,:) ! s: start  f: final storew0indum ( jsdum : jfdum ,:,:) = storew0inold ( js : jf ,:,:) ! s: start  f: final if ( ltempeq ) then storet0indum ( jsdum : jfdum ,:,:) = storet0inold ( js : jf ,:,:) ! s: start  f: final end if end do ! loop over original inlet files ! now interpolate in y call yinterpolate ( storeu0indum , storeu0innew , kbin , kein ) call yinterpolate ( storev0indum , storev0innew , kbin , kein ) call yinterpolate ( storew0indum , storew0innew , kbin , kein + 1 ) call yinterpolate ( storet0indum , storet0innew , kbin , kein ) if (. not . lzinzsim ) then ! interpolate when zin =/ zsim call zinterpolate ( storeu0innew (:,:,:), storeu0inletbc ) ! interpolate inlet profile to zgrid call zinterpolate ( storev0innew (:,:,:), storev0inletbc ) ! interpolate inlet profile to zgrid call zinterpolatew ( storew0innew (:,:,:), storew0inletbc ) ! interpolate inlet profile to zgrid if ( ltempeq ) then call zinterpolatet ( storet0innew (:,:,:), storet0inletbc ) ! interpolate inlet profile to zgrid end if else storeu0inletbc (:,:,:) = storeu0inold (:,:,:) storev0inletbc (:,:,:) = storev0inold (:,:,:) storew0inletbc (:,:,:) = storew0inold (:,:,:) if ( ltempeq ) then storet0inletbc (:,:,:) = storet0inold (:,:,:) end if end if if ( iangle /= 0.0 ) then ! modify for inflow angle do n = 1 , nstore do k = kb , ke do j = jb , je u0rot ( n , j , k ) = storeu0inletbc ( j , k , n ) ! swap indices in order v0rot ( n , j , k ) = storev0inletbc ( j , k , n ) ! to use excjs end do end do end do call excjs ( u0rot , 1 , nstore , jb , je , kb , ke , 0 , jh ) call excjs ( v0rot , 1 , nstore , jb , je , kb , ke , 0 , jh ) !         write(6,*) 'v0rot(1,je+1,30) = ',v0rot(1,je+1,30) do n = 1 , nstore do k = kb , ke do j = jb , je ! apply horizontal rotation (neglecting the delta_x difference) storeu0inletbc ( j , k , n ) = u0rot ( n , j , k ) * cos ( iangle ) - 0.5 * sin ( iangle ) * ( v0rot ( n , j , k ) + v0rot ( n , j + 1 , k )) storev0inletbc ( j , k , n ) = v0rot ( n , j , k ) * cos ( iangle ) + 0.5 * sin ( iangle ) * ( u0rot ( n , j , k ) + u0rot ( n , j - 1 , k )) end do end do end do end if ! iangle =/0.0 end subroutine readinletfile","tags":"","url":"proc/readinletfile.html"},{"title":"zinterpolate – uDALES","text":"public  subroutine zinterpolate(input, output) Uses modglobal proc~~zinterpolate~~UsesGraph proc~zinterpolate zinterpolate module~modglobal modglobal proc~zinterpolate->module~modglobal Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(in), dimension(jb:je,kbin:kein,1:nstore) :: input real, intent(inout), dimension(jb:je,kb:ke,1:nstore) :: output Called by proc~~zinterpolate~~CalledByGraph proc~zinterpolate zinterpolate proc~readinletfile readinletfile proc~readinletfile->proc~zinterpolate proc~inletgen inletgen proc~inletgen->proc~readinletfile proc~inletgennotemp inletgennotemp proc~inletgennotemp->proc~readinletfile proc~readinitfiles readinitfiles proc~readinitfiles->proc~readinletfile program~dalesurban DALESURBAN program~dalesurban->proc~readinitfiles Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine zinterpolate ( input , output ) use modglobal , only : jb , je , kb , ke , zf , nstore implicit none real , dimension ( jb : je , kbin : kein , 1 : nstore ), intent ( in ) :: input real , dimension ( jb : je , kb : ke , 1 : nstore ), intent ( inout ) :: output integer k do k = kb , ke if ( linuf ( k ) == kein + 1 ) then ! indicator for extrapolation! output (:, k ,:) = input (:, kein ,:) elseif ( linlf ( k ) == kbin - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) output (:, k ,:) = input (:, kbin ,:) / zfin ( kbin ) * zf ( k ) !        output(:,k,:) = input(:,kbin,:)   ! temeperature is not zero at the wall, so line above is wrong else ! normal interpolation output (:, k ,:) = input (:, linlf ( k ),:) + ( input (:, linuf ( k ),:) - input (:, linlf ( k ),:)) / ( zfin ( linuf ( k )) - zfin ( linlf ( k ))) * ( zf ( k ) - zfin ( linlf ( k ))) if (( zf ( k ) . gt . zfin ( linuf ( k ))) . or . ( zf ( k ) . lt . zfin ( linlf ( k )))) then write ( 6 , * ) '!!!Mistake in zinterpolate !!!!' end if end if end do end subroutine zinterpolate","tags":"","url":"proc/zinterpolate.html"},{"title":"zinterpolate1d – uDALES","text":"public  subroutine zinterpolate1d(input, output) Uses modglobal proc~~zinterpolate1d~~UsesGraph proc~zinterpolate1d zinterpolate1d module~modglobal modglobal proc~zinterpolate1d->module~modglobal Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(in), dimension(kbin:kein) :: input real, intent(inout), dimension(kb:ke) :: output Called by proc~~zinterpolate1d~~CalledByGraph proc~zinterpolate1d zinterpolate1d proc~readrestartfiles readrestartfiles proc~readrestartfiles->proc~zinterpolate1d proc~readinitfiles readinitfiles proc~readinitfiles->proc~readrestartfiles program~dalesurban DALESURBAN program~dalesurban->proc~readinitfiles Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine zinterpolate1d ( input , output ) use modglobal , only : kb , ke , zf implicit none real , dimension ( kbin : kein ), intent ( in ) :: input real , dimension ( kb : ke ), intent ( inout ) :: output integer k do k = kb , ke if ( linuf ( k ) == kein + 1 ) then ! indicator for extrapolation! output ( k ) = input ( kein ) elseif ( linlf ( k ) == kbin - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) output ( k ) = input ( kbin ) / zfin ( kbin ) * zf ( k ) !        output(:,k,:) = input(:,kbin,:)   ! temeperature is not zero at the wall, so line above is wrong else ! normal interpolation output ( k ) = input ( linlf ( k )) + ( input ( linuf ( k )) - input ( linlf ( k ))) / ( zfin ( linuf ( k )) - zfin ( linlf ( k ))) * ( zf ( k ) - zf ( linlf ( k ))) if (( zf ( k ) . gt . zfin ( linuf ( k ))) . or . ( zf ( k ) . lt . zfin ( linlf ( k )))) then write ( 6 , * ) '!!!Mistake in zinterpolate1d !!!!' end if end if end do end subroutine zinterpolate1d","tags":"","url":"proc/zinterpolate1d.html"},{"title":"zinterpolate2d – uDALES","text":"public  subroutine zinterpolate2d(input, output) Uses modglobal proc~~zinterpolate2d~~UsesGraph proc~zinterpolate2d zinterpolate2d module~modglobal modglobal proc~zinterpolate2d->module~modglobal Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(in), dimension(ib:ie,kbin:kein) :: input real, intent(inout), dimension(ib:ie,kb:ke) :: output Called by proc~~zinterpolate2d~~CalledByGraph proc~zinterpolate2d zinterpolate2d proc~readrestartfiles readrestartfiles proc~readrestartfiles->proc~zinterpolate2d proc~readinitfiles readinitfiles proc~readinitfiles->proc~readrestartfiles program~dalesurban DALESURBAN program~dalesurban->proc~readinitfiles Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine zinterpolate2d ( input , output ) use modglobal , only : ib , ie , kb , ke , zf , nstore implicit none real , dimension ( ib : ie , kbin : kein ), intent ( in ) :: input real , dimension ( ib : ie , kb : ke ), intent ( inout ) :: output integer k do k = kb , ke if ( linuf ( k ) == kein + 1 ) then ! indicator for extrapolation! output (:, k ) = input (:, kein ) elseif ( linlf ( k ) == kbin - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) output (:, k ) = input (:, kbin ) / zfin ( kbin ) * zf ( k ) !        output(:,k,:) = input(:,kbin,:)   ! temeperature is not zero at the wall, so line above is wrong else ! normal interpolation output (:, k ) = input (:, linlf ( k )) + ( input (:, linuf ( k )) - input (:, linlf ( k ))) / ( zfin ( linuf ( k )) - zfin ( linlf ( k ))) * ( zf ( k ) - zf ( linlf ( k ))) if (( zf ( k ) . gt . zfin ( linuf ( k ))) . or . ( zf ( k ) . lt . zfin ( linlf ( k )))) then write ( 6 , * ) '!!!Mistake in zinterpolate2d !!!!' end if end if end do end subroutine zinterpolate2d","tags":"","url":"proc/zinterpolate2d.html"},{"title":"zinterpolatew – uDALES","text":"public  subroutine zinterpolatew(input, output) Uses modglobal proc~~zinterpolatew~~UsesGraph proc~zinterpolatew zinterpolatew module~modglobal modglobal proc~zinterpolatew->module~modglobal Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(in), dimension(jb:je,kbin:kein+1,1:nstore) :: input real, intent(inout), dimension(jb:je,kb:ke+1,1:nstore) :: output Called by proc~~zinterpolatew~~CalledByGraph proc~zinterpolatew zinterpolatew proc~readinletfile readinletfile proc~readinletfile->proc~zinterpolatew proc~inletgen inletgen proc~inletgen->proc~readinletfile proc~inletgennotemp inletgennotemp proc~inletgennotemp->proc~readinletfile proc~readinitfiles readinitfiles proc~readinitfiles->proc~readinletfile program~dalesurban DALESURBAN program~dalesurban->proc~readinitfiles Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine zinterpolatew ( input , output ) use modglobal , only : jb , je , kb , ke , zh , nstore implicit none real , dimension ( jb : je , kbin : kein + 1 , 1 : nstore ), intent ( in ) :: input real , dimension ( jb : je , kb : ke + 1 , 1 : nstore ), intent ( inout ) :: output integer k do k = kb , ke + 1 if ( linuh ( k ) == kein + 2 ) then ! indicator for extrapolation! output (:, k ,:) = input (:, kein + 1 ,:) elseif ( linlh ( k ) == kbin - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) output (:, k ,:) = input (:, kbin ,:) ! =0 !        output(:,k,:) = input(:,kbin,:)/zhin(kbin) * zh(k) !        output(:,k,:) = input(:,kbin,:)   ! temeperature is not zero at the wall, so line above is wrong else ! normal interpolation output (:, k ,:) = input (:, linlh ( k ),:) + ( input (:, linuh ( k ),:) - input (:, linlh ( k ),:)) / ( zhin ( linuh ( k )) - zhin ( linlh ( k ))) * ( zh ( k ) - zhin ( linlh ( k ))) if (( zh ( k ) . gt . zhin ( linuh ( k ))) . or . ( zh ( k ) . lt . zhin ( linlh ( k )))) then write ( 6 , * ) '!!!Mistake in zinterpolatew !!!!' end if end if end do end subroutine zinterpolatew","tags":"","url":"proc/zinterpolatew.html"},{"title":"zinterpolatew1d – uDALES","text":"public  subroutine zinterpolatew1d(input, output) Uses modglobal proc~~zinterpolatew1d~~UsesGraph proc~zinterpolatew1d zinterpolatew1d module~modglobal modglobal proc~zinterpolatew1d->module~modglobal Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(in), dimension(kbin:kein+1) :: input real, intent(inout), dimension(kb:ke+1) :: output Called by proc~~zinterpolatew1d~~CalledByGraph proc~zinterpolatew1d zinterpolatew1d proc~readrestartfiles readrestartfiles proc~readrestartfiles->proc~zinterpolatew1d proc~readinitfiles readinitfiles proc~readinitfiles->proc~readrestartfiles program~dalesurban DALESURBAN program~dalesurban->proc~readinitfiles Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine zinterpolatew1d ( input , output ) use modglobal , only : kb , ke , zh implicit none real , dimension ( kbin : kein + 1 ), intent ( in ) :: input real , dimension ( kb : ke + 1 ), intent ( inout ) :: output integer k do k = kb , ke + 1 if ( linuh ( k ) == kein + 2 ) then ! indicator for extrapolation! output ( k ) = input ( kein + 1 ) elseif ( linlh ( k ) == kbin - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) output ( k ) = input ( kbin ) !=0 !        output(k) = input(kbin)/zhin(kbin) * zh(k) !        output(:,k,:) = input(:,kbin,:)   ! temeperature is not zero at the wall, so line above is wrong else ! normal interpolation output ( k ) = input ( linlh ( k )) + ( input ( linuh ( k )) - input ( linlh ( k ))) / ( zhin ( linuh ( k )) - zhin ( linlh ( k ))) * ( zh ( k ) - zh ( linlh ( k ))) if (( zh ( k ) . gt . zhin ( linuh ( k ))) . or . ( zh ( k ) . lt . zhin ( linlh ( k )))) then write ( 6 , * ) '!!!Mistake in zinterpolatew1d !!!!' end if end if end do end subroutine zinterpolatew1d","tags":"","url":"proc/zinterpolatew1d.html"},{"title":"zinterpolatet – uDALES","text":"public  subroutine zinterpolatet(input, output) Uses modsurfdata modglobal proc~~zinterpolatet~~UsesGraph proc~zinterpolatet zinterpolatet module~modglobal modglobal proc~zinterpolatet->module~modglobal module~modsurfdata modsurfdata proc~zinterpolatet->module~modsurfdata Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(in), dimension(jb:je,kbin:kein,1:nstore) :: input real, intent(inout), dimension(jb:je,kb:ke,1:nstore) :: output Called by proc~~zinterpolatet~~CalledByGraph proc~zinterpolatet zinterpolatet proc~readinletfile readinletfile proc~readinletfile->proc~zinterpolatet proc~inletgen inletgen proc~inletgen->proc~readinletfile proc~inletgennotemp inletgennotemp proc~inletgennotemp->proc~readinletfile proc~readinitfiles readinitfiles proc~readinitfiles->proc~readinletfile program~dalesurban DALESURBAN program~dalesurban->proc~readinitfiles Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine zinterpolatet ( input , output ) use modglobal , only : jb , je , kb , ke , zf , nstore use modsurfdata , only : thls implicit none real , dimension ( jb : je , kbin : kein , 1 : nstore ), intent ( in ) :: input real , dimension ( jb : je , kb : ke , 1 : nstore ), intent ( inout ) :: output integer k do k = kb , ke if ( linuf ( k ) == kein + 1 ) then ! indicator for extrapolation! output (:, k ,:) = input (:, kein ,:) elseif ( linlf ( k ) == kbin - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) output (:, k ,:) = thls + ( input (:, kb ,:) - thls ) / zfin ( kbin ) * zf ( k ) !         output(:,k,:) = (input(:,kb,:)-thls)/zfin(kbin)*zf(k) !        output(:,k,:) = input(:,kbin,:)/zfin(kbin) * zf(k) !        output(:,k,:) = input(:,kbin,:)   ! temeperature is not zero at the wall, so line above is wrong else ! normal interpolation output (:, k ,:) = input (:, linlf ( k ),:) + ( input (:, linuf ( k ),:) - input (:, linlf ( k ),:)) / ( zfin ( linuf ( k )) - zfin ( linlf ( k ))) * ( zf ( k ) - zfin ( linlf ( k ))) if (( zf ( k ) . gt . zfin ( linuf ( k ))) . or . ( zf ( k ) . lt . zfin ( linlf ( k )))) then write ( 6 , * ) '!!!Mistake in zinterpolatet !!!!' end if end if end do end subroutine zinterpolatet","tags":"","url":"proc/zinterpolatet.html"},{"title":"zinterpolatet1d – uDALES","text":"public  subroutine zinterpolatet1d(input, output) Uses modsurfdata modglobal proc~~zinterpolatet1d~~UsesGraph proc~zinterpolatet1d zinterpolatet1d module~modglobal modglobal proc~zinterpolatet1d->module~modglobal module~modsurfdata modsurfdata proc~zinterpolatet1d->module~modsurfdata Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(in), dimension(kbin:kein) :: input real, intent(inout), dimension(kb:ke) :: output Called by proc~~zinterpolatet1d~~CalledByGraph proc~zinterpolatet1d zinterpolatet1d proc~readrestartfiles readrestartfiles proc~readrestartfiles->proc~zinterpolatet1d proc~readinitfiles readinitfiles proc~readinitfiles->proc~readrestartfiles program~dalesurban DALESURBAN program~dalesurban->proc~readinitfiles Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine zinterpolatet1d ( input , output ) use modglobal , only : jb , je , kb , ke , zf , nstore use modsurfdata , only : thls implicit none real , dimension ( kbin : kein ), intent ( in ) :: input real , dimension ( kb : ke ), intent ( inout ) :: output integer k do k = kb , ke if ( linuf ( k ) == kein + 1 ) then ! indicator for extrapolation! output ( k ) = input ( kein ) elseif ( linlf ( k ) == kbin - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) output ( k ) = ( input ( kb ) - thls ) / zfin ( kbin ) * zf ( k ) !        output(:,k,:) = input(:,kbin,:)/zfin(kbin) * zf(k) !        output(:,k,:) = input(:,kbin,:)   ! temeperature is not zero at the wall, so line above is wrong else ! normal interpolation output ( k ) = input ( linlf ( k )) + ( input ( linuf ( k )) - input ( linlf ( k ))) / ( zfin ( linuf ( k )) - zfin ( linlf ( k ))) * ( zf ( k ) - zf ( linlf ( k ))) if (( zf ( k ) . gt . zfin ( linuf ( k ))) . or . ( zf ( k ) . lt . zfin ( linlf ( k )))) then write ( 6 , * ) '!!!Mistake in zinterpolatet1d !!!!' end if end if end do end subroutine zinterpolatet1d","tags":"","url":"proc/zinterpolatet1d.html"},{"title":"yinterpolate – uDALES","text":"public  subroutine yinterpolate(input, output, ks, kf) Uses modglobal proc~~yinterpolate~~UsesGraph proc~yinterpolate yinterpolate module~modglobal modglobal proc~yinterpolate->module~modglobal Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(in), dimension(jbdum:jedum,ks:kf,1:nstore) :: input real, intent(inout), dimension(jb   :je   ,ks:kf,1:nstore) :: output integer, intent(in) :: ks integer, intent(in) :: kf Called by proc~~yinterpolate~~CalledByGraph proc~yinterpolate yinterpolate proc~readinletfile readinletfile proc~readinletfile->proc~yinterpolate proc~inletgen inletgen proc~inletgen->proc~readinletfile proc~inletgennotemp inletgennotemp proc~inletgennotemp->proc~readinletfile proc~readinitfiles readinitfiles proc~readinitfiles->proc~readinletfile program~dalesurban DALESURBAN program~dalesurban->proc~readinitfiles Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine yinterpolate ( input , output , ks , kf ) use modglobal , only : jb , je , nstore integer , intent ( in ) :: ks integer , intent ( in ) :: kf real , dimension ( jbdum : jedum , ks : kf , 1 : nstore ), intent ( in ) :: input real , dimension ( jb : je , ks : kf , 1 : nstore ), intent ( inout ) :: output integer j do j = jb , je !      if (np==0 .and. yloclowf(j)==) output ( j ,:,:) = input ( yloclowf ( j ),:,:) + ( input ( ylocupf ( j ),:,:) - input ( yloclowf ( j ),:,:)) / ( yfdum ( ylocupf ( j )) - yfdum ( yloclowf ( j ))) * ( yf ( j ) - yfdum ( yloclowf ( j ))) end do end subroutine yinterpolate","tags":"","url":"proc/yinterpolate.html"},{"title":"yinterpolateh – uDALES","text":"public  subroutine yinterpolateh(input, output, ks, kf) Uses modglobal proc~~yinterpolateh~~UsesGraph proc~yinterpolateh yinterpolateh module~modglobal modglobal proc~yinterpolateh->module~modglobal Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real, intent(in), dimension(jbdum:jedum,ks:kf,1:nstore) :: input real, intent(inout), dimension(jb   :je   ,ks:kf,1:nstore) :: output integer, intent(in) :: ks integer, intent(in) :: kf Source Code subroutine yinterpolateh ( input , output , ks , kf ) use modglobal , only : jb , je , nstore integer , intent ( in ) :: ks integer , intent ( in ) :: kf real , dimension ( jbdum : jedum , ks : kf , 1 : nstore ), intent ( in ) :: input real , dimension ( jb : je , ks : kf , 1 : nstore ), intent ( inout ) :: output integer j , jj do j = jb , je !      if (np==0 .and. yloclowf(j)==) output ( j ,:,:) = input ( yloclowh ( j ),:,:) + ( input ( ylocuph ( j ),:,:) - input ( yloclowh ( j ),:,:)) / ( yhdum ( ylocuph ( j )) - yhdum ( yloclowh ( j ))) * ( yh ( j ) - yhdum ( yloclowh ( j ))) end do end subroutine yinterpolateh","tags":"","url":"proc/yinterpolateh.html"},{"title":"readzincoord – uDALES","text":"public  subroutine readzincoord() Uses modmpi modglobal proc~~readzincoord~~UsesGraph proc~readzincoord readzincoord module~modglobal modglobal proc~readzincoord->module~modglobal module~modmpi modmpi proc~readzincoord->module~modmpi mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~readzincoord~~CallsGraph proc~readzincoord readzincoord mpi_bcast mpi_bcast proc~readzincoord->mpi_bcast Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~readzincoord~~CalledByGraph proc~readzincoord readzincoord proc~initinlet initinlet proc~initinlet->proc~readzincoord Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Namelists Namelist INFO Variables Name Type Default Description nprocsinl integer None jgtotinl integer None kmaxin integer None dtin real None wtop real 0. totalreadu real None Source Code subroutine readzincoord use modglobal , only : kb , ke , kh , ifinput , zf , zh , ylen , jb , je , dy use modmpi , only : myid , mpi_integer , comm3d , mpierr , my_real , nprocs implicit none character ( 72 ) chmess character ( 20 ) namezinlet character ( 20 ) namezinfo integer ierr , k , kk , kmaxin , j , jj real ysizeproc namelist / INFO / nprocsinl , jgtotinl , kmaxin , dtin , wtop , totalreadu namezinlet = 'zgrid.inl' namezinfo = 'zgrid.inf' if ( myid == 0 ) then open ( ifinput , file = namezinfo , status = 'old' , iostat = ierr ) if ( ierr /= 0 ) then write ( 0 , * ) 'ERROR: zgrid.inf does not exist' stop 1 end if read ( ifinput , INFO , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'Problem in zgrid.inf INFO' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif write ( 6 , INFO ) close ( ifinput ) end if kbin = 0 kein = kmaxin - 1 call MPI_BCAST ( nprocsinl , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( jgtotinl , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( kbin , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( kein , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( dtin , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( wtop , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( totalreadu , 1 , MY_REAL , 0 , comm3d , mpierr ) allocate ( zhin ( kbin : kein + 1 )) allocate ( zfin ( kbin : kein + 1 )) allocate ( dzfin ( kbin - 1 : kein + 1 )) allocate ( dzhin ( kbin : kein + 1 )) if ( myid == 0 ) then write ( 6 , * ) 'loading ' , namezinlet open ( ifinput , file = namezinlet ) read ( ifinput , '(a72)' ) chmess read ( ifinput , '(a72)' ) chmess do k = kbin , kein read ( ifinput , * ) zfin ( k ) end do close ( ifinput ) zhin ( kbin ) = 0.0 do k = kbin , kein zhin ( k + 1 ) = zhin ( k ) + 2.0 * ( zfin ( k ) - zhin ( k )) end do zfin ( kein + kh ) = zfin ( kein ) + 2.0 * ( zhin ( kein + kh ) - zfin ( kein )) do k = kbin , kein dzfin ( k ) = zhin ( k + 1 ) - zhin ( k ) end do dzfin ( kein + 1 ) = dzfin ( kein ) dzfin ( kbin - 1 ) = dzfin ( kbin ) dzhin ( kbin ) = 2 * zfin ( kbin ) do k = kbin + 1 , kein + kh dzhin ( k ) = zfin ( k ) - zfin ( k - 1 ) end do ! check if the inlet mesh and the simulation mesh differ do k = kb , min ( ke , kein ) if ( abs ( zfin ( k ) - zf ( k )) > 1e-7 ) then lzinzsim = . false . end if enddo end if ! myid==0 ! MPI broadcast kmax elements from zf call MPI_BCAST ( zfin , kein - kbin + 2 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( zhin , kein - kbin + 2 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( dzfin , kein - kbin + 3 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( dzhin , kein - kbin + 2 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lzinzsim , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) if (. not . lzinzsim ) then if ( myid == 0 ) then write ( 6 , * ) 'zgrid.inl does not equal zgrid.inp: Inlet will be interpolated in z' end if !      allocate(linlf(kbin:kein)) !      allocate(linuf(kbin:kein)) !      allocate(linlh(kbin:kein+1)) !      allocate(linuh(kbin:kein+1)) allocate ( linlf ( kb : ke )) allocate ( linuf ( kb : ke )) allocate ( linlh ( kb : ke + 1 )) allocate ( linuh ( kb : ke + 1 )) ! zf do k = kb , ke do kk = kbin , kein if ( zfin ( kk ) >= zf ( k )) then linuf ( k ) = kk linlf ( k ) = kk - 1 exit elseif ( kk == kein ) then linuf ( k ) = kein + 1 ! this means extrapolation! linlf ( k ) = kein - 1 ! waarom niet ke? of wordt dit niet gebruikt? end if end do end do ! for w-components (zh) do k = kb , ke + 1 do kk = kbin , kein + 1 if ( zhin ( kk ) >= zh ( k )) then linuh ( k ) = kk linlh ( k ) = kk - 1 exit elseif ( kk == kein + 1 ) then linuh ( k ) = kein + 2 ! this means extrapolation! linlh ( k ) = kein end if end do end do else ! lzinzsim  -> grids are equal if ( myid == 0 ) then write ( 6 , * ) 'zgrid.inl equals zgrid.inp: Inlet will not be interpolated in z' end if end if ! Now prepare everything for interpolation in y-direction jgbin = 1 jgein = jgbin + jgtotinl - 1 jtotin = jgtotinl / nprocsinl jbin = 1 jein = 1 + jtotin - 1 ysizeproc = ylen / nprocs dyin = ylen / jgtotinl jbdum = 1 jtotdum = ceiling ( ysizeproc / real ( dyin )) + 1 ! dummy indices jedum = jbdum + jtotdum - 1 !     allocate(yf   (jb    :je)) allocate ( yf ( jb : je + 1 )) allocate ( yh ( jb : je + 1 )) allocate ( yfin ( jgbin : jgein + 1 )) allocate ( yhin ( jgbin - 1 : jgein + 1 )) !     allocate(yfdum(jbdum :jedum)) allocate ( yfdum ( jbdum : jedum + 1 )) allocate ( yhdum ( jbdum : jedum + 1 )) allocate ( yloclowf ( jb : je + 1 )) allocate ( ylocupf ( jb : je + 1 )) allocate ( yloclowh ( jb : je + 1 )) allocate ( ylocuph ( jb : je + 1 )) ! make global y-grid (equidistant) for inlet data do j = jgbin - 1 , jgein + 1 yhin ( j ) = ( j - jgbin ) * dyin end do do j = jgbin , jgein + 1 yfin ( j ) = yhin ( j ) + 0.5 * dyin end do ! make new y-grid (equidistant) do j = jb , je + 1 yh ( j ) = myid * ( ylen / nprocs ) + ( j - jb ) * dy yf ( j ) = yh ( j ) + 0.5 * dy end do ! check which original cells are needed for interpolation do j = jgein + 1 , jgbin , - 1 if ( yhin ( j ) <= yh ( jb )) then if ( yfin ( j ) <= yf ( jb )) then procinlo = floor ( real ( j - jgbin ) / real ( jtotin )) ! this is the first cell to consider filenumstart = procinlo jgbeg = j jbeg = j - ( procinlo * jtotin ) !            jend = jbeg+jtotdum-1 jj = j + jtotdum - 1 !            procinup = floor((j-jgbin)/real(jtotin)) !            procinup = floor((j-jgbin+1)/real(jtotin)) procinup = floor ( real ( jj - jgbin ) / real ( jtotin )) filenumend = procinup jend = jj - ( procinup * jtotin ) procinup = procinup - floor ( real ( procinup ) / real ( nprocsinl )) * nprocsinl ! continue on first procinl again else if ( j == jgbin ) then jgbeg = j - 1 jbeg = jein procinlo = nprocsinl - 1 filenumstart = - 1 jj = j + jtotdum - 2 procinup = floor ( real ( jj - jgbin ) / real ( jtotin )) filenumend = procinup jend = jj - ( procinup * jtotin ) procinup = procinup - floor ( real ( procinup ) / real ( nprocsinl )) * nprocsinl !continue on first procinl again else procinlo = floor ( real ( j - jgbin - 1 ) / real ( jtotin )) ! One cell lower is needed filenumstart = procinlo jgbeg = j - 1 jbeg = j - ( procinlo * jtotin ) - 1 jj = j + jtotdum - 2 procinup = floor ( real ( jj - jgbin ) / real ( jtotin )) filenumend = procinup jend = jj - ( procinup * jtotin ) procinup = procinup - floor ( real ( procinup ) / real ( nprocsinl )) * nprocsinl ! continue on first procinl again end if ! j=jgbin end if exit end if end do write ( 6 , * ) '!! myid,procinlo,jbeg,procinup,jend,jgbeg = ' , myid , procinlo , jbeg , procinup , jend , jgbeg ! make dummy y-grid (equidistant) do j = jbdum , jedum + 1 yhdum ( j ) = yhin ( jgbeg ) + ( j - jbdum + 1 ) * dyin yfdum ( j ) = yhdum ( j ) + 0.5 * dyin end do !      if (procoldup /= procoldlo) then !        write(6,*) '!!! Start-cell and end-cell are not in the same file!!!' !      end if filestoread = filenumend - filenumstart + 1 ! no. of files to be read !      write(6,*) '!! procinlo,procinup = ',procinlo,procinup !      write(6,*) '!! jbin,jein,jbeg,jend= ',jbin,jein,jbeg,jend ! for components defined on yf do j = jb , je do jj = jbdum + 1 , jedum + 1 if ( yfdum ( jj ) >= yf ( j )) then ylocupf ( j ) = jj yloclowf ( j ) = jj - 1 exit end if end do end do ! for components defined on yh do j = jb , je + 1 do jj = jbdum + 1 , jedum + 1 if ( yhdum ( jj ) >= yh ( j )) then ylocuph ( j ) = jj yloclowh ( j ) = jj - 1 exit end if end do end do end subroutine readzincoord","tags":"","url":"proc/readzincoord.html"},{"title":"exitinlet – uDALES","text":"public  subroutine exitinlet() Uses modglobal proc~~exitinlet~~UsesGraph proc~exitinlet exitinlet module~modglobal modglobal proc~exitinlet->module~modglobal Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~exitinlet~~CalledByGraph proc~exitinlet exitinlet proc~exitmodules exitmodules proc~exitmodules->proc~exitinlet Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine exitinlet use modglobal , only : iinletgen , lstoreplane , ltempeq if ( iinletgen == 1 ) then deallocate ( Uinl , Winl , Urec , Wrec , u0inletbc , v0inletbc , w0inletbc , zirf , ziif , ziih , zirh , zorf , zoif , zorh , zoih , loclowif , locupif , loclowih , locupih , loclowof , locupof , loclowoh , locupoh , uminletbc , vminletbc , wminletbc , u0inletbcold , v0inletbcold , w0inletbcold , Utav , upupavinl , vpvpavinl , wpwpavinl , upwpavinl , thlpthlpavinl , thlpupavinl , thlpwpavinl ) if ( ltempeq ) then deallocate ( t0inletbc , tminletbc , t0inletbcold , loclowot , locupot , zotr , zoti , Tinl , Trec ) end if if ( lstoreplane ) then deallocate ( storeu0inletbc , storev0inletbc , storew0inletbc ) if ( ltempeq ) then deallocate ( storet0inletbc ) end if end if else if ( iinletgen == 2 ) then deallocate ( storeu0inletbc , storev0inletbc , storew0inletbc , u0inletbc , v0inletbc , w0inletbc , uminletbc , vminletbc , wminletbc , u0inletbcold , v0inletbcold , w0inletbcold ) if ( ltempeq ) then deallocate ( t0inletbc , tminletbc , t0inletbcold , storet0inletbc ) end if end if end subroutine exitinlet","tags":"","url":"proc/exitinlet.html"},{"title":"init_heatpump – uDALES","text":"public  subroutine init_heatpump() Uses decomp_2d modmpi modglobal proc~~init_heatpump~~UsesGraph proc~init_heatpump init_heatpump decomp_2d decomp_2d proc~init_heatpump->decomp_2d module~modglobal modglobal proc~init_heatpump->module~modglobal module~modmpi modmpi proc~init_heatpump->module~modmpi mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~init_heatpump~~CallsGraph proc~init_heatpump init_heatpump mpi_bcast mpi_bcast proc~init_heatpump->mpi_bcast zend zend proc~init_heatpump->zend zstart zstart proc~init_heatpump->zstart Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~init_heatpump~~CalledByGraph proc~init_heatpump init_heatpump program~dalesurban DALESURBAN program~dalesurban->proc~init_heatpump Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine init_heatpump use modglobal , only : lheatpump , nhppoints , Q_dot_hp , QH_dot_hp , rhoa , cp , ifinput , cexpnr , ltempeq , dxi , dyi use modmpi , only : myid , comm3d , mpierr use decomp_2d , only : zstart , zend implicit none integer :: n character ( 80 ) :: chmess if (. not .( lheatpump ) . or . . not .( ltempeq ) . or . ( nhppoints < 1 )) return allocate ( idhppts_global ( nhppoints , 3 )) ! Allocate global heat pump points array allocate ( lhpptsrank ( nhppoints )) ! Allocate logical array for heat pump points on this rank ! read global heat pump points if ( myid == 0 ) then open ( ifinput , file = 'heatpump.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess read ( ifinput , '(a80)' ) chmess do n = 1 , nhppoints read ( ifinput , * ) idhppts_global ( n , 1 ), idhppts_global ( n , 2 ), idhppts_global ( n , 3 ) end do close ( ifinput ) end if ! Broadcast the heat pump points to all processes call MPI_BCAST ( idhppts_global , nhppoints * 3 , MPI_INTEGER , 0 , comm3d , mpierr ) ! Determine whether points are on this rank do n = 1 , nhppoints if (( idhppts_global ( n , 1 ) >= zstart ( 1 ) . and . idhppts_global ( n , 1 ) <= zend ( 1 )) . and . & ( idhppts_global ( n , 2 ) >= zstart ( 2 ) . and . idhppts_global ( n , 2 ) <= zend ( 2 ))) then lhpptsrank ( n ) = . true . else lhpptsrank ( n ) = . false . end if end do thl_dot_hp = QH_dot_hp / ( nhppoints * rhoa * cp ) ! Calculate temperature change rate from heat loss [Km&#94;3/s] w_hp_exhaust = ( Q_dot_hp / nhppoints ) * dxi * dyi ! Calculate exhaust velocity at heat pump points [m/s] end subroutine init_heatpump","tags":"","url":"proc/init_heatpump.html"},{"title":"heatpump – uDALES","text":"public  subroutine heatpump() Uses decomp_2d modfields modmpi modglobal proc~~heatpump~~UsesGraph proc~heatpump heatpump decomp_2d decomp_2d proc~heatpump->decomp_2d module~modfields modfields proc~heatpump->module~modfields module~modglobal modglobal proc~heatpump->module~modglobal module~modmpi modmpi proc~heatpump->module~modmpi module~modfields->decomp_2d mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~heatpump~~CallsGraph proc~heatpump heatpump zsize zsize proc~heatpump->zsize Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~heatpump~~CalledByGraph proc~heatpump heatpump program~dalesurban DALESURBAN program~dalesurban->proc~heatpump Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine heatpump use modglobal , only : lheatpump , lfan_hp , nhppoints , dxi , dyi , dzfi , ltempeq use modfields , only : wm , w0 , wp , thlp use modmpi , only : myidx , myidy use decomp_2d , only : zsize implicit none integer :: n , i , j , k if (. not .( lheatpump ) . or . . not .( ltempeq ) . or . ( nhppoints < 1 )) return do n = 1 , nhppoints if ( lhpptsrank ( n )) then i = idhppts_global ( n , 1 ) - myidx * zsize ( 1 ) j = idhppts_global ( n , 2 ) - myidy * zsize ( 2 ) k = idhppts_global ( n , 3 ) if ( lfan_hp ) then ! Heat pump fan is on wm ( i , j , k + 1 ) = w_hp_exhaust ! Set exhaust velocity at heat pump point [m/s], at input 'w' cell face k+1 w0 ( i , j , k + 1 ) = w_hp_exhaust wp ( i , j , k + 1 ) = 0. end if thlp ( i , j , k ) = thlp ( i , j , k ) - thl_dot_hp * dxi * dyi * dzfi ( k ) ! [K/s], at cell center k end if end do end subroutine heatpump","tags":"","url":"proc/heatpump.html"},{"title":"exit_heatpump – uDALES","text":"public  subroutine exit_heatpump() Uses modglobal proc~~exit_heatpump~~UsesGraph proc~exit_heatpump exit_heatpump module~modglobal modglobal proc~exit_heatpump->module~modglobal Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Called by proc~~exit_heatpump~~CalledByGraph proc~exit_heatpump exit_heatpump program~dalesurban DALESURBAN program~dalesurban->proc~exit_heatpump Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine exit_heatpump use modglobal , only : lheatpump , nhppoints , ltempeq implicit none if (. not .( lheatpump ) . or . . not .( ltempeq ) . or . ( nhppoints < 1 )) return deallocate ( idhppts_global , lhpptsrank ) ! Deallocate global heat pump points array and logical array end subroutine exit_heatpump","tags":"","url":"proc/exit_heatpump.html"},{"title":"createtrees – uDALES","text":"public  subroutine createtrees() Uses modmpi modsurfdata modibmdata modglobal modfields proc~~createtrees~~UsesGraph proc~createtrees createtrees module~modfields modfields proc~createtrees->module~modfields module~modglobal modglobal proc~createtrees->module~modglobal module~modibmdata modibmdata proc~createtrees->module~modibmdata module~modmpi modmpi proc~createtrees->module~modmpi module~modsurfdata modsurfdata proc~createtrees->module~modsurfdata decomp_2d decomp_2d module~modfields->decomp_2d mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~createtrees~~CallsGraph proc~createtrees createtrees mpi_bcast mpi_bcast proc~createtrees->mpi_bcast Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~createtrees~~CalledByGraph proc~createtrees createtrees program~dalesurban DALESURBAN program~dalesurban->proc~createtrees Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine createtrees use modglobal , only : ltrees , ntrees , tree , cexpnr , ifinput , zh , zf , dzh , dzfi , dzhi , dzf , Qstar ,& dec , lad , kb , ke , cp , rhoa , ntree_max , dQdt , tr_A , dy , xh use modfields , only : um , vm , wm , thlm , qt0 , svp , up , vp , wp , thlp , qtp , Rn , clai , qc , qa , ladzh , ladzf use modmpi , only : myid , comm3d , mpierr , MY_REAL use modsurfdata , only : wtsurf use modibmdata , only : bctfz implicit none integer :: n , k real :: Rq character ( 80 ) chmess if (( ltrees . eqv . . false .) . or . ( ntrees == 0 )) return allocate ( tree ( ntrees , 6 )) ! read global trees if ( myid == 0 ) then ! write(*,*) '1, myid, ntrees, ltrees, cexpnr', myid, ntrees, ltrees, cexpnr if ( ntrees > 0 ) then open ( ifinput , file = 'trees.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess read ( ifinput , '(a80)' ) chmess do n = 1 , ntrees read ( ifinput , * ) & tree ( n , 1 ), & tree ( n , 2 ), & tree ( n , 3 ), & tree ( n , 4 ), & tree ( n , 5 ), & tree ( n , 6 ) end do ! write (6,*) 'Tree number,   il, iu, jl, ju, kl, ku ' ! do n=1,ntrees !   write (1,*) & !         n , & !         tree(n,1), & !         tree(n,2), & !         tree(n,3), & !         tree(n,4), & !         tree(n,5), & !         tree(n,6) ! end do close ( ifinput ) end if end if ! end if myid==0 ! call MPI_BCAST(ntrees ,1,MPI_INTEGER ,0,comm3d,mpierr) call MPI_BCAST ( tree , 6 * ntrees , MPI_INTEGER , 0 , comm3d , mpierr ) !! capability to read lad of trees from a lad.inp.xxx file !! tg3315 commented - for now assume constant lad or hardcode as seen below !if (myid==0) then !  allocate(ladt(nlad)) !  if (nlad>0) then !    open (ifinput,file='lad.inp.'//cexpnr) !    read (ifinput,'(a80)') chmess !    do n=1,nlad !      read (ifinput,*) & !            ladt(n) !      end do !    write (*,*) 'lad' !    do n=1,nlad !      write (1,*) & !            n , & !            ladt(n) !    end do !  end if ! input into leaf area density array (cell faces) !lad(tree(1,5):tree(1,6)+1) = ladt !defined at cell faces ! initialise tree variables that are constant in time ! calculate clai for tallest possible tree ! assume no grid stretching in lowest layer with trees if ( myid == 0 ) then ntree_max = maxval ( tree (:, 6 )) - minval ( tree (:, 5 )) + 1 ! hard code non-uniform lad profiles - temporary if (. false .) then ladzh ( 1 : ntree_max ) = ( / 0.1 , 0.11 , 0.12 , 0.14 , 0.16 , 0.19 , 0.22 , 0.265 , 0.31 , 0.335 , 0.36 , 0.37 , 0.38 , 0.3725 , 0.365 , 0.3375 , 0.31 , 0.2375 , 0.165 , 0.0875 / ) !LAI =2 from Shaw, 1992 ! assumes lad at ntree_max+1 is 0.! else ladzh ( 1 : ntree_max + 1 ) = lad !up to ntree_max+1 cos ladzh is at cell faces end if ! interpolate to find lad at cell centres do k = 1 , ntree_max ladzf ( k ) = 0.5 * ( ladzh ( k ) + ladzh ( k + 1 )) end do ! clai at cell faces using lad at cell centre do k = 1 , ntree_max clai ( k ) = sum ( 0.5 * ( ladzh ( k : ntree_max ) + ladzh ( k + 1 : ntree_max + 1 )) * ( dzf ( maxval ( tree (:, 6 )) - ntree_max + k : maxval ( tree (:, 6 ))))) end do ! Net radiation at cell faces! !W/m&#94;2 do k = 1 , ntree_max + 1 Rn ( k ) = Qstar * exp ( - dec * clai ( k )) end do ! Change in radiation over each layer (at cell centres) W/m&#94;2 do k = 1 , ntree_max qc ( k ) = Rn ( k + 1 ) - Rn ( k ) end do ! incorporate the distributed storage term - updated for zero heat storage in tree do k = 1 , ntree_max qa ( k ) = qc ( k ) !(1 - Rq*0.11) * qc(k) - 0.11*Rq*dQdt + Rq*12.3 end do ! write relevant fields ! write(*,*) 'ntree_max', ntree_max ! write(*,*) 'qa', qa(1:ntree_max) ! write(*,*) 'qc', qc(1:ntree_max) ! write(*,*) 'clai', clai(1:ntree_max+1) ! write(*,*) 'Rn', Rn(1:ntree_max+1) ! write(*,*) 'ladzf', ladzf ! write(*,*) 'ladzh', ladzh end if !apply storage to set wtsurf and bctfz as a function of Qstar wtsurf = - (( 1 - 0.7 ) * Qstar - 0.33 * dQdt + 38 ) / ( rhoa * cp ) bctfz = - (( 1 - 0.7 ) * Qstar - 0.33 * dQdt + 38 ) / ( rhoa * cp ) ! calc tree cover area - used to apply steady-state boundary condition if ( myid == 0 ) then do n = 1 , ntrees tr_A = tr_A + ( xh ( tree ( n , 2 ) + 1 ) - xh ( tree ( n , 1 ))) * dy * ( tree ( n , 4 ) - tree ( n , 3 ) + 1 ) end do end if ! write updated ground and roof heat fluxes write ( * , * ) 'wtsurf' , wtsurf write ( * , * ) 'bctfz' , bctfz ! broadcast variables call MPI_BCAST ( ntree_max , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( tr_A , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( Rn , ke + 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( qc , ke + 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( clai , ke + 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( qa , ke + 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( ladzf , ke + 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( ladzh , ke + 1 , MY_REAL , 0 , comm3d , mpierr ) end subroutine createtrees","tags":"","url":"proc/createtrees.html"},{"title":"trees – uDALES","text":"public  subroutine trees() Uses modmpi modsubgriddata modsurfdata modibmdata modglobal modfields proc~~trees~~UsesGraph proc~trees trees module~modfields modfields proc~trees->module~modfields module~modglobal modglobal proc~trees->module~modglobal module~modibmdata modibmdata proc~trees->module~modibmdata module~modmpi modmpi proc~trees->module~modmpi module~modsubgriddata modsubgriddata proc~trees->module~modsubgriddata module~modsurfdata modsurfdata proc~trees->module~modsurfdata decomp_2d decomp_2d module~modfields->decomp_2d mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments None Calls proc~~trees~~CallsGraph proc~trees trees mpi_allreduce mpi_allreduce proc~trees->mpi_allreduce Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~trees~~CalledByGraph proc~trees trees program~dalesurban DALESURBAN program~dalesurban->proc~trees Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine trees use modglobal , only : ib , ie , jb , je , kb , ke , ih , jh , dzf , xh , dxf , numol , prandtlmol , rlv , cp , tree ,& ntrees , ltrees , itot , jtot , cd , ud , lmoist , nsv , dxf , dy , dzf , dzfi , zf , dy , zh ,& ltempeq , pref0 , r_s , lad , rhoa , ntree_max , lsize , Qstar , dQdt , BCxs , tr_A ,& rslabs , kmax , rv , rd use modfields , only : um , vm , wm , thlm , qtm , svp , up , vp , wp , thlp , qtp , svm , Rn , qc , qa , thlm , clai ,& ladzf , ladzh , IIcs , tr_omega ,& tr_u , tr_v , tr_w , tr_qt , tr_qtR , tr_qtA , tr_thl , tr_sv , thlpcar use modmpi , only : myidx , myidy , mpi_sum , mpierr , comm3d , mpierr , my_real , nprocx , nprocy use modsurfdata , only : wtsurf , wttop , wqtop use modibmdata , only : bctfz use modsubgriddata , only : ekh implicit none integer :: i , j , k , n , m , il , iu , jl , ju , kl , ku real :: e_sat , e_vap , qh , qe , shade , r_a , s , D , numoli , gam , Rq , qhmin , qhmax , omega real :: Vq_dum , Vq_dum2 , Vq_dum3 , VT_dum , VT_dum2 , VT_dum3 , wTbot_dum , wTbot_dum2 , wTbot , wTbot_dum3 numoli = 1 / numol gam = ( cp * pref0 * rv ) / ( rlv * rd ) qhmin = 0. ; qhmax = 0. if ( ltrees . eqv . . false .) return ! dummy variables used for steady-state BC calculation VT_dum2 = 0. Vq_dum2 = 0. wTbot_dum2 = 0. ! loop over all tree canopies do n = 1 , ntrees ! drag in z-direction il = tree ( n , 1 ) - myidx * itot / nprocx iu = tree ( n , 2 ) - myidx * itot / nprocx kl = tree ( n , 5 ) ku = tree ( n , 6 ) + 1 jl = tree ( n , 3 ) - myidy * jtot / nprocy ju = tree ( n , 4 ) - myidy * jtot / nprocy if ( iu < ib . or . il > ie . or . ju < jb . or . jl > je ) then cycle else if ( iu > ie ) iu = ie if ( il < ib ) il = ib if ( ju > je ) ju = je if ( jl < jb ) jl = jb do k = kl , ku do j = jl , ju do i = il , iu tr_w ( i , j , k ) = - cd * ladzh ( ntree_max - ( ku - k ) + 1 ) * wm ( i , j , k ) * & sqrt ( wm ( i , j , k ) ** 2 & + ( 0.25 * ( um ( i , j , k ) + um ( i + 1 , j , k ) + um ( i , j , k - 1 ) + um ( i + 1 , j , k - 1 ))) ** 2 & + ( 0.25 * ( vm ( i , j , k ) + vm ( i , j + 1 , k ) + vm ( i , j , k - 1 ) + vm ( i , j + 1 , k - 1 ))) ** 2 ) end do end do end do end if ! drag in y-direction il = tree ( n , 1 ) - myidx * itot / nprocx iu = tree ( n , 2 ) - myidx * itot / nprocx kl = tree ( n , 5 ) ku = tree ( n , 6 ) jl = tree ( n , 3 ) - myidy * jtot / nprocy ju = tree ( n , 4 ) + 1 - myidy * jtot / nprocy if ( iu < ib . or . il > ie . or . ju < jb . or . jl > je ) then cycle else if ( iu > ie ) iu = ie if ( il < ib ) il = ib if ( ju > je ) ju = je if ( jl < jb ) jl = jb do k = kl , ku do j = jl , ju do i = il , iu tr_v ( i , j , k ) = - cd * ladzf ( ntree_max - ( ku - k )) * vm ( i , j , k ) * & sqrt ( vm ( i , j , k ) ** 2 & + ( 0.25 * ( um ( i , j , k ) + um ( i + 1 , j , k ) + um ( i , j - 1 , k ) + um ( i + 1 , j - 1 , k ))) ** 2 & + ( 0.25 * ( wm ( i , j , k ) + wm ( i , j , k + 1 ) + wm ( i , j - 1 , k ) + wm ( i , j - 1 , k + 1 ))) ** 2 ) end do end do end do end if ! drag in x-direction il = tree ( n , 1 ) - myidx * itot / nprocx iu = tree ( n , 2 ) + 1 - myidx * itot / nprocx kl = tree ( n , 5 ) ku = tree ( n , 6 ) jl = tree ( n , 3 ) - myidy * jtot / nprocy ju = tree ( n , 4 ) - myidy * jtot / nprocy if ( iu < ib . or . il > ie . or . ju < jb . or . jl > je ) then cycle else if ( iu > ie ) iu = ie if ( il < ib ) il = ib if ( ju > je ) ju = je if ( jl < jb ) jl = jb do k = kl , ku do j = jl , ju do i = il , iu tr_u ( i , j , k ) = - cd * ladzf ( ntree_max - ( ku - k )) * um ( i , j , k ) * & sqrt ( um ( i , j , k ) ** 2 & + ( 0.25 * ( vm ( i , j , k ) + vm ( i , j + 1 , k ) + vm ( i - 1 , j , k ) + vm ( i - 1 , j + 1 , k ))) ** 2 & + ( 0.25 * ( wm ( i , j , k ) + wm ( i , j , k + 1 ) + wm ( i - 1 , j , k ) + wm ( i - 1 , j , k + 1 ))) ** 2 ) end do end do end do end if ! scalar volumetric sources/sinks ! Canopy EB if ( lmoist . and . ltempeq ) then il = tree ( n , 1 ) - myidx * itot / nprocx iu = tree ( n , 2 ) - myidx * itot / nprocx kl = tree ( n , 5 ) ku = tree ( n , 6 ) jl = tree ( n , 3 ) - myidy * jtot / nprocy ju = tree ( n , 4 ) - myidy * jtot / nprocy if ( iu < ib . or . il > ie . or . ju < jb . or . jl > je ) then cycle else if ( iu > ie ) iu = ie if ( il < ib ) il = ib if ( ju > je ) ju = je if ( jl < jb ) jl = jb do k = kl , ku do j = jl , ju do i = il , iu ! psychometrics ! saturation vapour pressure pressure e_sat = 61 0.8 * exp (( 1 7.27 * ( thlm ( i , j , k ) - 27 3.15 )) / ( thlm ( i , j , k ) - 3 5.85 )) ! water vapour partial pressure e_vap = ( qtm ( i , j , k ) * pref0 ) / ( 0.378 * qtm ( i , j , k ) + 0.622 ) ! qtcheck.m and https://earthscience.stackexchange.com/questions/2360/how-do-i-convert-specific-humidity-to-relative-humidity ! vapour pressure deficit D = max ( e_sat - e_vap , 0. ) ! output warning - cannot physically occur if ( e_sat < e_vap ) then write ( * , * ) 'D, e_sat, e_vap, thlm, qtm' , D , e_sat , e_vap , thlm ( i , j , k ), qtm ( i , j , k ) end if ! slope of the curve relating saturation vapour pressure to temperature s = ( 4098 * e_sat ) / (( thlm ( i , j , k ) - 3 5.85 ) ** 2 ) ! aerodynamic resistance r_a = 130 * sqrt ( lsize / ( sqrt (( 0.5 * ( um ( i , j , k ) + um ( i + 1 , j , k ))) ** 2 + ( 0.5 * ( vm ( i , j , k ) + vm ( i , j + 1 , k ))) ** 2 + ( 0.5 * ( wm ( i , j , k ) + wm ( i , j , k + 1 ))) ** 2 ))) ! decoupling factor omega = 1 / ( 1 + 2 * ( gam / ( s + 2 * gam )) * (( r_s ) / r_a ) ) ! latent heat qe = omega * ( s / ( s + 2 * gam )) * ( qa ( ntree_max - ( ku - k )) / ( dzf ( k ) * ladzf ( ntree_max - ( ku - k )))) + ( 1 - omega ) * ( 1 / ( gam * ( r_s ))) * rhoa * cp * D ! sensible heat qh = qa ( ntree_max - ( ku - k )) / ( dzf ( k ) * ladzf ( ntree_max - ( ku - k ))) - qe ! volumetric sinks/source of specific humidity and temp tr_qt ( i , j , k ) = ladzf ( ntree_max - ( ku - k )) * qe / ( rhoa * rlv ) tr_qtR ( i , j , k ) = ladzf ( ntree_max - ( ku - k )) * ( omega * ( s / ( s + 2 * gam )) * ( qa ( ntree_max - ( ku - k )) / ( dzf ( k ) * ladzf ( ntree_max - ( ku - k ))))) / ( rhoa * rlv ) tr_qtA ( i , j , k ) = ladzf ( ntree_max - ( ku - k )) * (( 1 - omega ) * ( 1 / ( gam * ( r_s ))) * rhoa * cp * D ) / ( rhoa * rlv ) tr_thl ( i , j , k ) = ladzf ( ntree_max - ( ku - k )) * qh / ( rhoa * cp ) tr_omega ( i , j , k ) = omega ! add to rhs qtp ( i , j , k ) = qtp ( i , j , k ) + tr_qt ( i , j , k ) !ladz(ntree_max-(ku-k))*qe/(rhoa*rlv) thlp ( i , j , k ) = thlp ( i , j , k ) + tr_thl ( i , j , k ) !ladz(ntree_max-(ku-k))*qh/(rhoa*cp) ! fill dummy variables for steady-state BCs VT_dum2 = VT_dum2 - tr_thl ( i , j , k ) * dzf ( k ) * dxf ( i ) * dy Vq_dum2 = Vq_dum2 - tr_qt ( i , j , k ) * dzf ( k ) * dxf ( i ) * dy end do end do end do ! fraction of total net radiation reaching the bottom of the tree Rq = Rn ( ntree_max + 1 - ( ku + 1 - kl )) / Qstar ! sensible heat flux from shaded surfaces shade = ( ( 1 - 0.7 ) * Rn ( ntree_max + 1 - ( ku + 1 - kl ) ) - 0.33 * Rq * dQdt + Rq * 38 ) / ( rhoa * cp ) ! dummy var for steady-state BC wTbot_dum2 = wTbot_dum2 - shade * ( xh ( iu + 1 ) - xh ( il )) * dy * ( ju - jl + 1 ) ! overwrite standard heat flux defined in modibm in shaded positions thlp ( il : iu , jl : ju , kb + 1 ) = thlp ( il : iu , jl : ju , kb + 1 ) + ( bctfz + shade ) * dzfi ( kb + 1 ) end if end if !lmoist and ltempeq ! scalar deposition if ( nsv > 0 ) then ! specific to infinite canyon study (tg3315 thesis - Chapter 5) if ( BCxs == 2 ) then ! no deposition effect from first or last tree to avoid interaction with BCs if ( n == 1 ) cycle if ( n == ntrees ) cycle end if il = tree ( n , 1 ) - myidx * itot / nprocx iu = tree ( n , 2 ) - myidx * itot / nprocx kl = tree ( n , 5 ) ku = tree ( n , 6 ) jl = tree ( n , 3 ) - myidy * jtot / nprocy ju = tree ( n , 4 ) - myidy * jtot / nprocy if ( iu < ib . or . il > ie . or . ju < jb . or . jl > je ) then cycle else if ( iu > ie ) iu = ie if ( il < ib ) il = ib if ( ju > je ) ju = je if ( jl < jb ) jl = jb do m = 1 , nsv ! define this for scalar variables that are deposited do k = kl , ku do j = jl , ju do i = il , iu tr_sv ( i , j , k , m ) = - svm ( i , j , k , m ) * ladzf ( ntree_max - ( ku - k )) * ud svp ( i , j , k , m ) = svp ( i , j , k , m ) + tr_sv ( i , j , k , m ) end do end do end do end do end if end if !nsv end do ! ntrees ! define these outside loop to avoid double counting cell faces wp ( ib : ie , jb : je , kb : ke ) = wp ( ib : ie , jb : je , kb : ke ) + tr_w ( ib : ie , jb : je , kb : ke ) vp ( ib : ie , jb : je , kb : ke ) = vp ( ib : ie , jb : je , kb : ke ) + tr_v ( ib : ie , jb : je , kb : ke ) up ( ib : ie , jb : je , kb : ke ) = up ( ib : ie , jb : je , kb : ke ) + tr_u ( ib : ie , jb : je , kb : ke ) ! steady-state BC calc. if ( lmoist . and . ltempeq ) then ! dummy vars - not all used? wTbot_dum3 = 0. wTbot_dum = 0. wTbot = 0. VT_dum3 = 0. Vq_dum3 = 0. VT_dum = 0. Vq_dum = 0. ! sum dummy variables assigned in main loop call MPI_ALLREDUCE ( wTbot_dum2 , wTbot_dum3 , 1 , MY_REAL , MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( VT_dum2 , VT_dum3 , 1 , MY_REAL , MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( Vq_dum2 , Vq_dum3 , 1 , MY_REAL , MPI_SUM , comm3d , mpierr ) ! not necessary wTbot_dum = wTbot_dum3 Vq_dum = Vq_dum3 VT_dum = VT_dum3 ! total flux of temp from ground and roofs accounting for shading wTbot = wTbot_dum + (( xh ( ie + 1 ) - xh ( ib )) * jtot * dy - tr_A ) * bctfz ! temp flux at top equal to half of the total flux of heat (ground, roofs and canopies) - consistent with tg3315 thesis Chapter 4 - method iii wttop = 0.5 * ( wTbot + VT_dum ) / (( xh ( ie + 1 ) - xh ( ib )) * jtot * dy ) ! volumetric sink term throughout domain to account for the remaining heating - \"\" thlpcar = wttop / (( sum ( real ( IIcs ( kb + 1 : ke )) / rslabs ) / real ( kmax - 1. )) * ( zh ( ke + 1 ) - zh ( kb + 1 ))) ! top flux of qt equal to total from canopies - therefore uniform flux profile wqtop = ( Vq_dum ) / (( xh ( ie + 1 ) - xh ( ib )) * jtot * dy ) end if end subroutine trees","tags":"","url":"proc/trees.html"},{"title":"modtimedep – uDALES","text":"Uses mpi module~~modtimedep~~UsesGraph module~modtimedep modtimedep mpi mpi module~modtimedep->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~modtimedep~~UsedByGraph module~modtimedep modtimedep proc~readnamelists readnamelists proc~readnamelists->module~modtimedep program~dalesurban DALESURBAN program~dalesurban->module~modtimedep Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, public :: ltimedep = .false. logical, public :: ltimedepsurf = .false. logical, public :: ltimedepnudge = .false. logical, public :: ltimedeplw = .false. logical, public :: ltimedepsw = .false. integer, public :: ntimedepsurf integer, public :: ntimedepnudge integer, public :: ntimedeplw integer, public :: ntimedepsw real, private, allocatable :: timeflux (:) real, private, allocatable :: bctfxmt (:) real, private, allocatable :: bctfxpt (:) real, private, allocatable :: bctfymt (:) real, private, allocatable :: bctfypt (:) real, private, allocatable :: bctfzt (:) real, private, allocatable :: timenudge (:) real, private, allocatable :: thlproft (:,:) real, private, allocatable :: qtproft (:,:) real, private, allocatable :: uproft (:,:) real, private, allocatable :: vproft (:,:) real, private, allocatable :: timelw (:) real, private, allocatable :: skyLWt (:) real, private, allocatable :: timesw (:) real, private, allocatable :: netswt (:,:) Subroutines public  subroutine inittimedep () Arguments None public  subroutine timedep () Arguments None private  subroutine timedepsurf () Arguments None private  subroutine timedepnudge () Arguments None private  subroutine timedeplw () Arguments None private  subroutine timedepsw () Arguments None public  subroutine exittimedep () Arguments None","tags":"","url":"module/modtimedep.html"},{"title":"modfields – uDALES","text":"Uses decomp_2d module~~modfields~~UsesGraph module~modfields modfields decomp_2d decomp_2d module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~modfields~~UsedByGraph module~modfields modfields module~modfielddump modfielddump module~modfielddump->module~modfields proc~advecc2nd_corr_conservative advecc2nd_corr_conservative proc~advecc2nd_corr_conservative->module~modfields proc~advecc2nd_corr_liberal advecc2nd_corr_liberal proc~advecc2nd_corr_liberal->module~modfields proc~advecc_2nd advecc_2nd proc~advecc_2nd->module~modfields proc~advecc_kappa advecc_kappa proc~advecc_kappa->module~modfields proc~advecc_upw advecc_upw proc~advecc_upw->module~modfields proc~advection advection proc~advection->module~modfields proc~advecu_2nd advecu_2nd proc~advecu_2nd->module~modfields proc~advecv_2nd advecv_2nd proc~advecv_2nd->module~modfields proc~advecw_2nd advecw_2nd proc~advecw_2nd->module~modfields proc~bcp bcp proc~bcp->module~modfields proc~bcpup bcpup proc~bcpup->module~modfields proc~bottom bottom proc~bottom->module~modfields proc~boundary boundary proc~boundary->module~modfields proc~calc_halflev calc_halflev proc~calc_halflev->module~modfields proc~calccourant calccourant proc~calccourant->module~modfields proc~calcfluidvolumes calcfluidvolumes proc~calcfluidvolumes->module~modfields proc~calcreyn calcreyn proc~calcreyn->module~modfields proc~calthv calthv proc~calthv->module~modfields proc~chem chem proc~chem->module~modfields proc~chkdiv chkdiv proc~chkdiv->module~modfields proc~closure closure proc~closure->module~modfields proc~coriolis coriolis proc~coriolis->module~modfields proc~createmasks createmasks proc~createmasks->module~modfields proc~createtrees createtrees proc~createtrees->module~modfields proc~detfreestream detfreestream proc~detfreestream->module~modfields proc~detfreestrtmp detfreestrtmp proc~detfreestrtmp->module~modfields proc~diagfld diagfld proc~diagfld->module~modfields proc~diffe diffe proc~diffe->module~modfields proc~diffu diffu proc~diffu->module~modfields proc~diffu_corr diffu_corr proc~diffu_corr->module~modfields proc~diffv diffv proc~diffv->module~modfields proc~diffv_corr diffv_corr proc~diffv_corr->module~modfields proc~diffw diffw proc~diffw->module~modfields proc~diffw_corr diffw_corr proc~diffw_corr->module~modfields proc~drivergen drivergen proc~drivergen->module~modfields proc~exitmodules exitmodules proc~exitmodules->module~modfields proc~fielddump fielddump proc~fielddump->module~modfields proc~fixthetainf fixthetainf proc~fixthetainf->module~modfields proc~fixuinf1 fixuinf1 proc~fixuinf1->module~modfields proc~fixuinf2 fixuinf2 proc~fixuinf2->module~modfields proc~fluidvolume fluidvolume proc~fluidvolume->module~modfields proc~fluxtopscal fluxtopscal proc~fluxtopscal->module~modfields proc~forces forces proc~forces->module~modfields proc~fromztop fromztop proc~fromztop->module~modfields proc~genstats genstats proc~genstats->module~modfields proc~grwdamp grwdamp proc~grwdamp->module~modfields proc~halos halos proc~halos->module~modfields proc~heatpump heatpump proc~heatpump->module~modfields proc~ibmnorm ibmnorm proc~ibmnorm->module~modfields proc~ibmwallfun ibmwallfun proc~ibmwallfun->module~modfields proc~initdriver initdriver proc~initdriver->module~modfields proc~initfielddump initfielddump proc~initfielddump->module~modfields proc~initinlet initinlet proc~initinlet->module~modfields proc~initstatsdump initstatsdump proc~initstatsdump->module~modfields proc~inittimedep inittimedep proc~inittimedep->module~modfields proc~inletgen inletgen proc~inletgen->module~modfields proc~inletgennotemp inletgennotemp proc~inletgennotemp->module~modfields proc~interp_temperature_u interp_temperature_u proc~interp_temperature_u->module~modfields proc~interp_temperature_v interp_temperature_v proc~interp_temperature_v->module~modfields proc~interp_temperature_w interp_temperature_w proc~interp_temperature_w->module~modfields proc~interp_velocity_c interp_velocity_c proc~interp_velocity_c->module~modfields proc~interp_velocity_u interp_velocity_u proc~interp_velocity_u->module~modfields proc~interp_velocity_v interp_velocity_v proc~interp_velocity_v->module~modfields proc~interp_velocity_w interp_velocity_w proc~interp_velocity_w->module~modfields proc~lstend lstend proc~lstend->module~modfields proc~masscorr masscorr proc~masscorr->module~modfields proc~nudge nudge proc~nudge->module~modfields proc~periodicebcorr periodicEBcorr proc~periodicebcorr->module~modfields proc~purifiers purifiers proc~purifiers->module~modfields proc~readdriverfile readdriverfile proc~readdriverfile->module~modfields proc~readdriverfile_chunk readdriverfile_chunk proc~readdriverfile_chunk->module~modfields proc~readinitfiles readinitfiles proc~readinitfiles->module~modfields proc~readnamelists readnamelists proc~readnamelists->module~modfields proc~readrestartfiles readrestartfiles proc~readrestartfiles->module~modfields proc~scalsource scalsource proc~scalsource->module~modfields proc~shiftedpbcs shiftedPBCs proc~shiftedpbcs->module~modfields proc~sources sources proc~sources->module~modfields proc~statsdump statsdump proc~statsdump->module~modfields proc~subgrid subgrid proc~subgrid->module~modfields proc~thermodynamics thermodynamics proc~thermodynamics->module~modfields proc~timedepnudge timedepnudge proc~timedepnudge->module~modfields proc~tkestats tkestats proc~tkestats->module~modfields proc~tkestatsdump tkestatsdump proc~tkestatsdump->module~modfields proc~tqaver tqaver proc~tqaver->module~modfields proc~trees trees proc~trees->module~modfields proc~tstep_integrate tstep_integrate proc~tstep_integrate->module~modfields proc~tstep_update tstep_update proc~tstep_update->module~modfields proc~uoutletarea uoutletarea proc~uoutletarea->module~modfields proc~valuetopscal valuetopscal proc~valuetopscal->module~modfields proc~voutletarea voutletarea proc~voutletarea->module~modfields proc~wallfunheat wallfunheat proc~wallfunheat->module~modfields proc~wallfunmom wallfunmom proc~wallfunmom->module~modfields proc~writedriverfile writedriverfile proc~writedriverfile->module~modfields proc~writerestartfiles writerestartfiles proc~writerestartfiles->module~modfields proc~xm_periodic xm_periodic proc~xm_periodic->module~modfields proc~xmi_driver xmi_driver proc~xmi_driver->module~modfields proc~xmi_profile xmi_profile proc~xmi_profile->module~modfields proc~xmo_convective xmo_convective proc~xmo_convective->module~modfields proc~xmo_neumann xmo_Neumann proc~xmo_neumann->module~modfields proc~xq_periodic xq_periodic proc~xq_periodic->module~modfields proc~xqi_driver xqi_driver proc~xqi_driver->module~modfields proc~xqi_profile xqi_profile proc~xqi_profile->module~modfields proc~xqo_convective xqo_convective proc~xqo_convective->module~modfields proc~xs_periodic xs_periodic proc~xs_periodic->module~modfields proc~xsi_custom xsi_custom proc~xsi_custom->module~modfields proc~xsi_driver xsi_driver proc~xsi_driver->module~modfields proc~xsi_profile xsi_profile proc~xsi_profile->module~modfields proc~xso_convective xso_convective proc~xso_convective->module~modfields proc~xso_neumann xso_Neumann proc~xso_neumann->module~modfields proc~xt_periodic xT_periodic proc~xt_periodic->module~modfields proc~xti_driver xTi_driver proc~xti_driver->module~modfields proc~xti_profile xTi_profile proc~xti_profile->module~modfields proc~xto_convective xTo_convective proc~xto_convective->module~modfields proc~xto_neumann xTo_Neumann proc~xto_neumann->module~modfields proc~ym_periodic ym_periodic proc~ym_periodic->module~modfields proc~ymi_profile ymi_profile proc~ymi_profile->module~modfields proc~ymo_convective ymo_convective proc~ymo_convective->module~modfields proc~yq_periodic yq_periodic proc~yq_periodic->module~modfields proc~yqi_profile yqi_profile proc~yqi_profile->module~modfields proc~yqo_convective yqo_convective proc~yqo_convective->module~modfields proc~ys_periodic ys_periodic proc~ys_periodic->module~modfields proc~ysi_profile ysi_profile proc~ysi_profile->module~modfields proc~yso_convective yso_convective proc~yso_convective->module~modfields proc~yso_neumann yso_Neumann proc~yso_neumann->module~modfields proc~yt_periodic yT_periodic proc~yt_periodic->module~modfields proc~yti_profile yTi_profile proc~yti_profile->module~modfields proc~yto_convective yTo_convective proc~yto_convective->module~modfields program~dalesurban DALESURBAN program~dalesurban->module~modfields program~dalesurban->module~modfielddump Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real, public, allocatable :: worksave (:) real, public, allocatable :: um (:,:,:) real, public, allocatable :: vm (:,:,:) real, public, allocatable :: wm (:,:,:) real, public, allocatable :: thlm (:,:,:) real, public, allocatable :: e12m (:,:,:) real, public, allocatable :: qtm (:,:,:) real, public, allocatable, target :: u0 (:,:,:) real, public, allocatable, target :: v0 (:,:,:) real, public, allocatable, target :: w0 (:,:,:) real, public, allocatable, target :: pres0 (:,:,:) real, public, allocatable, target :: div (:,:,:) real, public, allocatable, target :: dudx (:,:,:) real, public, allocatable, target :: dvdy (:,:,:) real, public, allocatable, target :: dwdz (:,:,:) real, public, allocatable :: u0h (:,:,:) real, public, allocatable :: uinit (:,:,:) real, public, allocatable :: vinit (:,:,:) real, public, allocatable :: uh (:,:,:) real, public, allocatable :: vh (:,:,:) real, public, allocatable :: wh (:,:,:) real, public, allocatable :: pres0h (:,:,:) real, public, allocatable, target :: u01 (:,:,:) real, public, allocatable, target :: u02 (:,:,:) real, public, allocatable, target :: thl0 (:,:,:) real, public, allocatable :: thl0c (:,:,:) real, public, allocatable :: thl0h (:,:,:) real, public, allocatable :: qt0h (:,:,:) real, public, allocatable :: e120 (:,:,:) real, public, allocatable, target :: qt0 (:,:,:) real, public, allocatable :: up (:,:,:) real, public, allocatable :: vp (:,:,:) real, public, allocatable :: wp (:,:,:) real, public, allocatable, target :: ru (:,:,:) real, public, allocatable, target :: rv (:,:,:) real, public, allocatable, target :: rw (:,:,:) real, public, allocatable :: thlp (:,:,:) real, public, allocatable :: thlpc (:,:,:) real, public, allocatable :: e12p (:,:,:) real, public, allocatable :: qtp (:,:,:) real, public, allocatable :: svm (:,:,:,:) real, public, allocatable, target :: sv0 (:,:,:,:) real, public, allocatable :: svp (:,:,:,:) real, public, allocatable :: svpp (:,:,:,:) real, public, allocatable, target :: tau_x (:,:,:) real, public, allocatable, target :: tau_y (:,:,:) real, public, allocatable, target :: tau_z (:,:,:) real, public, allocatable, target :: thl_flux (:,:,:) real, public, allocatable :: mindist (:,:,:) real, public, allocatable :: shear (:,:,:,:) real, public, allocatable :: momfluxb (:,:,:) real, public, allocatable :: tfluxb (:,:,:) real, public, allocatable :: qfluxb (:,:,:) real, public, allocatable :: cth (:,:,:) integer, public, allocatable :: IIc (:,:,:) integer, public, allocatable :: IIu (:,:,:) integer, public, allocatable :: IIv (:,:,:) integer, public, allocatable :: IIw (:,:,:) integer, public, allocatable :: IIuw (:,:,:) integer, public, allocatable :: IIvw (:,:,:) integer, public, allocatable :: IIuv (:,:,:) integer, public, allocatable :: IIct (:,:) integer, public, allocatable :: IIwt (:,:) integer, public, allocatable :: IIuwt (:,:) integer, public, allocatable :: IIut (:,:) integer, public, allocatable :: IIvt (:,:) integer, public, allocatable :: IIcs (:) integer, public, allocatable :: IIus (:) integer, public, allocatable :: IIvs (:) integer, public, allocatable :: IIws (:) integer, public, allocatable :: IIuws (:) integer, public, allocatable :: IIvws (:) integer, public, allocatable :: IIuvs (:) real, public, allocatable :: Rn (:) real, public, allocatable :: clai (:) real, public, allocatable :: qc (:) real, public, allocatable :: qa (:) real, public, allocatable :: ladzf (:) real, public, allocatable :: ladzh (:) real, public, allocatable :: tr_u (:,:,:) real, public, allocatable :: tr_v (:,:,:) real, public, allocatable :: tr_w (:,:,:) real, public, allocatable :: tr_qt (:,:,:) real, public, allocatable :: tr_qtR (:,:,:) real, public, allocatable :: tr_qtA (:,:,:) real, public, allocatable :: tr_thl (:,:,:) real, public, allocatable :: tr_sv (:,:,:,:) real, public, allocatable :: tr_omega (:,:,:) real, public, allocatable :: tr_ut (:,:,:) real, public, allocatable :: tr_vt (:,:,:) real, public, allocatable :: tr_wt (:,:,:) real, public, allocatable :: tr_qtt (:,:,:) real, public, allocatable :: tr_qtRt (:,:,:) real, public, allocatable :: tr_qtAt (:,:,:) real, public, allocatable :: tr_thlt (:,:,:) real, public, allocatable :: tr_sv1t (:,:,:) real, public, allocatable :: tr_sv2t (:,:,:) real, public, allocatable :: tr_omegat (:,:,:) real, public, allocatable :: uyt (:,:) real, public, allocatable :: uytik (:,:) real, public, allocatable :: vyt (:,:) real, public, allocatable :: wyt (:,:) real, public, allocatable :: wytik (:,:) real, public, allocatable :: thlyt (:,:) real, public, allocatable :: qtyt (:,:) real, public, allocatable :: thlytk (:,:) real, public, allocatable :: sca1yt (:,:) real, public, allocatable :: sca2yt (:,:) real, public, allocatable :: sca3yt (:,:) real, public, allocatable :: thlsgsyt (:,:) real, public, allocatable :: qtsgsyt (:,:) real, public, allocatable :: usgsyt (:,:) real, public, allocatable :: wsgsyt (:,:) real, public, allocatable :: sv1sgsyt (:,:) real, public, allocatable :: sv2sgsyt (:,:) real, public, allocatable :: sv3sgsyt (:,:) real, public, allocatable :: uxyt (:) real, public, allocatable :: vxyt (:) real, public, allocatable :: wxyt (:) real, public, allocatable :: thlxyt (:) real, public, allocatable :: qtxyt (:) real, public, allocatable :: pxyt (:) real, public, allocatable :: usgsxyt (:) real, public, allocatable :: thlsgsxyt (:) real, public, allocatable :: vsgsxyt (:) real, public, allocatable :: uwtik (:,:,:) real, public, allocatable :: wthltk (:,:,:) real, public, allocatable :: wqttk (:,:,:) real, public, allocatable :: thlthlt (:,:,:) real, public, allocatable :: qtqtt (:,:,:) real, public, allocatable :: sv1sv1t (:,:,:) real, public, allocatable :: sv2sv2t (:,:,:) real, public, allocatable :: sv3sv3t (:,:,:) real, public, allocatable :: sv4sv4t (:,:,:) real, public, allocatable :: PSSt (:,:,:) real, public, allocatable :: uutc (:,:,:) real, public, allocatable :: vvtc (:,:,:) real, public, allocatable :: wwtc (:,:,:) real, public, allocatable :: vwtjk (:,:,:) real, public, allocatable :: uvtij (:,:,:) real, public, allocatable :: utik (:,:,:) real, public, allocatable :: wtik (:,:,:) real, public, allocatable :: vtjk (:,:,:) real, public, allocatable :: wtjk (:,:,:) real, public, allocatable :: utij (:,:,:) real, public, allocatable :: vtij (:,:,:) real, public, allocatable :: wmt (:,:,:) real, public, allocatable :: thltk (:,:,:) real, public, allocatable :: qttk (:,:,:) real, public, allocatable :: thlt (:,:,:) real, public, allocatable :: utc (:,:,:) real, public, allocatable :: vtc (:,:,:) real, public, allocatable :: wtc (:,:,:) real, public, allocatable :: vmt (:,:,:) real, public, allocatable :: umt (:,:,:) real, public, allocatable :: sv1t (:,:,:) real, public, allocatable :: sv2t (:,:,:) real, public, allocatable :: sv3t (:,:,:) real, public, allocatable :: sv4t (:,:,:) real, public, allocatable :: sv1tk (:,:,:) real, public, allocatable :: sv2tk (:,:,:) real, public, allocatable :: sv3tk (:,:,:) real, public, allocatable :: sv4tk (:,:,:) real, public, allocatable :: wsv1tk (:,:,:) real, public, allocatable :: wsv2tk (:,:,:) real, public, allocatable :: wsv3tk (:,:,:) real, public, allocatable :: wsv4tk (:,:,:) real, public, allocatable :: sv1sgst (:,:,:) real, public, allocatable :: sv2sgst (:,:,:) real, public, allocatable :: sv3sgst (:,:,:) real, public, allocatable :: sv4sgst (:,:,:) real, public, allocatable :: qtt (:,:,:) real, public, allocatable :: pt (:,:,:) real, public, allocatable :: scar (:,:) real, public, allocatable :: scarl (:,:) real, public, allocatable :: uav (:,:,:) real, public, allocatable :: vav (:,:,:) real, public, allocatable :: wav (:,:,:) real, public, allocatable :: thlav (:,:,:) real, public, allocatable :: qtav (:,:,:) real, public, allocatable :: qlav (:,:,:) real, public, allocatable :: presav (:,:,:) real, public, allocatable :: svav (:,:,:,:) real, public, allocatable :: viscratioav (:,:,:) real, public, allocatable :: umint (:,:,:) real, public, allocatable :: vmint (:,:,:) real, public, allocatable :: wmint (:,:,:) real, public, allocatable :: thl2av (:,:,:) real, public, allocatable :: ql2av (:,:,:) real, public, allocatable :: qt2av (:,:,:) real, public, allocatable :: sv2av (:,:,:,:) real, public, allocatable :: uuav (:,:,:) real, public, allocatable :: vvav (:,:,:) real, public, allocatable :: wwav (:,:,:) real, public, allocatable :: uvav (:,:,:) real, public, allocatable :: uwav (:,:,:) real, public, allocatable :: vwav (:,:,:) real, public, allocatable :: thluav (:,:,:) real, public, allocatable :: thlvav (:,:,:) real, public, allocatable :: thlwav (:,:,:) real, public, allocatable :: thlthlav (:,:,:) real, public, allocatable :: qluav (:,:,:) real, public, allocatable :: qlvav (:,:,:) real, public, allocatable :: qlwav (:,:,:) real, public, allocatable :: qtuav (:,:,:) real, public, allocatable :: qtvav (:,:,:) real, public, allocatable :: qtwav (:,:,:) real, public, allocatable :: svuav (:,:,:,:) real, public, allocatable :: svvav (:,:,:,:) real, public, allocatable :: svwav (:,:,:,:) real, public, allocatable :: upupav (:,:,:) real, public, allocatable :: vpvpav (:,:,:) real, public, allocatable :: wpwpav (:,:,:) real, public, allocatable :: thlpthlpav (:,:,:) real, public, allocatable :: qlpqlpav (:,:,:) real, public, allocatable :: qtpqtpav (:,:,:) real, public, allocatable :: svpsvpav (:,:,:,:) real, public, allocatable :: upvpav (:,:,:) real, public, allocatable :: upwpav (:,:,:) real, public, allocatable :: vpwpav (:,:,:) real, public, allocatable :: thlpupav (:,:,:) real, public, allocatable :: thlpvpav (:,:,:) real, public, allocatable :: thlpwpav (:,:,:) real, public, allocatable :: qlpupav (:,:,:) real, public, allocatable :: qlpvpav (:,:,:) real, public, allocatable :: qlpwpav (:,:,:) real, public, allocatable :: qtpupav (:,:,:) real, public, allocatable :: qtpvpav (:,:,:) real, public, allocatable :: qtpwpav (:,:,:) real, public, allocatable :: svpupav (:,:,:,:) real, public, allocatable :: svpvpav (:,:,:,:) real, public, allocatable :: svpwpav (:,:,:,:) real, public, allocatable :: uusgsav (:,:,:) real, public, allocatable :: vvsgsav (:,:,:) real, public, allocatable :: wwsgsav (:,:,:) real, public, allocatable :: uwsgsav (:,:,:) real, public, allocatable :: thlusgsav (:,:,:) real, public, allocatable :: thlwsgsav (:,:,:) real, public, allocatable :: qlusgsav (:,:,:) real, public, allocatable :: qlwsgsav (:,:,:) real, public, allocatable :: qtusgsav (:,:,:) real, public, allocatable :: qtwsgsav (:,:,:) real, public, allocatable :: svusgsav (:,:,:,:) real, public, allocatable :: svwsgsav (:,:,:,:) real, public, allocatable :: tkesgsav (:,:,:) real, public, allocatable :: nusgsav (:,:,:) real, public, allocatable :: strain2av (:,:,:) real, public, allocatable :: disssgsav (:,:,:) real, public, allocatable :: tvmx (:,:,:) real, public, allocatable :: tvmy (:,:,:) real, public, allocatable :: tvmz (:,:,:) real, public, allocatable :: tpm (:,:,:) real, public, allocatable :: ttmx (:,:,:) real, public, allocatable :: ttmy (:,:,:) real, public, allocatable :: ttmz (:,:,:) real, public, allocatable :: tsgsmx1 (:,:,:) real, public, allocatable :: tsgsmy1 (:,:,:) real, public, allocatable :: tsgsmz1 (:,:,:) real, public, allocatable :: tsgsmx2 (:,:,:) real, public, allocatable :: tsgsmy2 (:,:,:) real, public, allocatable :: tsgsmz2 (:,:,:) real, public, allocatable :: t_vav (:,:,:) real, public, allocatable :: t_sgsav (:,:,:) real, public, allocatable :: t_pav (:,:,:) real, public, allocatable :: t_tav (:,:,:) real, public, allocatable :: p_tav (:,:,:) real, public, allocatable :: p_bav (:,:,:) real, public, allocatable :: d_sgsav (:,:,:) real, public, allocatable :: tkeadv (:,:,:) real, public, allocatable :: t_v (:) real, public, allocatable :: t_sgs (:) real, public, allocatable :: t_p (:) real, public, allocatable :: t_t (:) real, public, allocatable :: p_t (:) real, public, allocatable :: p_b (:) real, public, allocatable :: d_sgs (:) real, public, allocatable :: adv (:) real, public, allocatable, target :: ql0 (:,:,:) real, public, allocatable :: thv0h (:,:,:) real, public, allocatable :: whls (:) real, public, allocatable :: presf (:) real, public, allocatable :: presh (:) real, public, allocatable :: exnf (:) real, public, allocatable :: exnh (:) real, public, allocatable :: thvf (:) real, public, allocatable :: thvh (:) real, public, allocatable :: rhof (:) real, public, allocatable :: qt0av (:) real, public, allocatable :: ql0av (:) real, public, allocatable :: thl0av (:) real, public, allocatable :: u0av (:) real, public, allocatable :: v0av (:) real, public, allocatable :: ug (:) real, public, allocatable :: vg (:) real, public, allocatable :: pgx (:) real, public, allocatable :: pgy (:) real, public, allocatable :: dpdxl (:) real, public, allocatable :: dpdyl (:) real, public, allocatable :: dthldxls (:) real, public, allocatable :: dthldyls (:) real, public, allocatable :: dqtdxls (:) real, public, allocatable :: dqtdyls (:) real, public, allocatable :: dqtdtls (:) real, public, allocatable :: dudxls (:) real, public, allocatable :: dudyls (:) real, public, allocatable :: dvdxls (:) real, public, allocatable :: dvdyls (:) real, public, allocatable :: wfls (:) real, public, allocatable :: ql0h (:,:,:) real, public, allocatable :: dthvdz (:,:,:) real, public, allocatable :: thlprof (:) real, public, allocatable :: qtprof (:) real, public, allocatable :: uprof (:) real, public, allocatable :: vprof (:) real, public, allocatable :: e12prof (:) real, public, allocatable :: sv0av (:,:) real, public, allocatable :: svprof (:,:) real, public, allocatable :: qlprof (:) real, public, allocatable :: rhobf (:) real, public, allocatable :: rhobh (:) real, public, allocatable :: thlpcar (:) real, public, allocatable :: SW_up_TOA (:,:) real, public, allocatable :: SW_dn_TOA (:,:) real, public, allocatable :: LW_up_TOA (:,:) real, public, allocatable :: LW_dn_TOA (:,:) real, public, allocatable :: wout (:) real, public, allocatable :: friction (:) real, public, allocatable :: momthick (:) real, public, allocatable :: displthick (:) real, public :: uouttot real, public :: vouttot real, public :: wouttot real, public :: udef real, public :: vdef real, public :: thlsrcdt real, public :: dgdt real, public :: dpdx = 0. real, public :: uoutarea real, public :: voutarea real, public :: fluidvol character(len=80), public, allocatable :: ncname (:,:) character(len=80), public, allocatable :: ncname1 (:,:) character(len=80), public, allocatable :: ncname2 (:,:) character(len=80), public, allocatable :: ncstaty (:,:) character(len=80), public, allocatable :: ncstatyt (:,:) character(len=80), public, allocatable :: ncstattke (:,:) character(len=80), public, allocatable :: ncstatxy (:,:) character(len=80), public, allocatable :: ncstatxyt (:,:) character(len=80), public, allocatable :: ncstatkslice (:,:) character(len=80), public, allocatable :: ncstatislice (:,:) character(len=80), public, allocatable :: ncstatjslice (:,:) character(len=80), public, allocatable :: ncstatt (:,:) character(len=80), public, allocatable :: ncstattr (:,:) character(len=80), public, allocatable :: ncstatmint (:,:) integer, public, allocatable :: wall (:,:,:,:) Subroutines public  subroutine initfields () Arguments None public  subroutine exitfields () Arguments None","tags":"","url":"module/modfields.html"},{"title":"modstatistics – uDALES","text":"Uses modmpi modglobal module~~modstatistics~~UsesGraph module~modstatistics modstatistics module~modglobal modglobal module~modstatistics->module~modglobal module~modmpi modmpi module~modstatistics->module~modmpi mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~modstatistics~~UsedByGraph module~modstatistics modstatistics proc~statsdump statsdump proc~statsdump->module~modstatistics Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: klow integer, private :: khigh integer, private :: i integer, private :: j integer, private :: k Subroutines public  subroutine genstats (tsamplep, tstatsdumpp, umint, vmint, wmint) Arguments Type Intent Optional Attributes Name real :: tsamplep real :: tstatsdumpp real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) :: umint real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) :: vmint real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) :: wmint public  subroutine tkestats (tsamplep, tstatsdumpp) Arguments Type Intent Optional Attributes Name real :: tsamplep real :: tstatsdumpp","tags":"","url":"module/modstatistics.html"},{"title":"modmpi – uDALES","text":"Uses mpi module~~modmpi~~UsesGraph module~modmpi modmpi mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~modmpi~~UsedByGraph module~modmpi modmpi module~initfac initfac module~initfac->module~modmpi module~modstat_nc modstat_nc module~modstat_nc->module~modmpi module~modstatistics modstatistics module~modstatistics->module~modmpi module~modstatsdump modstatsdump module~modstatsdump->module~modmpi proc~advecc_2nd advecc_2nd proc~advecc_2nd->module~modmpi proc~advecc_2nd->module~initfac proc~advecu_2nd advecu_2nd proc~advecu_2nd->module~modmpi proc~bcpup bcpup proc~bcpup->module~modmpi proc~bottom bottom proc~bottom->module~modmpi proc~boundary boundary proc~boundary->module~modmpi proc~calccourant calccourant proc~calccourant->module~modmpi proc~calcdiffnr calcdiffnr proc~calcdiffnr->module~modmpi proc~calcreyn calcreyn proc~calcreyn->module~modmpi proc~checkinitvalues checkinitvalues proc~checkinitvalues->module~modmpi proc~checksim checksim proc~checksim->module~modmpi proc~chkdiv chkdiv proc~chkdiv->module~modmpi proc~closure closure proc~closure->module~modmpi proc~coriolis coriolis proc~coriolis->module~modmpi proc~createmasks createmasks proc~createmasks->module~modmpi proc~createpurifiers createpurifiers proc~createpurifiers->module~modmpi proc~createscals createscals proc~createscals->module~modmpi proc~createtrees createtrees proc~createtrees->module~modmpi proc~detfreestream detfreestream proc~detfreestream->module~modmpi proc~detfreestrtmp detfreestrtmp proc~detfreestrtmp->module~modmpi proc~diagfld diagfld proc~diagfld->module~modmpi proc~diffc diffc proc~diffc->module~modmpi proc~diffe diffe proc~diffe->module~modmpi proc~diffu diffu proc~diffu->module~modmpi proc~diffv diffv proc~diffv->module~modmpi proc~diffw diffw proc~diffw->module~modmpi proc~driverchunkread driverchunkread proc~driverchunkread->module~modmpi proc~drivergen drivergen proc~drivergen->module~modmpi proc~eb EB proc~eb->module~modmpi proc~eb->module~initfac proc~eb->module~modstat_nc proc~enthalpythickness enthalpythickness proc~enthalpythickness->module~modmpi proc~exitmodules exitmodules proc~exitmodules->module~modmpi proc~fielddump fielddump proc~fielddump->module~modmpi proc~fielddump->module~modstat_nc proc~fixthetainf fixthetainf proc~fixthetainf->module~modmpi proc~fixuinf1 fixuinf1 proc~fixuinf1->module~modmpi proc~fixuinf2 fixuinf2 proc~fixuinf2->module~modmpi proc~fluidvolume fluidvolume proc~fluidvolume->module~modmpi proc~forces forces proc~forces->module~modmpi proc~genstats genstats proc~genstats->module~modmpi proc~grwdamp grwdamp proc~grwdamp->module~modmpi proc~heatpump heatpump proc~heatpump->module~modmpi proc~ibmnorm ibmnorm proc~ibmnorm->module~modmpi proc~ibmwallfun ibmwallfun proc~ibmwallfun->module~modmpi proc~ibmwallfun->module~modstat_nc proc~init2decomp init2decomp proc~init2decomp->module~modmpi proc~init_heatpump init_heatpump proc~init_heatpump->module~modmpi proc~initchecksim initchecksim proc~initchecksim->module~modmpi proc~initdriver initdriver proc~initdriver->module~modmpi proc~initeb initEB proc~initeb->module~modmpi proc~initeb->module~initfac proc~initeb->module~modstat_nc proc~initfielddump initfielddump proc~initfielddump->module~modmpi proc~initfielddump->module~modstat_nc proc~initglobal initglobal proc~initglobal->module~modmpi proc~initibm initibm proc~initibm->module~modmpi proc~initibm->module~modstat_nc proc~initibmnorm initibmnorm proc~initibmnorm->module~modmpi proc~initibmwallfun initibmwallfun proc~initibmwallfun->module~modmpi proc~initibmwallfun->module~initfac proc~initinlet initinlet proc~initinlet->module~modmpi proc~initstat_nc initstat_nc proc~initstat_nc->module~modmpi proc~initstatsdump initstatsdump proc~initstatsdump->module~modmpi proc~initstatsdump->module~modstat_nc proc~initsubgrid initsubgrid proc~initsubgrid->module~modmpi proc~inittimedep inittimedep proc~inittimedep->module~modmpi proc~inletgen inletgen proc~inletgen->module~modmpi proc~inletgennotemp inletgennotemp proc~inletgennotemp->module~modmpi proc~intqh intqH proc~intqh->module~modmpi proc~intqh->module~initfac proc~lstend lstend proc~lstend->module~modmpi proc~masscorr masscorr proc~masscorr->module~modmpi proc~momentumthicknessexp momentumthicknessexp proc~momentumthicknessexp->module~modmpi proc~nudge nudge proc~nudge->module~modmpi proc~periodicebcorr periodicEBcorr proc~periodicebcorr->module~modmpi proc~purifiers purifiers proc~purifiers->module~modmpi proc~randomnize randomnize proc~randomnize->module~modmpi proc~readdriverfile readdriverfile proc~readdriverfile->module~modmpi proc~readdriverfile_chunk readdriverfile_chunk proc~readdriverfile_chunk->module~modmpi proc~readinitfiles readinitfiles proc~readinitfiles->module~modmpi proc~readinletfile readinletfile proc~readinletfile->module~modmpi proc~readnamelists readnamelists proc~readnamelists->module~modmpi proc~readrestartfiles readrestartfiles proc~readrestartfiles->module~modmpi proc~readzincoord readzincoord proc~readzincoord->module~modmpi proc~scalsource scalsource proc~scalsource->module~modmpi proc~statsdump statsdump proc~statsdump->module~modmpi proc~statsdump->module~modstat_nc proc~statsdump->module~modstatistics proc~subgrid subgrid proc~subgrid->module~modmpi proc~subgridnamelist subgridnamelist proc~subgridnamelist->module~modmpi proc~thermodynamics thermodynamics proc~thermodynamics->module~modmpi proc~timedeplw timedeplw proc~timedeplw->module~modmpi proc~timedepnudge timedepnudge proc~timedepnudge->module~modmpi proc~timedepsurf timedepsurf proc~timedepsurf->module~modmpi proc~timedepsw timedepsw proc~timedepsw->module~modmpi proc~timedepsw->module~initfac proc~tkestatsdump tkestatsdump proc~tkestatsdump->module~modmpi proc~tqaver tqaver proc~tqaver->module~modmpi proc~trees trees proc~trees->module~modmpi proc~tstep_integrate tstep_integrate proc~tstep_integrate->module~modmpi proc~tstep_update tstep_update proc~tstep_update->module~modmpi proc~uoutletarea uoutletarea proc~uoutletarea->module~modmpi proc~valuetop valuetop proc~valuetop->module~modmpi proc~voutletarea voutletarea proc~voutletarea->module~modmpi proc~wallfunheat wallfunheat proc~wallfunheat->module~modmpi proc~wallfunheat->module~initfac proc~wallfunmom wallfunmom proc~wallfunmom->module~modmpi proc~wallfunmom->module~initfac proc~wfgr wfGR proc~wfgr->module~modmpi proc~wfgr->module~initfac proc~wfmneutral wfmneutral proc~wfmneutral->module~modmpi proc~wfmneutral->module~initfac proc~wfuno wfuno proc~wfuno->module~modmpi proc~wfuno->module~initfac proc~writedriverfile writedriverfile proc~writedriverfile->module~modmpi proc~writeinletfile writeinletfile proc~writeinletfile->module~modmpi proc~writerestartfiles writerestartfiles proc~writerestartfiles->module~modmpi proc~writerestartfiles->module~initfac proc~writestat_dims_nc writestat_dims_nc proc~writestat_dims_nc->module~modmpi proc~xm_periodic xm_periodic proc~xm_periodic->module~modmpi proc~ym_periodic ym_periodic proc~ym_periodic->module~modmpi proc~yt_periodic yT_periodic proc~yt_periodic->module~modmpi program~dalesurban DALESURBAN program~dalesurban->module~modmpi program~dalesurban->module~initfac program~dalesurban->module~modstat_nc program~dalesurban->module~modstatsdump proc~calclw calclw proc~calclw->module~initfac proc~exitfielddump exitfielddump proc~exitfielddump->module~modstat_nc proc~exitstatsdump exitstatsdump proc~exitstatsdump->module~modstat_nc proc~tkestats tkestats proc~tkestats->module~modstat_nc proc~updategr updateGR proc~updategr->module~initfac Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: comm3d integer, public :: nbrnorth integer, public :: nbrsouth integer, public :: nbreast integer, public :: nbrwest integer, public :: myid integer, public :: myidx integer, public :: myidy integer, public :: nprocs integer, public :: nprocx integer, public :: nprocy integer, public :: mpierr integer, public :: my_real real, public :: CPU_program real, public :: CPU_program0 character(len=3), public :: cmyid character(len=3), public :: cmyidx character(len=3), public :: cmyidy Subroutines public  subroutine initmpi () Arguments None public  subroutine starttimer () Arguments None public  subroutine exitmpi () Arguments None public  subroutine barrou () Arguments None public  subroutine excis (a, sx, ex, sy, ey, sz, ez, ih, jh) Arguments Type Intent Optional Attributes Name real :: a (sx-ih:ex+ih,sy-jh:ey+jh,sz:ez) integer :: sx integer :: ex integer :: sy integer :: ey integer :: sz integer :: ez integer :: ih integer :: jh public  subroutine excjs (a, sx, ex, sy, ey, sz, ez, ih, jh) Arguments Type Intent Optional Attributes Name real :: a (sx-ih:ex+ih,sy-jh:ey+jh,sz:ez) integer :: sx integer :: ex integer :: sy integer :: ey integer :: sz integer :: ez integer :: ih integer :: jh public  subroutine slabsum (aver, ks, kf, var, ib, ie, jb, je, kb, ke, ibs, ies, jbs, jes, kbs, kes) Arguments Type Intent Optional Attributes Name real :: aver (ks:kf) integer :: ks integer :: kf real :: var (ib:ie,jb:je,kb:ke) integer :: ib integer :: ie integer :: jb integer :: je integer :: kb integer :: ke integer :: ibs integer :: ies integer :: jbs integer :: jes integer :: kbs integer :: kes public  subroutine avexy_ibm (aver, var, ib, ie, jb, je, kb, ke, ih, jh, kh, II, IIs, lnan) Arguments Type Intent Optional Attributes Name real :: aver (kb:ke+kh) real :: var (ib:ie,jb:je,kb:ke+kh) integer :: ib integer :: ie integer :: jb integer :: je integer :: kb integer :: ke integer :: ih integer :: jh integer :: kh integer :: II (ib:ie,jb:je,kb:ke+kh) integer :: IIs (kb:ke+kh) logical :: lnan public  subroutine slabsumi (aver, iis, iif, var, ib, ie, jb, je, kb, ke, ibs, ies, jbs, jes, kbs, kes) Arguments Type Intent Optional Attributes Name real :: aver (iis:iif) integer :: iis integer :: iif real :: var (ib:ie,jb:je,kb:ke) integer :: ib integer :: ie integer :: jb integer :: je integer :: kb integer :: ke integer :: ibs integer :: ies integer :: jbs integer :: jes integer :: kbs integer :: kes public  subroutine avey_ibm (aver, var, ib, ie, jb, je, kb, ke, II, IIt) Arguments Type Intent Optional Attributes Name real :: aver (ib:ie,kb:ke) real :: var (ib:ie,jb:je,kb:ke) integer :: ib integer :: ie integer :: jb integer :: je integer :: kb integer :: ke integer :: II (ib:ie,jb:je,kb:ke) integer :: IIt (ib:ie,kb:ke) public  subroutine sumy_ibm (sumy, var, ib, ie, jb, je, kb, ke, II) Arguments Type Intent Optional Attributes Name real :: sumy (ib:ie,kb:ke) real :: var (ib:ie,jb:je,kb:ke) integer :: ib integer :: ie integer :: jb integer :: je integer :: kb integer :: ke integer :: II (ib:ie,jb:je,kb:ke) public  subroutine sumx_ibm (sumx, var, ib, ie, jb, je, kb, ke, II) Arguments Type Intent Optional Attributes Name real :: sumx (jb:je,kb:ke) real :: var (ib:ie,jb:je,kb:ke) integer :: ib integer :: ie integer :: jb integer :: je integer :: kb integer :: ke integer :: II (ib:ie,jb:je,kb:ke)","tags":"","url":"module/modmpi.html"},{"title":"modthermodynamics – uDALES","text":"Used by module~~modthermodynamics~~UsedByGraph module~modthermodynamics modthermodynamics proc~exitmodules exitmodules proc~exitmodules->module~modthermodynamics proc~readinitfiles readinitfiles proc~readinitfiles->module~modthermodynamics proc~readnamelists readnamelists proc~readnamelists->module~modthermodynamics program~dalesurban DALESURBAN program~dalesurban->module~modthermodynamics Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, public :: lqlnr = .false. real, public, allocatable :: th0av (:) real, public :: chi_half = 0.5 real, public, allocatable :: thv0 (:,:,:) Subroutines public  subroutine initthermodynamics () Arguments None public  subroutine thermodynamics () Arguments None public  subroutine exitthermodynamics () Arguments None public  subroutine calthv () Arguments None public  subroutine diagfld () Arguments None public  subroutine fromztop () Arguments None public  subroutine thermo (thl, qt, ql, pressure, exner) Arguments Type Intent Optional Attributes Name real, intent(in) :: thl (ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh) real, intent(in) :: qt (ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh) real, intent(out) :: ql (ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) real, intent(in) :: pressure (kb:ke+kh) real, intent(in) :: exner (kb:ke+kh) public  subroutine calc_halflev () Arguments None","tags":"","url":"module/modthermodynamics.html"},{"title":"modEB – uDALES","text":"Uses mpi modglobal module~~modeb~~UsesGraph module~modeb modEB module~modglobal modglobal module~modeb->module~modglobal mpi mpi module~modeb->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~modeb~~UsedByGraph module~modeb modEB program~dalesurban DALESURBAN program~dalesurban->module~modeb Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: nstatT = 2 integer, public :: nstatEB = 6 integer, public :: ncidT integer, public :: ncidEB integer, public :: nrecT = 0 integer, public :: nrecEB = 0 character(len=80), public, allocatable :: ncstatT (:,:) character(len=80), public, allocatable :: ncstatEB (:,:) character(len=80), public :: Tname = \"facT.xxx.nc\" character(len=80), public :: EBname = 'facEB.xxx.nc' character(len=80), public, dimension(1,4) :: tncstatT character(len=80), public, dimension(1,4) :: tncstatEB real, public, allocatable :: varsT (:,:,:) real, public, allocatable :: varsEB (:,:) Functions public pure function matinv3 (A) result(B) Arguments Type Intent Optional Attributes Name real, intent(in) :: A (3,3) Return Value real, (3,3) public pure function matinv4 (A) result(B) Arguments Type Intent Optional Attributes Name real, intent(in) :: A (4,4) Return Value real, (4,4) public  function gaussji (c, d, n) result(a) Arguments Type Intent Optional Attributes Name real, intent(in) :: c (n,n) real, intent(in) :: d (n,n) integer :: n Return Value real, (n,n) Subroutines public  subroutine intqH () Arguments None public  subroutine initEB () Arguments None public  subroutine calclw () Arguments None public  subroutine updateGR () Arguments None public  subroutine EB () Arguments None","tags":"","url":"module/modeb.html"},{"title":"modstatsdump – uDALES","text":"Uses mpi modmpi modglobal module~~modstatsdump~~UsesGraph module~modstatsdump modstatsdump module~modglobal modglobal module~modstatsdump->module~modglobal module~modmpi modmpi module~modstatsdump->module~modmpi mpi mpi module~modstatsdump->mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~modstatsdump~~UsedByGraph module~modstatsdump modstatsdump program~dalesurban DALESURBAN program~dalesurban->module~modstatsdump Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: ncidy integer, private :: ncidyt integer, private :: ncidtke integer, private :: ncidxy integer, private :: ncidkslice integer, private :: ncidislice integer, private :: ncidjslice integer, private :: ncidxyt integer, private :: ncidtr integer, private :: nrecy = 0 integer, private :: nrecyt = 0 integer, private :: nrectke = 0 integer, private :: nrecxy = 0 integer, private :: nreckslice = 0 integer, private :: nrecislice = 0 integer, private :: nrecjslice = 0 integer, private :: nrecxyt = 0 integer, private :: nrectr = 0 integer, private :: nstatyt = 34 integer, private :: nstaty = 14 integer, private :: nstattke = 8 integer, private :: nstatxy = 15 integer, private :: nstatkslice = 5 integer, private :: nstatislice = 5 integer, private :: nstatjslice = 5 integer, private :: nstatxyt = 23 integer, private :: ncidt integer, private :: nrect = 0 integer, private :: nstatt = 32 integer, private :: nstattr = 10 integer, private :: ncidmint integer, private :: nrecmint = 0 integer, private :: nstatmint = 6 character(len=80), private :: yname = 'ydump.xxx.nc' character(len=80), private :: ytname = 'ytdump.xxx.nc' character(len=80), private :: tkename = 'tkedump.xxx.nc' character(len=80), private :: xyname = 'xydump.xxx.nc' character(len=80), private :: xytname = 'xytdump.xxx.nc' character(len=80), private :: tname = 'tdump.xxx.xxx.xxx.nc' character(len=80), private :: mintname = 'mintdump.xxx.xxx.xxx.nc' character(len=80), private :: kslicename = 'kslicedump.xxx.xxx.xxx.nc' character(len=80), private :: islicename = 'islicedump.xxx.xxx.xxx.nc' character(len=80), private :: jslicename = 'jslicedump.xxx.xxx.xxx.nc' character(len=80), private :: trname = 'treedump.xxx.xxx.xxx.nc' character(len=80), private, dimension(1,4) :: tncstaty character(len=80), private, dimension(1,4) :: tncstatyt character(len=80), private, dimension(1,4) :: tncstattke character(len=80), private, dimension(1,4) :: tncstatxy character(len=80), private, dimension(1,4) :: tncstatkslice character(len=80), private, dimension(1,4) :: tncstatislice character(len=80), private, dimension(1,4) :: tncstatjslice character(len=80), private, dimension(1,4) :: tncstatxyt character(len=80), private, dimension(1,4) :: tncstatt character(len=80), private, dimension(1,4) :: tncstattr character(len=80), private, dimension(1,4) :: tncstatmint integer, private :: klow integer, private :: khigh integer, private :: i integer, private :: j integer, private :: k real, private :: tsamplep real, private :: tstatsdumpp real, private :: tsample real, private :: tstatsdump Subroutines public  subroutine initstatsdump () Arguments None public  subroutine statsdump () Arguments None private  subroutine tkestatsdump () Arguments None public  subroutine exitstatsdump () Arguments None","tags":"","url":"module/modstatsdump.html"},{"title":"modfielddump – uDALES","text":"Uses mpi modfields modglobal module~~modfielddump~~UsesGraph module~modfielddump modfielddump module~modfields modfields module~modfielddump->module~modfields module~modglobal modglobal module~modfielddump->module~modglobal mpi mpi module~modfielddump->mpi decomp_2d decomp_2d module~modfields->decomp_2d Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~modfielddump~~UsedByGraph module~modfielddump modfielddump program~dalesurban DALESURBAN program~dalesurban->module~modfielddump Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: ncid integer, private :: ncid1 integer, private :: ncid2 integer, private :: nrec = 0 type( domainptr ), private, dimension(30) :: pfields character(len=80), private :: fname = 'fielddump.xxx.xxx.xxx.nc' character(len=80), private :: fname1 = 'fielddump.xxx.xxx.xxx.1.nc' character(len=80), private :: fname2 = 'fielddump.xxx.xxx.xxx.2.nc' character(len=80), private, dimension(1,4) :: tncname character(len=80), private, dimension(1,4) :: tncname1 character(len=80), private, dimension(1,4) :: tncname2 integer, private :: ilow integer, private :: ihigh integer, private :: jlow integer, private :: jhigh integer, private :: klow integer, private :: khigh integer, private :: nvar logical, private :: ldiracc = .false. logical, private :: lbinary = .false. logical, private :: lhalos Derived Types type, private :: domainptr Components Type Visibility Attributes Name Initial real, public, pointer :: point (:,:,:) Subroutines public  subroutine initfielddump () Arguments None public  subroutine fielddump () Arguments None public  subroutine exitfielddump () Arguments None","tags":"","url":"module/modfielddump.html"},{"title":"modboundary – uDALES","text":"Uses mpi module~~modboundary~~UsesGraph module~modboundary modboundary mpi mpi module~modboundary->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~modboundary~~UsedByGraph module~modboundary modboundary proc~closure closure proc~closure->module~modboundary proc~ibmnorm ibmnorm proc~ibmnorm->module~modboundary proc~readinitfiles readinitfiles proc~readinitfiles->module~modboundary proc~readnamelists readnamelists proc~readnamelists->module~modboundary program~dalesurban DALESURBAN program~dalesurban->module~modboundary Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: ksp = -1 real, private, allocatable :: tsc (:) real, private :: rnu0 = 2.75e-3 Subroutines public  subroutine initboundary () Arguments None public  subroutine halos () Arguments None public  subroutine boundary () Arguments None public  subroutine closurebc () Arguments None public  subroutine xm_periodic () Arguments None public  subroutine xT_periodic () Arguments None public  subroutine xq_periodic () Arguments None public  subroutine xs_periodic () Arguments None public  subroutine ym_periodic () Arguments None public  subroutine yT_periodic () Arguments None public  subroutine yq_periodic () Arguments None public  subroutine ys_periodic () Arguments None private  subroutine xmi_profile () Arguments None private  subroutine xmi_driver () Arguments None private  subroutine xTi_profile () Arguments None private  subroutine xTi_driver () Arguments None private  subroutine xqi_profile () Arguments None private  subroutine xqi_driver () Arguments None private  subroutine xsi_profile () Arguments None private  subroutine xsi_custom () Arguments None private  subroutine xsi_driver () Arguments None private  subroutine xmo_convective () Arguments None private  subroutine xmo_Neumann () Arguments None private  subroutine xTo_convective () Arguments None private  subroutine xTo_Neumann () Arguments None private  subroutine xqo_convective () Arguments None private  subroutine xso_convective () Arguments None private  subroutine xso_Neumann () Arguments None private  subroutine ymi_profile () Arguments None private  subroutine yTi_profile () Arguments None private  subroutine yqi_profile () Arguments None private  subroutine ysi_profile () Arguments None private  subroutine ymo_convective () Arguments None private  subroutine yTo_convective () Arguments None private  subroutine yqo_convective () Arguments None private  subroutine yso_convective () Arguments None private  subroutine yso_Neumann () Arguments None public  subroutine bcpup (pup, pvp, pwp, rk3coef) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(ib - ih:ie + ih, jb - jh:je + jh, kb:ke + kh) :: pup real, intent(inout), dimension(ib - ih:ie + ih, jb - jh:je + jh, kb:ke + kh) :: pvp real, intent(inout), dimension(ib - ih:ie + ih, jb - jh:je + jh, kb:ke + kh) :: pwp real, intent(in) :: rk3coef public  subroutine bcp (p) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(ib - ih:ie + ih, jb - jh:je + jh, kb - kh:ke + kh) :: p public  subroutine grwdamp () Arguments None private  subroutine fluxtop (field, ek, flux) Arguments Type Intent Optional Attributes Name real, intent(inout) :: field (ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh) real, intent(in) :: ek (ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh) real, intent(in) :: flux private  subroutine valuetop (field, val) Arguments Type Intent Optional Attributes Name real, intent(inout) :: field (ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh) real, intent(in) :: val private  subroutine fluxtopscal (flux) Arguments Type Intent Optional Attributes Name real, intent(in) :: flux (1:nsv) private  subroutine valuetopscal (val) Arguments Type Intent Optional Attributes Name real, intent(in) :: val (1:nsv) public  subroutine tqaver () Arguments None","tags":"","url":"module/modboundary.html"},{"title":"modglobal – uDALES","text":"Used by module~~modglobal~~UsedByGraph module~modglobal modglobal module~initfac initfac module~initfac->module~modglobal module~modchecksim modchecksim module~modchecksim->module~modglobal module~modeb modEB module~modeb->module~modglobal module~modfielddump modfielddump module~modfielddump->module~modglobal module~modstatistics modstatistics module~modstatistics->module~modglobal module~modstatsdump modstatsdump module~modstatsdump->module~modglobal proc~advecc2nd_corr_conservative advecc2nd_corr_conservative proc~advecc2nd_corr_conservative->module~modglobal proc~advecc2nd_corr_liberal advecc2nd_corr_liberal proc~advecc2nd_corr_liberal->module~modglobal proc~advecc_2nd advecc_2nd proc~advecc_2nd->module~modglobal proc~advecc_2nd->module~initfac proc~advecc_kappa advecc_kappa proc~advecc_kappa->module~modglobal proc~advecc_upw advecc_upw proc~advecc_upw->module~modglobal proc~advection advection proc~advection->module~modglobal proc~advecu_2nd advecu_2nd proc~advecu_2nd->module~modglobal proc~advecv_2nd advecv_2nd proc~advecv_2nd->module~modglobal proc~advecw_2nd advecw_2nd proc~advecw_2nd->module~modglobal proc~alignment alignment proc~alignment->module~modglobal proc~bcp bcp proc~bcp->module~modglobal proc~bcpup bcpup proc~bcpup->module~modglobal proc~blthickness blthickness proc~blthickness->module~modglobal proc~blthicknessmo blthicknessmo proc~blthicknessmo->module~modglobal proc~blthicknesst blthicknesst proc~blthicknesst->module~modglobal proc~bottom bottom proc~bottom->module~modglobal proc~boundary boundary proc~boundary->module~modglobal proc~calc_halflev calc_halflev proc~calc_halflev->module~modglobal proc~calccourant calccourant proc~calccourant->module~modglobal proc~calcdiffnr calcdiffnr proc~calcdiffnr->module~modglobal proc~calclw calclw proc~calclw->module~modglobal proc~calclw->module~initfac proc~calcreyn calcreyn proc~calcreyn->module~modglobal proc~calthv calthv proc~calthv->module~modglobal proc~checkinitvalues checkinitvalues proc~checkinitvalues->module~modglobal proc~checksim checksim proc~checksim->module~modglobal proc~chem chem proc~chem->module~modglobal proc~chkdiv chkdiv proc~chkdiv->module~modglobal proc~closure closure proc~closure->module~modglobal proc~closurebc closurebc proc~closurebc->module~modglobal proc~coriolis coriolis proc~coriolis->module~modglobal proc~createmasks createmasks proc~createmasks->module~modglobal proc~createpurifiers createpurifiers proc~createpurifiers->module~modglobal proc~createscals createscals proc~createscals->module~modglobal proc~createtrees createtrees proc~createtrees->module~modglobal proc~detfreestream detfreestream proc~detfreestream->module~modglobal proc~detfreestrtmp detfreestrtmp proc~detfreestrtmp->module~modglobal proc~diagfld diagfld proc~diagfld->module~modglobal proc~diffc diffc proc~diffc->module~modglobal proc~diffc_corr diffc_corr proc~diffc_corr->module~modglobal proc~diffe diffe proc~diffe->module~modglobal proc~diffu diffu proc~diffu->module~modglobal proc~diffu_corr diffu_corr proc~diffu_corr->module~modglobal proc~diffv diffv proc~diffv->module~modglobal proc~diffv_corr diffv_corr proc~diffv_corr->module~modglobal proc~diffw diffw proc~diffw->module~modglobal proc~diffw_corr diffw_corr proc~diffw_corr->module~modglobal proc~dispthickness dispthickness proc~dispthickness->module~modglobal proc~dispthicknessexp dispthicknessexp proc~dispthicknessexp->module~modglobal proc~dispthicknessmo dispthicknessmo proc~dispthicknessmo->module~modglobal proc~driverchunkread driverchunkread proc~driverchunkread->module~modglobal proc~drivergen drivergen proc~drivergen->module~modglobal proc~eb EB proc~eb->module~modglobal proc~eb->module~initfac proc~enthalpythickness enthalpythickness proc~enthalpythickness->module~modglobal proc~eval_corners eval_corners proc~eval_corners->module~modglobal proc~exit_heatpump exit_heatpump proc~exit_heatpump->module~modglobal proc~exitdriver exitdriver proc~exitdriver->module~modglobal proc~exitfielddump exitfielddump proc~exitfielddump->module~modglobal proc~exitinlet exitinlet proc~exitinlet->module~modglobal proc~exitmodules exitmodules proc~exitmodules->module~modglobal proc~exitstatsdump exitstatsdump proc~exitstatsdump->module~modglobal proc~fielddump fielddump proc~fielddump->module~modglobal proc~fixthetainf fixthetainf proc~fixthetainf->module~modglobal proc~fixuinf1 fixuinf1 proc~fixuinf1->module~modglobal proc~fixuinf2 fixuinf2 proc~fixuinf2->module~modglobal proc~fluidvolume fluidvolume proc~fluidvolume->module~modglobal proc~fluxtop fluxtop proc~fluxtop->module~modglobal proc~fluxtopscal fluxtopscal proc~fluxtopscal->module~modglobal proc~forces forces proc~forces->module~modglobal proc~fromztop fromztop proc~fromztop->module~modglobal proc~genstats genstats proc~genstats->module~modglobal proc~grwdamp grwdamp proc~grwdamp->module~modglobal proc~halos halos proc~halos->module~modglobal proc~heat_transfer_coef_flux heat_transfer_coef_flux proc~heat_transfer_coef_flux->module~modglobal proc~heatpump heatpump proc~heatpump->module~modglobal proc~ibmnorm ibmnorm proc~ibmnorm->module~modglobal proc~ibmwallfun ibmwallfun proc~ibmwallfun->module~modglobal proc~init2decomp init2decomp proc~init2decomp->module~modglobal proc~init_heatpump init_heatpump proc~init_heatpump->module~modglobal proc~initboundary initboundary proc~initboundary->module~modglobal proc~initchecksim initchecksim proc~initchecksim->module~modglobal proc~initdriver initdriver proc~initdriver->module~modglobal proc~initeb initEB proc~initeb->module~modglobal proc~initeb->module~initfac proc~initfielddump initfielddump proc~initfielddump->module~modglobal proc~initfields initfields proc~initfields->module~modglobal proc~initibm initibm proc~initibm->module~modglobal proc~initibmnorm initibmnorm proc~initibmnorm->module~modglobal proc~initibmwallfun initibmwallfun proc~initibmwallfun->module~modglobal proc~initibmwallfun->module~initfac proc~initinlet initinlet proc~initinlet->module~modglobal proc~initstat_nc initstat_nc proc~initstat_nc->module~modglobal proc~initstatsdump initstatsdump proc~initstatsdump->module~modglobal proc~initsubgrid initsubgrid proc~initsubgrid->module~modglobal proc~initthermodynamics initthermodynamics proc~initthermodynamics->module~modglobal proc~inittimedep inittimedep proc~inittimedep->module~modglobal proc~inletgen inletgen proc~inletgen->module~modglobal proc~inletgennotemp inletgennotemp proc~inletgennotemp->module~modglobal proc~intqh intqH proc~intqh->module~modglobal proc~intqh->module~initfac proc~is_equal is_equal proc~is_equal->module~modglobal proc~local_coords local_coords proc~local_coords->module~modglobal proc~lstend lstend proc~lstend->module~modglobal proc~masscorr masscorr proc~masscorr->module~modglobal proc~mom_transfer_coef_neutral mom_transfer_coef_neutral proc~mom_transfer_coef_neutral->module~modglobal proc~mom_transfer_coef_stability mom_transfer_coef_stability proc~mom_transfer_coef_stability->module~modglobal proc~momentumthickness momentumthickness proc~momentumthickness->module~modglobal proc~momentumthicknessexp momentumthicknessexp proc~momentumthicknessexp->module~modglobal proc~momentumthicknessmo momentumthicknessmo proc~momentumthicknessmo->module~modglobal proc~nudge nudge proc~nudge->module~modglobal proc~open_nc open_nc proc~open_nc->module~modglobal proc~periodicebcorr periodicEBcorr proc~periodicebcorr->module~modglobal proc~plane_line_intersection plane_line_intersection proc~plane_line_intersection->module~modglobal proc~purifiers purifiers proc~purifiers->module~modglobal proc~randomnize randomnize proc~randomnize->module~modglobal proc~readdriverfile readdriverfile proc~readdriverfile->module~modglobal proc~readdriverfile_chunk readdriverfile_chunk proc~readdriverfile_chunk->module~modglobal proc~readfacetfiles readfacetfiles proc~readfacetfiles->module~modglobal proc~readinitfiles readinitfiles proc~readinitfiles->module~modglobal proc~readinletfile readinletfile proc~readinletfile->module~modglobal proc~readnamelists readnamelists proc~readnamelists->module~modglobal proc~readrestartfiles readrestartfiles proc~readrestartfiles->module~modglobal proc~readzincoord readzincoord proc~readzincoord->module~modglobal proc~rlim rlim proc~rlim->module~modglobal proc~scalsource scalsource proc~scalsource->module~modglobal proc~shiftedpbcs shiftedPBCs proc~shiftedpbcs->module~modglobal proc~solid solid proc~solid->module~modglobal proc~sources sources proc~sources->module~modglobal proc~statsdump statsdump proc~statsdump->module~modglobal proc~statsdump->module~modstatistics proc~subgrid subgrid proc~subgrid->module~modglobal proc~subgridnamelist subgridnamelist proc~subgridnamelist->module~modglobal proc~thermo thermo proc~thermo->module~modglobal proc~thermodynamics thermodynamics proc~thermodynamics->module~modglobal proc~timedeplw timedeplw proc~timedeplw->module~modglobal proc~timedepnudge timedepnudge proc~timedepnudge->module~modglobal proc~timedepsurf timedepsurf proc~timedepsurf->module~modglobal proc~timedepsw timedepsw proc~timedepsw->module~modglobal proc~timedepsw->module~initfac proc~tkestats tkestats proc~tkestats->module~modglobal proc~tkestatsdump tkestatsdump proc~tkestatsdump->module~modglobal proc~tqaver tqaver proc~tqaver->module~modglobal proc~trees trees proc~trees->module~modglobal proc~trilinear_interp_var trilinear_interp_var proc~trilinear_interp_var->module~modglobal proc~tstep_integrate tstep_integrate proc~tstep_integrate->module~modglobal proc~tstep_update tstep_update proc~tstep_update->module~modglobal proc~unoh unoh proc~unoh->module~modglobal proc~unom unom proc~unom->module~modglobal proc~uoutletarea uoutletarea proc~uoutletarea->module~modglobal proc~updategr updateGR proc~updategr->module~modglobal proc~updategr->module~initfac proc~valuetop valuetop proc~valuetop->module~modglobal proc~valuetopscal valuetopscal proc~valuetopscal->module~modglobal proc~voutletarea voutletarea proc~voutletarea->module~modglobal proc~wallfunheat wallfunheat proc~wallfunheat->module~modglobal proc~wallfunheat->module~initfac proc~wallfunmom wallfunmom proc~wallfunmom->module~modglobal proc~wallfunmom->module~initfac proc~wfgr wfGR proc~wfgr->module~modglobal proc~wfgr->module~initfac proc~wfmneutral wfmneutral proc~wfmneutral->module~modglobal proc~wfmneutral->module~initfac proc~wfuno wfuno proc~wfuno->module~modglobal proc~wfuno->module~initfac proc~writedriverfile writedriverfile proc~writedriverfile->module~modglobal proc~writeinletfile writeinletfile proc~writeinletfile->module~modglobal proc~writerestartfiles writerestartfiles proc~writerestartfiles->module~modglobal proc~writerestartfiles->module~initfac proc~writestat_dims_nc writestat_dims_nc proc~writestat_dims_nc->module~modglobal proc~xm_periodic xm_periodic proc~xm_periodic->module~modglobal proc~xmi_driver xmi_driver proc~xmi_driver->module~modglobal proc~xmi_profile xmi_profile proc~xmi_profile->module~modglobal proc~xmo_convective xmo_convective proc~xmo_convective->module~modglobal proc~xmo_neumann xmo_Neumann proc~xmo_neumann->module~modglobal proc~xq_periodic xq_periodic proc~xq_periodic->module~modglobal proc~xqi_driver xqi_driver proc~xqi_driver->module~modglobal proc~xqi_profile xqi_profile proc~xqi_profile->module~modglobal proc~xqo_convective xqo_convective proc~xqo_convective->module~modglobal proc~xs_periodic xs_periodic proc~xs_periodic->module~modglobal proc~xsi_custom xsi_custom proc~xsi_custom->module~modglobal proc~xsi_driver xsi_driver proc~xsi_driver->module~modglobal proc~xsi_profile xsi_profile proc~xsi_profile->module~modglobal proc~xso_convective xso_convective proc~xso_convective->module~modglobal proc~xso_neumann xso_Neumann proc~xso_neumann->module~modglobal proc~xt_periodic xT_periodic proc~xt_periodic->module~modglobal proc~xti_driver xTi_driver proc~xti_driver->module~modglobal proc~xti_profile xTi_profile proc~xti_profile->module~modglobal proc~xto_convective xTo_convective proc~xto_convective->module~modglobal proc~xto_neumann xTo_Neumann proc~xto_neumann->module~modglobal proc~yinterpolate yinterpolate proc~yinterpolate->module~modglobal proc~yinterpolateh yinterpolateh proc~yinterpolateh->module~modglobal proc~ym_periodic ym_periodic proc~ym_periodic->module~modglobal proc~ymi_profile ymi_profile proc~ymi_profile->module~modglobal proc~ymo_convective ymo_convective proc~ymo_convective->module~modglobal proc~yq_periodic yq_periodic proc~yq_periodic->module~modglobal proc~yqi_profile yqi_profile proc~yqi_profile->module~modglobal proc~yqo_convective yqo_convective proc~yqo_convective->module~modglobal proc~ys_periodic ys_periodic proc~ys_periodic->module~modglobal proc~ysi_profile ysi_profile proc~ysi_profile->module~modglobal proc~yso_convective yso_convective proc~yso_convective->module~modglobal proc~yso_neumann yso_Neumann proc~yso_neumann->module~modglobal proc~yt_periodic yT_periodic proc~yt_periodic->module~modglobal proc~yti_profile yTi_profile proc~yti_profile->module~modglobal proc~yto_convective yTo_convective proc~yto_convective->module~modglobal proc~zinterpolate zinterpolate proc~zinterpolate->module~modglobal proc~zinterpolate1d zinterpolate1d proc~zinterpolate1d->module~modglobal proc~zinterpolate2d zinterpolate2d proc~zinterpolate2d->module~modglobal proc~zinterpolatet zinterpolatet proc~zinterpolatet->module~modglobal proc~zinterpolatet1d zinterpolatet1d proc~zinterpolatet1d->module~modglobal proc~zinterpolatew zinterpolatew proc~zinterpolatew->module~modglobal proc~zinterpolatew1d zinterpolatew1d proc~zinterpolatew1d->module~modglobal program~dalesurban DALESURBAN program~dalesurban->module~modglobal program~dalesurban->module~initfac program~dalesurban->module~modchecksim program~dalesurban->module~modeb program~dalesurban->module~modfielddump program~dalesurban->module~modstatsdump Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: poisrcheck = 0 integer, public :: itot = 96 integer, public :: jtot = 96 integer, public :: ktot = 96 integer, public :: imax integer, public :: imax1 integer, public :: imax2 integer, public :: isen integer, public :: jmax integer, public :: jmax1 integer, public :: jmax2 integer, public :: jsen integer, public :: kmax integer, public :: kmax1 integer, public :: kmax2 integer, public :: ib integer, public :: ie integer, public :: jb integer, public :: je integer, public :: jgb integer, public :: jge integer, public :: offset integer, public :: kb integer, public :: ke integer, public :: nsv = 0 integer, public :: nvar = 0 character(len=50), public :: fieldvars = '' integer, public :: ih = 3 integer, public :: jh = 3 integer, public :: kh = 1 integer, public :: ihc = 2 integer, public :: jhc = 2 integer, public :: khc = 2 integer, public :: nblocks = 0 integer, public, allocatable :: block (:,:) integer, public :: nfcts = -1 integer, public :: iplane integer, public :: nstore = 1002 character(len=90), public :: fname_options = 'namoptions' integer, public, parameter :: longint = 8 logical, public :: lwarmstart = .false. logical, public :: lstratstart = .false. logical, public :: lfielddump = .false. logical, public :: lreadscal = .false. integer, public, parameter :: BCxm_periodic = 1 integer, public, parameter :: BCxm_profile = 2 integer, public, parameter :: BCxm_driver = 3 integer, public, parameter :: BCxT_periodic = 1 integer, public, parameter :: BCxT_profile = 2 integer, public, parameter :: BCxT_driver = 3 integer, public, parameter :: BCxq_periodic = 1 integer, public, parameter :: BCxq_profile = 2 integer, public, parameter :: BCxq_driver = 3 integer, public, parameter :: BCxs_periodic = 1 integer, public, parameter :: BCxs_profile = 2 integer, public, parameter :: BCxs_driver = 3 integer, public, parameter :: BCxs_custom = 4 integer, public :: BCxm = BCxm_periodic integer, public :: BCxT = BCxT_periodic integer, public :: BCxq = BCxq_periodic integer, public :: BCxs = BCxs_periodic integer, public, parameter :: BCym_periodic = 1 integer, public, parameter :: BCym_profile = 2 integer, public, parameter :: BCyT_periodic = 1 integer, public, parameter :: BCyT_profile = 2 integer, public, parameter :: BCyq_periodic = 1 integer, public, parameter :: BCyq_profile = 2 integer, public, parameter :: BCys_periodic = 1 integer, public, parameter :: BCys_profile = 2 integer, public :: BCym = BCym_periodic integer, public :: BCyT = BCyT_periodic integer, public :: BCyq = BCyq_periodic integer, public :: BCys = BCys_periodic integer, public, parameter :: BCtopm_freeslip = 1 integer, public, parameter :: BCtopm_noslip = 2 integer, public, parameter :: BCtopm_pressure = 3 integer, public, parameter :: BCtopT_flux = 1 integer, public, parameter :: BCtopT_value = 2 integer, public, parameter :: BCtopq_flux = 1 integer, public, parameter :: BCtopq_value = 2 integer, public, parameter :: BCtops_flux = 1 integer, public, parameter :: BCtops_value = 2 integer, public :: BCtopm = BCtopm_freeslip integer, public :: BCtopT = BCtopT_flux integer, public :: BCtopq = BCtopq_flux integer, public :: BCtops = BCtops_flux integer, public, parameter :: BCbotm_freeslip = 1 integer, public, parameter :: BCbotm_wf = 2 integer, public, parameter :: BCbotm_wfneutral = 3 integer, public, parameter :: BCbotT_flux = 1 integer, public, parameter :: BCbotT_wf = 2 integer, public, parameter :: BCbotq_flux = 1 integer, public, parameter :: BCbots_flux = 1 integer, public :: BCbotm = BCbotm_wf integer, public :: BCbotT = BCbotT_flux integer, public :: BCbotq = BCbotq_flux integer, public :: BCbots = BCbots_flux integer, public :: BCzp = 1 real, public :: ds = 0 integer, public :: iinletgen = 0 integer, public :: idriver = 0 logical, public :: linoutflow = .false. logical, public :: lzerogradtop = .false. logical, public :: lzerogradtopscal = .false. logical, public :: lbuoyancy = .false. logical, public :: ltempeq = .false. logical, public :: lscalrec = .false. logical, public :: lSIRANEinout = .false. logical, public :: ltempinout = .false. logical, public :: lmoistinout = .false. logical, public :: lper2inout = .false. logical, public :: libm = .true. logical, public :: lwalldist = .false. logical, public :: lles = .true. logical, public :: linletRA = .false. logical, public :: lfixinlet = .false. logical, public :: lfixutauin = .false. logical, public :: lscasrc = .false. logical, public :: lscasrcl = .false. logical, public :: lydump = .false. logical, public :: lytdump = .false. logical, public :: lxydump = .false. logical, public :: lxytdump = .false. logical, public :: lscasrcr = .false. logical, public :: ltkedump = .false. logical, public :: lkslicedump = .false. logical, public :: lislicedump = .false. logical, public :: ljslicedump = .false. integer, public :: kslice = 1 integer, public :: islice = 1 integer, public :: jslice = 1 integer, public :: isliceloc logical, public :: islicerank integer, public :: jsliceloc logical, public :: jslicerank logical, public :: ltdump = .false. logical, public :: lmintdump = .false. logical, public :: ltrees = .false. logical, public :: lpurif = .false. logical, public :: ltreedump = .false. logical, public :: lreadminl = .false. logical, public :: lwallfunc = .true. logical, public :: luoutflowr = .false. logical, public :: lvoutflowr = .false. logical, public :: luvolflowr = .false. logical, public :: lvvolflowr = .false. logical, public :: lstoreplane = .false. logical, public :: lstorexy = .false. logical, public :: lreadmean = .false. logical, public :: lstat = .false. logical, public :: lEB = .false. logical, public :: lwriteEBfiles = .false. logical, public :: lwritefac = .false. real, public :: dtfac = 10. real, public :: tfac = 0. real, public :: tnextfac = 0. logical, public :: lperiodicEBcorr = .false. integer, public :: sinkbase = 0 real, public :: fraction = 1 logical, public :: lvfsparse = .false. integer, public :: nnz logical, public :: lconstW = .false. logical, public :: lfacTlyrs = .false. integer, public :: ifixuinf = 0 logical, public :: lvinf = .false. logical, public :: lrandomize = .true. logical, public :: ibrank logical, public :: ierank logical, public :: jbrank logical, public :: jerank real, public :: freestreamav = 0. real, public :: freestrtmpav = 0. integer, public, parameter :: ifinput = 1 integer, public, parameter :: ifoutput = 2 integer, public, parameter :: ifnamopt = 3 real, public, parameter :: pi = 3.141592653589793116 real, public, parameter :: grav = 9.81 real, public, parameter :: rd = 287.04 real, public, parameter :: rv = 461.5 real, public, parameter :: cp = 1004. real, public, parameter :: rlv = 2.26e6 real, public, parameter :: rlvi = 1/rlv real, public, parameter :: ep = rd/rv real, public, parameter :: ep2 = rv/rd-1. real, public, parameter :: rcp = rd/cp real, public, parameter :: cpr = cp/rd real, public, parameter :: rlvocp = rlv/cp real, public, parameter :: mair = 28.967 real, public, parameter :: rhoa = 1.2 real, public :: wfc = 313. real, public :: wwilt = 171. real, public :: wgrmax = 450. real, public :: rsmin = 110. real, public :: rsmax = 5000. real, public :: GRLAI = 2. real, public :: wsoil = 0. real, public :: bldT = 0. real, public :: flrT = 0. real, public :: skyLW = 0. real, public :: gres = 0. real, public :: grqs = 0. real, public :: grdqdt = 0. real, public, parameter :: numol = 1.5e-5 real, public, parameter :: numoli = 1./numol real, public, parameter :: prandtlmol = 0.71 real, public, parameter :: prandtlmoli = 1./prandtlmol real, public :: prandtlturb = prandtlmol integer, public :: iwallmom = 2 integer, public :: iwalltemp = 1 integer, public :: iwallmoist = 1 integer, public :: iwallscal = 1 real, public, parameter :: rhow = 0.998e3 real, public, parameter :: pref0 = 1.e5 real, public, parameter :: tmelt = 273.16 real, public, parameter :: es0 = 610.78 real, public, parameter :: at = 17.27 real, public, parameter :: bt = 35.86 real, public, parameter :: ekmin = 1.e-12 real, public, parameter :: e12min = 5.e-5 real, public :: fkar = 0.41 real, public, parameter :: eps1 = 1.e-10 real, public, parameter :: epscloud = 1.e-5 real, public, parameter :: boltz = 5.67e-8 real, public, parameter,               dimension(3) :: xhat = (/1., 0., 0./) real, public, parameter,               dimension(3) :: yhat = (/0., 1., 0./) real, public, parameter,               dimension(3) :: zhat = (/0., 0., 1./) real, public, parameter,               dimension(3) :: vec0 = (/0., 0., 0./) logical, public :: lprofforc = .false. logical, public :: lcoriol = .false. integer, public :: igrw_damp = 0 real, public :: geodamptime = 7200. real, public :: uflowrate = 1. real, public :: vflowrate = 1. real, public :: Uinf = 0. real, public :: Vinf = 0. real, public :: inletav = 0. real, public :: totinletav = 0. real, public :: om22 real, public :: om23 real, public :: om22_gs real, public :: om23_gs real, public :: xlat = 52. real, public :: xlon = 0. real, public, allocatable :: xSa (:) real, public, allocatable :: ySa (:) real, public, allocatable :: zSa (:) real, public :: xS = 0. real, public :: yS = 0. real, public :: zS = 0. real, public :: xSb = 0. real, public :: ySb = 0. real, public :: zSb = 0. real, public :: xSe = 0. real, public :: ySe = 0. real, public :: zSe = 0. real, public :: SS = 0. real, public :: sigS = 0. integer, public :: nscasrc = 0 integer, public :: nscasrcl = 0 real, public, allocatable :: scasrcp (:,:,:) real, public, allocatable :: scasrcl (:,:,:) integer, public, allocatable :: tree (:,:) integer, public :: ntree_max = 0 integer, public :: ntrees = 0 real, public :: cd = 0. real, public :: ud = 0. real, public :: Qstar = 0. real, public :: dQdt = 0. real, public :: dec = 0. real, public :: lad = 0. real, public :: lsize = 0. real, public :: r_s = 0. real, public :: tr_A = 0. logical, public :: lnudge = .false. logical, public :: lnudgevel = .true. real, public :: tnudge = 60. integer, public :: nnudge = 0 logical, public :: lchem = .false. real, public :: k1 = 0. real, public :: JNO2 = 0. integer, public, allocatable :: purif (:,:) integer, public :: npurif = 0 real, public :: Qpu = 0. real, public :: epu = 0. logical, public :: lheatpump = .false. logical, public :: lfan_hp = .true. integer, public :: nhppoints = 0 real, public :: QH_dot_hp = 0. real, public :: Q_dot_hp = 0. integer, public, parameter :: POISS_FFT2D = 0 integer, public, parameter :: POISS_CYC = 1 integer, public, parameter :: POISS_FFT3D = 2 integer, public, parameter :: POISS_FFT2D_2DECOMP = 3 integer, public :: ipoiss = POISS_FFT2D integer, public, parameter :: iadv_upw = 1 integer, public, parameter :: iadv_cd2 = 2 integer, public, parameter :: iadv_kappa = 7 integer, public :: iadv_mom = 2 integer, public :: iadv_tke = -1 integer, public :: iadv_thl = -1 integer, public :: iadv_qt = -1 integer, public :: iadv_sv (100) = -1 logical, public :: lmoist = .false. real, public :: xday = 1. real, public :: xtime = 0. real, public :: runtime = 300. real, public :: dtmax = 20. real, public :: trestart = 10000. real, public :: tfielddump = 10000. real, public :: tsample = 5. real, public :: tstatsdump = 10000. real, public :: tstatstart = 0. real, public :: tnextrestart real, public :: tscale real, public :: tnextfielddump character(len=90), public :: startfile = '' real, public :: totavtime = 0. real, public :: dtEB = 10. real, public :: tEB = 0. real, public :: tnextEB = 0. real, public :: totheatflux = 0. real, public :: totqflux = 0. real, public :: thres = 5.e-3 real, public :: dqt real, public :: dtheta real, public, allocatable :: dsv (:) real, public :: dt real, public :: timee real, public :: btime real, public :: runavtime integer, public :: ntimee integer, public :: ntrun real, public :: timeleft logical, public :: ladaptive = .false. real, public :: tdriverstart = 0. real, public :: tdriverstart_cold = 0. real, public :: tdriverdump real, public :: dtdriver = 0.1 integer, public :: driverstore integer, public :: driverjobnr character(len=3), public :: cdriverjobnr logical, public :: lhdriver = .false. logical, public :: lqdriver = .false. logical, public :: lsdriver = .false. logical, public :: iplanerank = .false. integer, public :: driverid character(len=3), public :: cdriverid logical, public :: lchunkread = .false. integer, public :: chunkread_size = 100 real, public :: courant = -1. real, public :: diffnr = 0.25 real, public :: dt_lim integer, public :: rk3step = 0 integer, public :: iexpnr = 0 character(len=3), public :: cexpnr real, public :: thlsrc = 0. real, public :: dx real, public :: dx2 real, public :: dxi real, public :: dxiq real, public :: dxi5 real, public :: dx2i real, public :: dy real, public :: dy2 real, public :: dz real, public :: dyi real, public :: dyiq real, public :: dyi5 real, public :: dy2i integer, public :: nfaclyrs = 3 real, public, allocatable :: AM (:,:) real, public, allocatable :: BM (:,:) real, public, allocatable :: CM (:,:) real, public, allocatable :: DM (:,:) real, public, allocatable :: EM (:,:) real, public, allocatable :: FM (:,:) real, public, allocatable :: GM (:,:) real, public, allocatable :: HM (:,:) real, public, allocatable :: inAM (:,:) real, public, allocatable :: IDM (:,:) real, public, allocatable :: bb (:) real, public, allocatable :: w (:) real, public, allocatable :: dumv (:) real, public, allocatable :: Tdash (:) real, public :: rslabs real, public, allocatable :: dzf (:) real, public, allocatable :: dzfc (:) real, public, allocatable :: dzfci (:) real, public, allocatable :: dzf2 (:) real, public, allocatable :: dzh (:) real, public, allocatable :: zh (:) real, public, allocatable :: zf (:) real, public, allocatable :: dzfi (:) real, public, allocatable :: dzfiq (:) real, public, allocatable :: dzfi5 (:) real, public, allocatable :: dzhi (:) real, public, allocatable :: dzhci (:) real, public, allocatable :: dzhiq (:) real, public, allocatable :: dzh2i (:) real, public, allocatable :: zhi (:) real, public, allocatable :: zfi (:) real, public, allocatable :: dxf (:) real, public, allocatable :: dxfc (:) real, public, allocatable :: dxfci (:) real, public, allocatable :: dxf2 (:) real, public, allocatable :: dxfi (:) real, public, allocatable :: dxfiq (:) real, public, allocatable :: dxfi5 (:) real, public, allocatable :: dxh (:) real, public, allocatable :: dxhi (:) real, public, allocatable :: dxhci (:) real, public, allocatable :: dxhiq (:) real, public, allocatable :: dxh2i (:) real, public, allocatable :: xh (:) real, public, allocatable :: xf (:) real, public, allocatable :: yh (:) real, public, allocatable :: yf (:) real, public :: xlen = -1. real, public :: ylen = -1. real, public, allocatable :: delta (:,:) logical, public :: lmomsubs = .false. character(len=80), public :: author = '' character(len=80), public :: version = 'DALES U' Subroutines public  subroutine initglobal () Arguments None public  subroutine exitglobal () Arguments None","tags":"","url":"module/modglobal.html"},{"title":"modibm – uDALES","text":"Uses modibmdata mpi module~~modibm~~UsesGraph module~modibm modibm module~modibmdata modibmdata module~modibm->module~modibmdata mpi mpi module~modibm->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~modibm~~UsedByGraph module~modibm modibm proc~advecc_2nd advecc_2nd proc~advecc_2nd->module~modibm proc~advecu_2nd advecu_2nd proc~advecu_2nd->module~modibm proc~initfielddump initfielddump proc~initfielddump->module~modibm proc~readnamelists readnamelists proc~readnamelists->module~modibm program~dalesurban DALESURBAN program~dalesurban->module~modibm Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, public :: lbottom = .false. logical, public :: lnorec = .false. integer, public :: nsolpts_u integer, public :: nsolpts_v integer, public :: nsolpts_w integer, public :: nsolpts_c integer, public :: nbndpts_u integer, public :: nbndpts_v integer, public :: nbndpts_w integer, public :: nbndpts_c integer, public :: nfctsecs_u integer, public :: nfctsecs_v integer, public :: nfctsecs_w integer, public :: nfctsecs_c real, public, allocatable, target, dimension(:,:,:) :: mask_u real, public, allocatable, target, dimension(:,:,:) :: mask_v real, public, allocatable, target, dimension(:,:,:) :: mask_w real, public, allocatable, target, dimension(:,:,:) :: mask_c type( solid_info_type ), public :: solid_info_u type( solid_info_type ), public :: solid_info_v type( solid_info_type ), public :: solid_info_w type( solid_info_type ), public :: solid_info_c type( bound_info_type ), public :: bound_info_u type( bound_info_type ), public :: bound_info_v type( bound_info_type ), public :: bound_info_w type( bound_info_type ), public :: bound_info_c integer, public :: nstatfac = 7 integer, public :: ncidfac integer, public :: nrecfac = 0 character(len=80), public, allocatable :: ncstatfac (:,:) character(len=80), public :: facname = 'fac.xxx.nc' character(len=80), public, dimension(1,4) :: tncstatfac real, public, allocatable :: varsfac (:,:) real, public, allocatable :: fac_tau_x (:) real, public, allocatable :: fac_tau_y (:) real, public, allocatable :: fac_tau_z (:) real, public, allocatable :: fac_pres (:) real, public, allocatable :: fac_pres2 (:) real, public, allocatable :: fac_htc (:) real, public, allocatable :: fac_cth (:) real, public, allocatable :: fac_tau_x_av (:) real, public, allocatable :: fac_tau_y_av (:) real, public, allocatable :: fac_tau_z_av (:) real, public, allocatable :: fac_pres_av (:) real, public, allocatable :: fac_pres2_av (:) real, public, allocatable :: fac_htc_av (:) real, public, allocatable :: fac_cth_av (:) Abstract Interfaces abstract interface public  function interp_velocity(i, j, k) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k Return Value real, (3) abstract interface public  function interp_temperature(i, j, k) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k Return Value real Derived Types type, public :: solid_info_type Components Type Visibility Attributes Name Initial integer, public :: nsolpts integer, public, allocatable :: solpts (:,:) logical, public, allocatable :: lsolptsrank (:) integer, public, allocatable :: solptsrank (:) integer, public :: nsolptsrank integer, public, allocatable :: solpts_loc (:,:) type, public :: bound_info_type Components Type Visibility Attributes Name Initial integer, public :: nbndpts integer, public, allocatable :: bndpts (:,:) real, public, allocatable :: recpts (:,:) integer, public, allocatable :: recids_u (:,:) integer, public, allocatable :: recids_v (:,:) integer, public, allocatable :: recids_w (:,:) integer, public, allocatable :: recids_c (:,:) real, public, allocatable :: bnddst (:) integer, public, allocatable :: bndptsrank (:) logical, public, allocatable :: lcomprec (:) logical, public, allocatable :: lskipsec (:) integer, public :: nbndptsrank integer, public, allocatable :: bndpts_loc (:,:) integer, public :: nfctsecs integer, public, allocatable :: secbndptids (:) integer, public, allocatable :: secfacids (:) real, public, allocatable :: secareas (:) integer, public, allocatable :: fctsecsrank (:) integer, public :: nfctsecsrank integer, public, allocatable :: secfacids_loc (:) real, public, allocatable :: secareas_loc (:) integer, public, allocatable :: secbndpts_loc (:,:) real, public, allocatable :: bnddst_loc (:) real, public, allocatable :: recpts_loc (:,:) integer, public, allocatable :: recids_u_loc (:,:) integer, public, allocatable :: recids_v_loc (:,:) integer, public, allocatable :: recids_w_loc (:,:) integer, public, allocatable :: recids_c_loc (:,:) logical, public, allocatable :: lcomprec_loc (:) logical, public, allocatable :: lskipsec_loc (:) Functions public  function trilinear_interp_var (var, cell, xgrid, ygrid, zgrid, x, y, z) Arguments Type Intent Optional Attributes Name real, intent(in) :: var (ib-ih:ie+ih,jb-jh:je+jh,kb-kh:kb+kh) integer, intent(in) :: cell (3) real, intent(in), dimension(ib:itot+ih) :: xgrid real, intent(in), dimension(jb:jtot+jh) :: ygrid real, intent(in), dimension(kb:ktot+kh) :: zgrid real, intent(in) :: x real, intent(in) :: y real, intent(in) :: z Return Value real public  function eval_corners (var, i, j, k) Arguments Type Intent Optional Attributes Name real, intent(in) :: var (ib-ih:ie+ih,jb-jh:je+jh,kb-kh:kb+kh) integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k Return Value real, dimension(8), (8) public  function trilinear_interp (x, y, z, x0, y0, z0, x1, y1, z1, corners) Arguments Type Intent Optional Attributes Name real, intent(in) :: x real, intent(in) :: y real, intent(in) :: z real, intent(in) :: x0 real, intent(in) :: y0 real, intent(in) :: z0 real, intent(in) :: x1 real, intent(in) :: y1 real, intent(in) :: z1 real, intent(in) :: corners (8) Return Value real public  function alignment (n) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(3) :: n Return Value integer public  function is_equal (a, b) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(3) :: a real, intent(in), dimension(3) :: b Return Value logical public  function cross_product (a, b) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(3) :: a real, intent(in), dimension(3) :: b Return Value real, dimension(3) public  function interp_velocity_u (i, j, k) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k Return Value real, (3) public  function interp_velocity_v (i, j, k) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k Return Value real, (3) public  function interp_velocity_w (i, j, k) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k Return Value real, (3) public  function interp_velocity_c (i, j, k) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k Return Value real, (3) public  function interp_temperature_u (i, j, k) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k Return Value real public  function interp_temperature_v (i, j, k) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k Return Value real public  function interp_temperature_w (i, j, k) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k Return Value real public  function mom_transfer_coef_stability (utan, dist, z0, z0h, Tair, Tsurf) Arguments Type Intent Optional Attributes Name real, intent(in) :: utan real, intent(in) :: dist real, intent(in) :: z0 real, intent(in) :: z0h real, intent(in) :: Tair real, intent(in) :: Tsurf Return Value real public  function mom_transfer_coef_neutral (dist, z0) Arguments Type Intent Optional Attributes Name real, intent(in) :: dist real, intent(in) :: z0 Return Value real public  function moist_flux (cveg, resa, qtair, qwall, hurel, resc, ress) Arguments Type Intent Optional Attributes Name real, intent(in) :: cveg real, intent(in) :: resa real, intent(in) :: qtair real, intent(in) :: qwall real, intent(in) :: hurel real, intent(in) :: resc real, intent(in) :: ress Return Value real Subroutines public  subroutine initibm () Arguments None public  subroutine initibmnorm (fname, solid_info) Arguments Type Intent Optional Attributes Name character(len=11), intent(in) :: fname type( solid_info_type ), intent(inout) :: solid_info public  subroutine initibmwallfun (fname_bnd, fname_sec, dir, bound_info) Arguments Type Intent Optional Attributes Name character(len=20), intent(in) :: fname_bnd character(len=20), intent(in) :: fname_sec real, intent(in), dimension(3) :: dir type( bound_info_type ) :: bound_info public  subroutine plane_line_intersection (norm, V0, P0, P1, I, check, dist) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(3) :: norm real, intent(in), dimension(3) :: V0 real, intent(in), dimension(3) :: P0 real, intent(in), dimension(3) :: P1 real, intent(out), dimension(3) :: I integer, intent(out) :: check real, intent(out) :: dist public  subroutine ibmnorm () Arguments None public  subroutine solid (solid_info, var, rhs, val, hi, hj, hk, mask) Arguments Type Intent Optional Attributes Name type( solid_info_type ), intent(in) :: solid_info real, intent(inout) :: var (ib-hi:ie+hi,jb-hj:je+hj,kb-hk:ke+hk) real, intent(inout) :: rhs (ib-hi:ie+hi,jb-hj:je+hj,kb:ke+hk) real, intent(in) :: val integer, intent(in) :: hi integer, intent(in) :: hj integer, intent(in) :: hk real, intent(in), optional :: mask (ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh) public  subroutine advecc2nd_corr_conservative (var, rhs) Arguments Type Intent Optional Attributes Name real, intent(in) :: var (ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh) real, intent(inout) :: rhs (ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) public  subroutine advecc2nd_corr_liberal (var, rhs) Arguments Type Intent Optional Attributes Name real, intent(in) :: var (ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh) real, intent(inout) :: rhs (ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) public  subroutine diffu_corr () Arguments None public  subroutine diffv_corr () Arguments None public  subroutine diffw_corr () Arguments None public  subroutine diffc_corr (var, rhs, hi, hj, hk) Arguments Type Intent Optional Attributes Name real, intent(in) :: var (ib-hi:ie+hi,jb-hj:je+hj,kb-hk:ke+hk) real, intent(inout) :: rhs (ib-hi:ie+hi,jb-hj:je+hj,kb:ke+hk) integer, intent(in) :: hi integer, intent(in) :: hj integer, intent(in) :: hk public  subroutine ibmwallfun () Arguments None public  subroutine wallfunmom (dir, rhs, bound_info) Arguments Type Intent Optional Attributes Name real, intent(in) :: dir (3) real, intent(inout) :: rhs (ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) type( bound_info_type ) :: bound_info public  subroutine wallfunheat () Arguments None public  subroutine local_coords (uvec, norm, span, strm, valid) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(3) :: uvec real, intent(in), dimension(3) :: norm real, intent(out), dimension(3) :: span real, intent(out), dimension(3) :: strm logical, intent(out) :: valid public  subroutine heat_transfer_coef_flux (utan, dist, z0, z0h, Tair, Tsurf, cth, flux, htc) Arguments Type Intent Optional Attributes Name real, intent(in) :: utan real, intent(in) :: dist real, intent(in) :: z0 real, intent(in) :: z0h real, intent(in) :: Tair real, intent(in) :: Tsurf real, intent(out) :: cth real, intent(out) :: flux real, intent(out) :: htc public  subroutine bottom () Arguments None public  subroutine createmasks () Arguments None","tags":"","url":"module/modibm.html"},{"title":"modsubgrid – uDALES","text":"Uses mpi modsubgriddata module~~modsubgrid~~UsesGraph module~modsubgrid modsubgrid module~modsubgriddata modsubgriddata module~modsubgrid->module~modsubgriddata mpi mpi module~modsubgrid->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~modsubgrid~~UsedByGraph module~modsubgrid modsubgrid proc~exitmodules exitmodules proc~exitmodules->module~modsubgrid proc~readnamelists readnamelists proc~readnamelists->module~modsubgrid proc~statsdump statsdump proc~statsdump->module~modsubgrid proc~tkestatsdump tkestatsdump proc~tkestatsdump->module~modsubgrid program~dalesurban DALESURBAN program~dalesurban->module~modsubgrid Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine initsubgrid () Arguments None public  subroutine subgridnamelist () Arguments None public  subroutine subgrid () Arguments None public  subroutine exitsubgrid () Arguments None public  subroutine closure () Arguments None public  subroutine sources () Arguments None public  subroutine diffc (hi, hj, hk, putin, putout) Arguments Type Intent Optional Attributes Name integer, intent(in) :: hi integer, intent(in) :: hj integer, intent(in) :: hk real, intent(in) :: putin (ib-hi:ie+hi,jb-hj:je+hj,kb-hk:ke+hk) real, intent(inout) :: putout (ib-hi:ie+hi,jb-hj:je+hj,kb:ke+hk) public  subroutine diffe (putout) Arguments Type Intent Optional Attributes Name real, intent(inout) :: putout (ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) public  subroutine diffu (putout) Arguments Type Intent Optional Attributes Name real, intent(inout) :: putout (ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) public  subroutine diffv (putout) Arguments Type Intent Optional Attributes Name real, intent(inout) :: putout (ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) public  subroutine diffw (putout) Arguments Type Intent Optional Attributes Name real, intent(inout) :: putout (ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh)","tags":"","url":"module/modsubgrid.html"},{"title":"initfac – uDALES","text":"Uses mpi netcdf modmpi modglobal module~~initfac~~UsesGraph module~initfac initfac module~modglobal modglobal module~initfac->module~modglobal module~modmpi modmpi module~initfac->module~modmpi mpi mpi module~initfac->mpi netcdf netcdf module~initfac->netcdf module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~initfac~~UsedByGraph module~initfac initfac proc~advecc_2nd advecc_2nd proc~advecc_2nd->module~initfac proc~calclw calclw proc~calclw->module~initfac proc~eb EB proc~eb->module~initfac proc~initeb initEB proc~initeb->module~initfac proc~initibmwallfun initibmwallfun proc~initibmwallfun->module~initfac proc~intqh intqH proc~intqh->module~initfac proc~timedepsw timedepsw proc~timedepsw->module~initfac proc~updategr updateGR proc~updategr->module~initfac proc~wallfunheat wallfunheat proc~wallfunheat->module~initfac proc~wallfunmom wallfunmom proc~wallfunmom->module~initfac proc~wfgr wfGR proc~wfgr->module~initfac proc~wfmneutral wfmneutral proc~wfmneutral->module~initfac proc~wfuno wfuno proc~wfuno->module~initfac proc~writerestartfiles writerestartfiles proc~writerestartfiles->module~initfac program~dalesurban DALESURBAN program~dalesurban->module~initfac Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, public, allocatable :: faclGR (:) real, public, allocatable :: facz0 (:) real, public, allocatable :: facz0h (:) real, public, allocatable :: facalb (:) real, public, allocatable :: facem (:) real, public, allocatable :: facd (:,:) real, public, allocatable :: faccp (:,:) real, public, allocatable :: faclam (:,:) real, public, allocatable :: fackappa (:,:) real, public, allocatable :: faca (:) integer, public, allocatable :: facets (:) real, public, allocatable :: facnorm (:,:) real, public, allocatable :: factypes (:,:) real, public, allocatable :: vf (:,:) real, public, allocatable :: svf (:) real, public, allocatable :: netsw (:) real, public, allocatable :: facLWin (:) real, public, allocatable :: vfsparse (:) real, public, allocatable :: ivfsparse (:) real, public, allocatable :: jvfsparse (:) real, public, allocatable :: Tfacinit (:) real, public, allocatable :: Tfacinit_layers (:,:) real, public, allocatable :: facT (:,:) real, public, allocatable :: facTdash (:,:) real, public, allocatable :: facef (:) real, public, allocatable :: facefi (:) real, public, allocatable :: facefsum (:) real, public, allocatable :: fachf (:) real, public, allocatable :: fachfi (:) real, public, allocatable :: fachfsum (:) real, public, allocatable :: facf (:,:) real, public, allocatable :: fachurel (:) real, public, allocatable :: facwsoil (:) real, public, allocatable :: faccth (:) real, public, allocatable :: facqsat (:) integer, public, allocatable :: typeloc (:) integer, public :: nfactypes = 0 character(len=80), public :: chmess integer, public :: nfacprops Functions public  function qsat (T) Arguments Type Intent Optional Attributes Name real, intent(in) :: T Return Value real public  function dqsatdT (T) Arguments Type Intent Optional Attributes Name real, intent(in) :: T Return Value real Subroutines public  subroutine readfacetfiles () Arguments None","tags":"","url":"module/initfac.html"},{"title":"modinletdata – uDALES","text":"Used by module~~modinletdata~~UsedByGraph module~modinletdata modinletdata module~moddriver moddriver module~moddriver->module~modinletdata module~modinlet modinlet module~modinlet->module~modinletdata proc~bcpup bcpup proc~bcpup->module~modinletdata proc~boundary boundary proc~boundary->module~modinletdata proc~boundary->module~moddriver proc~closure closure proc~closure->module~modinletdata proc~driverchunkread driverchunkread proc~driverchunkread->module~modinletdata proc~enthalpythickness enthalpythickness proc~enthalpythickness->module~modinletdata proc~initboundary initboundary proc~initboundary->module~modinletdata proc~momentumthicknessexp momentumthicknessexp proc~momentumthicknessexp->module~modinletdata proc~readdriverfile readdriverfile proc~readdriverfile->module~modinletdata proc~readdriverfile_chunk readdriverfile_chunk proc~readdriverfile_chunk->module~modinletdata proc~readinitfiles readinitfiles proc~readinitfiles->module~modinletdata proc~readinitfiles->module~moddriver proc~readinitfiles->module~modinlet proc~readnamelists readnamelists proc~readnamelists->module~modinletdata proc~readnamelists->module~moddriver proc~readnamelists->module~modinlet proc~tstep_integrate tstep_integrate proc~tstep_integrate->module~modinletdata proc~writedriverfile writedriverfile proc~writedriverfile->module~modinletdata proc~writerestartfiles writerestartfiles proc~writerestartfiles->module~modinletdata proc~xmi_driver xmi_driver proc~xmi_driver->module~modinletdata proc~xqi_driver xqi_driver proc~xqi_driver->module~modinletdata proc~xsi_driver xsi_driver proc~xsi_driver->module~modinletdata proc~xti_driver xTi_driver proc~xti_driver->module~modinletdata proc~exitmodules exitmodules proc~exitmodules->module~modinlet proc~readrestartfiles readrestartfiles proc~readrestartfiles->module~modinlet program~dalesurban DALESURBAN program~dalesurban->module~moddriver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real, public, allocatable :: storeu0inletbc (:,:,:) real, public, allocatable :: storev0inletbc (:,:,:) real, public, allocatable :: storew0inletbc (:,:,:) real, public, allocatable :: storet0inletbc (:,:,:) real, public, allocatable :: u0rot (:,:,:) real, public, allocatable :: v0rot (:,:,:) real, public, allocatable :: Utav (:,:) real, public, allocatable :: QLtav (:,:) real, public, allocatable :: QTtav (:,:) real, public, allocatable :: Ttav (:,:) real, public, allocatable :: uaver (:,:) real, public, allocatable :: taver (:,:) real, public, allocatable :: u0inletbc (:,:) real, public, allocatable :: v0inletbc (:,:) real, public, allocatable :: w0inletbc (:,:) real, public, allocatable :: t0inletbc (:,:) real, public, allocatable :: u0inletbcold (:,:) real, public, allocatable :: v0inletbcold (:,:) real, public, allocatable :: w0inletbcold (:,:) real, public, allocatable :: t0inletbcold (:,:) real, public, allocatable :: uminletbc (:,:) real, public, allocatable :: vminletbc (:,:) real, public, allocatable :: wminletbc (:,:) real, public, allocatable :: tminletbc (:,:) real, public, allocatable :: Uinl (:) real, public, allocatable :: QLinl (:) real, public, allocatable :: QTinl (:) real, public, allocatable :: Winl (:) real, public, allocatable :: Tinl (:) real, public, allocatable :: Urec (:) real, public, allocatable :: QLrec (:) real, public, allocatable :: QTrec (:) real, public, allocatable :: Wrec (:) real, public, allocatable :: Trec (:) real, public, allocatable :: zirf (:) real, public, allocatable :: ziif (:) real, public, allocatable :: zirh (:) real, public, allocatable :: ziih (:) real, public, allocatable :: zorf (:) real, public, allocatable :: zoif (:) real, public, allocatable :: zorh (:) real, public, allocatable :: zoih (:) real, public, allocatable :: zotr (:) real, public, allocatable :: zoti (:) real, public, allocatable :: displ (:) real, public, allocatable :: displold (:) real, public, allocatable :: upupavinl (:) real, public, allocatable :: vpvpavinl (:) real, public, allocatable :: wpwpavinl (:) real, public, allocatable :: upwpavinl (:) real, public, allocatable :: thlpthlpavinl (:) real, public, allocatable :: thlpupavinl (:) real, public, allocatable :: thlpwpavinl (:) real, public, allocatable :: qlpqlpavinl (:) real, public, allocatable :: qlpupavinl (:) real, public, allocatable :: qlpwpavinl (:) real, public, allocatable :: qtpqtpavinl (:) real, public, allocatable :: qtpupavinl (:) real, public, allocatable :: qtpwpavinl (:) real, public, allocatable :: zfin (:) real, public, allocatable :: zhin (:) real, public, allocatable :: dzfin (:) real, public, allocatable :: dzhin (:) real, public, allocatable :: heavif (:) real, public, allocatable :: heavih (:) real, public, allocatable :: heavit (:) integer, public, allocatable :: loclowif (:) integer, public, allocatable :: locupif (:) integer, public, allocatable :: loclowih (:) integer, public, allocatable :: locupih (:) integer, public, allocatable :: loclowof (:) integer, public, allocatable :: locupof (:) integer, public, allocatable :: loclowoh (:) integer, public, allocatable :: locupoh (:) integer, public, allocatable :: loclowot (:) integer, public, allocatable :: locupot (:) integer, public, allocatable :: linlf (:) integer, public, allocatable :: linuf (:) integer, public, allocatable :: linlh (:) integer, public, allocatable :: linuh (:) real, public :: di = 0.09 real, public :: di_test real, public :: dti_test real, public :: dr real, public :: dti real, public :: dtr real, public :: thetai real, public :: thetar real, public :: thetati real, public :: thetatr real, public :: utaui real, public :: utaur real, public :: ttaui real, public :: ttaur real, public :: lmoi real, public :: lmor real, public :: q0 real, public :: deltat = 0. real, public :: ubulk = 0. real, public :: vbulk = 0. real, public :: totalu = 0. real, public :: totaluold = 0. real, public :: ddispdx = 0. real, public :: ddispdxold = 0. real, public :: wtop = 0. real, public :: xfm real, public :: xf2m real, public :: dtin real, public :: elapstep = 0. real, public :: totalreadu real, public :: iangle real, public :: iangledeg = 0. integer, public :: jgbin integer, public :: jgein integer, public :: jgtotinl integer, public :: jbin integer, public :: jein integer, public :: jtotin integer, public :: jbdum integer, public :: jedum integer, public :: jtotdum integer, public :: filenumstart integer, public :: filenumend integer, public :: filestoread integer, public :: procinlo integer, public :: procinup integer, public :: jend integer, public :: jgend integer, public :: jbeg integer, public :: jgbeg real, public, allocatable :: yh (:) real, public, allocatable :: yf (:) real, public, allocatable :: yhin (:) real, public, allocatable :: yfin (:) real, public, allocatable :: yhdum (:) real, public, allocatable :: yfdum (:) integer, public, allocatable :: ylocupf (:) integer, public, allocatable :: yloclowf (:) integer, public, allocatable :: ylocuph (:) integer, public, allocatable :: yloclowh (:) real, public :: dyin integer, public :: irecy integer, public :: nfile = 0 integer, public :: nstepread = 1 integer, public :: rk3stepin = 1 integer, public :: kbin integer, public :: kein integer, public :: nprocsinl integer, public :: inlfactor logical, public :: lzinzsim = .true. real, public, allocatable :: storeu0driver (:,:,:) real, public, allocatable :: storev0driver (:,:,:) real, public, allocatable :: storew0driver (:,:,:) real, public, allocatable :: storethl0driver (:,:,:) real, public, allocatable :: storee120driver (:,:,:) real, public, allocatable :: storeqt0driver (:,:,:) real, public, allocatable :: storesv0driver (:,:,:,:) real, public, allocatable :: storetdriver (:) real, public, allocatable :: u0driver (:,:) real, public, allocatable :: v0driver (:,:) real, public, allocatable :: u0driverrot (:,:) real, public, allocatable :: v0driverrot (:,:) real, public, allocatable :: w0driver (:,:) real, public, allocatable :: e120driver (:,:) real, public, allocatable :: tdriver (:) real, public, allocatable :: thl0driver (:,:) real, public, allocatable :: qt0driver (:,:) real, public, allocatable :: sv0driver (:,:,:) real, public, allocatable :: storeumdriver (:,:,:) real, public, allocatable :: umdriver (:,:) real, public, allocatable :: storevmdriver (:,:,:) real, public, allocatable :: vmdriver (:,:) real, public, allocatable :: storewmdriver (:,:,:) real, public, allocatable :: wmdriver (:,:) real, public, allocatable :: storee12mdriver (:,:,:) real, public, allocatable :: e12mdriver (:,:) real, public, allocatable :: storethlmdriver (:,:,:) real, public, allocatable :: thlmdriver (:,:) real, public, allocatable :: storeqtmdriver (:,:,:) real, public, allocatable :: qtmdriver (:,:) real, public, allocatable :: storesvmdriver (:,:,:,:) real, public, allocatable :: svmdriver (:,:,:) integer, public :: irecydriver integer, public :: nstepreaddriver = 0 integer, public :: chunkreadctr = 1 integer, public :: chunkread_s = 0 integer, public :: chunkread_e = 0","tags":"","url":"module/modinletdata.html"},{"title":"moddriver – uDALES","text":"Uses modinletdata module~~moddriver~~UsesGraph module~moddriver moddriver module~modinletdata modinletdata module~moddriver->module~modinletdata Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~moddriver~~UsedByGraph module~moddriver moddriver proc~boundary boundary proc~boundary->module~moddriver proc~readinitfiles readinitfiles proc~readinitfiles->module~moddriver proc~readnamelists readnamelists proc~readnamelists->module~moddriver program~dalesurban DALESURBAN program~dalesurban->module~moddriver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine initdriver () Arguments None public  subroutine drivergen () Arguments None public  subroutine writedriverfile () Arguments None public  subroutine readdriverfile () Arguments None public  subroutine readdriverfile_chunk () Arguments None public  subroutine driverchunkread () Arguments None public  subroutine exitdriver () Arguments None","tags":"","url":"module/moddriver.html"},{"title":"modsurfdata – uDALES","text":"Used by module~~modsurfdata~~UsedByGraph module~modsurfdata modsurfdata proc~bottom bottom proc~bottom->module~modsurfdata proc~boundary boundary proc~boundary->module~modsurfdata proc~calc_halflev calc_halflev proc~calc_halflev->module~modsurfdata proc~calthv calthv proc~calthv->module~modsurfdata proc~checkinitvalues checkinitvalues proc~checkinitvalues->module~modsurfdata proc~closure closure proc~closure->module~modsurfdata proc~createtrees createtrees proc~createtrees->module~modsurfdata proc~diagfld diagfld proc~diagfld->module~modsurfdata proc~diffu diffu proc~diffu->module~modsurfdata proc~diffv diffv proc~diffv->module~modsurfdata proc~dispthicknessmo dispthicknessmo proc~dispthicknessmo->module~modsurfdata proc~enthalpythickness enthalpythickness proc~enthalpythickness->module~modsurfdata proc~fielddump fielddump proc~fielddump->module~modsurfdata proc~fixthetainf fixthetainf proc~fixthetainf->module~modsurfdata proc~fixuinf2 fixuinf2 proc~fixuinf2->module~modsurfdata proc~forces forces proc~forces->module~modsurfdata proc~fromztop fromztop proc~fromztop->module~modsurfdata proc~inletgen inletgen proc~inletgen->module~modsurfdata proc~readinitfiles readinitfiles proc~readinitfiles->module~modsurfdata proc~readnamelists readnamelists proc~readnamelists->module~modsurfdata proc~readrestartfiles readrestartfiles proc~readrestartfiles->module~modsurfdata proc~sources sources proc~sources->module~modsurfdata proc~statsdump statsdump proc~statsdump->module~modsurfdata proc~subgrid subgrid proc~subgrid->module~modsurfdata proc~thermo thermo proc~thermo->module~modsurfdata proc~tkestats tkestats proc~tkestats->module~modsurfdata proc~tkestatsdump tkestatsdump proc~tkestatsdump->module~modsurfdata proc~trees trees proc~trees->module~modsurfdata proc~wallfunheat wallfunheat proc~wallfunheat->module~modsurfdata proc~writerestartfiles writerestartfiles proc~writerestartfiles->module~modsurfdata proc~zinterpolatet zinterpolatet proc~zinterpolatet->module~modsurfdata proc~zinterpolatet1d zinterpolatet1d proc~zinterpolatet1d->module~modsurfdata Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real, public, allocatable :: tskin (:,:) real, public, allocatable :: qskin (:,:) real, public :: ps = 101325. logical, public :: lmostlocal = .false. real, public, allocatable :: obl (:,:) real, public :: oblav = 0.001 real, public, allocatable :: Cm (:,:) real, public, allocatable :: Cs (:,:) real, public, allocatable :: ustar (:,:) real, public, allocatable :: thlflux (:,:) real, public, allocatable :: qtflux (:,:) real, public, allocatable :: svflux (:,:,:) real, public, allocatable :: dudz (:,:) real, public, allocatable :: dvdz (:,:) real, public, allocatable :: dqtdz (:,:) real, public, allocatable :: dthldz (:,:) real, public :: thls = -1. real, public :: thl_top = -1. real, public :: qts = -1. real, public :: qt_top = -1. real, public :: thvs = -1. real, public, allocatable :: svs (:) real, public, allocatable :: sv_top (:) real, public :: z0 = -1. real, public :: z0h = -1. real, public :: Cmav real, public :: Csav real, public :: horvel real, public :: wtsurf = -1. real, public :: wttop = 0. real, public :: wqtop = 0. real, public :: wqsurf = -1. real, public, allocatable :: wsvsurf (:) real, public, allocatable :: wsvtop (:) real, public :: wsvsurfdum (1:99) = 0. real, public :: wsvtopdum (1:99) = 0.","tags":"","url":"module/modsurfdata.html"},{"title":"modstat_nc – uDALES","text":"Uses netcdf modmpi module~~modstat_nc~~UsesGraph module~modstat_nc modstat_nc module~modmpi modmpi module~modstat_nc->module~modmpi netcdf netcdf module~modstat_nc->netcdf mpi mpi module~modmpi->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~modstat_nc~~UsedByGraph module~modstat_nc modstat_nc proc~eb EB proc~eb->module~modstat_nc proc~exitfielddump exitfielddump proc~exitfielddump->module~modstat_nc proc~exitstatsdump exitstatsdump proc~exitstatsdump->module~modstat_nc proc~fielddump fielddump proc~fielddump->module~modstat_nc proc~ibmwallfun ibmwallfun proc~ibmwallfun->module~modstat_nc proc~initeb initEB proc~initeb->module~modstat_nc proc~initfielddump initfielddump proc~initfielddump->module~modstat_nc proc~initibm initibm proc~initibm->module~modstat_nc proc~initstatsdump initstatsdump proc~initstatsdump->module~modstat_nc proc~statsdump statsdump proc~statsdump->module~modstat_nc proc~tkestats tkestats proc~tkestats->module~modstat_nc program~dalesurban DALESURBAN program~dalesurban->module~modstat_nc Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, save :: timeID = 0 integer, public, save :: ztID = 0 integer, public, save :: zmID = 0 integer, public, save :: xtID = 0 integer, public, save :: xmID = 0 integer, public, save :: ytID = 0 integer, public, save :: ymID = 0 integer, public, save :: ztsID = 0 integer, public, save :: fctID = 0 integer, public, save :: lyrID = 0 real(kind=4), public :: nc_fillvalue = -999. Interfaces public        interface writestat_nc public  subroutine writestat_time_nc (ncid, nvar, ncname, vars, nrec, lraise) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(in) :: nvar character(len=*), intent(in), dimension(:,:) :: ncname real, intent(in), dimension(nvar) :: vars integer, intent(inout) :: nrec logical, intent(in) :: lraise public  subroutine writestat_1D_nc (ncid, nvar, ncname, vars, nrec, dim1) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(in) :: nvar character(len=*), intent(in), dimension(:,:) :: ncname real, intent(in), dimension(dim1,nvar) :: vars integer, intent(in) :: nrec integer, intent(in) :: dim1 public  subroutine writestat_2D_nc (ncid, nvar, ncname, vars, nrec, dim1, dim2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(in) :: nvar character(len=*), intent(in), dimension(:,:) :: ncname real, intent(in), dimension(:,:,:) :: vars integer, intent(in) :: nrec integer, intent(in) :: dim1 integer, intent(in) :: dim2 public  subroutine writestat_3D_nc (ncid, nvar, ncname, vars, nrec, dim1, dim2, dim3) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(in) :: nvar character(len=*), intent(in), dimension(:,:) :: ncname real, intent(in) :: vars (0:dim1-1,0:dim2-1,0:dim3-1,nvar) integer, intent(in) :: nrec integer, intent(in) :: dim1 integer, intent(in) :: dim2 integer, intent(in) :: dim3 public  subroutine writestat_3D_short_nc (ncid, nvar, ncname, vars, nrec, dim1, dim2, dim3) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(in) :: nvar character(len=*), intent(in), dimension(:,:) :: ncname integer(kind=selected_int_kind(4)), intent(in), dimension(dim1,dim2,dim3,nvar) :: vars integer, intent(in) :: nrec integer, intent(in) :: dim1 integer, intent(in) :: dim2 integer, intent(in) :: dim3 Subroutines public  subroutine initstat_nc () Arguments None public  subroutine open_nc (fname, ncid, nrec, n1, n2, n3, ns, nfcts, nlyrs) Arguments Type Intent Optional Attributes Name character(len=40), intent(in) :: fname integer, intent(out) :: ncid integer, intent(out) :: nrec integer, intent(in), optional :: n1 integer, intent(in), optional :: n2 integer, intent(in), optional :: n3 integer, intent(in), optional :: ns integer, intent(in), optional :: nfcts integer, intent(in), optional :: nlyrs public  subroutine define_nc (ncID, nVar, sx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncID integer, intent(in) :: nVar character(len=*), intent(in) :: sx (nVar,4) public  subroutine redefine_nc (ncid) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid public  subroutine exitstat_nc (ncid) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid public  subroutine writestat_dims_nc (ncid) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid public  subroutine writestat_time_nc (ncid, nvar, ncname, vars, nrec, lraise) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(in) :: nvar character(len=*), intent(in), dimension(:,:) :: ncname real, intent(in), dimension(nvar) :: vars integer, intent(inout) :: nrec logical, intent(in) :: lraise public  subroutine writestat_1D_nc (ncid, nvar, ncname, vars, nrec, dim1) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(in) :: nvar character(len=*), intent(in), dimension(:,:) :: ncname real, intent(in), dimension(dim1,nvar) :: vars integer, intent(in) :: nrec integer, intent(in) :: dim1 public  subroutine writestat_2D_nc (ncid, nvar, ncname, vars, nrec, dim1, dim2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(in) :: nvar character(len=*), intent(in), dimension(:,:) :: ncname real, intent(in), dimension(:,:,:) :: vars integer, intent(in) :: nrec integer, intent(in) :: dim1 integer, intent(in) :: dim2 public  subroutine writestat_3D_nc (ncid, nvar, ncname, vars, nrec, dim1, dim2, dim3) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(in) :: nvar character(len=*), intent(in), dimension(:,:) :: ncname real, intent(in) :: vars (0:dim1-1,0:dim2-1,0:dim3-1,nvar) integer, intent(in) :: nrec integer, intent(in) :: dim1 integer, intent(in) :: dim2 integer, intent(in) :: dim3 public  subroutine writestat_3D_short_nc (ncid, nvar, ncname, vars, nrec, dim1, dim2, dim3) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ncid integer, intent(in) :: nvar character(len=*), intent(in), dimension(:,:) :: ncname integer(kind=selected_int_kind(4)), intent(in), dimension(dim1,dim2,dim3,nvar) :: vars integer, intent(in) :: nrec integer, intent(in) :: dim1 integer, intent(in) :: dim2 integer, intent(in) :: dim3 public  subroutine ncinfo (out, in1, in2, in3, in4) Arguments Type Intent Optional Attributes Name character(len=*), intent(out), dimension(4) :: out character(len=*), intent(in) :: in1 character(len=*), intent(in) :: in2 character(len=*), intent(in) :: in3 character(len=*), intent(in) :: in4 public  subroutine nchandle_error (status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: status","tags":"","url":"module/modstat_nc.html"},{"title":"modchem – uDALES","text":"Used by module~~modchem~~UsedByGraph module~modchem modchem proc~tstep_integrate tstep_integrate proc~tstep_integrate->module~modchem Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine chem () Arguments None","tags":"","url":"module/modchem.html"},{"title":"modibmdata – uDALES","text":"Used by module~~modibmdata~~UsedByGraph module~modibmdata modibmdata module~modibm modibm module~modibm->module~modibmdata proc~advecc_kappa advecc_kappa proc~advecc_kappa->module~modibmdata proc~createtrees createtrees proc~createtrees->module~modibmdata proc~forces forces proc~forces->module~modibmdata proc~inittimedep inittimedep proc~inittimedep->module~modibmdata proc~readnamelists readnamelists proc~readnamelists->module~modibmdata proc~readnamelists->module~modibm proc~timedepsurf timedepsurf proc~timedepsurf->module~modibmdata proc~trees trees proc~trees->module~modibmdata proc~wallfunheat wallfunheat proc~wallfunheat->module~modibmdata proc~wfgr wfGR proc~wfgr->module~modibmdata proc~wfmneutral wfmneutral proc~wfmneutral->module~modibmdata proc~wfuno wfuno proc~wfuno->module~modibmdata proc~writerestartfiles writerestartfiles proc~writerestartfiles->module~modibmdata proc~advecc_2nd advecc_2nd proc~advecc_2nd->module~modibm proc~advecu_2nd advecu_2nd proc~advecu_2nd->module~modibm proc~initfielddump initfielddump proc~initfielddump->module~modibm program~dalesurban DALESURBAN program~dalesurban->module~modibm Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, allocatable :: xwallsglobal (:,:) integer, public, allocatable :: ywallsglobal (:,:) integer, public, allocatable :: zwallsglobal (:,:) integer, public, allocatable :: xwallsshear (:,:) integer, public, allocatable :: ywallsp (:,:) integer, public, allocatable :: ywallsm (:,:) integer, public, allocatable :: zwallsshear (:,:) integer, public, allocatable :: xwallsnorm (:,:) integer, public, allocatable :: ywallsnorm (:,:) integer, public, allocatable :: zwallsnorm (:,:) integer, public :: nxwall integer, public, allocatable :: ixwall (:) integer, public :: nywall integer, public, allocatable :: iyminwall (:,:) integer, public :: nyminwall integer, public, allocatable :: iywall (:) integer, public :: nypluswall integer, public, allocatable :: iypluswall (:,:) real, public, allocatable :: ibmxforce (:,:) real, public, allocatable :: ibmxforcevol (:,:) real, public, allocatable :: ibmxforcevolp (:,:) real, public :: sumctm = 0. real, public :: bcTfluxA = 0. real, public :: bcqfluxA = 0. real, public :: bctfxm = 0. real, public :: bctfxp = 0. real, public :: bctfym = 0. real, public :: bctfyp = 0. real, public :: bctfz = 0. real, public :: bcqfxm = 0. real, public :: bcqfxp = 0. real, public :: bcqfym = 0. real, public :: bcqfyp = 0. real, public :: bcqfz = 0. integer, public :: nxwallsnorm integer, public :: nywallsnorm integer, public :: nzwallsnorm integer, public :: nxwallsshear integer, public :: nywallsp integer, public :: nywallsm integer, public :: nzwallsshear integer, public :: offset = 1","tags":"","url":"module/modibmdata.html"},{"title":"modpurifiers – uDALES","text":"Uses mpi module~~modpurifiers~~UsesGraph module~modpurifiers modpurifiers mpi mpi module~modpurifiers->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~modpurifiers~~UsedByGraph module~modpurifiers modpurifiers program~dalesurban DALESURBAN program~dalesurban->module~modpurifiers Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine createpurifiers () Arguments None public  subroutine purifiers () Arguments None","tags":"","url":"module/modpurifiers.html"},{"title":"modsubgriddata – uDALES","text":"Used by module~~modsubgriddata~~UsedByGraph module~modsubgriddata modsubgriddata module~modsubgrid modsubgrid module~modsubgrid->module~modsubgriddata proc~advecc2nd_corr_conservative advecc2nd_corr_conservative proc~advecc2nd_corr_conservative->module~modsubgriddata proc~advecc2nd_corr_liberal advecc2nd_corr_liberal proc~advecc2nd_corr_liberal->module~modsubgriddata proc~advection advection proc~advection->module~modsubgriddata proc~bottom bottom proc~bottom->module~modsubgriddata proc~boundary boundary proc~boundary->module~modsubgriddata proc~calcdiffnr calcdiffnr proc~calcdiffnr->module~modsubgriddata proc~calcreyn calcreyn proc~calcreyn->module~modsubgriddata proc~closurebc closurebc proc~closurebc->module~modsubgriddata proc~diffc_corr diffc_corr proc~diffc_corr->module~modsubgriddata proc~diffu_corr diffu_corr proc~diffu_corr->module~modsubgriddata proc~diffv_corr diffv_corr proc~diffv_corr->module~modsubgriddata proc~diffw_corr diffw_corr proc~diffw_corr->module~modsubgriddata proc~fluxtopscal fluxtopscal proc~fluxtopscal->module~modsubgriddata proc~ibmwallfun ibmwallfun proc~ibmwallfun->module~modsubgriddata proc~readinitfiles readinitfiles proc~readinitfiles->module~modsubgriddata proc~readrestartfiles readrestartfiles proc~readrestartfiles->module~modsubgriddata proc~tkestats tkestats proc~tkestats->module~modsubgriddata proc~trees trees proc~trees->module~modsubgriddata proc~tstep_integrate tstep_integrate proc~tstep_integrate->module~modsubgriddata proc~tstep_update tstep_update proc~tstep_update->module~modsubgriddata proc~wfgr wfGR proc~wfgr->module~modsubgriddata proc~wfmneutral wfmneutral proc~wfmneutral->module~modsubgriddata proc~wfuno wfuno proc~wfuno->module~modsubgriddata proc~writerestartfiles writerestartfiles proc~writerestartfiles->module~modsubgriddata proc~xm_periodic xm_periodic proc~xm_periodic->module~modsubgriddata proc~xmi_driver xmi_driver proc~xmi_driver->module~modsubgriddata proc~xmi_profile xmi_profile proc~xmi_profile->module~modsubgriddata proc~xmo_convective xmo_convective proc~xmo_convective->module~modsubgriddata proc~xmo_neumann xmo_Neumann proc~xmo_neumann->module~modsubgriddata proc~ym_periodic ym_periodic proc~ym_periodic->module~modsubgriddata proc~ymi_profile ymi_profile proc~ymi_profile->module~modsubgriddata proc~ymo_convective ymo_convective proc~ymo_convective->module~modsubgriddata proc~exitmodules exitmodules proc~exitmodules->module~modsubgrid proc~readnamelists readnamelists proc~readnamelists->module~modsubgrid proc~statsdump statsdump proc~statsdump->module~modsubgrid proc~tkestatsdump tkestatsdump proc~tkestatsdump->module~modsubgrid program~dalesurban DALESURBAN program~dalesurban->module~modsubgrid Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, public :: ldelta = .false. logical, public :: lmason = .false. logical, public :: lsmagorinsky = .false. logical, public :: lvreman = .true. logical, public :: lbuoycorr = .false. logical, public :: loneeqn = .false. real, public :: cf = 2.5 real, public :: Rigc = 0.25 real, public :: Prandtl = 0.333 real, public :: prandtli real, public :: cm = 0.12 real, public :: cn = 0.76 real, public :: ch1 = 1. real, public :: ch2 = 2. real, public :: ce1 = 0.19 real, public :: ce2 = 0.51 real, public :: cs = -1. real, public :: nmason = 2. real, public :: alpha_kolm = 1.5 real, public :: beta_kolm = 1. real, public :: dampmin = 1e-10 real, public :: c_vreman = 0.07 real, public, allocatable :: ekm (:,:,:) real, public, allocatable :: ekh (:,:,:) real, public, allocatable :: sbdiss (:,:,:) real, public, allocatable :: sbshr (:,:,:) real, public, allocatable :: sbbuo (:,:,:) real, public, allocatable :: zlt (:,:,:) real, public, allocatable :: csz (:,:) real, public, allocatable :: damp (:,:,:)","tags":"","url":"module/modsubgriddata.html"},{"title":"modstartup – uDALES","text":"Uses mpi module~~modstartup~~UsesGraph module~modstartup modstartup mpi mpi module~modstartup->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~modstartup~~UsedByGraph module~modstartup modstartup program~dalesurban DALESURBAN program~dalesurban->module~modstartup Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=selected_int_kind(6)), public :: irandom = 43 integer, public :: krand = huge(0) real, public :: randu = 0.01 real, public :: randthl = 0.0 real, public :: randqt = 0.0 Subroutines public  subroutine readnamelists () Arguments None public  subroutine init2decomp () Arguments None public  subroutine checkinitvalues () Arguments None public  subroutine readinitfiles () Arguments None public  subroutine readrestartfiles () Arguments None public  subroutine exitmodules () Arguments None public  subroutine randomnize (field, klev, ampl, ir, ihl, jhl) Arguments Type Intent Optional Attributes Name real :: field (ib-ihl:ie+ihl,jb-jhl:je+jhl,kb-kh:ke+kh) integer :: klev real :: ampl integer(kind=selected_int_kind(6)) :: ir integer :: ihl integer :: jhl","tags":"","url":"module/modstartup.html"},{"title":"modforces – uDALES","text":"Used by module~~modforces~~UsedByGraph module~modforces modforces proc~readnamelists readnamelists proc~readnamelists->module~modforces program~dalesurban DALESURBAN program~dalesurban->module~modforces Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine forces () Arguments None public  subroutine detfreestream (freestream) Arguments Type Intent Optional Attributes Name real, intent(out) :: freestream public  subroutine detfreestrtmp (freestrtmp) Arguments Type Intent Optional Attributes Name real, intent(out) :: freestrtmp public  subroutine fixuinf2 () Arguments None public  subroutine fixuinf1 () Arguments None public  subroutine fixthetainf () Arguments None public  subroutine masscorr () Arguments None public  subroutine uoutletarea (area) Arguments Type Intent Optional Attributes Name real, intent(out) :: area public  subroutine voutletarea (area) Arguments Type Intent Optional Attributes Name real, intent(out) :: area public  subroutine fluidvolume (volume) Arguments Type Intent Optional Attributes Name real, intent(out) :: volume public  subroutine calcfluidvolumes () Arguments None public  subroutine coriolis () Arguments None public  subroutine lstend () Arguments None public  subroutine nudge () Arguments None public  subroutine periodicEBcorr () Arguments None public  subroutine shiftedPBCs () Arguments None","tags":"","url":"module/modforces.html"},{"title":"modsave – uDALES","text":"Used by module~~modsave~~UsedByGraph module~modsave modsave proc~drivergen drivergen proc~drivergen->module~modsave proc~inletgen inletgen proc~inletgen->module~modsave proc~inletgennotemp inletgennotemp proc~inletgennotemp->module~modsave program~dalesurban DALESURBAN program~dalesurban->module~modsave Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine writerestartfiles () Arguments None","tags":"","url":"module/modsave.html"},{"title":"modchecksim – uDALES","text":"Uses modglobal module~~modchecksim~~UsesGraph module~modchecksim modchecksim module~modglobal modglobal module~modchecksim->module~modglobal Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~modchecksim~~UsedByGraph module~modchecksim modchecksim program~dalesurban DALESURBAN program~dalesurban->module~modchecksim Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real, private :: tcheck = 0. real, private :: tnext = 0. real, private :: dtmn = 0. real, private :: ndt = 0. Subroutines public  subroutine initchecksim () Arguments None public  subroutine checksim () Arguments None private  subroutine calccourant () Arguments None private  subroutine calcdiffnr () Arguments None private  subroutine calcreyn () Arguments None private  subroutine chkdiv () Arguments None","tags":"","url":"module/modchecksim.html"},{"title":"modtest – uDALES","text":"Uses mpi decomp_2d module~~modtest~~UsesGraph module~modtest modtest decomp_2d decomp_2d module~modtest->decomp_2d mpi mpi module~modtest->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine inittest () Arguments None public  subroutine exittest () Arguments None","tags":"","url":"module/modtest.html"},{"title":"modinlet – uDALES","text":"Uses mpi modinletdata module~~modinlet~~UsesGraph module~modinlet modinlet module~modinletdata modinletdata module~modinlet->module~modinletdata mpi mpi module~modinlet->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~modinlet~~UsedByGraph module~modinlet modinlet proc~exitmodules exitmodules proc~exitmodules->module~modinlet proc~readinitfiles readinitfiles proc~readinitfiles->module~modinlet proc~readnamelists readnamelists proc~readnamelists->module~modinlet proc~readrestartfiles readrestartfiles proc~readrestartfiles->module~modinlet Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine initinlet () Arguments None public  subroutine inletgen () Arguments None public  subroutine inletgennotemp () Arguments None public  subroutine momentumthicknessexp (output, uinput) Arguments Type Intent Optional Attributes Name real, intent(out) :: output real, intent(in), dimension(kb:ke) :: uinput public  subroutine momentumthickness (output, ustar, blth) Arguments Type Intent Optional Attributes Name real, intent(out) :: output real, intent(in) :: ustar real, intent(in) :: blth public  subroutine momentumthicknessmo (output, ustar, blth, lmo) Arguments Type Intent Optional Attributes Name real, intent(out) :: output real, intent(in) :: ustar real, intent(in) :: blth real, intent(in) :: lmo public  subroutine enthalpythickness (output, tinput, uinput) Arguments Type Intent Optional Attributes Name real, intent(out) :: output real, intent(in), dimension(kb:ke) :: tinput real, intent(in), dimension(kb:ke) :: uinput public  subroutine dispthicknessexp (output) Arguments Type Intent Optional Attributes Name real, intent(out), dimension(ib:ie) :: output public  subroutine dispthickness (output) Arguments Type Intent Optional Attributes Name real, intent(out), dimension(ib:ie) :: output public  subroutine dispthicknessmo (output) Arguments Type Intent Optional Attributes Name real, intent(out), dimension(ib:ie) :: output public  subroutine blthicknesst (output, uinput, criterion) Arguments Type Intent Optional Attributes Name real, intent(out) :: output real, intent(in), dimension(kb:ke) :: uinput real, intent(in) :: criterion public  subroutine blthickness (output, ustar) Arguments Type Intent Optional Attributes Name real, intent(out) :: output real, intent(in) :: ustar public  subroutine blthicknessmo (output, ustar, lmo) Arguments Type Intent Optional Attributes Name real, intent(inout) :: output real, intent(in) :: ustar real, intent(in) :: lmo public  subroutine wallawinlet (utan, dx, visc, tau) Arguments Type Intent Optional Attributes Name real, intent(in) :: utan real, intent(in) :: dx real, intent(in) :: visc real, intent(out) :: tau public  subroutine writeinletfile () Arguments None public  subroutine readinletfile () Arguments None public  subroutine zinterpolate (input, output) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(jb:je,kbin:kein,1:nstore) :: input real, intent(inout), dimension(jb:je,kb:ke,1:nstore) :: output public  subroutine zinterpolate1d (input, output) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(kbin:kein) :: input real, intent(inout), dimension(kb:ke) :: output public  subroutine zinterpolate2d (input, output) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(ib:ie,kbin:kein) :: input real, intent(inout), dimension(ib:ie,kb:ke) :: output public  subroutine zinterpolatew (input, output) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(jb:je,kbin:kein+1,1:nstore) :: input real, intent(inout), dimension(jb:je,kb:ke+1,1:nstore) :: output public  subroutine zinterpolatew1d (input, output) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(kbin:kein+1) :: input real, intent(inout), dimension(kb:ke+1) :: output public  subroutine zinterpolatet (input, output) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(jb:je,kbin:kein,1:nstore) :: input real, intent(inout), dimension(jb:je,kb:ke,1:nstore) :: output public  subroutine zinterpolatet1d (input, output) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(kbin:kein) :: input real, intent(inout), dimension(kb:ke) :: output public  subroutine yinterpolate (input, output, ks, kf) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(jbdum:jedum,ks:kf,1:nstore) :: input real, intent(inout), dimension(jb   :je   ,ks:kf,1:nstore) :: output integer, intent(in) :: ks integer, intent(in) :: kf public  subroutine yinterpolateh (input, output, ks, kf) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(jbdum:jedum,ks:kf,1:nstore) :: input real, intent(inout), dimension(jb   :je   ,ks:kf,1:nstore) :: output integer, intent(in) :: ks integer, intent(in) :: kf public  subroutine readzincoord () Arguments None public  subroutine exitinlet () Arguments None","tags":"","url":"module/modinlet.html"},{"title":"modheatpump – uDALES","text":"Uses mpi module~~modheatpump~~UsesGraph module~modheatpump modheatpump mpi mpi module~modheatpump->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~modheatpump~~UsedByGraph module~modheatpump modheatpump program~dalesurban DALESURBAN program~dalesurban->module~modheatpump Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, allocatable :: idhppts_global (:,:) logical, private, allocatable :: lhpptsrank (:) real, private :: thl_dot_hp real, private :: w_hp_exhaust Subroutines public  subroutine init_heatpump () Arguments None public  subroutine heatpump () Arguments None public  subroutine exit_heatpump () Arguments None","tags":"","url":"module/modheatpump.html"},{"title":"modtrees – uDALES","text":"Uses mpi module~~modtrees~~UsesGraph module~modtrees modtrees mpi mpi module~modtrees->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~modtrees~~UsedByGraph module~modtrees modtrees program~dalesurban DALESURBAN program~dalesurban->module~modtrees Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine createtrees () Arguments None public  subroutine trees () Arguments None","tags":"","url":"module/modtrees.html"},{"title":"DALESURBAN – uDALES","text":"Uses modmpi modEB modpois modheatpump modsubgrid modstat_nc modtrees moddriver modthermodynamics modstatsdump modpurifiers modfields modfielddump modsave modchecksim modforces modtimedep modibm modstartup modboundary initfac modglobal program~~dalesurban~~UsesGraph program~dalesurban DALESURBAN modpois modpois program~dalesurban->modpois module~initfac initfac program~dalesurban->module~initfac module~modboundary modboundary program~dalesurban->module~modboundary module~modchecksim modchecksim program~dalesurban->module~modchecksim module~moddriver moddriver program~dalesurban->module~moddriver module~modeb modEB program~dalesurban->module~modeb module~modfielddump modfielddump program~dalesurban->module~modfielddump module~modfields modfields program~dalesurban->module~modfields module~modforces modforces program~dalesurban->module~modforces module~modglobal modglobal program~dalesurban->module~modglobal module~modheatpump modheatpump program~dalesurban->module~modheatpump module~modibm modibm program~dalesurban->module~modibm module~modmpi modmpi program~dalesurban->module~modmpi module~modpurifiers modpurifiers program~dalesurban->module~modpurifiers module~modsave modsave program~dalesurban->module~modsave module~modstartup modstartup program~dalesurban->module~modstartup module~modstat_nc modstat_nc program~dalesurban->module~modstat_nc module~modstatsdump modstatsdump program~dalesurban->module~modstatsdump module~modsubgrid modsubgrid program~dalesurban->module~modsubgrid module~modthermodynamics modthermodynamics program~dalesurban->module~modthermodynamics module~modtimedep modtimedep program~dalesurban->module~modtimedep module~modtrees modtrees program~dalesurban->module~modtrees module~initfac->module~modglobal module~initfac->module~modmpi mpi mpi module~initfac->mpi netcdf netcdf module~initfac->netcdf module~modboundary->mpi module~modchecksim->module~modglobal module~modinletdata modinletdata module~moddriver->module~modinletdata module~modeb->module~modglobal module~modeb->mpi module~modfielddump->module~modfields module~modfielddump->module~modglobal module~modfielddump->mpi decomp_2d decomp_2d module~modfields->decomp_2d module~modheatpump->mpi module~modibmdata modibmdata module~modibm->module~modibmdata module~modibm->mpi module~modmpi->mpi module~modpurifiers->mpi module~modstartup->mpi module~modstat_nc->module~modmpi module~modstat_nc->netcdf module~modstatsdump->module~modglobal module~modstatsdump->module~modmpi module~modstatsdump->mpi module~modsubgriddata modsubgriddata module~modsubgrid->module~modsubgriddata module~modsubgrid->mpi module~modtimedep->mpi module~modtrees->mpi Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~dalesurban~~CallsGraph program~dalesurban DALESURBAN advection advection program~dalesurban->advection createscals createscals program~dalesurban->createscals initpois initpois program~dalesurban->initpois poisson poisson program~dalesurban->poisson proc~bottom bottom program~dalesurban->proc~bottom proc~boundary boundary program~dalesurban->proc~boundary proc~calcfluidvolumes calcfluidvolumes program~dalesurban->proc~calcfluidvolumes proc~checkinitvalues checkinitvalues program~dalesurban->proc~checkinitvalues proc~checksim checksim program~dalesurban->proc~checksim proc~coriolis coriolis program~dalesurban->proc~coriolis proc~createmasks createmasks program~dalesurban->proc~createmasks proc~createpurifiers createpurifiers program~dalesurban->proc~createpurifiers proc~createtrees createtrees program~dalesurban->proc~createtrees proc~eb EB program~dalesurban->proc~eb proc~exit_heatpump exit_heatpump program~dalesurban->proc~exit_heatpump proc~exitfielddump exitfielddump program~dalesurban->proc~exitfielddump proc~exitmpi exitmpi program~dalesurban->proc~exitmpi proc~exitstatsdump exitstatsdump program~dalesurban->proc~exitstatsdump proc~fielddump fielddump program~dalesurban->proc~fielddump proc~fixuinf1 fixuinf1 program~dalesurban->proc~fixuinf1 proc~fixuinf2 fixuinf2 program~dalesurban->proc~fixuinf2 proc~forces forces program~dalesurban->proc~forces proc~grwdamp grwdamp program~dalesurban->proc~grwdamp proc~halos halos program~dalesurban->proc~halos proc~heatpump heatpump program~dalesurban->proc~heatpump proc~ibmnorm ibmnorm program~dalesurban->proc~ibmnorm proc~ibmwallfun ibmwallfun program~dalesurban->proc~ibmwallfun proc~init2decomp init2decomp program~dalesurban->proc~init2decomp proc~init_heatpump init_heatpump program~dalesurban->proc~init_heatpump proc~initboundary initboundary program~dalesurban->proc~initboundary proc~initchecksim initchecksim program~dalesurban->proc~initchecksim proc~initdriver initdriver program~dalesurban->proc~initdriver proc~initeb initEB program~dalesurban->proc~initeb proc~initfielddump initfielddump program~dalesurban->proc~initfielddump proc~initfields initfields program~dalesurban->proc~initfields proc~initglobal initglobal program~dalesurban->proc~initglobal proc~initibm initibm program~dalesurban->proc~initibm proc~initmpi initmpi program~dalesurban->proc~initmpi proc~initstat_nc initstat_nc program~dalesurban->proc~initstat_nc proc~initstatsdump initstatsdump program~dalesurban->proc~initstatsdump proc~initsubgrid initsubgrid program~dalesurban->proc~initsubgrid proc~initthermodynamics initthermodynamics program~dalesurban->proc~initthermodynamics proc~inittimedep inittimedep program~dalesurban->proc~inittimedep proc~lstend lstend program~dalesurban->proc~lstend proc~masscorr masscorr program~dalesurban->proc~masscorr proc~nudge nudge program~dalesurban->proc~nudge proc~periodicebcorr periodicEBcorr program~dalesurban->proc~periodicebcorr proc~purifiers purifiers program~dalesurban->proc~purifiers proc~readfacetfiles readfacetfiles program~dalesurban->proc~readfacetfiles proc~readinitfiles readinitfiles program~dalesurban->proc~readinitfiles proc~readnamelists readnamelists program~dalesurban->proc~readnamelists proc~shiftedpbcs shiftedPBCs program~dalesurban->proc~shiftedpbcs proc~starttimer starttimer program~dalesurban->proc~starttimer proc~statsdump statsdump program~dalesurban->proc~statsdump proc~subgrid subgrid program~dalesurban->proc~subgrid proc~thermodynamics thermodynamics program~dalesurban->proc~thermodynamics proc~timedep timedep program~dalesurban->proc~timedep proc~trees trees program~dalesurban->proc~trees proc~writerestartfiles writerestartfiles program~dalesurban->proc~writerestartfiles scalsource scalsource program~dalesurban->scalsource tstep_integrate tstep_integrate program~dalesurban->tstep_integrate tstep_update tstep_update program~dalesurban->tstep_update wfmneutral wfmneutral proc~bottom->wfmneutral wfuno wfuno proc~bottom->wfuno proc~driverchunkread driverchunkread proc~boundary->proc~driverchunkread proc~drivergen drivergen proc~boundary->proc~drivergen proc~fluxtop fluxtop proc~boundary->proc~fluxtop proc~fluxtopscal fluxtopscal proc~boundary->proc~fluxtopscal proc~valuetop valuetop proc~boundary->proc~valuetop proc~valuetopscal valuetopscal proc~boundary->proc~valuetopscal proc~xmi_driver xmi_driver proc~boundary->proc~xmi_driver proc~xmi_profile xmi_profile proc~boundary->proc~xmi_profile proc~xmo_convective xmo_convective proc~boundary->proc~xmo_convective proc~xqi_driver xqi_driver proc~boundary->proc~xqi_driver proc~xqi_profile xqi_profile proc~boundary->proc~xqi_profile proc~xqo_convective xqo_convective proc~boundary->proc~xqo_convective proc~xsi_custom xsi_custom proc~boundary->proc~xsi_custom proc~xsi_driver xsi_driver proc~boundary->proc~xsi_driver proc~xsi_profile xsi_profile proc~boundary->proc~xsi_profile proc~xso_convective xso_convective proc~boundary->proc~xso_convective proc~xti_driver xTi_driver proc~boundary->proc~xti_driver proc~xti_profile xTi_profile proc~boundary->proc~xti_profile proc~xto_convective xTo_convective proc~boundary->proc~xto_convective proc~ymi_profile ymi_profile proc~boundary->proc~ymi_profile proc~ymo_convective ymo_convective proc~boundary->proc~ymo_convective proc~yqi_profile yqi_profile proc~boundary->proc~yqi_profile proc~yqo_convective yqo_convective proc~boundary->proc~yqo_convective proc~ysi_profile ysi_profile proc~boundary->proc~ysi_profile proc~yso_convective yso_convective proc~boundary->proc~yso_convective proc~yti_profile yTi_profile proc~boundary->proc~yti_profile proc~yto_convective yTo_convective proc~boundary->proc~yto_convective proc~fluidvolume fluidvolume proc~calcfluidvolumes->proc~fluidvolume proc~uoutletarea uoutletarea proc~calcfluidvolumes->proc~uoutletarea proc~voutletarea voutletarea proc~calcfluidvolumes->proc~voutletarea mpi_bcast mpi_bcast proc~checkinitvalues->mpi_bcast mpi_finalize mpi_finalize proc~checkinitvalues->mpi_finalize proc~calccourant calccourant proc~checksim->proc~calccourant proc~calcdiffnr calcdiffnr proc~checksim->proc~calcdiffnr proc~chkdiv chkdiv proc~checksim->proc~chkdiv mpi_allreduce mpi_allreduce proc~createmasks->mpi_allreduce zstart zstart proc~createmasks->zstart proc~createpurifiers->mpi_bcast proc~createtrees->mpi_bcast interface~writestat_nc writestat_nc proc~eb->interface~writestat_nc proc~eb->mpi_bcast proc~calclw calclw proc~eb->proc~calclw proc~gaussji gaussji proc~eb->proc~gaussji proc~intqh intqH proc~eb->proc~intqh proc~matinv4 matinv4 proc~eb->proc~matinv4 proc~updategr updateGR proc~eb->proc~updategr proc~writestat_1d_nc writestat_1D_nc proc~eb->proc~writestat_1d_nc proc~writestat_2d_nc writestat_2D_nc proc~eb->proc~writestat_2d_nc proc~exitstat_nc exitstat_nc proc~exitfielddump->proc~exitstat_nc decomp_2d_finalize decomp_2d_finalize proc~exitmpi->decomp_2d_finalize proc~exitmpi->mpi_finalize mpi_wtime mpi_wtime proc~exitmpi->mpi_wtime proc~fielddump->interface~writestat_nc proc~detfreestream detfreestream proc~fixuinf2->proc~detfreestream exchange_halo_z exchange_halo_z proc~halos->exchange_halo_z proc~xm_periodic xm_periodic proc~halos->proc~xm_periodic proc~xq_periodic xq_periodic proc~halos->proc~xq_periodic proc~xs_periodic xs_periodic proc~halos->proc~xs_periodic proc~xt_periodic xT_periodic proc~halos->proc~xt_periodic proc~ym_periodic ym_periodic proc~halos->proc~ym_periodic proc~yq_periodic yq_periodic proc~halos->proc~yq_periodic proc~ys_periodic ys_periodic proc~halos->proc~ys_periodic proc~yt_periodic yT_periodic proc~halos->proc~yt_periodic zsize zsize proc~heatpump->zsize proc~advecc2nd_corr_liberal advecc2nd_corr_liberal proc~ibmnorm->proc~advecc2nd_corr_liberal proc~solid solid proc~ibmnorm->proc~solid proc~ibmwallfun->interface~writestat_nc proc~diffc_corr diffc_corr proc~ibmwallfun->proc~diffc_corr proc~diffu_corr diffu_corr proc~ibmwallfun->proc~diffu_corr proc~diffv_corr diffv_corr proc~ibmwallfun->proc~diffv_corr proc~diffw_corr diffw_corr proc~ibmwallfun->proc~diffw_corr proc~wallfunheat wallfunheat proc~ibmwallfun->proc~wallfunheat proc~wallfunmom wallfunmom proc~ibmwallfun->proc~wallfunmom proc~ibmwallfun->proc~writestat_1d_nc decomp_2d_init decomp_2d_init proc~init2decomp->decomp_2d_init mpi_cart_coords mpi_cart_coords proc~init2decomp->mpi_cart_coords mpi_cart_shift mpi_cart_shift proc~init2decomp->mpi_cart_shift proc~init_heatpump->mpi_bcast zend zend proc~init_heatpump->zend proc~init_heatpump->zstart proc~initchecksim->mpi_bcast proc~initdriver->zend proc~initdriver->zstart proc~define_nc define_nc proc~initeb->proc~define_nc proc~initeb->proc~gaussji proc~initeb->proc~matinv4 proc~ncinfo ncinfo proc~initeb->proc~ncinfo proc~open_nc open_nc proc~initeb->proc~open_nc proc~writestat_dims_nc writestat_dims_nc proc~initeb->proc~writestat_dims_nc proc~initfielddump->mpi_bcast proc~initfielddump->proc~define_nc proc~initfielddump->proc~ncinfo proc~initfielddump->proc~open_nc proc~initfielddump->proc~writestat_dims_nc alloc_z alloc_z proc~initfields->alloc_z float float proc~initglobal->float proc~initglobal->mpi_bcast xsize xsize proc~initglobal->xsize ysize ysize proc~initglobal->ysize proc~initglobal->zend proc~initglobal->zsize proc~initglobal->zstart proc~initibm->exchange_halo_z proc~initibm->proc~define_nc proc~initibmnorm initibmnorm proc~initibm->proc~initibmnorm proc~initibmwallfun initibmwallfun proc~initibm->proc~initibmwallfun proc~initibm->proc~ncinfo proc~initibm->proc~open_nc proc~initibm->proc~solid proc~initibm->proc~writestat_dims_nc mpi_comm_rank mpi_comm_rank proc~initmpi->mpi_comm_rank mpi_comm_size mpi_comm_size proc~initmpi->mpi_comm_size mpi_init mpi_init proc~initmpi->mpi_init proc~initstatsdump->mpi_bcast proc~initstatsdump->proc~define_nc proc~initstatsdump->proc~ncinfo proc~initstatsdump->proc~open_nc proc~initstatsdump->proc~writestat_dims_nc proc~initstatsdump->zend proc~initstatsdump->zstart proc~subgridnamelist subgridnamelist proc~initsubgrid->proc~subgridnamelist proc~inittimedep->proc~timedep proc~inittimedep->mpi_bcast proc~avexy_ibm avexy_ibm proc~masscorr->proc~avexy_ibm proc~sumy_ibm sumy_ibm proc~masscorr->proc~sumy_ibm proc~periodicebcorr->mpi_allreduce proc~readfacetfiles->mpi_bcast nf90_get_var nf90_get_var proc~readfacetfiles->nf90_get_var nf90_inq_varid nf90_inq_varid proc~readfacetfiles->nf90_inq_varid nf90_open nf90_open proc~readfacetfiles->nf90_open proc~qsat qsat proc~readfacetfiles->proc~qsat proc~readinitfiles->proc~halos proc~readinitfiles->proc~thermodynamics proc~readinitfiles->mpi_bcast proc~readinitfiles->proc~avexy_ibm proc~calc_halflev calc_halflev proc~readinitfiles->proc~calc_halflev proc~readinitfiles->proc~drivergen proc~randomnize randomnize proc~readinitfiles->proc~randomnize proc~readdriverfile readdriverfile proc~readinitfiles->proc~readdriverfile proc~readdriverfile_chunk readdriverfile_chunk proc~readinitfiles->proc~readdriverfile_chunk proc~readinletfile readinletfile proc~readinitfiles->proc~readinletfile proc~readrestartfiles readrestartfiles proc~readinitfiles->proc~readrestartfiles proc~slabsum slabsum proc~readinitfiles->proc~slabsum proc~readnamelists->mpi_bcast proc~shiftedpbcs->zstart proc~starttimer->mpi_wtime proc~statsdump->interface~writestat_nc proc~statsdump->proc~avexy_ibm proc~avey_ibm avey_ibm proc~statsdump->proc~avey_ibm proc~tkestatsdump tkestatsdump proc~statsdump->proc~tkestatsdump proc~statsdump->proc~writestat_1d_nc proc~closure closure proc~subgrid->proc~closure proc~diffc diffc proc~subgrid->proc~diffc proc~diffe diffe proc~subgrid->proc~diffe proc~diffu diffu proc~subgrid->proc~diffu proc~diffv diffv proc~subgrid->proc~diffv proc~diffw diffw proc~subgrid->proc~diffw proc~sources sources proc~subgrid->proc~sources proc~thermodynamics->proc~avexy_ibm proc~thermodynamics->proc~calc_halflev proc~calthv calthv proc~thermodynamics->proc~calthv proc~diagfld diagfld proc~thermodynamics->proc~diagfld proc~thermo thermo proc~thermodynamics->proc~thermo proc~timedeplw timedeplw proc~timedep->proc~timedeplw proc~timedepnudge timedepnudge proc~timedep->proc~timedepnudge proc~timedepsurf timedepsurf proc~timedep->proc~timedepsurf proc~timedepsw timedepsw proc~timedep->proc~timedepsw proc~trees->mpi_allreduce mpi_abort mpi_abort proc~writerestartfiles->mpi_abort proc~writerestartfiles->mpi_bcast interface~writestat_nc->proc~writestat_1d_nc interface~writestat_nc->proc~writestat_2d_nc proc~writestat_3d_nc writestat_3D_nc interface~writestat_nc->proc~writestat_3d_nc proc~writestat_3d_short_nc writestat_3D_short_nc interface~writestat_nc->proc~writestat_3d_short_nc proc~writestat_time_nc writestat_time_nc interface~writestat_nc->proc~writestat_time_nc proc~advecc2nd_corr_liberal->zstart proc~avexy_ibm->mpi_allreduce proc~avey_ibm->mpi_allreduce proc~calccourant->mpi_allreduce proc~calcdiffnr->mpi_allreduce proc~chkdiv->mpi_allreduce proc~closurebc closurebc proc~closure->proc~closurebc proc~define_nc->nf90_inq_varid nf90_def_var nf90_def_var proc~define_nc->nf90_def_var nf90_enddef nf90_enddef proc~define_nc->nf90_enddef nf90_inq_dimid nf90_inq_dimid proc~define_nc->nf90_inq_dimid nf90_put_att nf90_put_att proc~define_nc->nf90_put_att nf90_redef nf90_redef proc~define_nc->nf90_redef proc~nchandle_error nchandle_error proc~define_nc->proc~nchandle_error proc~diagfld->proc~avexy_ibm proc~fromztop fromztop proc~diagfld->proc~fromztop proc~diffc_corr->zstart proc~diffu_corr->zstart proc~diffv_corr->zstart proc~diffw_corr->zstart proc~driverchunkread->proc~readdriverfile_chunk proc~writedriverfile writedriverfile proc~drivergen->proc~writedriverfile nf90_close nf90_close proc~exitstat_nc->nf90_close proc~exitstat_nc->proc~nchandle_error proc~fluidvolume->proc~avexy_ibm proc~initibmnorm->mpi_bcast proc~initibmnorm->zend proc~initibmnorm->zstart proc~initibmwallfun->mpi_bcast proc~initibmwallfun->zend proc~initibmwallfun->zstart proc~alignment alignment proc~initibmwallfun->proc~alignment proc~plane_line_intersection plane_line_intersection proc~initibmwallfun->proc~plane_line_intersection proc~intqh->mpi_allreduce proc~open_nc->nf90_get_var proc~open_nc->nf90_inq_varid proc~open_nc->nf90_open nf90_create nf90_create proc~open_nc->nf90_create nf90_def_dim nf90_def_dim proc~open_nc->nf90_def_dim proc~open_nc->nf90_def_var proc~open_nc->nf90_enddef proc~open_nc->nf90_inq_dimid nf90_inquire nf90_inquire proc~open_nc->nf90_inquire nf90_inquire_dimension nf90_inquire_dimension proc~open_nc->nf90_inquire_dimension proc~open_nc->nf90_put_att nf90_sync nf90_sync proc~open_nc->nf90_sync proc~excjs excjs proc~readinletfile->proc~excjs proc~yinterpolate yinterpolate proc~readinletfile->proc~yinterpolate proc~zinterpolate zinterpolate proc~readinletfile->proc~zinterpolate proc~zinterpolatet zinterpolatet proc~readinletfile->proc~zinterpolatet proc~zinterpolatew zinterpolatew proc~readinletfile->proc~zinterpolatew proc~zinterpolate1d zinterpolate1d proc~readrestartfiles->proc~zinterpolate1d proc~zinterpolate2d zinterpolate2d proc~readrestartfiles->proc~zinterpolate2d proc~zinterpolatet1d zinterpolatet1d proc~readrestartfiles->proc~zinterpolatet1d proc~zinterpolatew1d zinterpolatew1d proc~readrestartfiles->proc~zinterpolatew1d proc~slabsum->mpi_allreduce proc~solid->zstart proc~subgridnamelist->mpi_bcast proc~sumy_ibm->mpi_allreduce proc~tkestatsdump->exchange_halo_z proc~tkestatsdump->proc~avexy_ibm proc~uoutletarea->proc~sumy_ibm proc~updategr->proc~qsat proc~sumx_ibm sumx_ibm proc~voutletarea->proc~sumx_ibm proc~wallfunheat->mpi_allreduce proc~wallfunheat->zstart proc~heat_transfer_coef_flux heat_transfer_coef_flux proc~wallfunheat->proc~heat_transfer_coef_flux proc~interp_velocity_c interp_velocity_c proc~wallfunheat->proc~interp_velocity_c proc~is_equal is_equal proc~wallfunheat->proc~is_equal proc~local_coords local_coords proc~wallfunheat->proc~local_coords proc~moist_flux moist_flux proc~wallfunheat->proc~moist_flux proc~trilinear_interp_var trilinear_interp_var proc~wallfunheat->proc~trilinear_interp_var proc~wallfunmom->mpi_allreduce proc~wallfunmom->zstart proc~wallfunmom->proc~alignment proc~wallfunmom->proc~is_equal proc~wallfunmom->proc~local_coords proc~mom_transfer_coef_neutral mom_transfer_coef_neutral proc~wallfunmom->proc~mom_transfer_coef_neutral proc~mom_transfer_coef_stability mom_transfer_coef_stability proc~wallfunmom->proc~mom_transfer_coef_stability proc~wallfunmom->proc~trilinear_interp_var proc~writestat_1d_nc->nf90_inq_varid nf90_put_var nf90_put_var proc~writestat_1d_nc->nf90_put_var proc~writestat_1d_nc->nf90_sync proc~writestat_2d_nc->nf90_inq_varid proc~writestat_2d_nc->nf90_put_var proc~writestat_2d_nc->nf90_sync proc~writestat_dims_nc->nf90_inq_varid proc~writestat_dims_nc->nf90_inquire_dimension proc~writestat_dims_nc->nf90_put_var proc~xsi_custom->zstart proc~alignment->proc~is_equal proc~closurebc->exchange_halo_z mpi_isend mpi_isend proc~excjs->mpi_isend mpi_recv mpi_recv proc~excjs->mpi_recv mpi_wait mpi_wait proc~excjs->mpi_wait proc~local_coords->proc~is_equal proc~cross_product cross_product proc~local_coords->proc~cross_product nf90_strerror nf90_strerror proc~nchandle_error->nf90_strerror proc~sumx_ibm->mpi_allreduce proc~trilinear_interp_var->zstart proc~eval_corners eval_corners proc~trilinear_interp_var->proc~eval_corners proc~trilinear_interp trilinear_interp proc~trilinear_interp_var->proc~trilinear_interp proc~writestat_3d_nc->nf90_inq_varid proc~writestat_3d_nc->nf90_put_var proc~writestat_3d_nc->nf90_sync proc~writestat_3d_short_nc->nf90_inq_varid proc~writestat_3d_short_nc->nf90_put_var proc~writestat_3d_short_nc->nf90_sync proc~writestat_time_nc->nf90_inq_varid proc~writestat_time_nc->nf90_put_var proc~writestat_time_nc->nf90_sync Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program DALESURBAN !Version 48 !!---------------------------------------------------------------- !!     0.0    USE STATEMENTS FOR CORE MODULES !!---------------------------------------------------------------- use modmpi , only : initmpi , exitmpi , myid , starttimer use modglobal , only : initglobal , rk3step , timeleft use modstartup , only : readnamelists , init2decomp , checkinitvalues , readinitfiles , exitmodules use modfields , only : initfields use modsave , only : writerestartfiles use modboundary , only : initboundary , boundary , grwdamp , halos use modthermodynamics , only : initthermodynamics , thermodynamics use modsubgrid , only : initsubgrid , subgrid use modforces , only : calcfluidvolumes , forces , coriolis , lstend , fixuinf1 , fixuinf2 , fixthetainf , nudge , masscorr , shiftedPBCs , periodicEBcorr use modpois , only : initpois , poisson use modibm , only : initibm , createmasks , ibmwallfun , ibmnorm , bottom use modtrees , only : createtrees , trees use modpurifiers , only : createpurifiers , purifiers use modheatpump , only : init_heatpump , heatpump , exit_heatpump use initfac , only : readfacetfiles use modEB , only : initEB , EB use moddriver , only : initdriver !---------------------------------------------------------------- !     0.1     USE STATEMENTS FOR ADDONS STATISTICAL ROUTINES !---------------------------------------------------------------- use modchecksim , only : initchecksim , checksim use modstat_nc , only : initstat_nc use modfielddump , only : initfielddump , fielddump , exitfielddump use modstatsdump , only : initstatsdump , statsdump , exitstatsdump !tg3315 use modtimedep , only : inittimedep , timedep implicit none !---------------------------------------------------------------- !     1      READ NAMELISTS,INITIALISE GRID, CONSTANTS AND FIELDS !---------------------------------------------------------------- call initmpi !call startup call readnamelists call init2decomp call checkinitvalues call initglobal call initfields call initboundary call initthermodynamics call initsubgrid ! call initinlet call initdriver call initpois call readfacetfiles ! These should be combined once file format is sorted call initibm call createmasks call calcfluidvolumes call readinitfiles call createscals !--------------------------------------------------------- !      2     INITIALIZE STATISTICAL ROUTINES AND ADD-ONS !--------------------------------------------------------- call initchecksim ! Could be deprecated call initstat_nc ! Could be deprecated call initstatsdump call initEB call inittimedep call initfielddump call boundary call createtrees call createpurifiers call init_heatpump !call fielddump !------------------------------------------------------ !   3.0   MAIN TIME LOOP !------------------------------------------------------ !write(*,*) 'Starting rank ', myid call starttimer do while (( timeleft > 0 ) . or . ( rk3step < 3 )) call tstep_update call timedep !----------------------------------------------------- !   3.2   ADVECTION AND DIFFUSION !----------------------------------------------------- call advection ! includes predicted pressure gradient term call shiftedPBCs call subgrid !----------------------------------------------------- !   3.3   THE SURFACE LAYER !----------------------------------------------------- call bottom !----------------------------------------------------- !   3.4   REMAINING TERMS !----------------------------------------------------- call coriolis !remaining terms of ns equation call forces !remaining terms of ns equation call lstend !large scale forcings call nudge ! nudge top cells of fields to enforce steady-state call ibmwallfun ! immersed boundary forcing: only shear forces. call periodicEBcorr call masscorr ! correct pred. velocity pup to get correct mass flow call ibmnorm ! immersed boundary forcing: set normal velocities to zero call EB call trees call heatpump call scalsource ! adds continuous forces in specified region of domain !------------------------------------------------------ !   3.4   EXECUTE ADD ONS !------------------------------------------------------ call fixuinf2 call fixuinf1 !----------------------------------------------------------------------- !   3.5  PRESSURE FLUCTUATIONS, TIME INTEGRATION AND BOUNDARY CONDITIONS !----------------------------------------------------------------------- call grwdamp !damping at top of the model call poisson call purifiers !placing of purifiers here may need to be checked call tstep_integrate call halos call checksim call fielddump call statsdump call boundary !call fixthetainf ! deprecated !----------------------------------------------------- !   3.6   LIQUID WATER CONTENT AND DIAGNOSTIC FIELDS !----------------------------------------------------- call thermodynamics !----------------------------------------------------- !   3.7  WRITE RESTARTFILES AND DO STATISTICS !------------------------------------------------------ call writerestartfiles end do !------------------------------------------------------- !             END OF TIME LOOP !------------------------------------------------------- !-------------------------------------------------------- !    4    FINALIZE ADD ONS AND THE MAIN PROGRAM !------------------------------------------------------- call exitfielddump call exitstatsdump !tg3315 call exit_heatpump !call exitmodules !call exittest call exitmpi end program DALESURBAN","tags":"","url":"program/dalesurban.html"},{"title":"  NAMSTATSDUMP – uDALES\n","text":"Variables Name Type Default Description lydump logical .false. tsample real None klow integer None khigh integer None tstatsdump real None lytdump logical .false. ltkedump logical .false. lxydump logical .false. lxytdump logical .false. ltdump logical .false. ltreedump logical .false. lmintdump logical .false.","tags":"","url":"namelist/namstatsdump.html"},{"title":"  NAMSUBGRID – uDALES\n","text":"Variables Name Type Default Description ldelta logical .false. lmason logical .false. cf real 2.5 cn real 0.76 Rigc real 0.25 Prandtl real 0.333 lsmagorinsky logical .false. lvreman logical .true. loneeqn logical .false. c_vreman real 0.07 cs real -1. nmason real 2. lbuoycorr logical .false.","tags":"","url":"namelist/namsubgrid.html"},{"title":"  RUN – uDALES\n","text":"Variables Name Type Default Description iexpnr integer 0 lwarmstart logical .false. lstratstart logical .false. startfile character(len=90) '' runtime real 300. dtmax real 20. trestart real 10000. ladaptive logical .false. irandom integer(kind=selected_int_kind(6)) 43 randu real 0.01 randthl real 0.0 randqt real 0.0 krand integer huge(0) courant real -1. diffnr real 0.25 author character(len=80) '' libm logical .true. lles logical .true. lper2inout logical .false. lwalldist logical .false. lreadmean logical .false. nprocx integer None nprocy integer None lrandomize logical .true.","tags":"","url":"namelist/run.html"},{"title":"  DOMAIN – uDALES\n","text":"Variables Name Type Default Description itot integer 96 jtot integer 96 ktot integer 96 xlen real -1. ylen real -1. xlat real 52. xlon real 0. xday real 1. xtime real 0. ksp integer -1","tags":"","url":"namelist/domain.html"},{"title":"  PHYSICS – uDALES\n","text":"Variables Name Type Default Description ps real 101325. igrw_damp integer 0 lmoist logical .false. lcoriol logical .false. lbuoyancy logical .false. ltempeq logical .false. lprofforc logical .false. ifixuinf integer 0 lvinf logical .false. tscale real None dpdx real 0. luoutflowr logical .false. lvoutflowr logical .false. luvolflowr logical .false. lvvolflowr logical .false. uflowrate real 1. vflowrate real 1. lnudge logical .false. lnudgevel logical .true. tnudge real 60. nnudge integer 0 ltimedepsurf logical .false. ntimedepsurf integer None ltimedepnudge logical .false. ntimedepnudge integer None ltimedeplw logical .false. ntimedeplw integer None ltimedepsw logical .false. ntimedepsw integer None","tags":"","url":"namelist/physics.html"},{"title":"  DYNAMICS – uDALES\n","text":"Variables Name Type Default Description lqlnr logical .false. ipoiss integer POISS_FFT2D iadv_mom integer 2 iadv_tke integer -1 iadv_thl integer -1 iadv_qt integer -1 iadv_sv integer -1","tags":"","url":"namelist/dynamics.html"},{"title":"  BC – uDALES\n","text":"Variables Name Type Default Description BCxm integer BCxm_periodic BCxT integer BCxT_periodic BCxq integer BCxq_periodic BCxs integer BCxs_periodic BCym integer BCym_periodic BCyT integer BCyT_periodic BCyq integer BCyq_periodic BCys integer BCys_periodic BCtopm integer BCtopm_freeslip BCtopT integer BCtopT_flux BCtopq integer BCtopq_flux BCtops integer BCtops_flux BCbotm integer BCbotm_wf BCbotT integer BCbotT_flux BCbotq integer BCbotq_flux BCbots integer BCbots_flux bctfxm real 0. bctfxp real 0. bctfym real 0. bctfyp real 0. bctfz real 0. bcqfxm real 0. bcqfxp real 0. bcqfym real 0. bcqfyp real 0. bcqfz real 0. wttop real 0. thl_top real -1. qt_top real -1. qts real -1. wsvsurfdum real 0. wsvtopdum real 0. wtsurf real -1. wqsurf real -1. thls real -1. z0 real -1. z0h real -1. BCzp integer 1 ds real 0","tags":"","url":"namelist/bc.html"},{"title":"  INLET – uDALES\n","text":"Variables Name Type Default Description Uinf real 0. Vinf real 0. di real 0.09 dti real None inletav real 0. linletRA logical .false. lstoreplane logical .false. lreadminl logical .false. lfixinlet logical .false. lfixutauin logical .false. lwallfunc logical .true.","tags":"","url":"namelist/inlet.html"},{"title":"  DRIVER – uDALES\n","text":"Variables Name Type Default Description idriver integer 0 tdriverstart real 0. driverjobnr integer None dtdriver real 0.1 driverstore integer None iplane integer None iangledeg real 0. lchunkread logical .false. chunkread_size integer 100","tags":"","url":"namelist/driver.html"},{"title":"  WALLS – uDALES\n","text":"Variables Name Type Default Description nblocks integer 0 nfcts integer -1 iwallmom integer 2 iwalltemp integer 1 iwallmoist integer 1 iwallscal integer 1 nsolpts_u integer None nsolpts_v integer None nsolpts_w integer None nsolpts_c integer None nbndpts_u integer None nbndpts_v integer None nbndpts_w integer None nbndpts_c integer None nfctsecs_u integer None nfctsecs_v integer None nfctsecs_w integer None nfctsecs_c integer None lbottom logical .false. lnorec logical .false. prandtlturb real prandtlmol fkar real 0.41 lwritefac logical .false. dtfac real 10.","tags":"","url":"namelist/walls.html"},{"title":"  ENERGYBALANCE – uDALES\n","text":"Variables Name Type Default Description lEB logical .false. lwriteEBfiles logical .false. lperiodicEBcorr logical .false. sinkbase integer 0 lconstW logical .false. dtEB real 10. bldT real 0. flrT real 0. wsoil real 0. wgrmax real 450. wwilt real 171. wfc real 313. skyLW real 0. GRLAI real 2. rsmin real 110. nfaclyrs integer 3 lfacTlyrs logical .false. lvfsparse logical .false. nnz integer None fraction real 1","tags":"","url":"namelist/energybalance.html"},{"title":"  SCALARS – uDALES\n","text":"Variables Name Type Default Description lreadscal logical .false. lscasrc logical .false. lscasrcl logical .false. lscasrcr logical .false. nsv integer 0 nscasrc integer 0 nscasrcl integer 0","tags":"","url":"namelist/scalars.html"},{"title":"  CHEMISTRY – uDALES\n","text":"Variables Name Type Default Description lchem logical .false. k1 real 0. JNO2 real 0.","tags":"","url":"namelist/chemistry.html"},{"title":"  OUTPUT – uDALES\n","text":"Variables Name Type Default Description lfielddump logical .false. tfielddump real 10000. fieldvars character(len=50) '' ltdump logical .false. lydump logical .false. lytdump logical .false. lxydump logical .false. lxytdump logical .false. lmintdump logical .false. lkslicedump logical .false. kslice integer 1 lislicedump logical .false. islice integer 1 ljslicedump logical .false. jslice integer 1 ltkedump logical .false. tstatsdump real 10000. tsample real 5. tstatstart real 0.","tags":"","url":"namelist/output.html"},{"title":"  TREES – uDALES\n","text":"Variables Name Type Default Description ltrees logical .false. ntrees integer 0 cd real 0. dec real 0. ud real 0. lad real 0. Qstar real 0. dQdt real 0. lsize real 0. r_s real 0. ltreedump logical .false.","tags":"","url":"namelist/trees.html"},{"title":"  PURIFS – uDALES\n","text":"Variables Name Type Default Description lpurif logical .false. npurif integer 0 Qpu real 0. epu real 0.","tags":"","url":"namelist/purifs.html"},{"title":"  HEATPUMP – uDALES\n","text":"Variables Name Type Default Description lheatpump logical .false. lfan_hp logical .true. nhppoints integer 0 Q_dot_hp real 0. QH_dot_hp real 0.","tags":"","url":"namelist/heatpump.html"},{"title":"  NAMCHECKSIM – uDALES\n","text":"Variables Name Type Default Description tcheck real 0.","tags":"","url":"namelist/namchecksim.html"},{"title":"  INFO – uDALES\n","text":"Variables Name Type Default Description nprocsinl integer None jgtotinl integer None kmaxin integer None dtin real None wtop real 0. totalreadu real None","tags":"","url":"namelist/info.html"},{"title":"modtimedep.f90 – uDALES","text":"This file depends on sourcefile~~modtimedep.f90~~EfferentGraph sourcefile~modtimedep.f90 modtimedep.f90 sourcefile~initfac.f90 initfac.f90 sourcefile~modtimedep.f90->sourcefile~initfac.f90 sourcefile~modfields.f90 modfields.f90 sourcefile~modtimedep.f90->sourcefile~modfields.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~modtimedep.f90->sourcefile~modglobal.f90 sourcefile~modibmdata.f90 modibmdata.f90 sourcefile~modtimedep.f90->sourcefile~modibmdata.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~modtimedep.f90->sourcefile~modmpi.f90 sourcefile~initfac.f90->sourcefile~modglobal.f90 sourcefile~initfac.f90->sourcefile~modmpi.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~modtimedep.f90~~AfferentGraph sourcefile~modtimedep.f90 modtimedep.f90 sourcefile~modstartup.f90 modstartup.f90 sourcefile~modstartup.f90->sourcefile~modtimedep.f90 sourcefile~program.f90 program.f90 sourcefile~program.f90->sourcefile~modtimedep.f90 sourcefile~program.f90->sourcefile~modstartup.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> \\file modtimedep.f90 !!  Prescribes surface values, fluxes and LS forcings at certain times !> !!  Prescribes surface values, fluxes and LS forcings at certain times !> !!  \\author Roel Neggers, KNMI !!  \\author Thijs Heus,MPI-M !!  \\author Stephan de Roode, TU Delft !!  \\author Simon Axelsen, UU !!  \\par Revision list !! \\todo documentation !  This file is part of DALES. ! ! ! DALES is free software; you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation; either version 3 of the License, or ! (at your option) any later version. ! ! DALES is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !  Copyright 1993-2009 Delft University of Technology, Wageningen University, Utrecht University, KNMI ! module modtimedep use mpi implicit none private public :: inittimedep , timedep , ltimedep , ltimedepsurf , ltimedepnudge , ltimedeplw , ltimedepsw , & ntimedepsurf , ntimedepnudge , ntimedeplw , ntimedepsw , exittimedep save ! switches for timedependent surface fluxes and large scale forcings logical :: ltimedep = . false . !< Overall switch logical :: ltimedepsurf = . false . !< Switch for fluid BC fluxes logical :: ltimedepnudge = . false . !< Switch for nudging profiles logical :: ltimedeplw = . false . !< Switch for longwave radiative fluxes logical :: ltimedepsw = . false . !< Switch for shortwave radiative fluxes integer :: ntimedepsurf integer :: ntimedepnudge integer :: ntimedeplw integer :: ntimedepsw real , allocatable :: timeflux (:) real , allocatable :: bctfxmt (:) real , allocatable :: bctfxpt (:) real , allocatable :: bctfymt (:) real , allocatable :: bctfypt (:) real , allocatable :: bctfzt (:) !real, allocatable     :: bctfzft (:) real , allocatable :: timenudge (:) real , allocatable :: thlproft (:,:) real , allocatable :: qtproft (:,:) real , allocatable :: uproft (:,:) real , allocatable :: vproft (:,:) real , allocatable :: timelw (:) real , allocatable :: skyLWt (:) real , allocatable :: timesw (:) real , allocatable :: netswt (:,:) contains !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine inittimedep use modmpi , only : myid , my_real , mpi_logical , mpierr , comm3d use modglobal , only : cexpnr , kb , ke , kh , kmax , ifinput , runtime , zf , skyLW , nfcts use modibmdata , only : bctfxm , bctfxp , bctfym , bctfyp , bctfz !, bctfzf use modfields , only : thlprof !use initfac, only : netsw !Should probably be moved to somewhere else implicit none character ( 80 ) :: chmess character ( 1 ) :: chmess1 integer :: k , t , n , ierr real :: dummyr real , allocatable , dimension (:) :: height ltimedep = ( ltimedepsurf . or . ltimedepnudge ) . or . ( ltimedeplw . or . ltimedepsw ) if (. not . ltimedep ) return if ( ltimedepsurf ) then allocate ( timeflux ( 1 : ntimedepsurf )) allocate ( bctfxmt ( 1 : ntimedepsurf )) allocate ( bctfxpt ( 1 : ntimedepsurf )) allocate ( bctfymt ( 1 : ntimedepsurf )) allocate ( bctfypt ( 1 : ntimedepsurf )) allocate ( bctfzt ( 1 : ntimedepsurf )) !allocate(bctfzft (1:ntimedepsurf)) timeflux = 0. bctfxmt = bctfxm bctfxpt = bctfxp bctfymt = bctfym bctfypt = bctfyp bctfzt = bctfz !bctfzft = bctfzf if ( myid == 0 ) then open ( ifinput , file = 'timedepsurf.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess !write(6,*) chmess read ( ifinput , '(a80)' ) chmess !write(6,*) chmess !--- load fluxes--- !t    = 1 ierr = 0 do t = 1 , ntimedepsurf read ( ifinput , * , iostat = ierr ) timeflux ( t ), bctfxmt ( t ), bctfxpt ( t ), bctfymt ( t ), bctfypt ( t ), bctfzt ( t ) !, bctfzft(t) !write(*,*) t, timeflux(t), bctfxmt(t), bctfxpt(t), bctfymt(t), bctfypt(t), bctfzt(t)!, bctfzft(t) !if (ierr < 0) then !stop 'STOP: No time dependend data for end of run (surface fluxes)' !end if end do !if(timeflux(1)>runtime) then !write(6,*) 'Time dependent surface variables do not change before end of simulation' !ltimedepsurf=.false. !endif ! flush to the end of fluxlist !do while (ierr ==0) !read (ifinput,*,iostat=ierr) dummyr !end do !backspace (ifinput) !close(ifinput) end if !myid==0 call MPI_BCAST ( timeflux , ntimedepsurf , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( bctfxmt , ntimedepsurf , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( bctfxpt , ntimedepsurf , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( bctfymt , ntimedepsurf , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( bctfypt , ntimedepsurf , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( bctfzt , ntimedepsurf , MY_REAL , 0 , comm3d , mpierr ) !call MPI_BCAST(bctfzft , ntimedepsurf, MY_REAL, 0, comm3d,mpierr) end if if ( ltimedepnudge ) then allocate ( timenudge ( 1 : ntimedepnudge )) allocate ( height ( kb : ke + kh )) allocate ( uproft ( kb : ke + kh , ntimedepnudge )) allocate ( vproft ( kb : ke + kh , ntimedepnudge )) allocate ( thlproft ( kb : ke + kh , ntimedepnudge )) allocate ( qtproft ( kb : ke + kh , ntimedepnudge )) timenudge = 0 thlproft = 0 qtproft = 0 uproft = 0 vproft = 0 if ( myid == 0 ) then !---load nudging profiles---- open ( ifinput , file = 'timedepnudge.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess !write(6,*) chmess !t = 0 do t = 1 , ntimedepnudge !t = t + 1 chmess1 = \"#\" ierr = 1 ! not zero do while (. not .( chmess1 == \"#\" . and . ierr == 0 )) !search for the next line consisting of \"# time\", from there onwards the profiles will be read read ( ifinput , * , iostat = ierr ) chmess1 , timenudge ( t ) !if (ierr < 0) then !stop 'STOP: No time dependend data for end of run' !end if end do !write (*,*) 'timenudge = ',timenudge(t) !write(*,*) 'Nudging profiles' do k = kb , ke read ( ifinput , * ) & height ( k ) , & thlproft ( k , t ), & qtproft ( k , t ), & uproft ( k , t ), & vproft ( k , t ) !write(*,*) height(k), thlproft (k,t), qtproft(k,t), uproft(k,t), vproft(k,t) end do end do end if !myid == 0 call MPI_BCAST ( timenudge , ntimedepnudge , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( thlproft , ( kmax + 1 ) * ntimedepnudge , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( qtproft , ( kmax + 1 ) * ntimedepnudge , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( uproft , ( kmax + 1 ) * ntimedepnudge , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( vproft , ( kmax + 1 ) * ntimedepnudge , MY_REAL , 0 , comm3d , mpierr ) deallocate ( height ) end if if ( ltimedeplw ) then allocate ( timelw ( 1 : ntimedeplw )) allocate ( skyLWt ( 1 : ntimedeplw )) ! Read longwave timelw = 0. skyLWt = skyLW if ( myid == 0 ) then open ( ifinput , file = 'timedeplw.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess !write(6,*) chmess read ( ifinput , '(a80)' ) chmess !write(6,*) chmess !--- load fluxes--- !t    = 1 ierr = 0 do t = 1 , ntimedeplw read ( ifinput , * , iostat = ierr ) timelw ( t ), skyLWt ( t ) !write(*,*) t, timelw(t), skyLWt(t) !if (ierr < 0) then !stop 'STOP: No time dependend data for end of run (surface fluxes)' !end if end do !if(timelw(1)>runtime) then !write(6,*) 'Time dependent surface variables do not change before end of simulation' !ltimedeplw=.false. !endif ! flush to the end of fluxlist !do while (ierr ==0) !read (ifinput,*,iostat=ierr) dummyr !end do !backspace (ifinput) !close(ifinput) end if ! myid = 0 call MPI_BCAST ( timelw , ntimedeplw , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( skyLWt , ntimedeplw , MY_REAL , 0 , comm3d , mpierr ) end if !ltimedeplw if ( ltimedepsw ) then allocate ( timesw ( 1 : ntimedepsw )) allocate ( netswt ( 1 : nfcts , 1 : ntimedepsw )) timesw = 0. netswt = 0. if ( myid == 0 ) then ! Read shortwave open ( ifinput , file = 'timedepsw.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess ! first line is a description of the file read ( ifinput , * ) ( timesw ( t ), t = 1 , ntimedepsw ) ! second line is the times do n = 1 , nfcts read ( ifinput , * ) ( netswt ( n , t ), t = 1 , ntimedepsw ) end do !write(*,*) \"read timedepsw\" end if !myid==0 call MPI_BCAST ( timesw , ntimedepsw , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( netswt , ntimedepsw * nfcts , MY_REAL , 0 , comm3d , mpierr ) end if ! timedepsw call MPI_BCAST ( ltimedepsurf , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( ltimedepnudge , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( ltimedeplw , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( ltimedepsw , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call timedep end subroutine inittimedep subroutine timedep !-----------------------------------------------------------------| !                                                                 | !*** *timedep*  calculates ls forcings and surface forcings       | !               case as a funtion of timee                        | !                                                                 | !      Roel Neggers    K.N.M.I.     01/05/2001                    | !                                                                 | !                                                                 | !    calls                                                        | !    * timedepz                                                   | !      calculation of large scale advection, radiation and        | !      surface fluxes by interpolation between prescribed         | !      values at certain times                                    | !                                                                 | !    * timedepsurf                                                | !      calculation  surface fluxes by interpolation               | !      between prescribed values at certain times                 | !                                                                 | !                                                                 | !-----------------------------------------------------------------| implicit none if (. not . ltimedep ) return call timedepsurf call timedepnudge call timedeplw call timedepsw end subroutine timedep subroutine timedepsurf use modmpi , only : myid use modglobal , only : timee use modibmdata , only : bctfxm , bctfxp , bctfym , bctfyp , bctfz !, bctfzf implicit none integer t real fac if (. not .( ltimedepsurf )) return !     --- interpolate! ---- do t = ntimedepsurf , 1 , - 1 if ( timee . ge . timeflux ( t )) then exit endif end do ! if ((myid == 0) .or. (myid == 1)) then !   write(*, *) \"myid\", myid, \"t\", t, \"timee\", timee, \"timeflux(t)\", timeflux(t) ! end if if ( t . ne . ntimedepsurf ) then fac = ( timee - timeflux ( t )) / ( timeflux ( t + 1 ) - timeflux ( t )) bctfxm = bctfxmt ( t ) + fac * ( bctfxmt ( t + 1 ) - bctfxmt ( t )) bctfxp = bctfxpt ( t ) + fac * ( bctfxpt ( t + 1 ) - bctfxpt ( t )) bctfym = bctfymt ( t ) + fac * ( bctfymt ( t + 1 ) - bctfymt ( t )) bctfyp = bctfypt ( t ) + fac * ( bctfypt ( t + 1 ) - bctfypt ( t )) bctfz = bctfzt ( t ) + fac * ( bctfzt ( t + 1 ) - bctfzt ( t )) !bctfzf = bctfzft(t) + fac * (bctfzft(t+1) - bctfzft(t)) end if ! if ((myid == 0) .or. (myid == 1)) then !   write(*, *) \"myid\", myid, \"bctfz\", bctfz, \"bctfzf\", bctfzf ! end if return end subroutine timedepsurf subroutine timedepnudge use modfields , only : thlprof , qtprof , uprof , vprof use modglobal , only : timee , dzf , dzh , kb , ke , kh , kmax use modmpi , only : myid implicit none integer t , k real fac if (. not .( ltimedepnudge )) return !---- interpolate ---- do t = ntimedepnudge , 1 , - 1 if ( timee . ge . timenudge ( t )) then exit endif end do if ( t . ne . ntimedepnudge ) then fac = ( timee - timenudge ( t )) / ( timenudge ( t + 1 ) - timenudge ( t )) thlprof = thlproft (:, t ) + fac * ( thlproft (:, t + 1 ) - thlproft (:, t )) qtprof = qtproft (:, t ) + fac * ( qtproft (:, t + 1 ) - qtproft (:, t )) uprof = uproft (:, t ) + fac * ( uproft (:, t + 1 ) - uproft (:, t )) vprof = vproft (:, t ) + fac * ( vproft (:, t + 1 ) - vproft (:, t )) end if ! if ((myid == 0) .or. (myid == 1)) then !   write(*, *) \"myid, t, timee, timenudge(t), thlproft(ke,t), thlproft(ke,t+1), thlprof(ke)\" !   write(*, *) myid, t, timee, timenudge(t), thlproft(ke,t), thlproft(ke,t+1), thlprof(ke) ! end if !write(*, *) \"myid, thlproft(k,t), thlprof(k)\" !do k = kb,ke !write(*,*) myid, thlproft(k, t), thlprof(k) !end do return end subroutine timedepnudge subroutine timedeplw use modglobal , only : timee , skyLW , rk3step , tnextEB use modmpi , only : myid implicit none integer t , k real fac if (. not .( ltimedeplw )) return if (( rk3step . eq . 3 ) . and . ( timee . ge . tnextEB )) then ! if (myid == 0) then !  write(*,*) \"EB coming up so changing longwave forcing\" ! end if !---- interpolate ---- do t = ntimedeplw , 1 , - 1 if ( timee . ge . timelw ( t )) then exit endif end do if ( t . ne . ntimedeplw ) then fac = ( timee - timelw ( t )) / ( timelw ( t + 1 ) - timelw ( t )) skyLW = skyLWt ( t ) + fac * ( skyLWt ( t + 1 ) - skyLWt ( t )) end if end if end subroutine timedeplw subroutine timedepsw use modglobal , only : timee , nfcts , rk3step , tnextEB use initfac , only : netsw use modmpi , only : myid implicit none integer t , n real fac if (. not .( ltimedepsw . and . myid == 0 )) return if (( rk3step . eq . 3 ) . and . ( timee . ge . tnextEB )) then ! if (myid == 0) then !  write(*,*) \"EB coming up so changing solar position\" ! end if !---- interpolate ---- do t = ntimedepsw , 1 , - 1 if ( timee . ge . timesw ( t )) then exit endif end do if ( t . ne . ntimedepsw ) then fac = ( timee - timesw ( t )) / ( timesw ( t + 1 ) - timesw ( t )) do n = 1 , nfcts netsw ( n ) = netswt ( n , t ) + fac * ( netswt ( n , t + 1 ) - netswt ( n , t )) end do end if end if end subroutine timedepsw subroutine exittimedep implicit none if (. not . ltimedep ) return if ( ltimedepsurf ) then deallocate ( timeflux , bctfxmt , bctfxpt , bctfymt , bctfypt , bctfzt ) !, bctfzft) end if if ( ltimedepnudge ) then deallocate ( timenudge , thlproft , qtproft , uproft , vproft ) end if end subroutine end module modtimedep","tags":"","url":"sourcefile/modtimedep.f90.html"},{"title":"advec_2nd.f90 – uDALES","text":"This file depends on sourcefile~~advec_2nd.f90~~EfferentGraph sourcefile~advec_2nd.f90 advec_2nd.f90 sourcefile~initfac.f90 initfac.f90 sourcefile~advec_2nd.f90->sourcefile~initfac.f90 sourcefile~modfields.f90 modfields.f90 sourcefile~advec_2nd.f90->sourcefile~modfields.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~advec_2nd.f90->sourcefile~modglobal.f90 sourcefile~modibm.f90 modibm.f90 sourcefile~advec_2nd.f90->sourcefile~modibm.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~advec_2nd.f90->sourcefile~modmpi.f90 sourcefile~initfac.f90->sourcefile~modglobal.f90 sourcefile~initfac.f90->sourcefile~modmpi.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 sourcefile~modibm.f90->sourcefile~initfac.f90 sourcefile~modibm.f90->sourcefile~modfields.f90 sourcefile~modibm.f90->sourcefile~modglobal.f90 sourcefile~modibm.f90->sourcefile~modmpi.f90 sourcefile~modboundary.f90 modboundary.f90 sourcefile~modibm.f90->sourcefile~modboundary.f90 sourcefile~modibmdata.f90 modibmdata.f90 sourcefile~modibm.f90->sourcefile~modibmdata.f90 sourcefile~modstat_nc.f90 modstat_nc.f90 sourcefile~modibm.f90->sourcefile~modstat_nc.f90 sourcefile~modsubgriddata.f90 modsubgriddata.f90 sourcefile~modibm.f90->sourcefile~modsubgriddata.f90 sourcefile~modsurfdata.f90 modsurfdata.f90 sourcefile~modibm.f90->sourcefile~modsurfdata.f90 sourcefile~modboundary.f90->sourcefile~modfields.f90 sourcefile~modboundary.f90->sourcefile~modglobal.f90 sourcefile~modboundary.f90->sourcefile~modmpi.f90 sourcefile~modboundary.f90->sourcefile~modsubgriddata.f90 sourcefile~modboundary.f90->sourcefile~modsurfdata.f90 sourcefile~moddriver.f90 moddriver.f90 sourcefile~modboundary.f90->sourcefile~moddriver.f90 sourcefile~modinletdata.f90 modinletdata.f90 sourcefile~modboundary.f90->sourcefile~modinletdata.f90 sourcefile~modstat_nc.f90->sourcefile~modglobal.f90 sourcefile~modstat_nc.f90->sourcefile~modmpi.f90 sourcefile~moddriver.f90->sourcefile~modfields.f90 sourcefile~moddriver.f90->sourcefile~modglobal.f90 sourcefile~moddriver.f90->sourcefile~modmpi.f90 sourcefile~moddriver.f90->sourcefile~modinletdata.f90 sourcefile~modsave.f90 modsave.f90 sourcefile~moddriver.f90->sourcefile~modsave.f90 sourcefile~modsave.f90->sourcefile~initfac.f90 sourcefile~modsave.f90->sourcefile~modfields.f90 sourcefile~modsave.f90->sourcefile~modglobal.f90 sourcefile~modsave.f90->sourcefile~modmpi.f90 sourcefile~modsave.f90->sourcefile~modibmdata.f90 sourcefile~modsave.f90->sourcefile~modsubgriddata.f90 sourcefile~modsave.f90->sourcefile~modsurfdata.f90 sourcefile~modsave.f90->sourcefile~modinletdata.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> \\file advec_2nd.f90 !!  Does advection with a 2nd order central differencing scheme. !! \\par Revision list !! \\par Authors !! Second order central differencing can be used for variables where neither very !! high accuracy nor strict monotonicity is necessary. !! \\latexonly !!\\begin{eqnarray} !! F_{i-\\frac{1}{2}}&#94;{2nd} &=& !!\\fav{u}_{i-\\frac{1}{2}}\\frac{\\phi_{i}+\\phi_{i-1}}{2}, !!\\end{eqnarray} !! \\endlatexonly !! !  This file is part of DALES. ! ! DALES is free software; you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation; either version 3 of the License, or ! (at your option) any later version. ! ! DALES is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !  Copyright 1993-2009 Delft University of Technology, Wageningen University, Utrecht University, KNMI ! !> Advection at cell center subroutine advecc_2nd ( hi , hj , hk , putin , putout ) use modglobal , only : ih , jh , kh , kb , ke , ib , ie , jb , je , dxi , dxi5 , dyi , dyi5 , dzf , dzfi , dzhi , dzfi5 , libm , jmax use modfields , only : u0 , v0 , w0 use modibm , only : nxwallsnorm , nzwallsnorm , nywallsm , nywallsp , ywallsm , ywallsp , & xwallsnorm , zwallsnorm , iypluswall , iyminwall , nyminwall , nypluswall use initfac , only : block use modmpi , only : myid implicit none integer , intent ( in ) :: hi !< size of halo in i integer , intent ( in ) :: hj !< size of halo in j integer , intent ( in ) :: hk !< size of halo in k real , dimension ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ), intent ( in ) :: putin !< Input: the cell centered field real , dimension ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ), intent ( inout ) :: putout !< Output: the tendency integer :: i , j , k , ip , im , jp , jm , kp , km , il , iu , jl , ju , kl , ku , n do k = kb , ke km = k - 1 kp = k + 1 do j = jb , je jm = j - 1 jp = j + 1 do i = ib , ie im = i - 1 ip = i + 1 putout ( i , j , k ) = putout ( i , j , k ) - ( & ( & u0 ( ip , j , k ) * ( putin ( ip , j , k ) + putin ( i , j , k )) & - u0 ( i , j , k ) * ( putin ( im , j , k ) + putin ( i , j , k )) & ! d(uc)/dx ) * dxi5 & + ( & ! v0 ( i , jp , k ) * ( putin ( i , jp , k ) + putin ( i , j , k )) & - v0 ( i , j , k ) * ( putin ( i , jm , k ) + putin ( i , j , k )) & ! d(vc)/dy ) * dyi5 ) end do end do end do do j = jb , je jm = j - 1 jp = j + 1 do i = ib , ie im = i - 1 ip = i + 1 do k = kb , ke km = k - 1 kp = k + 1 putout ( i , j , k ) = putout ( i , j , k ) - ( & w0 ( i , j , kp ) * ( putin ( i , j , kp ) * dzf ( k ) + putin ( i , j , k ) * dzf ( kp )) * dzhi ( kp ) & - w0 ( i , j , k ) * ( putin ( i , j , km ) * dzf ( k ) + putin ( i , j , k ) * dzf ( km )) * dzhi ( k ) & ) * dzfi5 ( k ) end do end do end do end subroutine advecc_2nd !> Advection at the u point. subroutine advecu_2nd ( putin , putout ) use modglobal , only : ih , ib , ie , jb , je , jh , kb , ke , kh , dxi , dxiq , dyiq , dzf , dzfi5 , dzhi , libm , imax , jmax , ktot use modfields , only : u0 , v0 , w0 , pres0 , uh , vh , wh , pres0h use modibm , only : nxwallsnorm , nzwallsnorm , nywallsm , nywallsp , ywallsm , ywallsp , & xwallsnorm , zwallsnorm use modmpi , only : myid use decomp_2d implicit none real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ), intent ( in ) :: putin !< Input: the u-field real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ), intent ( inout ) :: putout !< Output: the tendency integer :: i , j , k , ip , im , jp , jm , kp , km , il , iu , jl , ju , kl , ku , n do k = kb , ke km = k - 1 kp = k + 1 do j = jb , je jm = j - 1 jp = j + 1 do i = ib , ie im = i - 1 ip = i + 1 putout ( i , j , k ) = putout ( i , j , k ) - ( & ( & ( putin ( i , j , k ) + putin ( ip , j , k )) * ( u0 ( i , j , k ) + u0 ( ip , j , k )) & - ( putin ( i , j , k ) + putin ( im , j , k )) * ( u0 ( i , j , k ) + u0 ( im , j , k )) & ! d(uu)/dx ) * dxiq & + ( & ( putin ( i , j , k ) + putin ( i , jp , k )) * ( v0 ( i , jp , k ) + v0 ( im , jp , k )) & - ( putin ( i , j , k ) + putin ( i , jm , k )) * ( v0 ( i , j , k ) + v0 ( im , j , k )) & ! d(vu)/dy ) * dyiq ) & - (( pres0 ( i , j , k ) - pres0 ( i - 1 , j , k )) * dxi ) ! - dp/dx end do end do end do do j = jb , je jm = j - 1 jp = j + 1 do i = ib , ie im = i - 1 ip = i + 1 do k = kb , ke km = k - 1 kp = k + 1 putout ( i , j , k ) = putout ( i , j , k ) - ( & ( putin ( i , j , kp ) * dzf ( k ) + putin ( i , j , k ) * dzf ( kp )) * dzhi ( kp ) & * ( w0 ( i , j , kp ) + w0 ( im , j , kp )) & - ( putin ( i , j , k ) * dzf ( km ) + putin ( i , j , km ) * dzf ( k )) * dzhi ( k ) & * ( w0 ( i , j , k ) + w0 ( im , j , k )) & ) * 0.5 * dzfi5 ( k ) end do end do end do end subroutine advecu_2nd !> Advection at the v point. subroutine advecv_2nd ( putin , putout ) use modglobal , only : ih , ib , ie , jh , jb , je , kb , ke , kh , dx , dxi , dxiq , dyiq , dzf , dzfi5 , dzhi , dyi use modfields , only : u0 , v0 , w0 , pres0 implicit none real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ), intent ( in ) :: putin !< Input: the v-field real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ), intent ( inout ) :: putout !< Output: the tendency integer :: i , j , k , ip , im , jp , jm , kp , km do k = kb , ke km = k - 1 kp = k + 1 do j = jb , je jm = j - 1 jp = j + 1 do i = ib , ie im = i - 1 ip = i + 1 putout ( i , j , k ) = putout ( i , j , k ) - ( & ( & ( u0 ( ip , j , k ) + u0 ( ip , jm , k )) * ( putin ( i , j , k ) + putin ( ip , j , k )) & - ( u0 ( i , j , k ) + u0 ( i , jm , k )) * ( putin ( i , j , k ) + putin ( im , j , k )) & ! d(uv)/dx ) * dxiq & + ( & ( v0 ( i , jp , k ) + v0 ( i , j , k )) * ( putin ( i , j , k ) + putin ( i , jp , k )) & - ( v0 ( i , jm , k ) + v0 ( i , j , k )) * ( putin ( i , j , k ) + putin ( i , jm , k )) & ! d(vv)/dy ) * dyiq & ) & - (( pres0 ( i , j , k ) - pres0 ( i , jm , k )) * dyi ) ! - dp/dy end do end do end do do j = jb , je jm = j - 1 jp = j + 1 do i = ib , ie im = i - 1 ip = i + 1 do k = kb , ke km = k - 1 kp = k + 1 putout ( i , j , k ) = putout ( i , j , k ) - ( & ( w0 ( i , j , kp ) + w0 ( i , jm , kp )) & * ( putin ( i , j , kp ) * dzf ( k ) + putin ( i , j , k ) * dzf ( kp )) * dzhi ( kp ) & - ( w0 ( i , j , k ) + w0 ( i , jm , k )) & * ( putin ( i , j , km ) * dzf ( k ) + putin ( i , j , k ) * dzf ( km )) * dzhi ( k ) & ) * 0.5 * dzfi5 ( k ) end do end do end do end subroutine advecv_2nd !> Advection at the w point. subroutine advecw_2nd ( putin , putout ) use modglobal , only : ih , ib , ie , jh , jb , je , kb , ke , kh , dx , dxi , dxiq , dyiq , dzf , dzhi , dzhiq use modfields , only : u0 , v0 , w0 , pres0 ! use modmpi, only : myid implicit none real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ), intent ( in ) :: putin !< Input: the w-field real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ), intent ( inout ) :: putout !< Output: the tendency integer :: i , j , k , ip , im , jp , jm , kp , km do k = kb + 1 , ke km = k - 1 kp = k + 1 do j = jb , je jm = j - 1 jp = j + 1 do i = ib , ie im = i - 1 ip = i + 1 putout ( i , j , k ) = putout ( i , j , k ) - ( & ( & ( putin ( ip , j , k ) + putin ( i , j , k )) * ( dzf ( km ) * u0 ( ip , j , k ) + dzf ( k ) * u0 ( ip , j , km )) & - ( putin ( i , j , k ) + putin ( im , j , k )) * ( dzf ( km ) * u0 ( i , j , k ) + dzf ( k ) * u0 ( i , j , km )) & ) * dxiq * dzhi ( k ) & ! d(uw)/dx + ( & ( putin ( i , jp , k ) + putin ( i , j , k )) * ( dzf ( km ) * v0 ( i , jp , k ) + dzf ( k ) * v0 ( i , jp , km )) & - ( putin ( i , j , k ) + putin ( i , jm , k )) * ( dzf ( km ) * v0 ( i , j , k ) + dzf ( k ) * v0 ( i , j , km )) & ) * dyiq * dzhi ( k ) & ! d(vw)/dy + ( & ( putin ( i , j , k ) + putin ( i , j , kp )) * ( w0 ( i , j , k ) + w0 ( i , j , kp )) & - ( putin ( i , j , k ) + putin ( i , j , km )) * ( w0 ( i , j , k ) + w0 ( i , j , km )) & ) * dzhiq ( k ) & ! d(ww)/dz ) & - (( pres0 ( i , j , k ) - pres0 ( i , j , km )) * dzhi ( k )) ! - dp/dz end do end do end do end subroutine advecw_2nd","tags":"","url":"sourcefile/advec_2nd.f90.html"},{"title":"modfields.f90 – uDALES","text":"This file depends on sourcefile~~modfields.f90~~EfferentGraph sourcefile~modfields.f90 modfields.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~modfields.f90~~AfferentGraph sourcefile~modfields.f90 modfields.f90 sourcefile~advec_2nd.f90 advec_2nd.f90 sourcefile~advec_2nd.f90->sourcefile~modfields.f90 sourcefile~modibm.f90 modibm.f90 sourcefile~advec_2nd.f90->sourcefile~modibm.f90 sourcefile~advec_kappa.f90 advec_kappa.f90 sourcefile~advec_kappa.f90->sourcefile~modfields.f90 sourcefile~advec_upw.f90 advec_upw.f90 sourcefile~advec_upw.f90->sourcefile~modfields.f90 sourcefile~advection.f90 advection.f90 sourcefile~advection.f90->sourcefile~modfields.f90 sourcefile~heatpump.f90 heatpump.f90 sourcefile~heatpump.f90->sourcefile~modfields.f90 sourcefile~modboundary.f90 modboundary.f90 sourcefile~modboundary.f90->sourcefile~modfields.f90 sourcefile~moddriver.f90 moddriver.f90 sourcefile~modboundary.f90->sourcefile~moddriver.f90 sourcefile~modchecksim.f90 modchecksim.f90 sourcefile~modchecksim.f90->sourcefile~modfields.f90 sourcefile~modchem.f90 modchem.f90 sourcefile~modchem.f90->sourcefile~modfields.f90 sourcefile~moddriver.f90->sourcefile~modfields.f90 sourcefile~modsave.f90 modsave.f90 sourcefile~moddriver.f90->sourcefile~modsave.f90 sourcefile~modfielddump.f90 modfielddump.f90 sourcefile~modfielddump.f90->sourcefile~modfields.f90 sourcefile~modfielddump.f90->sourcefile~modibm.f90 sourcefile~modforces.f90 modforces.f90 sourcefile~modforces.f90->sourcefile~modfields.f90 sourcefile~modibm.f90->sourcefile~modfields.f90 sourcefile~modibm.f90->sourcefile~modboundary.f90 sourcefile~modinlet.f90 modinlet.f90 sourcefile~modinlet.f90->sourcefile~modfields.f90 sourcefile~modinlet.f90->sourcefile~modsave.f90 sourcefile~modpurifiers.f90 modpurifiers.f90 sourcefile~modpurifiers.f90->sourcefile~modfields.f90 sourcefile~modsave.f90->sourcefile~modfields.f90 sourcefile~modstartup.f90 modstartup.f90 sourcefile~modstartup.f90->sourcefile~modfields.f90 sourcefile~modstartup.f90->sourcefile~modboundary.f90 sourcefile~modstartup.f90->sourcefile~moddriver.f90 sourcefile~modstartup.f90->sourcefile~modforces.f90 sourcefile~modstartup.f90->sourcefile~modibm.f90 sourcefile~modstartup.f90->sourcefile~modinlet.f90 sourcefile~modsubgrid.f90 modsubgrid.f90 sourcefile~modstartup.f90->sourcefile~modsubgrid.f90 sourcefile~modthermodynamics.f90 modthermodynamics.f90 sourcefile~modstartup.f90->sourcefile~modthermodynamics.f90 sourcefile~modtimedep.f90 modtimedep.f90 sourcefile~modstartup.f90->sourcefile~modtimedep.f90 sourcefile~modstatistics.f90 modstatistics.f90 sourcefile~modstatistics.f90->sourcefile~modfields.f90 sourcefile~modstatsdump.f90 modstatsdump.f90 sourcefile~modstatsdump.f90->sourcefile~modfields.f90 sourcefile~modstatsdump.f90->sourcefile~modstatistics.f90 sourcefile~modstatsdump.f90->sourcefile~modsubgrid.f90 sourcefile~modsubgrid.f90->sourcefile~modfields.f90 sourcefile~modsubgrid.f90->sourcefile~modboundary.f90 sourcefile~modthermodynamics.f90->sourcefile~modfields.f90 sourcefile~modtimedep.f90->sourcefile~modfields.f90 sourcefile~modtrees.f90 modtrees.f90 sourcefile~modtrees.f90->sourcefile~modfields.f90 sourcefile~program.f90 program.f90 sourcefile~program.f90->sourcefile~modfields.f90 sourcefile~program.f90->sourcefile~heatpump.f90 sourcefile~program.f90->sourcefile~modboundary.f90 sourcefile~program.f90->sourcefile~modchecksim.f90 sourcefile~program.f90->sourcefile~moddriver.f90 sourcefile~program.f90->sourcefile~modfielddump.f90 sourcefile~program.f90->sourcefile~modforces.f90 sourcefile~program.f90->sourcefile~modibm.f90 sourcefile~program.f90->sourcefile~modpurifiers.f90 sourcefile~program.f90->sourcefile~modsave.f90 sourcefile~program.f90->sourcefile~modstartup.f90 sourcefile~program.f90->sourcefile~modstatsdump.f90 sourcefile~program.f90->sourcefile~modsubgrid.f90 sourcefile~program.f90->sourcefile~modthermodynamics.f90 sourcefile~program.f90->sourcefile~modtimedep.f90 sourcefile~program.f90->sourcefile~modtrees.f90 sourcefile~scalsource.f90 scalsource.f90 sourcefile~scalsource.f90->sourcefile~modfields.f90 sourcefile~tstep.f90 tstep.f90 sourcefile~tstep.f90->sourcefile~modfields.f90 sourcefile~tstep.f90->sourcefile~modchem.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> \\file modfields.f90 !!  Declares, allocates and initializes the 3D fields !  This file is part of DALES. ! ! DALES is free software; you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation; either version 3 of the License, or ! (at your option) any later version. ! ! DALES is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !  Copyright 1993-2009 Delft University of Technology, Wageningen University, Utrecht University, KNMI ! module modfields use decomp_2d implicit none save ! Prognostic variables real , allocatable :: worksave (:) !<   Used in POISR! real , allocatable :: um (:,:,:) !<   x-component of velocity at time step t-1 real , allocatable :: vm (:,:,:) !<   y-component of velocity at time step t-1 real , allocatable :: wm (:,:,:) !<   z-component of velocity at time step t-1 real , allocatable :: thlm (:,:,:) !<   liq. water pot. temperature at time step t-1 real , allocatable :: e12m (:,:,:) !<   turb. kin. energy at time step t-1 real , allocatable :: qtm (:,:,:) !<   total specific humidity at time step t real , allocatable , target :: u0 (:,:,:) !<   x-component of velocity at time step t real , allocatable , target :: v0 (:,:,:) !<   y-component of velocity at time step t real , allocatable , target :: w0 (:,:,:) !<   z-component of velocity at time step t real , allocatable , target :: pres0 (:,:,:) !<   pressure at time step t real , allocatable , target :: div (:,:,:) real , allocatable , target :: dudx (:,:,:) real , allocatable , target :: dvdy (:,:,:) real , allocatable , target :: dwdz (:,:,:) real , allocatable :: u0h (:,:,:) !<   x-component of velocity at time step t real , allocatable :: uinit (:,:,:) real , allocatable :: vinit (:,:,:) ! Halo cell arrays - subject to change! real , allocatable :: uh (:,:,:) real , allocatable :: vh (:,:,:) real , allocatable :: wh (:,:,:) real , allocatable :: pres0h (:,:,:) real , allocatable , target :: u01 (:,:,:) !<   x-component of velocity at time step t-1 real , allocatable , target :: u02 (:,:,:) !<   x-component of velocity at time step t-1 real , allocatable , target :: thl0 (:,:,:) !<   liq. water pot. temperature at time step t real , allocatable :: thl0c (:,:,:) !<   liq. water pot. temperature at time step t real , allocatable :: thl0h (:,:,:) !<   3d-field of theta_l at half levels for kappa scheme real , allocatable :: qt0h (:,:,:) !<  3d-field of q_tot   at half levels for kappa scheme real , allocatable :: e120 (:,:,:) !<   turb. kin. energy at time step t real , allocatable , target :: qt0 (:,:,:) !<   total specific humidity at time step t real , allocatable :: up (:,:,:) !<   tendency of um real , allocatable :: vp (:,:,:) !<   tendency of vm real , allocatable :: wp (:,:,:) !<   tendency of wm real , allocatable , target :: ru (:,:,:) !<   tendency of um real , allocatable , target :: rv (:,:,:) !<   tendency of vm real , allocatable , target :: rw (:,:,:) !<   tendency of wm real , allocatable :: thlp (:,:,:) !<   tendency of thlm real , allocatable :: thlpc (:,:,:) !<   tendency of thlm real , allocatable :: e12p (:,:,:) !<   tendency of e12m real , allocatable :: qtp (:,:,:) !<   tendency of qtm real , allocatable :: svm (:,:,:,:) !<  scalar sv(n) at time step t-1 real , allocatable , target :: sv0 (:,:,:,:) !<  scalar sv(n) at time step t real , allocatable :: svp (:,:,:,:) !<  tendency of sv(n) real , allocatable :: svpp (:,:,:,:) real , allocatable , target :: tau_x (:,:,:), tau_y (:,:,:), tau_z (:,:,:), thl_flux (:,:,:) ! Diagnostic variables real , allocatable :: mindist (:,:,:) !< minimal distance of cell center to a wall real , allocatable :: shear (:,:,:,:) !<   wall shear (last rank indicates the type of shear componenten (uym, uyp, etc.) real , allocatable :: momfluxb (:,:,:) !< fields for the wallfluxes of total momentum real , allocatable :: tfluxb (:,:,:) !< heat real , allocatable :: qfluxb (:,:,:) !< and moisture real , allocatable :: cth (:,:,:) !< heat transfer coefficient !tg3315 added variables (statistics, masking and others) integer , allocatable :: IIc (:,:,:) !< Masking matrix for blocks at cell centres integer , allocatable :: IIu (:,:,:) !< Masking matrix for blocks at x-direction half cells integer , allocatable :: IIv (:,:,:) !< Masking matrix for blocks at y-direction half cells integer , allocatable :: IIw (:,:,:) !< Masking matrix for blocks at z-direction half cells integer , allocatable :: IIuw (:,:,:) !< Masking matrix for blocks at x-and z-direction half cells integer , allocatable :: IIvw (:,:,:) !< Masking matrix for blocks at y- and z-direction half cells integer , allocatable :: IIuv (:,:,:) !< Masking matrix for blocks at x- and y-direction half cells integer , allocatable :: IIct (:,:) !< 2-D Masking matrix for blocks at cell centre that span 1:jtot integer , allocatable :: IIwt (:,:) !< 2-D Masking matrix for blocks at z-direction half cells that span 1:jtot integer , allocatable :: IIuwt (:,:) !< 2-D Masking matrix for blocks at x- and z-direction half cells that span 1:jtot integer , allocatable :: IIut (:,:) !< 2-D Masking matrix for blocks at x-direction half cells that span 1:jtot integer , allocatable :: IIvt (:,:) !< 2-D Masking matrix for blocks at y-direction half cells that span 1:jtot integer , allocatable :: IIcs (:) !< 1-D Masking matrix for blocks at cell centres that span ib:ie and 1:jtot integer , allocatable :: IIus (:) !< 1-D Masking matrix for blocks at x-direction half cells that span ib:ie and 1:jtot integer , allocatable :: IIvs (:) !< 1-D Masking matrix for blocks at y-direction half cells that span ib:ie and 1:jtot integer , allocatable :: IIws (:) !< 1-D Masking matrix for blocks at z-direction half cells that span ib:ie and 1:jtot integer , allocatable :: IIuws (:) !< 1-D Masking matrix for blocks at x- and z-direction half cells that span ib:ie and 1:jtot integer , allocatable :: IIvws (:) !< 1-D Masking matrix for blocks at y- and z-direction half cells that span ib:ie and 1:jtot integer , allocatable :: IIuvs (:) !< 1-D Masking matrix for blocks at x- and y-direction half cells that span ib:ie and 1:jtot real , allocatable :: Rn (:) real , allocatable :: clai (:) real , allocatable :: qc (:) real , allocatable :: qa (:) real , allocatable :: ladzf (:) real , allocatable :: ladzh (:) real , allocatable :: tr_u (:,:,:) !< volumetric drag acting on trees along x real , allocatable :: tr_v (:,:,:) !< volumetric drag acting on trees along y real , allocatable :: tr_w (:,:,:) !< volumetric drag acting on trees along z real , allocatable :: tr_qt (:,:,:) real , allocatable :: tr_qtR (:,:,:) real , allocatable :: tr_qtA (:,:,:) real , allocatable :: tr_thl (:,:,:) real , allocatable :: tr_sv (:,:,:,:) !< tree deposition (scalar sink) real , allocatable :: tr_omega (:,:,:) real , allocatable :: tr_ut (:,:,:) real , allocatable :: tr_vt (:,:,:) real , allocatable :: tr_wt (:,:,:) real , allocatable :: tr_qtt (:,:,:) real , allocatable :: tr_qtRt (:,:,:) real , allocatable :: tr_qtAt (:,:,:) real , allocatable :: tr_thlt (:,:,:) real , allocatable :: tr_sv1t (:,:,:) real , allocatable :: tr_sv2t (:,:,:) real , allocatable :: tr_omegat (:,:,:) !  integer              :: IIbl = 1          !< Switch for if layer at kb is all blocks ! statistical fields following notation \"[statistical name][averaging directions - x,y,z,t][position in grid - i,j,k]\" real , allocatable :: uyt (:,:) real , allocatable :: uytik (:,:) real , allocatable :: vyt (:,:) real , allocatable :: wyt (:,:) real , allocatable :: wytik (:,:) real , allocatable :: thlyt (:,:) real , allocatable :: qtyt (:,:) real , allocatable :: thlytk (:,:) real , allocatable :: sca1yt (:,:) real , allocatable :: sca2yt (:,:) real , allocatable :: sca3yt (:,:) real , allocatable :: thlsgsyt (:,:) real , allocatable :: qtsgsyt (:,:) real , allocatable :: usgsyt (:,:) real , allocatable :: wsgsyt (:,:) real , allocatable :: sv1sgsyt (:,:) real , allocatable :: sv2sgsyt (:,:) real , allocatable :: sv3sgsyt (:,:) real , allocatable :: uxyt (:) real , allocatable :: vxyt (:) real , allocatable :: wxyt (:) real , allocatable :: thlxyt (:) real , allocatable :: qtxyt (:) real , allocatable :: pxyt (:) ! bss116 real , allocatable :: usgsxyt (:) real , allocatable :: thlsgsxyt (:) real , allocatable :: vsgsxyt (:) real , allocatable :: uwtik (:,:,:) real , allocatable :: wthltk (:,:,:) real , allocatable :: wqttk (:,:,:) real , allocatable :: thlthlt (:,:,:) real , allocatable :: qtqtt (:,:,:) real , allocatable :: sv1sv1t (:,:,:) real , allocatable :: sv2sv2t (:,:,:) real , allocatable :: sv3sv3t (:,:,:) real , allocatable :: sv4sv4t (:,:,:) ! real, allocatable :: sv1max(:,:,:) ! real, allocatable :: sv2max(:,:,:) ! real, allocatable :: sv3max(:,:,:) ! real, allocatable :: sv4max(:,:,:) real , allocatable :: PSSt (:,:,:) real , allocatable :: uutc (:,:,:) real , allocatable :: vvtc (:,:,:) real , allocatable :: wwtc (:,:,:) real , allocatable :: vwtjk (:,:,:) real , allocatable :: uvtij (:,:,:) real , allocatable :: utik (:,:,:) real , allocatable :: wtik (:,:,:) real , allocatable :: vtjk (:,:,:) real , allocatable :: wtjk (:,:,:) real , allocatable :: utij (:,:,:) real , allocatable :: vtij (:,:,:) real , allocatable :: wmt (:,:,:) real , allocatable :: thltk (:,:,:) real , allocatable :: qttk (:,:,:) real , allocatable :: thlt (:,:,:) real , allocatable :: utc (:,:,:) real , allocatable :: vtc (:,:,:) real , allocatable :: wtc (:,:,:) real , allocatable :: vmt (:,:,:) real , allocatable :: umt (:,:,:) real , allocatable :: sv1t (:,:,:) real , allocatable :: sv2t (:,:,:) real , allocatable :: sv3t (:,:,:) real , allocatable :: sv4t (:,:,:) real , allocatable :: sv1tk (:,:,:) real , allocatable :: sv2tk (:,:,:) real , allocatable :: sv3tk (:,:,:) real , allocatable :: sv4tk (:,:,:) real , allocatable :: wsv1tk (:,:,:) real , allocatable :: wsv2tk (:,:,:) real , allocatable :: wsv3tk (:,:,:) real , allocatable :: wsv4tk (:,:,:) real , allocatable :: sv1sgst (:,:,:) real , allocatable :: sv2sgst (:,:,:) real , allocatable :: sv3sgst (:,:,:) real , allocatable :: sv4sgst (:,:,:) real , allocatable :: qtt (:,:,:) ! bss116 real , allocatable :: pt (:,:,:) ! bss116 ! fields for scalar sources real , allocatable :: scar (:,:) real , allocatable :: scarl (:,:) real , allocatable :: uav (:,:,:) !<   time-averaged u-velocity real , allocatable :: vav (:,:,:) !<   time-averaged u-velocity real , allocatable :: wav (:,:,:) !<   time-averaged u-velocity real , allocatable :: thlav (:,:,:) !<   time-averaged liquid temperature real , allocatable :: qtav (:,:,:) !<   time-averaged specific humidity real , allocatable :: qlav (:,:,:) !<   time-averaged liquid water real , allocatable :: presav (:,:,:) !<   time-averaged pressure real , allocatable :: svav (:,:,:,:) !<   time-averaged scalar concentration real , allocatable :: viscratioav (:,:,:) !<   time-averaged viscosity ratio; turb viscosity / molecular viscosity real , allocatable :: umint (:,:,:) !<   um interpolated to cell-center real , allocatable :: vmint (:,:,:) !<   vm interpolated to cell-center real , allocatable :: wmint (:,:,:) !<   wm interpolated to cell-center real , allocatable :: thl2av (:,:,:) !<   time-average: liquid temperature squared real , allocatable :: ql2av (:,:,:) !<   time-average: liquid temperature squared real , allocatable :: qt2av (:,:,:) !<   time-average: liquid temperature squared real , allocatable :: sv2av (:,:,:,:) !<   time-average: scalar concentration squared real , allocatable :: uuav (:,:,:) !<   time-average: u-velocity squared real , allocatable :: vvav (:,:,:) !<   time-average: v-velocity squared real , allocatable :: wwav (:,:,:) !<   time-average: w-velocity squared real , allocatable :: uvav (:,:,:) !<   time-average: u-velocity times v-velocity real , allocatable :: uwav (:,:,:) !<   time-average: u-velocity times fluctuation real , allocatable :: vwav (:,:,:) !<   time-average: v-velocity times w-velocity real , allocatable :: thluav (:,:,:) !<   time-average: thl times u-velocity real , allocatable :: thlvav (:,:,:) !<   time-average: thl times v-velocity real , allocatable :: thlwav (:,:,:) !<   time-average: thl times w-velocity real , allocatable :: thlthlav (:,:,:) !<   time-average: thl times thl real , allocatable :: qluav (:,:,:) !<   time-average: ql times u-velocity real , allocatable :: qlvav (:,:,:) !<   time-average: ql times v-velocity real , allocatable :: qlwav (:,:,:) !<   time-average: ql times w-velocity real , allocatable :: qtuav (:,:,:) !<   time-average: qt times u-velocity real , allocatable :: qtvav (:,:,:) !<   time-average: qt times v-velocity real , allocatable :: qtwav (:,:,:) !<   time-average: qt times w-velocity real , allocatable :: svuav (:,:,:,:) !<   time-average: sv times u-velocity real , allocatable :: svvav (:,:,:,:) !<   time-average: sv times v-velocity real , allocatable :: svwav (:,:,:,:) !<   time-average: sv times w-velocity !  real, allocatable :: tekm(:,:,:)     !tekm = ekm - numol !tg3315 real , allocatable :: upupav (:,:,:) !<   time-average: u'u' real , allocatable :: vpvpav (:,:,:) !<   time-average: v'v' real , allocatable :: wpwpav (:,:,:) !<   time-average: w'w' real , allocatable :: thlpthlpav (:,:,:) !<   time-average: thl'thl' real , allocatable :: qlpqlpav (:,:,:) !<   time-average: ql'ql' real , allocatable :: qtpqtpav (:,:,:) !<   time-average: thl'thl' real , allocatable :: svpsvpav (:,:,:,:) !<   time-average: sv'sv' real , allocatable :: upvpav (:,:,:) !<   time-average: u'v' real , allocatable :: upwpav (:,:,:) !<   time-average: u'w' real , allocatable :: vpwpav (:,:,:) !<   time-average: v'w' real , allocatable :: thlpupav (:,:,:) !<   time-average: thl'u' real , allocatable :: thlpvpav (:,:,:) !<   time-average: thl'v' real , allocatable :: thlpwpav (:,:,:) !<   time-average: thl'w' real , allocatable :: qlpupav (:,:,:) !<   time-average: ql'u' real , allocatable :: qlpvpav (:,:,:) !<   time-average: ql'v' real , allocatable :: qlpwpav (:,:,:) !<   time-average: ql'w' real , allocatable :: qtpupav (:,:,:) !<   time-average: qt'u' real , allocatable :: qtpvpav (:,:,:) !<   time-average: qt'v' real , allocatable :: qtpwpav (:,:,:) !<   time-average: qt'w' real , allocatable :: svpupav (:,:,:,:) !<   time-average: sv'u' real , allocatable :: svpvpav (:,:,:,:) !<   time-average: sv'v' real , allocatable :: svpwpav (:,:,:,:) !<   time-average: sv'w' ! SGS fields real , allocatable :: uusgsav (:,:,:) !<   time-average subgrid contribution (estimate) real , allocatable :: vvsgsav (:,:,:) !<   time-average subgrid contribution (estimate) real , allocatable :: wwsgsav (:,:,:) !<   time-average subgrid contribution (estimate) real , allocatable :: uwsgsav (:,:,:) !<   time-average subgrid contribution (estimate) real , allocatable :: thlusgsav (:,:,:) !<   time-average subgrid contribution (estimate) real , allocatable :: thlwsgsav (:,:,:) !<   time-average subgrid contribution (estimate) real , allocatable :: qlusgsav (:,:,:) !<   time-average subgrid contribution (estimate) real , allocatable :: qlwsgsav (:,:,:) !<   time-average subgrid contribution (estimate) real , allocatable :: qtusgsav (:,:,:) !<   time-average subgrid contribution (estimate) real , allocatable :: qtwsgsav (:,:,:) !<   time-average subgrid contribution (estimate) real , allocatable :: svusgsav (:,:,:,:) !<   time-average subgrid contribution (estimate) real , allocatable :: svwsgsav (:,:,:,:) !<   time-average subgrid contribution (estimate) real , allocatable :: tkesgsav (:,:,:) !<   time-average subgrid turbulence kinetic energy real , allocatable :: nusgsav (:,:,:) !<   time-average subgrid viscosity ! Resolved dissipation 'terms' real , allocatable :: strain2av (:,:,:) !<   <Sij*Sij> used to compute <Sij'*Sij'> = <Sij*Sij> - <S>ij*<S>ij real , allocatable :: disssgsav (:,:,:) !<   mean subgrid dissipation: <nu_sgs*2.*Sij*Sij> !<   which is used for resolved dissipation = nu*2*<Sij'*Sij'> ! TKE budget terms: real , allocatable :: tvmx (:,:,:) !<   needed for viscous transport: <u*d/dxj(2*nu*S1j)> real , allocatable :: tvmy (:,:,:) !<   needed for viscous transport: <v*d/dxj(2*nu*S2j)> real , allocatable :: tvmz (:,:,:) !<   needed for viscous transport: <w*d/dxj(2*nu*S3j)> real , allocatable :: tpm (:,:,:) !<   needed for transport by pressure fluctuations real , allocatable :: ttmx (:,:,:) !<   needed for transport by turb. vel. fluctuations real , allocatable :: ttmy (:,:,:) !<   needed for transport by turb. vel. fluctuations real , allocatable :: ttmz (:,:,:) !<   needed for transport by turb. vel. fluctuations real , allocatable :: tsgsmx1 (:,:,:) !<   needed for transport by subgrid x = <u*d/dxj(2*nu_t*S1j)> real , allocatable :: tsgsmy1 (:,:,:) !<   needed for transport by subgrid y = <v*d/dxj(2*nu_t*S2j)> real , allocatable :: tsgsmz1 (:,:,:) !<   needed for transport by subgrid z = <w*d/dxj(2*nu_t*S3j)> real , allocatable :: tsgsmx2 (:,:,:) !<   needed for transport by subgrid x = <d/dxj(2*nu_t*S1j)> real , allocatable :: tsgsmy2 (:,:,:) !<   needed for transport by subgrid y = <d/dxj(2*nu_t*S2j)> real , allocatable :: tsgsmz2 (:,:,:) !<   needed for transport by subgrid z = <d/dxj(2*nu_t*S3j)> ! TKE budget results (written to files): real , allocatable :: t_vav (:,:,:) !<   viscous transport real , allocatable :: t_sgsav (:,:,:) !<   transport by subgrid real , allocatable :: t_pav (:,:,:) !<   transport by pressure fluctuations real , allocatable :: t_tav (:,:,:) !<   transport by by turb. vel. fluctuations real , allocatable :: p_tav (:,:,:) !<   production by shear real , allocatable :: p_bav (:,:,:) !<   production/destruction by buoyancy real , allocatable :: d_sgsav (:,:,:) !<   dissipation by subgrid real , allocatable :: tkeadv (:,:,:) !<   advection of tke ! TKE budget results (written to tkedump): !tg3315 real , allocatable :: t_v (:) !<   viscous transport real , allocatable :: t_sgs (:) !<   transport by subgrid real , allocatable :: t_p (:) !<   transport by pressurefluctuations real , allocatable :: t_t (:) !<   transport by by turb. vel. fluctuations real , allocatable :: p_t (:) !<   production by shear real , allocatable :: p_b (:) !<   production/destruction by buoyancy real , allocatable :: d_sgs (:) !<   dissipation by subgrid real , allocatable :: adv (:) !<   advection of tke real , allocatable , target :: ql0 (:,:,:) !<   liquid water content real , allocatable :: thv0h (:,:,:) !<   theta_v at half level real , allocatable :: whls (:) !<   large scale vert velocity at half levels real , allocatable :: presf (:) !<   hydrostatic pressure at full level real , allocatable :: presh (:) !<   hydrostatic pressure at half level real , allocatable :: exnf (:) !<   hydrostatic exner function at full level real , allocatable :: exnh (:) !<   hydrostatic exner function at half level real , allocatable :: thvf (:) !<   hydrostatic exner function at full level real , allocatable :: thvh (:) !<   hydrostatic exner function at half level real , allocatable :: rhof (:) !<   slab averaged density at full level real , allocatable :: qt0av (:) !<   slab averaged q_tot real , allocatable :: ql0av (:) !<   slab averaged q_liq real , allocatable :: thl0av (:) !<   slab averaged th_liq real , allocatable :: u0av (:) !<   slab averaged u real , allocatable :: v0av (:) !<   slab averaged v real , allocatable :: ug (:) !<   geostrophic u-wind real , allocatable :: vg (:) !<   geostrophic v-wind real , allocatable :: pgx (:) !<   driving pressure gradient in x, this is dp/dx [(\\Delta p) / (\\Delta x)] across one cell, already divided by \\rho -> in units of [m/s&#94;2] real , allocatable :: pgy (:) !<   driving pressure gradient in y [m/s&#94;2] real , allocatable :: dpdxl (:) !<   large scale pressure x-gradient [m/s&#94;2] real , allocatable :: dpdyl (:) !<   large scale pressure y-gradient [m/s&#94;2] real , allocatable :: dthldxls (:) !<   large scale x-gradient of th_liq real , allocatable :: dthldyls (:) !<   large scale y-gradient of th_liq real , allocatable :: dqtdxls (:) !<   large scale x-gradient of q_tot real , allocatable :: dqtdyls (:) !<   large scale y-gradient of q_tot real , allocatable :: dqtdtls (:) !<   large scale y-gradient of q_tot real , allocatable :: dudxls (:) !<   large scale x-gradient of u real , allocatable :: dudyls (:) !<   large scale y-gradient of u real , allocatable :: dvdxls (:) !<   large scale x-gradient of v real , allocatable :: dvdyls (:) !<   large scale y-gradient of v real , allocatable :: wfls (:) !<   large scale y-gradient of v real , allocatable :: ql0h (:,:,:) real , allocatable :: dthvdz (:,:,:) !<   theta_v at half level real , allocatable :: thlprof (:) !<   initial thl-profile real , allocatable :: qtprof (:) !<   initial qt-profile real , allocatable :: uprof (:) !<   initial u-profile real , allocatable :: vprof (:) !<   initial v-profile real , allocatable :: e12prof (:) !<   initial subgrid TKE profile real , allocatable :: sv0av (:,:) !<   slab average of sv(n) real , allocatable :: svprof (:,:) !<   initial sv(n)-profile real , allocatable :: qlprof (:) real , allocatable :: rhobf (:) real , allocatable :: rhobh (:) real , allocatable :: thlpcar (:) !< prescribed radiatively forced thl tendency real , allocatable :: SW_up_TOA (:,:), SW_dn_TOA (:,:), LW_up_TOA (:,:), LW_dn_TOA (:,:) real , allocatable :: wout (:) !< j-averaged top velocity real , allocatable :: friction (:) !< skin-friction coeff: from y-line-averaged shear real , allocatable :: momthick (:) !< momentum thickness: y-line average real , allocatable :: displthick (:) !< displacement thickness: y-line average real :: uouttot !< area-averaged outflow velocity (used in convective outflow BC) real :: vouttot !< area-averaged outflow velocity (used in convective outflow BC) real :: wouttot !< area-averaveraged top velocity real :: udef real :: vdef real :: thlsrcdt ! thlsrc -> thlsrcdt is used to solve 1-order ODE for thlsrc real :: dgdt ! g = dp/dx -> dgdt is used to solve 1-order ODE for dpdx real :: dpdx = 0. ! dpdx given in namoptions real :: uoutarea !< area of domain u-outlet real :: voutarea !< area of domain v-outlet real :: fluidvol !< fluid volume (excluding blocks) character ( 80 ), allocatable :: ncname (:,:) character ( 80 ), allocatable :: ncname1 (:,:) character ( 80 ), allocatable :: ncname2 (:,:) character ( 80 ), allocatable :: ncstaty (:,:) character ( 80 ), allocatable :: ncstatyt (:,:) character ( 80 ), allocatable :: ncstattke (:,:) character ( 80 ), allocatable :: ncstatxy (:,:) character ( 80 ), allocatable :: ncstatxyt (:,:) character ( 80 ), allocatable :: ncstatkslice (:,:) character ( 80 ), allocatable :: ncstatislice (:,:) character ( 80 ), allocatable :: ncstatjslice (:,:) character ( 80 ), allocatable :: ncstatt (:,:) character ( 80 ), allocatable :: ncstattr (:,:) character ( 80 ), allocatable :: ncstatmint (:,:) integer , allocatable :: wall (:,:,:,:) !< wall(ic,jc,kc,1-5) gives the global indices of the wall closest to cell center ic,jc,kc. The 4th and 5th integer gives the corresponding shear components contains !> Allocate and initialize the prognostic variables subroutine initfields use modglobal , only : ib , ie , jb , je , ih , jh , kb , ke , kh , jtot , nsv ,& ihc , jhc , khc , ltdump , lmintdump , lytdump , lxytdump , ltkedump , ltempeq , lmoist , lchem , lscasrcr , ltreedump !, iadv_kappa,iadv_sv use decomp_2d , only : alloc_z ! Allocation of prognostic variables implicit none udef = 0. ; vdef = 0. !allocate(worksave(2*imax*jmax*ktot)) ! Maybe define in poisson ! ! Original ! allocate(um(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)); um = 0. ! allocate(vm(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)); vm = 0. ! allocate(wm(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)); wm = 0. ! allocate(u0(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)); u0 = 0. ! allocate(v0(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)); v0 = 0. ! allocate(w0(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)); w0 = 0. allocate ( up ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) ; up = 0. allocate ( vp ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) ; vp = 0. allocate ( wp ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) ; wp = 0. allocate ( ru ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) ; ru = 0. allocate ( rv ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) ; rv = 0. allocate ( rw ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) ; rw = 0. ! allocate(pres0(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)); pres0 = 0. ! ! ! Always have to allocate these, even if they are constant ! ! Maybe change this eventually ! allocate(thlm(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)); thlm = 0. ! allocate(thl0(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)); thl0 = 0. ! allocate(thl0h(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)); thl0h = 0. allocate ( thlp ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )); thlp = 0. allocate ( thlpc ( ib - ihc : ie + ihc , jb - jhc : je + jhc , kb : ke + khc )); thlpc = 0. ! allocate(qtm(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)); qtm = 0. ! allocate(qt0(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)); qt0 = 0. ! allocate(ql0(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)); ql0 = 0. ! allocate(qt0h(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)); qt0h = 0. allocate ( qtp ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )); qtp = 0. ! allocate(e12m(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)); e12m = 0. ! allocate(e120(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)); e120 = 0. allocate ( e12p ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )); e12p = 0. allocate ( ql0h ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )); ql0h = 0. allocate ( dthvdz ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )); dthvdz = 0. allocate ( thv0h ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )); thv0h = 0. ! allocate(mindist(ib:ie,jb:je,kb:ke)); mindist = 0. !! Allocate 3D fields using 2DECOMP&FFT in z-pencil. call alloc_z ( um ); um = 0. call alloc_z ( vm ); vm = 0. call alloc_z ( wm ); wm = 0. call alloc_z ( u0 ); u0 = 0. call alloc_z ( v0 ); v0 = 0. call alloc_z ( w0 ); w0 = 0. call alloc_z ( tau_x ); tau_x = 0. call alloc_z ( tau_y ); tau_y = 0. call alloc_z ( tau_z ); tau_z = 0. call alloc_z ( thl_flux ); thl_flux = 0. call alloc_z ( uinit ); uinit = 0. call alloc_z ( vinit ); vinit = 0. ! call alloc_z(up); up = 0. ! call alloc_z(vp); vp = 0. ! call alloc_z(wp); wp = 0. call alloc_z ( pres0 ); pres0 = 0. call alloc_z ( div , opt_zlevel = ( / 0 , 0 , 0 / )) call alloc_z ( dudx , opt_zlevel = ( / 0 , 0 , 0 / )) call alloc_z ( dvdy , opt_zlevel = ( / 0 , 0 , 0 / )) call alloc_z ( dwdz , opt_zlevel = ( / 0 , 0 , 0 / )) ! Always have to allocate these, even if ltempeq/lmoist = .false. call alloc_z ( thlm ); thlm = 0. !allocate(thlm(ib-ihc:ie+ihc,jb-jhc:je+jhc,kb-khc:ke+khc)); thlm = 0. call alloc_z ( thl0 ); thl0 = 0. allocate ( thl0c ( ib - ihc : ie + ihc , jb - jhc : je + jhc , kb - khc : ke + khc )); thl0c = 0. ! call alloc_z(thlp); thlp = 0. call alloc_z ( thl0h ); thl0h = 0. ! call alloc_z(thv0h); thv0h = 0. ! call alloc_z(dthvdz); dthvdz = 0. call alloc_z ( qtm ); qtm = 0. call alloc_z ( qt0 ); qt0 = 0. call alloc_z ( ql0 ); ql0 = 0. ! call alloc_z(qtp); qtp = 0. call alloc_z ( qt0h ); qt0h = 0. ! call alloc_z(ql0h); ql0h = 0. call alloc_z ( e12m ); e12m = 0. call alloc_z ( e120 ); e120 = 0. ! call alloc_z(e12p); e12p = 0. call alloc_z ( mindist , opt_zlevel = ( / 0 , 0 , 0 / )); mindist = 0. ! These always have to be allocated differently? !if (nsv>0) then allocate ( svm ( ib - ihc : ie + ihc , jb - jhc : je + jhc , kb - khc : ke + khc , nsv )); svm = 0. allocate ( sv0 ( ib - ihc : ie + ihc , jb - jhc : je + jhc , kb - khc : ke + khc , nsv )); sv0 = 0. allocate ( svp ( ib - ihc : ie + ihc , jb - jhc : je + jhc , kb : ke + khc , nsv )); svp = 0. allocate ( svpp ( ib - ihc : ie + ihc , jb - jhc : je + jhc , kb : ke + khc , 1 )); svpp = 0. !end if ! Allocation of diagnostic variables ! Only used in nearwall in modibm, which is not being used any more allocate ( whls ( kb : ke + kh )); whls = 0. allocate ( presf ( kb : ke + kh )); presf = 0. allocate ( presh ( kb : ke + kh )); presh = 0. allocate ( exnf ( kb : ke + kh )); exnf = 0. allocate ( exnh ( kb : ke + kh )); exnh = 0. allocate ( thvf ( kb : ke + kh )); thvf = 0. allocate ( thvh ( kb : ke + kh )); thvh = 0. allocate ( rhof ( kb : ke + kh )); rhof = 0. allocate ( qt0av ( kb : ke + kh )); qt0av = 0. allocate ( ql0av ( kb : ke + kh )); ql0av = 0. allocate ( thl0av ( kb : ke + kh )); thl0av = 0. allocate ( u0av ( kb : ke + kh )); u0av = 0. allocate ( v0av ( kb : ke + kh )); v0av = 0. allocate ( ug ( kb : ke + kh )); ug = 0. allocate ( vg ( kb : ke + kh )); vg = 0. allocate ( pgx ( kb : ke + kh )); pgx = 0. allocate ( pgy ( kb : ke + kh )); pgy = 0. allocate ( dpdxl ( kb : ke + kh )); dpdxl = 0. allocate ( dpdyl ( kb : ke + kh )); dpdyl = 0. allocate ( dthldxls ( kb : ke + kh )); dthldxls = 0. allocate ( dthldyls ( kb : ke + kh )); dthldyls = 0. allocate ( dqtdxls ( kb : ke + kh )); dqtdxls = 0. allocate ( dqtdyls ( kb : ke + kh )); dqtdyls = 0. allocate ( dqtdtls ( kb : ke + kh )); dqtdtls = 0. allocate ( dudxls ( kb : ke + kh )); dudxls = 0. allocate ( dudyls ( kb : ke + kh )); dudyls = 0. allocate ( dvdxls ( kb : ke + kh )); dvdxls = 0. allocate ( dvdyls ( kb : ke + kh )); dvdyls = 0. allocate ( wfls ( kb : ke + kh )); wfls = 0. allocate ( thlprof ( kb : ke + kh )); thlprof = 0. allocate ( qtprof ( kb : ke + kh )); qtprof = 0. allocate ( qlprof ( kb : ke + kh )); qlprof = 0. allocate ( uprof ( kb : ke + kh )); uprof = 0. allocate ( vprof ( kb : ke + kh )); vprof = 0. allocate ( e12prof ( kb : ke + kh )); e12prof = 0. allocate ( sv0av ( kb : ke + khc , nsv )); sv0av = 0. allocate ( svprof ( kb : ke + kh , nsv )); svprof = 0. allocate ( thlpcar ( kb : ke + kh )); thlpcar = 0. allocate ( wout ( ib : ie )); wout = 0. ; ! j -averaged top velocity !allocate(friction(ib:ie)); friction = 0. ! line-averaged (along j) skin friction !allocate(momthick(ib:ie)); momthick = 0.     ! line-averaged (along j) momentum thickness !allocate(displthick(ib:ie)); displthick = 0.   ! line-averaged (along j) displacement thickness !allocate(SW_up_TOA(ib-ih:ie+ih,jb-jh:je+jh)); SW_up_TOA = 0. !allocate(SW_dn_TOA(ib-ih:ie+ih,jb-jh:je+jh)); SW_dn_TOA = 0. !allocate(LW_up_TOA(ib-ih:ie+ih,jb-jh:je+jh)); LW_up_TOA = 0. !allocate(LW_dn_TOA(ib-ih:ie+ih,jb-jh:je+jh)); LW_dn_TOA = 0. !allocate(viscratioav(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)); viscratioav = 0. allocate ( rhobf ( kb : ke + kh )); rhobf = 1. allocate ( rhobh ( kb : ke + kh )); rhobh = 1. allocate ( IIc ( ib - ihc : ie + ihc , jb - jhc : je + jhc , kb : ke + khc )) allocate ( IIu ( ib - ihc : ie + ihc , jb - jhc : je + jhc , kb : ke + khc )) allocate ( IIv ( ib - ihc : ie + ihc , jb - jhc : je + jhc , kb : ke + khc )) allocate ( IIw ( ib - ihc : ie + ihc , jb - jhc : je + jhc , kb : ke + khc )) allocate ( IIuw ( ib - ihc : ie + ihc , jb - jhc : je + jhc , kb : ke + khc )) allocate ( IIvw ( ib - ihc : ie + ihc , jb - jhc : je + jhc , kb : ke + khc )) allocate ( IIuv ( ib - ihc : ie + ihc , jb - jhc : je + jhc , kb : ke + khc )) allocate ( IIct ( ib : ie , kb : ke )) allocate ( IIwt ( ib : ie , kb : ke )) allocate ( IIuwt ( ib : ie , kb : ke )) allocate ( IIut ( ib : ie , kb : ke )) allocate ( IIvt ( ib : ie , kb : ke )) allocate ( IIcs ( kb : ke + khc )) allocate ( IIus ( kb : ke + khc )) allocate ( IIvs ( kb : ke + khc )) allocate ( IIws ( kb : ke + khc )) allocate ( IIuws ( kb : ke + khc )) allocate ( IIvws ( kb : ke + khc )) allocate ( IIuvs ( kb : ke + khc )) IIc = 1 ; IIu = 1 ; IIv = 1 ; IIct = 1 ; IIw = 1 ; IIuw = 1 ; IIvw = 1 ; IIuwt = 1 ; IIut = 1 ; IIvt = 1 ; IIwt = 1 ; IIcs = 1 ; IIus = 1 ; IIvs = 1 ; IIws = 1 ; IIuws = 1 ; IIvws = 1 ; IIuw = 1 ; IIuvs = 1 if ( ltreedump ) then allocate ( qc ( kb : ke )) allocate ( qa ( kb : ke )) allocate ( ladzf ( kb : ke )) allocate ( ladzh ( kb : ke )) allocate ( Rn ( kb : ke )) allocate ( clai ( kb : ke )) allocate ( tr_u ( ib : ie , jb : je , kb : ke )) allocate ( tr_v ( ib : ie , jb : je , kb : ke )) allocate ( tr_w ( ib : ie , jb : je , kb : ke )) allocate ( tr_qt ( ib : ie , jb : je , kb : ke )) allocate ( tr_qtR ( ib : ie , jb : je , kb : ke )) allocate ( tr_qtA ( ib : ie , jb : je , kb : ke )) allocate ( tr_thl ( ib : ie , jb : je , kb : ke )) allocate ( tr_sv ( ib : ie , jb : je , kb : ke , 1 : nsv )) allocate ( tr_omega ( ib : ie , jb : je , kb : ke )) allocate ( tr_ut ( ib : ie , jb : je , kb : ke )) allocate ( tr_vt ( ib : ie , jb : je , kb : ke )) allocate ( tr_wt ( ib : ie , jb : je , kb : ke )) allocate ( tr_qtt ( ib : ie , jb : je , kb : ke )) allocate ( tr_qtRt ( ib : ie , jb : je , kb : ke )) allocate ( tr_qtAt ( ib : ie , jb : je , kb : ke )) allocate ( tr_thlt ( ib : ie , jb : je , kb : ke )) allocate ( tr_sv1t ( ib : ie , jb : je , kb : ke )) allocate ( tr_sv2t ( ib : ie , jb : je , kb : ke )) allocate ( tr_omegat ( ib : ie , jb : je , kb : ke )) clai = 0. ; Rn = 0. ; qc = 0. ; qa = 0. ; ladzf = 0. ; ladzh = 0. ; tr_u = 0. ; tr_v = 0. ; tr_w = 0. ; tr_thl = 0. ; tr_qt = 0. ; tr_qtR = 0. ; tr_qtA = 0. ; tr_sv = 0. tr_ut = 0. ; tr_vt = 0. ; tr_wt = 0. ; tr_thlt = 0. ; tr_qtt = 0. ; tr_qtRt = 0. ; tr_qtAt = 0. ; tr_sv1t = 0. ; tr_sv2t = 0. ; tr_omega = 0. ; tr_omegat = 0. end if ! Statistics - currenly not implemented. if ( lytdump ) then allocate ( uyt ( ib : ie , kb : ke )) allocate ( uytik ( ib : ie , kb : ke )) allocate ( vyt ( ib : ie , kb : ke )) allocate ( wyt ( ib : ie , kb : ke )) allocate ( wytik ( ib : ie , kb : ke )) allocate ( thlyt ( ib : ie , kb : ke )) allocate ( qtyt ( ib : ie , kb : ke )) allocate ( thlytk ( ib : ie , kb : ke )) allocate ( sca1yt ( ib : ie , kb : ke )) allocate ( sca2yt ( ib : ie , kb : ke )) allocate ( sca3yt ( ib : ie , kb : ke )) allocate ( usgsyt ( ib : ie , kb : ke )) allocate ( thlsgsyt ( ib : ie , kb : ke )) allocate ( qtsgsyt ( ib : ie , kb : ke )) allocate ( wsgsyt ( ib : ie , kb : ke )) allocate ( sv1sgsyt ( ib : ie , kb : ke )) allocate ( sv2sgsyt ( ib : ie , kb : ke )) allocate ( sv3sgsyt ( ib : ie , kb : ke )) uyt = 0. ; uytik = 0. ; vyt = 0. ; wyt = 0. ; wytik = 0. ; thlyt = 0. ; qtyt = 0. ; thlytk = 0. ; sca1yt = 0. ; sca2yt = 0. ; sca3yt = 0. ; usgsyt = 0. ; thlsgsyt = 0. ; wsgsyt = 0. ; qtsgsyt = 0. ; sv1sgsyt = 0. ; sv2sgsyt = 0. ; sv3sgsyt = 0. end if if ( lxytdump ) then allocate ( uxyt ( kb : ke + kh )) allocate ( vxyt ( kb : ke + kh )) allocate ( wxyt ( kb : ke + kh )) allocate ( thlxyt ( kb : ke + kh )) allocate ( qtxyt ( kb : ke + kh )) allocate ( pxyt ( kb : ke + kh )) allocate ( usgsxyt ( kb : ke + kh )) allocate ( thlsgsxyt ( kb : ke + kh )) allocate ( vsgsxyt ( kb : ke + kh )) uxyt = 0. ; vxyt = 0. ; wxyt = 0. ; thlxyt = 0. ; qtxyt = 0. ; pxyt = 0. ; usgsxyt = 0. ; vsgsxyt = 0. ; thlsgsxyt = 0. ; end if if ( lxytdump . or . lytdump . or . ltdump . or . lmintdump ) then allocate ( umt ( ib : ie , jb : je , kb : ke + kh )); umt = 0 ; allocate ( vmt ( ib : ie , jb : je , kb : ke + kh )); vmt = 0 ; allocate ( wmt ( ib : ie , jb : je , kb : ke + kh )); wmt = 0 ; allocate ( utc ( ib : ie , jb : je , kb : ke + kh )); utc = 0 ; allocate ( vtc ( ib : ie , jb : je , kb : ke + kh )); vtc = 0 ; allocate ( wtc ( ib : ie , jb : je , kb : ke + kh )); wtc = 0 ; allocate ( utij ( ib : ie , jb : je , kb : ke + kh )); utij = 0 ; allocate ( utik ( ib : ie , jb : je , kb : ke + kh )); utik = 0 ; allocate ( vtij ( ib : ie , jb : je , kb : ke + kh )); vtij = 0 ; allocate ( vtjk ( ib : ie , jb : je , kb : ke + kh )); vtjk = 0 ; allocate ( wtik ( ib : ie , jb : je , kb : ke + kh )); wtik = 0 ; allocate ( wtjk ( ib : ie , jb : je , kb : ke + kh )); wtjk = 0 ; allocate ( uvtij ( ib : ie , jb : je , kb : ke + kh )); uvtij = 0 ; allocate ( uwtik ( ib : ie , jb : je , kb : ke + kh )); uwtik = 0 ; allocate ( vwtjk ( ib : ie , jb : je , kb : ke + kh )); vwtjk = 0 ; allocate ( uutc ( ib : ie , jb : je , kb : ke + kh )); uutc = 0 ; allocate ( vvtc ( ib : ie , jb : je , kb : ke + kh )); vvtc = 0 ; allocate ( wwtc ( ib : ie , jb : je , kb : ke + kh )); wwtc = 0 ; allocate ( pt ( ib : ie , jb : je , kb : ke + kh )); pt = 0 ; !if (ltempeq) then ! can't have this switch for now because arrays will be wrong size in tdump file e.g. allocate ( thlt ( ib : ie , jb : je , kb : ke + kh )); thlt = 0 ; allocate ( thltk ( ib : ie , jb : je , kb : ke + kh )); thltk = 0 ; allocate ( wthltk ( ib : ie , jb : je , kb : ke + kh )); wthltk = 0 ; allocate ( thlthlt ( ib : ie , jb : je , kb : ke + kh )); thlthlt = 0 ; !end if !if (lmoist) then allocate ( qtt ( ib : ie , jb : je , kb : ke + kh )); qtt = 0 ; allocate ( qttk ( ib : ie , jb : je , kb : ke + kh )); qttk = 0 ; allocate ( wqttk ( ib : ie , jb : je , kb : ke + kh )); wqttk = 0 ; allocate ( qtqtt ( ib : ie , jb : je , kb : ke + kh )); qtqtt = 0 ; !end if !if (nsv>0) then allocate ( sv1t ( ib : ie , jb : je , kb : ke + kh )); sv1t = 0 ; allocate ( sv1tk ( ib : ie , jb : je , kb : ke + kh )); sv1tk = 0 ; allocate ( wsv1tk ( ib : ie , jb : je , kb : ke + kh )); wsv1tk = 0 ; allocate ( sv1sv1t ( ib : ie , jb : je , kb : ke + kh )); sv1sv1t = 0 ; allocate ( sv1sgst ( ib : ie , jb : je , kb : ke + kh )); sv1sgst = 0 ; !if (nsv>1) then allocate ( sv2t ( ib : ie , jb : je , kb : ke + kh )); sv2t = 0 ; allocate ( sv2tk ( ib : ie , jb : je , kb : ke + kh )); sv2tk = 0 ; allocate ( wsv2tk ( ib : ie , jb : je , kb : ke + kh )); wsv2tk = 0 ; allocate ( sv2sv2t ( ib : ie , jb : je , kb : ke + kh )); sv2sv2t = 0 ; allocate ( sv2sgst ( ib : ie , jb : je , kb : ke + kh )); sv2sgst = 0 ; !if (nsv>2) then allocate ( sv3t ( ib : ie , jb : je , kb : ke + kh )); sv3t = 0 ; allocate ( sv3tk ( ib : ie , jb : je , kb : ke + kh )); sv3tk = 0 ; allocate ( wsv3tk ( ib : ie , jb : je , kb : ke + kh )); wsv3tk = 0 ; allocate ( sv3sv3t ( ib : ie , jb : je , kb : ke + kh )); sv3sv3t = 0 ; allocate ( sv3sgst ( ib : ie , jb : je , kb : ke + kh )); sv3sgst = 0 ; !if (nsv>3) then allocate ( sv4t ( ib : ie , jb : je , kb : ke + kh )); sv4t = 0 ; allocate ( sv4tk ( ib : ie , jb : je , kb : ke + kh )); sv4tk = 0 ; allocate ( wsv4tk ( ib : ie , jb : je , kb : ke + kh )); wsv4tk = 0 ; allocate ( sv4sv4t ( ib : ie , jb : je , kb : ke + kh )); sv4sv4t = 0 ; allocate ( sv4sgst ( ib : ie , jb : je , kb : ke + kh )); sv4sgst = 0 ; !end if !end if !end if !end if !if ((lchem .eqv. .true.) .and. (nsv>2)) then allocate ( PSSt ( ib : ie , jb : je , kb : ke + kh )); PSSt = 0 ; !end if ! uwtik=0.;wthltk=0.;wqttk=0.;thlthlt=0.;qtqtt=0.;sv1sv1t=0.;sv2sv2t=0.;sv3sv3t=0.;sv4sv4t=0.;uutc=0.;vvtc=0.;wwtc=0.;vwtjk=0.;uvtij=0.;utik=0.;wtik=0.;wtjk=0.;vtjk=0.;utij=0.;vtij=0.; ! wmt=0.;thltk=0.;qttk=0.;thlt=0.;utc=0.;vtc=0.;wtc=0. ! wsv1tk=0.;wsv2tk=0.;wsv3tk=0.;wsv4tk=0.;sv1sgst=0.;sv2sgst=0.;sv3sgst=0.;sv4sgst=0.;qtt=0.;pt=0. ! PSSt = 0. !sv1max = 0.; sv2max = 0.; sv3max = 0.; sv4max = 0. end if if ( lscasrcr . and . nsv > 0 ) then allocate ( scar ( ib : ie , jb : jtot )) allocate ( scarl ( ib : ie , jb : je )) scar = 0. ; scarl = 0. end if if ( ltkedump ) then ! this is currently not usable ! allocate averaged variables allocate ( uav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( vav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( wav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( thlav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( qtav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( qlav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( presav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( svav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh , 1 : nsv )) allocate ( umint ( ib : ie , jb : je , kb : ke )) allocate ( vmint ( ib : ie , jb : je , kb : ke )) allocate ( wmint ( ib : ie , jb : je , kb : ke )) allocate ( uuav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( vvav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( wwav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( uvav ( ib : ie + ih , jb : je + jh , kb : ke )) allocate ( uwav ( ib : ie + ih , jb : je , kb : ke + kh )) allocate ( vwav ( ib : ie , jb : je + jh , kb : ke + kh )) !TKE budget terms allocate ( tvmx ( ib - 1 : ie + 1 , jb - 1 : je + 1 , kb : ke )) allocate ( tvmy ( ib - 1 : ie + 1 , jb - 1 : je + 1 , kb : ke )) allocate ( tvmz ( ib : ie , jb : je , kb : ke + 1 )) allocate ( tpm ( ib : ie , jb : je , kb : ke )) allocate ( ttmx ( ib - 1 : ie + 1 , jb - 1 : je + 1 , kb : ke )) allocate ( ttmy ( ib - 1 : ie + 1 , jb - 1 : je + 1 , kb : ke )) allocate ( ttmz ( ib : ie , jb : je , kb : ke + 1 )) allocate ( tsgsmx1 ( ib - 1 : ie + 1 , jb - 1 : je + 1 , kb : ke )) allocate ( tsgsmy1 ( ib - 1 : ie + 1 , jb - 1 : je + 1 , kb : ke )) allocate ( tsgsmz1 ( ib : ie , jb : je , kb : ke + 1 )) allocate ( tsgsmx2 ( ib - 1 : ie + 1 , jb - 1 : je + 1 , kb : ke )) allocate ( tsgsmy2 ( ib - 1 : ie + 1 , jb - 1 : je + 1 , kb : ke )) allocate ( tsgsmz2 ( ib : ie , jb : je , kb : ke + 1 )) allocate ( t_pav ( ib : ie , jb : je , kb : ke )) allocate ( t_vav ( ib : ie , jb : je , kb : ke )) allocate ( t_tav ( ib : ie , jb : je , kb : ke )) allocate ( t_sgsav ( ib : ie , jb : je , kb : ke )) allocate ( p_tav ( ib : ie , jb : je , kb : ke )) allocate ( p_bav ( ib : ie , jb : je , kb : ke )) allocate ( d_sgsav ( ib : ie , jb : je , kb : ke )) allocate ( tkeadv ( ib : ie , jb : je , kb : ke )) allocate ( t_p ( kb : ke )) allocate ( t_v ( kb : ke )) allocate ( t_t ( kb : ke )) allocate ( t_sgs ( kb : ke )) allocate ( p_t ( kb : ke )) allocate ( p_b ( kb : ke )) allocate ( d_sgs ( kb : ke )) allocate ( adv ( kb : ke )) uav = 0. ; vav = 0. ; wav = 0. ; thlav = 0. ; qtav = 0. ; svav = 0. ;; uuav = 0. ; vvav = 0. wwav = 0. ; uvav = 0. ; uwav = 0. ; vwav = 0. ; presav = 0. umint = 0. ; vmint = 0. ; wmint = 0. t_vav = 0. ; tvmx = 0. ; tvmy = 0. ; tvmz = 0. ; tpm = 0. ; ttmx = 0. ; ttmy = 0. ; ttmz = 0. ; t_sgsav = 0. ; p_tav = 0. tsgsmx1 = 0. ; tsgsmy1 = 0. ; tsgsmz1 = 0. ; tsgsmx2 = 0. ; tsgsmy2 = 0. ; tsgsmz2 = 0. t_pav = 0. ; t_tav = 0. ; p_bav = 0. ; d_sgsav = 0. ; tkeadv = 0. ; t_p = 0. ; t_v = 0. ; t_t = 0. ; t_sgs = 0. ; p_t = 0. ; p_b = 0. ; d_sgs = 0. ; adv = 0. allocate ( thl2av ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( ql2av ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( qt2av ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( sv2av ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh , 1 : nsv )) allocate ( thluav ( ib : ie + ih , jb : je , kb : ke )) allocate ( thlvav ( ib : ie , jb : je + jh , kb : ke )) allocate ( thlwav ( ib : ie , jb : je , kb : ke + kh )) allocate ( thlthlav ( ib : ie , jb : je , kb : ke + kh )) allocate ( qluav ( ib : ie + ih , jb : je , kb : ke )) allocate ( qlvav ( ib : ie , jb : je + jh , kb : ke )) allocate ( qlwav ( ib : ie , jb : je , kb : ke + kh )) allocate ( qtuav ( ib : ie + ih , jb : je , kb : ke )) allocate ( qtvav ( ib : ie , jb : je + jh , kb : ke )) allocate ( qtwav ( ib : ie , jb : je , kb : ke + kh )) allocate ( svuav ( ib : ie + ih , jb : je , kb : ke , 1 : nsv )) allocate ( svvav ( ib : ie , jb : je + jh , kb : ke , 1 : nsv )) allocate ( svwav ( ib : ie , jb : je , kb : ke + kh , 1 : nsv )) thluav = 0. ; thlvav = 0. ; thlwav = 0. ; thlthlav = 0. ; svuav = 0. ; svvav = 0. ; svwav = 0. ; sv2av = 0. ; thl2av = 0. ; ql2av = 0. ; qt2av = 0. ; ! <x'x> ( = <xx> -<x><x> ) allocate ( upupav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( vpvpav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( wpwpav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( upvpav ( ib : ie + ih , jb : je + jh , kb : ke )) allocate ( upwpav ( ib : ie + ih , jb : je , kb : ke + kh )) allocate ( vpwpav ( ib : ie , jb : je + jh , kb : ke + kh )) allocate ( thlpthlpav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( thlpupav ( ib : ie + ih , jb : je , kb : ke )) allocate ( thlpvpav ( ib : ie , jb : je + jh , kb : ke )) allocate ( thlpwpav ( ib : ie , jb : je , kb : ke + kh )) allocate ( qlpqlpav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( qlpupav ( ib : ie + ih , jb : je , kb : ke )) allocate ( qlpvpav ( ib : ie , jb : je + jh , kb : ke )) allocate ( qlpwpav ( ib : ie , jb : je , kb : ke + kh )) allocate ( qtpqtpav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( qtpupav ( ib : ie + ih , jb : je , kb : ke )) allocate ( qtpvpav ( ib : ie , jb : je + jh , kb : ke )) allocate ( qtpwpav ( ib : ie , jb : je , kb : ke + kh )) allocate ( svpsvpav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh , 1 : nsv )) allocate ( svpupav ( ib : ie + ih , jb : je , kb : ke , 1 : nsv )) allocate ( svpvpav ( ib : ie , jb : je + jh , kb : ke , 1 : nsv )) allocate ( svpwpav ( ib : ie , jb : je , kb : ke + kh , 1 : nsv )) upupav = 0. ; vpvpav = 0. ; wpwpav = 0. ; thlpthlpav = 0. ; qlpqlpav = 0. ; qtpqtpav = 0. ; svpsvpav = 0. ; upvpav = 0. ; upwpav = 0. ; vpwpav = 0. thlpupav = 0. ; thlpvpav = 0. ; thlpwpav = 0. ; qlpupav = 0. ; qlpvpav = 0. ; qlpwpav = 0. ; qtpwpav = 0. ; qtpvpav = 0. ; qtpupav = 0. ; svpupav = 0. ; svpvpav = 0. ; svpwpav = 0. ! Subgrid allocate ( uusgsav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( vvsgsav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( wwsgsav ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( uwsgsav ( ib : ie + ih , jb : je , kb : ke + kh )) allocate ( thlusgsav ( ib : ie + ih , jb : je , kb : ke )) allocate ( thlwsgsav ( ib : ie , jb : je , kb : ke + kh )) allocate ( qlusgsav ( ib : ie + ih , jb : je , kb : ke )) allocate ( qlwsgsav ( ib : ie , jb : je , kb : ke + kh )) allocate ( qtusgsav ( ib : ie + ih , jb : je , kb : ke )) allocate ( qtwsgsav ( ib : ie , jb : je , kb : ke + kh )) allocate ( tkesgsav ( ib : ie , jb : je , kb : ke )) allocate ( svusgsav ( ib : ie + ih , jb : je , kb : ke , 1 : nsv )) allocate ( svwsgsav ( ib : ie , jb : je , kb : ke + kh , 1 : nsv )) allocate ( nusgsav ( ib : ie , jb : je , kb : ke )) uusgsav = 0. ; vvsgsav = 0. ; wwsgsav = 0. ; uwsgsav = 0. ; thlusgsav = 0. ; thlwsgsav = 0. ; qlusgsav = 0. ; qlwsgsav = 0. ; qtwsgsav = 0. ; qtusgsav = 0. ; svusgsav = 0. ; svwsgsav = 0. ; tkesgsav = 0. ; nusgsav = 0. allocate ( strain2av ( ib : ie , jb : je , kb : ke )) ! resolved dissipation allocate ( disssgsav ( ib : ie , jb : je , kb : ke )) ! Subgrid dissipation strain2av = 0. disssgsav = 0. end if ! allocate wall shear-stress terms (immersed boundaries) allocate ( shear ( ib - 1 : ie + 1 , jb - 1 : je + 1 , kb - 1 : ke + 1 , 0 : 12 )) ! halo is set to 1 allocate ( momfluxb ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( tfluxb ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( qfluxb ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( cth ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( wall ( ib : ie , jb : je , kb : ke , 5 )) momfluxb = 0. ; tfluxb = 0. ; qfluxb = 0. ; cth = 0. shear = 0. ! domain fluid volume and area calculations uoutarea = 0. ; voutarea = 0. ; fluidvol = 0. end subroutine initfields !> Deallocate the fields subroutine exitfields implicit none deallocate ( um , vm , wm , thlm , e12m , qtm , u0 , v0 , w0 , pres0 , thl0 , thl0h , qt0h , e120 , qt0 ) deallocate ( up , vp , wp , thlp , e12p , qtp ) deallocate ( svm , sv0 , svp , svpp ) deallocate ( ql0 , ql0h , thv0h , dthvdz , whls , presf , presh , exnf , exnh , thvf , thvh , rhof , qt0av , ql0av , thl0av , u0av , v0av ) deallocate ( ug , vg , pgx , pgy , dpdxl , dpdyl , dthldxls , dthldyls , dqtdxls , dqtdyls , dqtdtls , dudxls , dudyls , dvdxls , dvdyls , wfls ) deallocate ( thlprof , qtprof , uprof , vprof , e12prof , sv0av , svprof ) deallocate ( thlpcar ) deallocate ( momfluxb , tfluxb , qfluxb , cth ) deallocate ( SW_up_TOA , SW_dn_TOA , LW_up_TOA , LW_dn_TOA ) end subroutine exitfields end module modfields","tags":"","url":"sourcefile/modfields.f90.html"},{"title":"modstatistics.f90 – uDALES","text":"This file depends on sourcefile~~modstatistics.f90~~EfferentGraph sourcefile~modstatistics.f90 modstatistics.f90 sourcefile~modfields.f90 modfields.f90 sourcefile~modstatistics.f90->sourcefile~modfields.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~modstatistics.f90->sourcefile~modglobal.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~modstatistics.f90->sourcefile~modmpi.f90 sourcefile~modstat_nc.f90 modstat_nc.f90 sourcefile~modstatistics.f90->sourcefile~modstat_nc.f90 sourcefile~modsubgriddata.f90 modsubgriddata.f90 sourcefile~modstatistics.f90->sourcefile~modsubgriddata.f90 sourcefile~modsurfdata.f90 modsurfdata.f90 sourcefile~modstatistics.f90->sourcefile~modsurfdata.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 sourcefile~modstat_nc.f90->sourcefile~modglobal.f90 sourcefile~modstat_nc.f90->sourcefile~modmpi.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~modstatistics.f90~~AfferentGraph sourcefile~modstatistics.f90 modstatistics.f90 sourcefile~modstatsdump.f90 modstatsdump.f90 sourcefile~modstatsdump.f90->sourcefile~modstatistics.f90 sourcefile~program.f90 program.f90 sourcefile~program.f90->sourcefile~modstatsdump.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> \\file modstatistics.f90 !!  Calculates field statistics to be written in modstatsdump.f90 !> !!  \\author Tom Grylls, ICL Dec 16 2016 ! !  This file is part of uDALES. ! ! This program is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! This program is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !  Copyright 2006-2021 the uDALES Team. ! module modstatistics use modglobal , only : dt , ltkedump use modmpi , only : myid implicit none private PUBLIC :: genstats , tkestats save !NetCDF variables integer :: klow , khigh , i , j , k !  real    :: tsamplep,tstatsdumpp,tsample,tstatsdump contains !------------------------- !> Calculate general stats !------------------------- subroutine genstats ( tsamplep , tstatsdumpp , umint , vmint , wmint ) use modfields , only : um , up , vm , wm , thlm , uav , vav , wav , uuav , vvav , wwav , uvav , vwav , uwav , thlav , thlwav , thlthlav , & upupav , vpvpav , wpwpav , upvpav , upwpav , vpwpav , thlpwpav use modglobal , only : ib , ie , ih , jb , je , dy , jh , ke , kb , kh , rk3step , timee , cexpnr , tsample , tstatsdump ,& ltempeq , dxf , dzf , dzhi use modmpi , only : myid , cmyid , my_real , mpi_sum , mpierr , comm3d implicit none real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ) :: umint real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ) :: vmint real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ) :: wmint real :: tstatsdumppi , tsamplep , tstatsdumpp integer :: km tstatsdumppi = 1. / tstatsdumpp !  if (lydump) then if (. not . rk3step == 3 ) return !      if (tsamplep > tsample) then !> Interpolate velocity fields to cell centers !        do k=kb-kh,ke !          do j=jb-jh,je+jh !            do i=ib-ih,ie+ih !              umint(i,j,k) = 0.5*(um(i,j,k)+um(i+1,j,k)) !              vmint(i,j,k) = 0.5*(vm(i,j,k)+vm(i,j+1,k)) !              wmint(i,j,k) = 0.5*(wm(i,j,k)+wm(i,j,k+1)) !            enddo !          enddo !        enddo do k = kb , ke do j = jb , je do i = ib , ie uav ( i , j , k ) = ( uav ( i , j , k ) * ( tstatsdumpp - tsamplep ) + umint ( i , j , k ) * tsamplep ) * tstatsdumppi vav ( i , j , k ) = ( vav ( i , j , k ) * ( tstatsdumpp - tsamplep ) + vmint ( i , j , k ) * tsamplep ) * tstatsdumppi wav ( i , j , k ) = ( wav ( i , j , k ) * ( tstatsdumpp - tsamplep ) + wmint ( i , j , k ) * tsamplep ) * tstatsdumppi uuav ( i , j , k ) = ( uuav ( i , j , k ) * ( tstatsdumpp - tsamplep ) + ( umint ( i , j , k ) ** 2 ) * tsamplep ) * tstatsdumppi vvav ( i , j , k ) = ( vvav ( i , j , k ) * ( tstatsdumpp - tsamplep ) + ( vmint ( i , j , k ) ** 2 ) * tsamplep ) * tstatsdumppi wwav ( i , j , k ) = ( wwav ( i , j , k ) * ( tstatsdumpp - tsamplep ) + ( wmint ( i , j , k ) ** 2 ) * tsamplep ) * tstatsdumppi uvav ( i , j , k ) = ( uvav ( i , j , k ) * ( tstatsdumpp - tsamplep ) + umint ( i , j , k ) * vmint ( i , j , k ) * tsamplep ) * tstatsdumppi vwav ( i , j , k ) = ( vwav ( i , j , k ) * ( tstatsdumpp - tsamplep ) + vmint ( i , j , k ) * wmint ( i , j , k ) * tsamplep ) * tstatsdumppi uwav ( i , j , k ) = ( uwav ( i , j , k ) * ( tstatsdumpp - tsamplep ) + umint ( i , j , k ) * wmint ( i , j , k ) * tsamplep ) * tstatsdumppi if ( ltempeq ) then thlav ( i , j , k ) = ( thlav ( i , j , k ) * ( tstatsdumpp - tsamplep ) + thlm ( i , j , k ) * tsamplep ) * tstatsdumppi thlwav ( i , j , k ) = ( thlwav ( i , j , k ) * ( tstatsdumpp - tsamplep ) + thlm ( i , j , k ) * wmint ( i , j , k ) * tsamplep ) * tstatsdumppi thlthlav ( i , j , k ) = ( thlthlav ( i , j , k ) * ( tstatsdumpp - tsamplep ) + ( thlm ( i , j , k ) ** 2 ) * tsamplep ) * tstatsdumppi end if end do end do end do upupav = uuav - uav ** 2 ! overline(u'u') = overline(uu) - U&#94;2 vpvpav = vvav - vav ** 2 ! overline(v'v') = overline(vv) - V&#94;2 wpwpav = wwav - wav ** 2 ! overline(w'w') = overline(ww) - W&#94;2 upvpav = uvav - uav * vav ! overline(u'v') = overline(uv) - U*V upwpav = uwav - uav * wav ! overline(u'w') = overline(uw) - U*W vpwpav = vwav - vav * wav ! overline(v'w') = overline(vw) - V*W ! thlw and svw: ib:ie jb:je kb:ke+1  (located on w-faces) !tg3315 BUT thlwav is on cell centre... do k = kb , ke + 1 km = k - 1 do j = jb , je do i = ib , ie thlpwpav ( i , j , k ) = thlwav ( i , j , k ) - & 0.5 * wav ( i , j , k ) * & ! no interpolation ( thlav ( i , j , km ) * dzf ( k ) + thlav ( i , j , k ) * dzf ( km )) * dzhi ( k ) ! interpolate thl to w-faces !              qlpwpav(i,j,k) = thlwav(i,j,k) - & !                                0.5 * wav(i,j,k) * & ! no interpolation !                               (qlav(i,j,km)*dzf(k) + qlav(i,j,k)*dzf(km))*dzhi(k) ! interpolate thl to w-faces !              qtpwpav(i,j,k) = qtwav(i,j,k) - & !                                0.5 * wav(i,j,k) * & ! no interpolation !                                (qtav(i,j,km)*dzf(k) + qtav(i,j,k)*dzf(km))*dzhi(k) ! interpolate thl to w-faces ! !              do n=1,nsv !                svpwpav(i,j,k,n) = svwav(i,j,k,n) - & !                                   0.5 * wav(i,j,k) * & ! no interpolation !                                   (svav(i,j,km,n)*dzf(k) + svav(i,j,k,n)*dzf(km))*dzhi(k) ! interpolate svav to w-faces !              end do end do end do end do !> generate time averaged stats for TKE budget and call subroutine final field values if ( ltkedump ) then call tkestats ( tsamplep , tstatsdumpp ) end if !        tsample = dt !     else !timestatsdumpp < tsample !       tsamplep = tsamplep + dt !      end if !    end if !  end if end subroutine genstats !------------------------- !> Calculate TKE budget terms !------------------------- subroutine tkestats ( tsamplep , tstatsdumpp ) ! change of variable names not yet translated across to here ! tg3315 30/11/17 use modfields , only : u0 , v0 , w0 , thlm , uyt , vyt , wyt , thlyt , pres0 ,& tvmx , tvmy , tvmz , strain2av , tsgsmx1 , tsgsmx2 , tsgsmy1 , tsgsmy2 ,& tsgsmz1 , tsgsmz2 , pres0 use modglobal , only : ib , ie , ih , jb , je , jgb , jge , dy , jh , ke , kb , kh , rk3step , cexpnr , tsample , tstatsdump , dzf , zh , dxf , dzf , numol ,& dzfi , dxfi , dyi , dy2i , dxfiq , dxhiq , dyiq , dzfi5 , dzh , dzf , dzhi , dzhiq , dxf , dxhi use modstat_nc , only : writestat_nc use modsurfdata , only : thls use modsubgriddata , only : ekm implicit none real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ) :: tekm ! turbulent viscosity !  real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)  :: emom !  real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)  :: eomm !  real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)  :: eopm !  real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)  :: epom !  real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)  :: emmo !  real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)  :: eomp !  real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)  :: epmo !  real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)  :: emop !  real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)  :: empo !  real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)  :: tkesgs !  real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh)  :: nusgs !  real :: dummy integer i , j , k , im , ip , jm , jp , km , kp real tstatsdumppi , tsamplep , tstatsdumpp , strain2 , tkesgs , nusgs ,& emom , eomm , eopm , epom , emmo , eomp , epmo , emop , empo , dummy tekm (:,:,:) = ekm (:,:,:) - numol tstatsdumppi = 1. / tstatsdumpp !--------------------------------------- ! Viscous transport TKE !--------------------------------------- !> Time averaged viscous transport in x,y and z to be used to calculate the total viscous transport for TKE ! Tvmx at u-locations (ib:ih+ih:jb:je,kb:ke) ! This is similar to routine diffu time u_i do k = kb , ke kp = k + 1 km = k - 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie ip = i + 1 im = i - 1 dummy = u0 ( i , j , k ) * ( & ( numol * ( u0 ( i + 1 , j , k ) - u0 ( i , j , k )) * dxfi ( i ) & - numol * ( u0 ( i , j , k ) - u0 ( i - 1 , j , k )) * dxfi ( i - 1 ) ) * 2. * dxhi ( i ) & + & ( numol * ( ( u0 ( i , jp , k ) - u0 ( i , j , k )) * dyi & + ( v0 ( i , jp , k ) - v0 ( i - 1 , jp , k )) * dxhi ( i )) & - numol * ( ( u0 ( i , j , k ) - u0 ( i , jm , k )) * dyi & + ( v0 ( i , j , k ) - v0 ( i - 1 , j , k )) * dxhi ( i )) & ) * dyi & + & ( numol * ( ( u0 ( i , j , kp ) - u0 ( i , j , k )) * dzhi ( kp ) & + ( w0 ( i , j , kp ) - w0 ( i - 1 , j , kp )) * dxhi ( i )) & - numol * ( ( u0 ( i , j , k ) - u0 ( i , j , km )) * dzhi ( k ) & + ( w0 ( i , j , k ) - w0 ( i - 1 , j , k )) * dxhi ( i )) & ) * dzfi ( k ) ) tvmx ( i , j , k ) = ( tvmx ( i , j , k ) * ( tstatsdumpp - tsamplep ) + dummy * tsamplep ) * tstatsdumppi ! update average tvmx ! Tvmv at v-locations (ib:ih:jb:je+1,kb:ke) ! This is similar to routine diffv time v dummy = v0 ( i , j , k ) * ( & ( numol * ( ( v0 ( i + 1 , j , k ) - v0 ( i , j , k )) * dxhi ( i + 1 ) & + ( u0 ( i + 1 , j , k ) - u0 ( i + 1 , jm , k )) * dyi ) & - numol * ( ( v0 ( i , j , k ) - v0 ( i - 1 , j , k )) * dxhi ( i ) & + ( u0 ( i , j , k ) - u0 ( i , jm , k )) * dyi ) & ) * dxfi ( i ) & ! = d/dx( Km*(dv/dx + du/dy) ) + & ( numol * ( v0 ( i , jp , k ) - v0 ( i , j , k )) & - numol * ( v0 ( i , j , k ) - v0 ( i , jm , k )) ) * 2. * dy2i & ! = d/dy( 2*Km*(dv/dy) ) + & ( numol * ( ( v0 ( i , j , kp ) - v0 ( i , j , k )) * dzhi ( kp ) & + ( w0 ( i , j , kp ) - w0 ( i , jm , kp )) * dyi ) & - numol * ( ( v0 ( i , j , k ) - v0 ( i , j , km )) * dzhi ( k ) & + ( w0 ( i , j , k ) - w0 ( i , jm , k )) * dyi ) & ) * dzfi ( k ) ) ! = d/dz( Km*(dv/dz + dw/dy) ) tvmy ( i , j , k ) = ( tvmy ( i , j , k ) * ( tstatsdumpp - tsamplep ) + dummy * tsamplep ) * tstatsdumppi ! update average tvmy ! Tvmz at w-locations (ib:ih:jb:je,kb:ke+kh) ! This is similar to routine diffw time w dummy = w0 ( i , j , k ) * ( & ( numol * ( ( w0 ( i + 1 , j , k ) - w0 ( i , j , k )) * dxhi ( i + 1 ) & + ( u0 ( i + 1 , j , k ) - u0 ( i + 1 , j , km )) * dzhi ( k ) ) & - numol * ( ( w0 ( i , j , k ) - w0 ( i - 1 , j , k )) * dxhi ( i ) & + ( u0 ( i , j , k ) - u0 ( i , j , km )) * dzhi ( k ) ) & ) * dxfi ( i ) & + & ( numol * ( ( w0 ( i , jp , k ) - w0 ( i , j , k )) * dyi & + ( v0 ( i , jp , k ) - v0 ( i , jp , km )) * dzhi ( k ) ) & - numol * ( ( w0 ( i , j , k ) - w0 ( i , jm , k )) * dyi & + ( v0 ( i , j , k ) - v0 ( i , j , km )) * dzhi ( k ) ) & ) * dyi & + & ( numol * ( w0 ( i , j , kp ) - w0 ( i , j , k )) * dzfi ( k ) & - numol * ( w0 ( i , j , k ) - w0 ( i , j , km )) * dzfi ( km ) ) * 2. & * dzhi ( k ) ) tvmz ( i , j , k ) = ( tvmz ( i , j , k ) * ( tstatsdumpp - tsamplep ) + dummy * tsamplep ) * tstatsdumppi ! update average uwsgsav ! Compute stresses and fluxes at c.c. , also used in total viscous transport strain2 = ( & (( u0 ( ip , j , k ) - u0 ( i , j , k )) * dxfi ( i ) ) ** 2 + & (( v0 ( i , jp , k ) - v0 ( i , j , k )) * dyi ) ** 2 + & (( w0 ( i , j , kp ) - w0 ( i , j , k )) * dzfi ( k ) ) ** 2 ) strain2 = strain2 + 0.125 * ( & (( w0 ( i , j , kp ) - w0 ( im , j , kp )) * dxhi ( i ) + & ( u0 ( i , j , kp ) - u0 ( i , j , k )) * dzhi ( kp ) ) ** 2 + & (( w0 ( i , j , k ) - w0 ( im , j , k )) * dxhi ( i ) + & ( u0 ( i , j , k ) - u0 ( i , j , km )) * dzhi ( k ) ) ** 2 + & (( w0 ( ip , j , k ) - w0 ( i , j , k )) * dxhi ( ip ) + & ( u0 ( ip , j , k ) - u0 ( ip , j , km )) * dzhi ( k ) ) ** 2 + & (( w0 ( ip , j , kp ) - w0 ( i , j , kp )) * dxhi ( ip ) + & ( u0 ( ip , j , kp ) - u0 ( ip , j , k )) * dzhi ( kp ) ) ** 2 ) strain2 = strain2 + 0.125 * ( & (( u0 ( i , jp , k ) - u0 ( i , j , k )) * dyi + & ( v0 ( i , jp , k ) - v0 ( im , jp , k )) * dxhi ( i ) ) ** 2 + & (( u0 ( i , j , k ) - u0 ( i , jm , k )) * dyi + & ( v0 ( i , j , k ) - v0 ( im , j , k )) * dxhi ( i ) ) ** 2 + & (( u0 ( ip , j , k ) - u0 ( ip , jm , k )) * dyi + & ( v0 ( ip , j , k ) - v0 ( i , j , k )) * dxhi ( ip ) ) ** 2 + & (( u0 ( ip , jp , k ) - u0 ( ip , j , k )) * dyi + & ( v0 ( ip , jp , k ) - v0 ( i , jp , k )) * dxhi ( ip ) ) ** 2 ) strain2 = strain2 + 0.125 * ( & (( v0 ( i , j , kp ) - v0 ( i , j , k )) * dzhi ( kp ) + & ( w0 ( i , j , kp ) - w0 ( i , jm , kp )) * dyi ) ** 2 + & (( v0 ( i , j , k ) - v0 ( i , j , km )) * dzhi ( k ) + & ( w0 ( i , j , k ) - w0 ( i , jm , k )) * dyi ) ** 2 + & (( v0 ( i , jp , k ) - v0 ( i , jp , km )) * dzhi ( k ) + & ( w0 ( i , jp , k ) - w0 ( i , j , k )) * dyi ) ** 2 + & (( v0 ( i , jp , kp ) - v0 ( i , jp , k )) * dzhi ( kp ) + & ( w0 ( i , jp , kp ) - w0 ( i , j , kp )) * dyi ) ** 2 ) strain2av ( i , j , k ) = ( strain2av ( i , j , k ) * ( tstatsdumpp - tsamplep ) + strain2 * tsamplep ) * tstatsdumppi ! update average strain2av !-------------------------------------------------- !> SGS TKE !-------------------------------------------------- ! x-direction emom = ( dzf ( km ) * ( tekm ( i , j , k ) * dxf ( i - 1 ) + tekm ( i - 1 , j , k ) * dxf ( i ) ) + & ! dx is non-equidistant dzf ( k ) * ( tekm ( i , j , km ) * dxf ( i - 1 ) + tekm ( i - 1 , j , km ) * dxf ( i ) ) ) * dxhi ( i ) * dzhiq ( k ) emop = ( dzf ( kp ) * ( tekm ( i , j , k ) * dxf ( i - 1 ) + tekm ( i - 1 , j , k ) * dxf ( i ) ) + & ! dx is non-equidistant dzf ( k ) * ( tekm ( i , j , kp ) * dxf ( i - 1 ) + tekm ( i - 1 , j , kp ) * dxf ( i ) ) ) * dxhi ( i ) * dzhiq ( kp ) empo = 0.25 * ( ( tekm ( i , j , k ) + tekm ( i , jp , k )) * dxf ( i - 1 ) + ( tekm ( i - 1 , j , k ) + tekm ( i - 1 , jp , k )) * dxf ( i ) ) * dxhi ( i ) ! dx is non-equidistant emmo = 0.25 * ( ( tekm ( i , j , k ) + tekm ( i , jm , k )) * dxf ( i - 1 ) + ( tekm ( i - 1 , jm , k ) + tekm ( i - 1 , j , k )) * dxf ( i ) ) * dxhi ( i ) ! dx is non-equidistant !        dummy =  u0(i,j,k)*(                           & dummy = ( & ( tekm ( i , j , k ) * ( u0 ( i + 1 , j , k ) - u0 ( i , j , k )) * dxfi ( i ) & - tekm ( i - 1 , j , k ) * ( u0 ( i , j , k ) - u0 ( i - 1 , j , k )) * dxfi ( i - 1 ) ) * 2. * dxhi ( i ) & + & ( empo * ( ( u0 ( i , jp , k ) - u0 ( i , j , k )) * dyi & + ( v0 ( i , jp , k ) - v0 ( i - 1 , jp , k )) * dxhi ( i )) & - emmo * ( ( u0 ( i , j , k ) - u0 ( i , jm , k )) * dyi & + ( v0 ( i , j , k ) - v0 ( i - 1 , j , k )) * dxhi ( i )) & ) * dyi & + & ( emop * ( ( u0 ( i , j , kp ) - u0 ( i , j , k )) * dzhi ( kp ) & + ( w0 ( i , j , kp ) - w0 ( i - 1 , j , kp )) * dxhi ( i )) & - emom * ( ( u0 ( i , j , k ) - u0 ( i , j , km )) * dzhi ( k ) & + ( w0 ( i , j , k ) - w0 ( i - 1 , j , k )) * dxhi ( i )) & ) * dzfi ( k ) ) tsgsmx1 ( i , j , k ) = ( tsgsmx1 ( i , j , k ) * ( tstatsdumpp - tsamplep ) + dummy * u0 ( i , j , k ) * tsamplep ) * tstatsdumppi ! update average tsgsmx1 tsgsmx2 ( i , j , k ) = ( tsgsmx2 ( i , j , k ) * ( tstatsdumpp - tsamplep ) + dummy * tsamplep ) * tstatsdumppi ! update average tsgsmx2 ! y-direction eomm = ( dzf ( km ) * ( tekm ( i , j , k ) + tekm ( i , jm , k ) ) + & dzf ( k ) * ( tekm ( i , j , km ) + tekm ( i , jm , km ) ) ) * dzhiq ( k ) eomp = ( dzf ( kp ) * ( tekm ( i , j , k ) + tekm ( i , jm , k ) ) + & dzf ( k ) * ( tekm ( i , j , kp ) + tekm ( i , jm , kp ) ) ) * dzhiq ( kp ) emmo = 0.25 * ( ( tekm ( i , j , k ) + tekm ( i , jm , k )) * dxf ( i - 1 ) + ( tekm ( i - 1 , jm , k ) + tekm ( i - 1 , j , k )) * dxf ( i ) ) * dxhi ( i ) ! dx is non-equidistant epmo = 0.25 * ( ( tekm ( i , j , k ) + tekm ( i , jm , k )) * dxf ( i + 1 ) + ( tekm ( i + 1 , jm , k ) + tekm ( i + 1 , j , k )) * dxf ( i ) ) * dxhi ( i + 1 ) ! dx is non-equidistant !       dummy = v0(i,j,k) * (                            & dummy = ( & ( epmo * ( ( v0 ( i + 1 , j , k ) - v0 ( i , j , k )) * dxhi ( i + 1 ) & + ( u0 ( i + 1 , j , k ) - u0 ( i + 1 , jm , k )) * dyi ) & - emmo * ( ( v0 ( i , j , k ) - v0 ( i - 1 , j , k )) * dxhi ( i ) & + ( u0 ( i , j , k ) - u0 ( i , jm , k )) * dyi ) & ) * dxfi ( i ) & ! = d/dx( Km*(dv/dx + du/dy) ) + & ( tekm ( i , j , k ) * ( v0 ( i , jp , k ) - v0 ( i , j , k )) & - tekm ( i , jm , k ) * ( v0 ( i , j , k ) - v0 ( i , jm , k )) ) * 2. * dy2i & ! = d/dy( 2*Km*(dv/dy) ) + & ( eomp * ( ( v0 ( i , j , kp ) - v0 ( i , j , k )) * dzhi ( kp ) & + ( w0 ( i , j , kp ) - w0 ( i , jm , kp )) * dyi ) & - eomm * ( ( v0 ( i , j , k ) - v0 ( i , j , km )) * dzhi ( k ) & + ( w0 ( i , j , k ) - w0 ( i , jm , k )) * dyi ) & ) * dzfi ( k ) ) ! = d/dz( Km*(dv/dz + dw/dy) ) tsgsmy1 ( i , j , k ) = ( tsgsmy1 ( i , j , k ) * ( tstatsdumpp - tsamplep ) + dummy * v0 ( i , j , k ) * tsamplep ) * tstatsdumppi ! update average tsgsmy1  = <v*d/dxj(2*nu*S2j)> tsgsmy2 ( i , j , k ) = ( tsgsmy2 ( i , j , k ) * ( tstatsdumpp - tsamplep ) + dummy * tsamplep ) * tstatsdumppi ! update average tsgsmy2  = <d/dxj(2*nu*S2j)> ! z-direction emom = ( dzf ( km ) * ( tekm ( i , j , k ) * dxf ( i - 1 ) + tekm ( i - 1 , j , k ) * dxf ( i ) ) * dxhi ( i ) + & dzf ( k ) * ( tekm ( i , j , km ) * dxf ( i - 1 ) + tekm ( i - 1 , j , km ) * dxf ( i ) ) * dxhi ( i ) ) * dzhiq ( k ) eomm = ( dzf ( km ) * ( tekm ( i , j , k ) + tekm ( i , jm , k ) ) + & dzf ( k ) * ( tekm ( i , j , km ) + tekm ( i , jm , km ) ) ) * dzhiq ( k ) eopm = ( dzf ( km ) * ( tekm ( i , j , k ) + tekm ( i , jp , k ) ) + & dzf ( k ) * ( tekm ( i , j , km ) + tekm ( i , jp , km ) ) ) * dzhiq ( k ) epom = ( dzf ( km ) * ( tekm ( i , j , k ) * dxf ( i + 1 ) + tekm ( i + 1 , j , k ) * dxf ( i ) ) * dxhi ( i + 1 ) + & dzf ( k ) * ( tekm ( i , j , km ) * dxf ( i + 1 ) + tekm ( i + 1 , j , km ) * dxf ( i ) ) * dxhi ( i + 1 ) ) * dzhiq ( k ) !        dummy = w0(i,j,k) * (                                         & dummy = ( & ( epom * ( ( w0 ( i + 1 , j , k ) - w0 ( i , j , k )) * dxhi ( i + 1 ) & + ( u0 ( i + 1 , j , k ) - u0 ( i + 1 , j , km )) * dzhi ( k ) ) & - emom * ( ( w0 ( i , j , k ) - w0 ( i - 1 , j , k )) * dxhi ( i ) & + ( u0 ( i , j , k ) - u0 ( i , j , km )) * dzhi ( k ) ) & ) * dxfi ( i ) & + & ( eopm * ( ( w0 ( i , jp , k ) - w0 ( i , j , k )) * dyi & + ( v0 ( i , jp , k ) - v0 ( i , jp , km )) * dzhi ( k ) ) & - eomm * ( ( w0 ( i , j , k ) - w0 ( i , jm , k )) * dyi & + ( v0 ( i , j , k ) - v0 ( i , j , km )) * dzhi ( k ) ) & ) * dyi & + & ( tekm ( i , j , k ) * ( w0 ( i , j , kp ) - w0 ( i , j , k )) * dzfi ( k ) & - tekm ( i , j , km ) * ( w0 ( i , j , k ) - w0 ( i , j , km )) * dzfi ( km ) ) * 2. & * dzhi ( k )) tsgsmz1 ( i , j , k ) = ( tsgsmz1 ( i , j , k ) * ( tstatsdumpp - tsamplep ) + dummy * w0 ( i , j , k ) * tsamplep ) * tstatsdumppi ! update average tsgsmz1 = <w*d/dxj(2*nu*S3j)> tsgsmz2 ( i , j , k ) = ( tsgsmz2 ( i , j , k ) * ( tstatsdumpp - tsamplep ) + dummy * tsamplep ) * tstatsdumppi ! update average tsgsmz2 = <d/dxj(2*nu*S3j)> end do end do end do end subroutine tkestats end module modstatistics","tags":"","url":"sourcefile/modstatistics.f90.html"},{"title":"advection.f90 – uDALES","text":"This file depends on sourcefile~~advection.f90~~EfferentGraph sourcefile~advection.f90 advection.f90 sourcefile~modfields.f90 modfields.f90 sourcefile~advection.f90->sourcefile~modfields.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~advection.f90->sourcefile~modglobal.f90 sourcefile~modsubgriddata.f90 modsubgriddata.f90 sourcefile~advection.f90->sourcefile~modsubgriddata.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> \\file advection.f90 !!  Advection management !> !!  Advection management !! \\par Revision list !! variable x-grid now possible !! Thijs Heus, Chiel van Heerwaarden, 15 June 2007 !! \\par Authors !  This file is part of DALES. ! ! DALES is free software; you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation; either version 3 of the License, or ! (at your option) any later version. ! ! DALES is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !  Copyright 1993-2009 Delft University of Technology, Wageningen University, Utrecht University, KNMI ! !> Advection redirection function subroutine advection use modglobal , only : lmoist , nsv , iadv_mom , iadv_tke , iadv_thl , iadv_qt , iadv_sv , & iadv_cd2 , iadv_kappa , iadv_upw , & ltempeq , ih , jh , kh , ihc , jhc , khc , kb , ke , ib , ie , jb , je use modfields , only : u0 , up , v0 , vp , w0 , wp , e120 , e12p , thl0 , thl0c , thlp , thlpc , qt0 , qtp , sv0 , svp , pres0 , uh , vh , wh , pres0h use modsubgriddata , only : loneeqn use decomp_2d implicit none integer :: n select case ( iadv_mom ) case ( iadv_cd2 ) call advecu_2nd ( u0 , up ) call advecv_2nd ( v0 , vp ) call advecw_2nd ( w0 , wp ) case default write ( 0 , * ) \"ERROR: Unknown advection scheme\" stop 1 end select if ( loneeqn ) then select case ( iadv_tke ) case ( iadv_cd2 ) call advecc_2nd ( ih , jh , kh , e120 , e12p ) case default write ( 0 , * ) \"ERROR: Unknown advection scheme\" stop 1 end select end if select case ( iadv_thl ) case ( iadv_cd2 ) if ( ltempeq ) call advecc_2nd ( ih , jh , kh , thl0 , thlp ) case ( iadv_kappa ) thlpc ( ib : ie , jb : je , kb : ke ) = thlp ( ib : ie , jb : je , kb : ke ) if ( ltempeq ) call advecc_kappa ( ihc , jhc , khc , thl0c , thlpc ) thlp ( ib : ie , jb : je , kb : ke ) = thlpc ( ib : ie , jb : je , kb : ke ) case default write ( 0 , * ) \"ERROR: Unknown advection scheme\" stop 1 end select if ( lmoist ) then select case ( iadv_qt ) case ( iadv_cd2 ) call advecc_2nd ( ih , jh , kh , qt0 , qtp ) case default write ( 0 , * ) \"ERROR: Unknown advection scheme\" stop 1 end select end if do n = 1 , nsv select case ( iadv_sv ( n )) case ( iadv_cd2 ) call advecc_2nd ( ihc , jhc , khc , sv0 (:, :, :, n ), svp (:, :, :, n )) case ( iadv_kappa ) call advecc_kappa ( ihc , jhc , khc , sv0 (:, :, :, n ), svp (:, :, :, n )) case ( iadv_upw ) call advecc_upw ( ihc , jhc , khc , sv0 (:, :, :, n ), svp (:, :, :, n )) case default write ( 0 , * ) \"ERROR: Unknown advection scheme\" stop 1 end select end do end subroutine advection","tags":"","url":"sourcefile/advection.f90.html"},{"title":"modmpi.f90 – uDALES","text":"Files dependent on this one sourcefile~~modmpi.f90~~AfferentGraph sourcefile~modmpi.f90 modmpi.f90 sourcefile~advec_2nd.f90 advec_2nd.f90 sourcefile~advec_2nd.f90->sourcefile~modmpi.f90 sourcefile~initfac.f90 initfac.f90 sourcefile~advec_2nd.f90->sourcefile~initfac.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~advec_2nd.f90->sourcefile~modglobal.f90 sourcefile~modibm.f90 modibm.f90 sourcefile~advec_2nd.f90->sourcefile~modibm.f90 sourcefile~modfields.f90 modfields.f90 sourcefile~advec_2nd.f90->sourcefile~modfields.f90 sourcefile~heatpump.f90 heatpump.f90 sourcefile~heatpump.f90->sourcefile~modmpi.f90 sourcefile~heatpump.f90->sourcefile~modglobal.f90 sourcefile~heatpump.f90->sourcefile~modfields.f90 sourcefile~initfac.f90->sourcefile~modmpi.f90 sourcefile~initfac.f90->sourcefile~modglobal.f90 sourcefile~modboundary.f90 modboundary.f90 sourcefile~modboundary.f90->sourcefile~modmpi.f90 sourcefile~moddriver.f90 moddriver.f90 sourcefile~modboundary.f90->sourcefile~moddriver.f90 sourcefile~modboundary.f90->sourcefile~modglobal.f90 sourcefile~modboundary.f90->sourcefile~modfields.f90 sourcefile~modchecksim.f90 modchecksim.f90 sourcefile~modchecksim.f90->sourcefile~modmpi.f90 sourcefile~modchecksim.f90->sourcefile~modglobal.f90 sourcefile~modchecksim.f90->sourcefile~modfields.f90 sourcefile~moddriver.f90->sourcefile~modmpi.f90 sourcefile~moddriver.f90->sourcefile~modglobal.f90 sourcefile~modsave.f90 modsave.f90 sourcefile~moddriver.f90->sourcefile~modsave.f90 sourcefile~moddriver.f90->sourcefile~modfields.f90 sourcefile~modeb.f90 modEB.f90 sourcefile~modeb.f90->sourcefile~modmpi.f90 sourcefile~modeb.f90->sourcefile~initfac.f90 sourcefile~modeb.f90->sourcefile~modglobal.f90 sourcefile~modstat_nc.f90 modstat_nc.f90 sourcefile~modeb.f90->sourcefile~modstat_nc.f90 sourcefile~modfielddump.f90 modfielddump.f90 sourcefile~modfielddump.f90->sourcefile~modmpi.f90 sourcefile~modfielddump.f90->sourcefile~modglobal.f90 sourcefile~modfielddump.f90->sourcefile~modibm.f90 sourcefile~modfielddump.f90->sourcefile~modstat_nc.f90 sourcefile~modfielddump.f90->sourcefile~modfields.f90 sourcefile~modforces.f90 modforces.f90 sourcefile~modforces.f90->sourcefile~modmpi.f90 sourcefile~modforces.f90->sourcefile~modglobal.f90 sourcefile~modforces.f90->sourcefile~modfields.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 sourcefile~modibm.f90->sourcefile~modmpi.f90 sourcefile~modibm.f90->sourcefile~initfac.f90 sourcefile~modibm.f90->sourcefile~modboundary.f90 sourcefile~modibm.f90->sourcefile~modglobal.f90 sourcefile~modibm.f90->sourcefile~modstat_nc.f90 sourcefile~modibm.f90->sourcefile~modfields.f90 sourcefile~modinlet.f90 modinlet.f90 sourcefile~modinlet.f90->sourcefile~modmpi.f90 sourcefile~modinlet.f90->sourcefile~modglobal.f90 sourcefile~modinlet.f90->sourcefile~modsave.f90 sourcefile~modinlet.f90->sourcefile~modfields.f90 sourcefile~modpurifiers.f90 modpurifiers.f90 sourcefile~modpurifiers.f90->sourcefile~modmpi.f90 sourcefile~modpurifiers.f90->sourcefile~modglobal.f90 sourcefile~modpurifiers.f90->sourcefile~modfields.f90 sourcefile~modsave.f90->sourcefile~modmpi.f90 sourcefile~modsave.f90->sourcefile~initfac.f90 sourcefile~modsave.f90->sourcefile~modglobal.f90 sourcefile~modsave.f90->sourcefile~modfields.f90 sourcefile~modstartup.f90 modstartup.f90 sourcefile~modstartup.f90->sourcefile~modmpi.f90 sourcefile~modstartup.f90->sourcefile~modboundary.f90 sourcefile~modstartup.f90->sourcefile~moddriver.f90 sourcefile~modstartup.f90->sourcefile~modforces.f90 sourcefile~modstartup.f90->sourcefile~modglobal.f90 sourcefile~modstartup.f90->sourcefile~modibm.f90 sourcefile~modstartup.f90->sourcefile~modinlet.f90 sourcefile~modsubgrid.f90 modsubgrid.f90 sourcefile~modstartup.f90->sourcefile~modsubgrid.f90 sourcefile~modthermodynamics.f90 modthermodynamics.f90 sourcefile~modstartup.f90->sourcefile~modthermodynamics.f90 sourcefile~modtimedep.f90 modtimedep.f90 sourcefile~modstartup.f90->sourcefile~modtimedep.f90 sourcefile~modstartup.f90->sourcefile~modfields.f90 sourcefile~modstat_nc.f90->sourcefile~modmpi.f90 sourcefile~modstat_nc.f90->sourcefile~modglobal.f90 sourcefile~modstatistics.f90 modstatistics.f90 sourcefile~modstatistics.f90->sourcefile~modmpi.f90 sourcefile~modstatistics.f90->sourcefile~modglobal.f90 sourcefile~modstatistics.f90->sourcefile~modstat_nc.f90 sourcefile~modstatistics.f90->sourcefile~modfields.f90 sourcefile~modstatsdump.f90 modstatsdump.f90 sourcefile~modstatsdump.f90->sourcefile~modmpi.f90 sourcefile~modstatsdump.f90->sourcefile~modglobal.f90 sourcefile~modstatsdump.f90->sourcefile~modstat_nc.f90 sourcefile~modstatsdump.f90->sourcefile~modstatistics.f90 sourcefile~modstatsdump.f90->sourcefile~modsubgrid.f90 sourcefile~modstatsdump.f90->sourcefile~modfields.f90 sourcefile~modsubgrid.f90->sourcefile~modmpi.f90 sourcefile~modsubgrid.f90->sourcefile~modboundary.f90 sourcefile~modsubgrid.f90->sourcefile~modglobal.f90 sourcefile~modsubgrid.f90->sourcefile~modfields.f90 sourcefile~modthermodynamics.f90->sourcefile~modmpi.f90 sourcefile~modthermodynamics.f90->sourcefile~modglobal.f90 sourcefile~modthermodynamics.f90->sourcefile~modfields.f90 sourcefile~modtimedep.f90->sourcefile~modmpi.f90 sourcefile~modtimedep.f90->sourcefile~initfac.f90 sourcefile~modtimedep.f90->sourcefile~modglobal.f90 sourcefile~modtimedep.f90->sourcefile~modfields.f90 sourcefile~modtrees.f90 modtrees.f90 sourcefile~modtrees.f90->sourcefile~modmpi.f90 sourcefile~modtrees.f90->sourcefile~modglobal.f90 sourcefile~modtrees.f90->sourcefile~modfields.f90 sourcefile~program.f90 program.f90 sourcefile~program.f90->sourcefile~modmpi.f90 sourcefile~program.f90->sourcefile~heatpump.f90 sourcefile~program.f90->sourcefile~initfac.f90 sourcefile~program.f90->sourcefile~modboundary.f90 sourcefile~program.f90->sourcefile~modchecksim.f90 sourcefile~program.f90->sourcefile~moddriver.f90 sourcefile~program.f90->sourcefile~modeb.f90 sourcefile~program.f90->sourcefile~modfielddump.f90 sourcefile~program.f90->sourcefile~modforces.f90 sourcefile~program.f90->sourcefile~modglobal.f90 sourcefile~program.f90->sourcefile~modibm.f90 sourcefile~program.f90->sourcefile~modpurifiers.f90 sourcefile~program.f90->sourcefile~modsave.f90 sourcefile~program.f90->sourcefile~modstartup.f90 sourcefile~program.f90->sourcefile~modstat_nc.f90 sourcefile~program.f90->sourcefile~modstatsdump.f90 sourcefile~program.f90->sourcefile~modsubgrid.f90 sourcefile~program.f90->sourcefile~modthermodynamics.f90 sourcefile~program.f90->sourcefile~modtimedep.f90 sourcefile~program.f90->sourcefile~modtrees.f90 sourcefile~program.f90->sourcefile~modfields.f90 sourcefile~scalsource.f90 scalsource.f90 sourcefile~scalsource.f90->sourcefile~modmpi.f90 sourcefile~scalsource.f90->sourcefile~modglobal.f90 sourcefile~scalsource.f90->sourcefile~modfields.f90 sourcefile~tstep.f90 tstep.f90 sourcefile~tstep.f90->sourcefile~modmpi.f90 sourcefile~tstep.f90->sourcefile~modglobal.f90 sourcefile~modchem.f90 modchem.f90 sourcefile~tstep.f90->sourcefile~modchem.f90 sourcefile~tstep.f90->sourcefile~modfields.f90 sourcefile~wf_gr.f90 wf_gr.f90 sourcefile~wf_gr.f90->sourcefile~modmpi.f90 sourcefile~wf_gr.f90->sourcefile~initfac.f90 sourcefile~wf_gr.f90->sourcefile~modglobal.f90 sourcefile~wf_uno.f90 wf_uno.f90 sourcefile~wf_uno.f90->sourcefile~modmpi.f90 sourcefile~wf_uno.f90->sourcefile~initfac.f90 sourcefile~wf_uno.f90->sourcefile~modglobal.f90 sourcefile~wfmneutral.f90 wfmneutral.f90 sourcefile~wfmneutral.f90->sourcefile~modmpi.f90 sourcefile~wfmneutral.f90->sourcefile~initfac.f90 sourcefile~wfmneutral.f90->sourcefile~modglobal.f90 sourcefile~advec_kappa.f90 advec_kappa.f90 sourcefile~advec_kappa.f90->sourcefile~modglobal.f90 sourcefile~advec_kappa.f90->sourcefile~modfields.f90 sourcefile~advec_upw.f90 advec_upw.f90 sourcefile~advec_upw.f90->sourcefile~modglobal.f90 sourcefile~advec_upw.f90->sourcefile~modfields.f90 sourcefile~advection.f90 advection.f90 sourcefile~advection.f90->sourcefile~modglobal.f90 sourcefile~advection.f90->sourcefile~modfields.f90 sourcefile~modchem.f90->sourcefile~modglobal.f90 sourcefile~modchem.f90->sourcefile~modfields.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> \\file modmpi.f90 !!  Layer to deal with the parallelization. !> !!  Layer to deal with the parallelization. !> !!  \\author Matthieu Pourquie, TU Delft !!  \\par Revision list !!  \\todo Documentation !!  \\todo 2D/3D parallelization !!  \\todo Include interfaces for MPI_ALLREDUCE, MPI_ALLTOALL, MPI_BCAST, !! MPI_SENDRECV to get rid of pure mpi calls in the code !  This file is part of DALES. ! ! DALES is free software; you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation; either version 3 of the License, or ! (at your option) any later version. ! ! DALES is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !  Copyright 1993-2009 Delft University of Technology, Wageningen University, Utrecht University, KNMI ! module modmpi use mpi implicit none save integer comm3d !integer nbrtop integer nbrnorth !integer nbrbottom integer nbrsouth integer nbreast integer nbrwest integer myid integer myidx integer myidy integer nprocs ! Remove integer nprocx integer nprocy integer mpierr integer my_real real CPU_program !end time real CPU_program0 !start time character ( 3 ) :: cmyid character ( 3 ) :: cmyidx character ( 3 ) :: cmyidy contains subroutine initmpi use decomp_2d , only : nrank , nproc implicit none ! integer dims(1) ! logical periods(1) ! integer periods2(1) call MPI_INIT ( mpierr ) MY_REAL = MPI_DOUBLE_PRECISION !MPI_REAL8 should be the same.. comm3d = MPI_COMM_WORLD call MPI_COMM_RANK ( MPI_COMM_WORLD , nrank , mpierr ) call MPI_COMM_SIZE ( MPI_COMM_WORLD , nproc , mpierr ) myid = nrank nprocs = nproc write ( cmyid , '(i3.3)' ) myid ! ! Specify the # procs in each direction. ! ! specifying a 0 means that MPI will try to find a useful # procs in ! ! the corresponding  direction, ! ! ! specifying 1 means only 1 processor in this direction, meaning that ! ! we have in fact a grid of (at most) 2 dimensions left. This is used ! ! when we want the array index range in 1 particular direction to be ! ! present on all processors in the grid ! !     dims(1) = 0 ! ! ! ! directions 1 and 2 are chosen periodic ! ! !     periods(1) = .true. ! ! Soares 20080115 !     periods2(1) = 1 ! ! ! find suitable # procs in each direction ! !     call MPI_DIMS_CREATE( nprocs, 1, dims, mpierr ) ! ! ! create the Cartesian communicator, denoted by the integer comm3d ! !     ! BUG - Thijs, Harm !     !call MPI_CART_CREATE(MPI_COMM_WORLD, 1, dims, periods,.false., & !     !                    comm3d, ierr ) ! !     call MPI_CART_CREATE(MPI_COMM_WORLD, 1, dims, periods,.true., & !                         comm3d, mpierr ) ! ! ! Soares 20080115 ! !     call MPI_CART_CREATE(MPI_COMM_WORLD, 1, dims, periods2,1, & ! !                         comm3d, mpierr ) ! ! ! Get my processor number in this communicator ! !     call MPI_COMM_RANK( comm3d, myid, mpierr ) ! ! ! ! when applying boundary conditions, we need to know which processors ! ! are neighbours in all 3 directions ! ! ! ! these are determined with the aid of the MPI routine MPI_CART_SHIFT, ! !     call MPI_CART_SHIFT( comm3d, 0,  1, nbrbottom, nbrtop,   mpierr ) ! ! ! determine some useful MPI datatypes for sending/receiving data ! !      write(cmyid,'(i3.3)') myid ! ! if(myid==0)then !   CPU_program0 = MPI_Wtime() ! end if ! !     write(*,*)'nprocs = ', nprocs end subroutine initmpi subroutine starttimer if ( myid == 0 ) then CPU_program0 = MPI_Wtime () end if end subroutine starttimer !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine exitmpi use decomp_2d implicit none if ( myid == 0 ) then CPU_program = MPI_Wtime () - CPU_program0 write ( 6 , * ) 'TOTAL CPU time = ' , CPU_program end if !call MPI_Comm_free( comm3d, mpierr ) !call MPI_FINALIZE(mpierr) call decomp_2d_finalize call MPI_FINALIZE ( mpierr ) end subroutine exitmpi subroutine barrou () implicit none call MPI_BARRIER ( comm3d , mpierr ) return end subroutine barrou !   subroutine excj( a, sx, ex, sy, ey, sz,ez) !     implicit none ! !   integer sx, ex, sy, ey, sz, ez !   real a(sx:ex, sy:ey, sz:ez) !   integer iiget, status(MPI_STATUS_SIZE) !   integer ii, i, k !   real,allocatable, dimension(:) :: buffj1,buffj2,buffj3,buffj4 !   iiget = (ex - sx + 1)*(ez - sz + 1) ! !   allocate( buffj1(iiget),& !             buffj2(iiget),& !             buffj3(iiget),& !             buffj4(iiget)) ! ! ! !   if(nbrnorth/=MPI_PROC_NULL)then !     do k=sz,ez !     do i=sx,ex !       ii = i - sx + 1 + (k - sz )*(ex - sx + 1) !       buffj1(ii) = a(i,ey-1,k) !     enddo !     enddo !   endif !   call MPI_SENDRECV(  buffj1,  ii    , MY_REAL, nbrnorth, 4, & !                       buffj2,  iiget , MY_REAL, nbrsouth,  4,      & !                       comm3d, status, mpierr ) !   if(nbrsouth/=MPI_PROC_NULL)then !     do k=sz,ez !     do i=sx,ex !       ii = i - sx + 1 + (k - sz )*(ex - sx + 1) !       a(i,sy,k) = buffj2(ii) !     enddo !     enddo !   endif ! ! !   call barrou() ! !   if(nbrsouth/=MPI_PROC_NULL)then !     do k=sz,ez !     do i=sx,ex !       ii = i - sx + 1 + (k - sz )*(ex - sx + 1) !       buffj3(ii) = a(i,sy+1,k) !     enddo !     enddo !   endif !   call MPI_SENDRECV(  buffj3,  ii    , MY_REAL, nbrnorth,  5, & !                           buffj4,  iiget , MY_REAL, nbrsouth, 5, & !                           comm3d, status, mpierr ) !   if(nbrnorth/=MPI_PROC_NULL)then !     do k=sz,ez !     do i=sx,ex !       ii = i - sx + 1 + (k - sz )*(ex - sx + 1) !       a(i,ey,k) = buffj4(ii) !     enddo !     enddo !   endif ! ! !   call barrou() !   deallocate (buffj1,buffj2,buffj3,buffj4) ! !   return !   end subroutine excj !   ! tg3315 - does some transfer of ghost cell information in the y-direction. !   ! nbrbottom is cpu below and nbrtop is cpu above !   ! MPI_PROC_NULL = -2??? !   subroutine excjs( a, sx, ex, sy, ey, sz,ez,ih,jh) !     implicit none !   integer sx, ex, sy, ey, sz, ez, ih, jh !   real a(sx-ih:ex+ih, sy-jh:ey+jh, sz:ez) !   integer status(MPI_STATUS_SIZE), iiget !   integer ii, i, j, k !   real,allocatable, dimension(:) :: buffj1,buffj2,buffj3,buffj4 !   iiget = jh*(ex - sx + 1 + 2*ih)*(ez - sz + 1) ! !   allocate( buffj1(iiget),& !             buffj2(iiget),& !             buffj3(iiget),& !             buffj4(iiget)) ! !   if(nbrtop/=MPI_PROC_NULL)then !     ii = 0 !     do j=1,jh !     do k=sz,ez !     do i=sx-ih,ex+ih !       ii = ii + 1 !       buffj1(ii) = a(i,ey-j+1,k) ! tg3315 buffj1 is je-jhc ghost cells on myid !     enddo !     enddo !     enddo !   endif ! !   call MPI_SENDRECV(  buffj1,  ii    , MY_REAL, nbrtop, 4, & !                            buffj2,  iiget , MY_REAL, nbrbottom,  4, & !                            comm3d, status, mpierr ) ! !   ! tg3315 sends this to nbrtop and pulls buffj2 from nbrbottom! send and receive process that is good for executing chain shifts. ! !   if(nbrbottom/=MPI_PROC_NULL)then !     ii = 0 !     do j=1,jh !     do k=sz,ez !     do i=sx-ih,ex+ih !       ii = ii + 1 !       a(i,sy-j,k) = buffj2(ii) ! set the previous ghost cells to buffj2 (last cells of nbrbottom I think) !     enddo !     enddo !     enddo !   endif ! ! !   call barrou() ! !   ! repeats this process for other way round ! !   if(nbrbottom/=MPI_PROC_NULL)then !     ii = 0 !     do j=1,jh !     do k=sz,ez !     do i=sx-ih,ex+ih !       ii = ii + 1 !       buffj3(ii) = a(i,sy+j-1,k) !     enddo !     enddo !     enddo !   endif !   call MPI_SENDRECV(  buffj3,  ii    , MY_REAL, nbrbottom,  5, & !                           buffj4,  iiget , MY_REAL, nbrtop, 5, & !                           comm3d, status, mpierr ) !   if(nbrtop/=MPI_PROC_NULL)then !     ii = 0 !     do j=1,jh !     do k=sz,ez !     do i=sx-ih,ex+ih !       ii = ii + 1 !       a(i,ey+j,k) = buffj4(ii) !     enddo !     enddo !     enddo !   endif ! ! !   call barrou() !   deallocate (buffj1,buffj2,buffj3,buffj4) ! !   return !   end subroutine excjs ! subroutine exci(a,sx,ex,sy,ey,sz,ez) !   implicit none !   integer sx, ex, sy, ey, sz, ez !   real a(sx:ex, sy:ey, sz:ez) !   integer status(MPI_STATUS_SIZE) !   integer ii, i, j, k !   integer reqe, reqw !   integer ewsize !   real,allocatable, dimension(:) :: sende,recve !   real,allocatable, dimension(:) :: sendw,recvw ! !   Calculate buffer size !   ewsize = (ey - sy + 1)*(ez - sz + 1) ! !   Allocate send / receive buffers !   allocate(sende(ewsize),sendw(ewsize)) !   allocate(recve(ewsize),recvw(ewsize)) !   if(nprocx .gt. 1)then !     !   Send east/west !     ii = 0 !     do k=sz,ez !     do j=sy,ey !       ii = ii + 1 !       sende(ii) = a(ex-i+1,j,k) !       sendw(ii) = a(sx+i-1,j,k) !     enddo !     enddo !     call MPI_ISEND(sende, ewsize, MY_REAL, nbreast, 6, comm3d, reqe, mpierr) !     call MPI_ISEND(sendw, ewsize, MY_REAL, nbrwest, 7, comm3d, reqw, mpierr) !     !   Receive west/east !     call MPI_RECV(recvw, ewsize, MY_REAL, nbrwest, 6, comm3d, status, mpierr) !     call MPI_RECV(recve, ewsize, MY_REAL, nbreast, 7, comm3d, status, mpierr) !     ii = 0 !     do k=sz,ez !     do j=sy,ey !       ii = ii + 1 !       a(sx-i,j,k) = recvw(ii) !       a(ex+i,j,k) = recve(ii) !     enddo !     enddo !   else !     ! Single processor, make sure the field is periodic !     do k=sz,ez !     do j=sy,ey !       a(sx-i,j,k) = a(ex-i+1,j,k) !       a(ex+i,j,k) = a(sx+i-1,j,k) !     enddo !     enddo !   endif !   if(nprocx.gt.1)then !     call MPI_WAIT(reqe, status, mpierr) !     call MPI_WAIT(reqw, status, mpierr) !   endif !   deallocate (sende, sendw) !   deallocate (recve, recvw) !   return ! end subroutine exci subroutine excis ( a , sx , ex , sy , ey , sz , ez , ih , jh ) implicit none integer sx , ex , sy , ey , sz , ez , ih , jh real a ( sx - ih : ex + ih , sy - jh : ey + jh , sz : ez ) integer status ( MPI_STATUS_SIZE ) integer ii , i , j , k integer reqe , reqw integer ewsize real , allocatable , dimension (:) :: sende , recve real , allocatable , dimension (:) :: sendw , recvw !   Calculate buffer size ewsize = ih * ( ey - sy + 1 + 2 * jh ) * ( ez - sz + 1 ) !   Allocate send / receive buffers allocate ( sende ( ewsize ), sendw ( ewsize )) allocate ( recve ( ewsize ), recvw ( ewsize )) if ( nprocx . gt . 1 ) then !   Send east/west ii = 0 do i = 1 , ih do k = sz , ez do j = sy - jh , ey + jh ii = ii + 1 sende ( ii ) = a ( ex - i + 1 , j , k ) sendw ( ii ) = a ( sx + i - 1 , j , k ) enddo enddo enddo call MPI_ISEND ( sende , ewsize , MY_REAL , nbreast , 6 , comm3d , reqe , mpierr ) call MPI_ISEND ( sendw , ewsize , MY_REAL , nbrwest , 7 , comm3d , reqw , mpierr ) !   Receive west/east call MPI_RECV ( recvw , ewsize , MY_REAL , nbrwest , 6 , comm3d , status , mpierr ) call MPI_RECV ( recve , ewsize , MY_REAL , nbreast , 7 , comm3d , status , mpierr ) ii = 0 do i = 1 , ih do k = sz , ez do j = sy - jh , ey + jh ii = ii + 1 a ( sx - i , j , k ) = recvw ( ii ) a ( ex + i , j , k ) = recve ( ii ) enddo enddo enddo else ! Single processor, make sure the field is periodic do i = 1 , ih do k = sz , ez do j = sy - jh , ey + jh a ( sx - i , j , k ) = a ( ex - i + 1 , j , k ) a ( ex + i , j , k ) = a ( sx + i - 1 , j , k ) enddo enddo enddo endif if ( nprocx . gt . 1 ) then call MPI_WAIT ( reqe , status , mpierr ) call MPI_WAIT ( reqw , status , mpierr ) endif deallocate ( sende , sendw ) deallocate ( recve , recvw ) return end subroutine excis ! subroutine excj(a,sx,ex,sy,ey,sz,ez) !   implicit none !   integer sx, ex, sy, ey, sz, ez !   real a(sx:ex, sy:ey, sz:ez) !   integer status(MPI_STATUS_SIZE) !   integer ii, i, j, k !   integer reqn, reqs !   integer nssize !   real,allocatable, dimension(:) :: sendn,recvn !   real,allocatable, dimension(:) :: sends,recvs ! !   Calculate buffer size !   nssize = (ex - sx + 1)*(ez - sz + 1) ! !   Allocate send / receive buffers !   allocate(sendn(nssize),sends(nssize)) !   allocate(recvn(nssize),recvs(nssize)) !   if(nprocy .gt. 1)then !     !   Send north/south !     ii = 0 !     do k=sz,ez !     do i=sx,ex !       ii = ii + 1 !       sendn(ii) = a(i,ey-j+1,k) !       sends(ii) = a(i,sy+j-1,k) !     enddo !     enddo !     call MPI_ISEND(sendn, nssize, MY_REAL, nbrnorth, 4, comm3d, reqn, mpierr) !     call MPI_ISEND(sends, nssize, MY_REAL, nbrsouth, 5, comm3d, reqs, mpierr) !     !   Receive south/north !     call MPI_RECV(recvs, nssize, MY_REAL, nbrsouth, 4, comm3d, status, mpierr) !     call MPI_RECV(recvn, nssize, MY_REAL, nbrnorth, 5, comm3d, status, mpierr) !     ii = 0 !     do k=sz,ez !     do i=sx,ex !       ii = ii + 1 !       a(i,sy-j,k) = recvs(ii) !       a(i,ey+j,k) = recvn(ii) !     enddo !     enddo !   else !     ! Single processor, make sure the field is periodic !     do k=sz,ez !     do i=sx,ex !       a(i,sy-j,k) = a(i,ey-j+1,k) !       a(i,ey+j,k) = a(i,sy+j-1,k) !     enddo !     enddo !   endif !   if(nprocy.gt.1)then !     call MPI_WAIT(reqn, status, mpierr) !     call MPI_WAIT(reqs, status, mpierr) !   endif !   deallocate (sendn, sends) !   deallocate (recvn, recvs) !   return !   end subroutine excj subroutine excjs ( a , sx , ex , sy , ey , sz , ez , ih , jh ) implicit none integer sx , ex , sy , ey , sz , ez , ih , jh real a ( sx - ih : ex + ih , sy - jh : ey + jh , sz : ez ) integer status ( MPI_STATUS_SIZE ) integer ii , i , j , k integer reqn , reqs integer nssize real , allocatable , dimension (:) :: sendn , recvn real , allocatable , dimension (:) :: sends , recvs !   Calculate buffer size nssize = jh * ( ex - sx + 1 + 2 * ih ) * ( ez - sz + 1 ) !   Allocate send / receive buffers allocate ( sendn ( nssize ), sends ( nssize )) allocate ( recvn ( nssize ), recvs ( nssize )) if ( nprocy . gt . 1 ) then !   Send north/south ii = 0 do j = 1 , jh do k = sz , ez do i = sx - ih , ex + ih ii = ii + 1 sendn ( ii ) = a ( i , ey - j + 1 , k ) sends ( ii ) = a ( i , sy + j - 1 , k ) enddo enddo enddo call MPI_ISEND ( sendn , nssize , MY_REAL , nbrnorth , 4 , comm3d , reqn , mpierr ) call MPI_ISEND ( sends , nssize , MY_REAL , nbrsouth , 5 , comm3d , reqs , mpierr ) !   Receive south/north call MPI_RECV ( recvs , nssize , MY_REAL , nbrsouth , 4 , comm3d , status , mpierr ) call MPI_RECV ( recvn , nssize , MY_REAL , nbrnorth , 5 , comm3d , status , mpierr ) ii = 0 do j = 1 , jh do k = sz , ez do i = sx - ih , ex + ih ii = ii + 1 a ( i , sy - j , k ) = recvs ( ii ) a ( i , ey + j , k ) = recvn ( ii ) enddo enddo enddo else ! Single processor, make sure the field is periodic do j = 1 , jh do k = sz , ez do i = sx - ih , ex + ih a ( i , sy - j , k ) = a ( i , ey - j + 1 , k ) a ( i , ey + j , k ) = a ( i , sy + j - 1 , k ) enddo enddo enddo endif if ( nprocy . gt . 1 ) then call MPI_WAIT ( reqn , status , mpierr ) call MPI_WAIT ( reqs , status , mpierr ) endif deallocate ( sendn , sends ) deallocate ( recvn , recvs ) return end subroutine excjs subroutine slabsum ( aver , ks , kf , var , ib , ie , jb , je , kb , ke , ibs , ies , jbs , jes , kbs , kes ) implicit none integer :: ks , kf integer :: ib , ie , jb , je , kb , ke , ibs , ies , jbs , jes , kbs , kes real :: aver ( ks : kf ) real :: var ( ib : ie , jb : je , kb : ke ) real :: averl ( ks : kf ) real :: avers ( ks : kf ) integer :: k averl = 0. avers = 0. do k = kbs , kes averl ( k ) = sum ( var ( ibs : ies , jbs : jes , k )) enddo call MPI_ALLREDUCE ( averl , avers , kf - ks + 1 , MY_REAL , & MPI_SUM , comm3d , mpierr ) aver = aver + avers return end subroutine slabsum subroutine avexy_ibm ( aver , var , ib , ie , jb , je , kb , ke , ih , jh , kh , II , IIs , lnan ) implicit none integer :: ib , ie , jb , je , kb , ke , ih , jh , kh real :: aver ( kb : ke + kh ) real :: var ( ib : ie , jb : je , kb : ke + kh ) integer :: II ( ib : ie , jb : je , kb : ke + kh ) integer :: IIs ( kb : ke + kh ) integer :: IId ( kb : ke + kh ) real :: averl ( kb : ke + kh ) real :: avers ( kb : ke + kh ) integer :: k logical :: lnan averl = 0. avers = 0. do k = kb , ke + kh averl ( k ) = sum ( var ( ib : ie , jb : je , k ) * II ( ib : ie , jb : je , k )) enddo IId = IIs ! tg3315 22.03.19 - if not calculating stats and all blocks on lowest layer... ! should not be necessary but value at kb is used in modthermo so reasonable value must ! be assigned. Potentially should leave as before and only account for in modthermo... if ((. not . lnan ) . and . ( IId ( kb ) == 0 )) then averl ( kb ) = sum ( var ( ib : ie , jb : je , kb )) IId ( kb ) = IId ( ke ) end if call MPI_ALLREDUCE ( averl , avers , ke + kh - kb + 1 , MY_REAL , & MPI_SUM , comm3d , mpierr ) where ( IId == 0 ) aver = - 99 9. elsewhere aver = avers / IId endwhere return end subroutine avexy_ibm subroutine slabsumi ( aver , iis , iif , var , ib , ie , jb , je , kb , ke , ibs , ies , jbs , jes , kbs , kes ) implicit none integer :: iis , iif integer :: ib , ie , jb , je , kb , ke , ibs , ies , jbs , jes , kbs , kes real :: aver ( iis : iif ) real :: var ( ib : ie , jb : je , kb : ke ) real :: averl ( iis : iif ) real :: avers ( iis : iif ) integer :: i averl = 0. avers = 0. do i = ibs , ies averl ( i ) = sum ( var ( i , jbs : jes , kbs : kes )) enddo call MPI_ALLREDUCE ( averl , avers , iif - iis + 1 , MY_REAL , & MPI_SUM , comm3d , mpierr ) aver = aver + avers return end subroutine slabsumi !Could make this so it has cases like if the input is 1,2 or 3D... subroutine avey_ibm ( aver , var , ib , ie , jb , je , kb , ke , II , IIt ) implicit none integer :: ib , ie , jb , je , kb , ke real :: aver ( ib : ie , kb : ke ) real :: avero ( ib : ie , kb : ke ) real :: var ( ib : ie , jb : je , kb : ke ) integer :: II ( ib : ie , jb : je , kb : ke ) integer :: IIt ( ib : ie , kb : ke ) logical :: lytdump , lnan avero = 0. aver = 0. avero = sum ( var ( ib : ie , jb : je , kb : ke ) * II ( ib : ie , jb : je , kb : ke ), DIM = 2 ) call MPI_ALLREDUCE ( avero ( ib : ie , kb : ke ), aver ( ib : ie , kb : ke ), ( ke - kb + 1 ) * ( ie - ib + 1 ), MY_REAL , MPI_SUM , comm3d , mpierr ) where ( IIt == 0 ) aver = - 99 9. elsewhere aver = aver / IIt endwhere end subroutine avey_ibm subroutine sumy_ibm ( sumy , var , ib , ie , jb , je , kb , ke , II ) ! This routine sums up a variable over the y direction, ! only including the fluid cells. implicit none integer :: ib , ie , jb , je , kb , ke real :: sumy ( ib : ie , kb : ke ) real :: sumproc ( ib : ie , kb : ke ) real :: var ( ib : ie , jb : je , kb : ke ) integer :: II ( ib : ie , jb : je , kb : ke ) sumproc = 0. sumy = 0. sumproc = sum ( var ( ib : ie , jb : je , kb : ke ) * II ( ib : ie , jb : je , kb : ke ), DIM = 2 ) call MPI_ALLREDUCE ( sumproc ( ib : ie , kb : ke ), sumy ( ib : ie , kb : ke ), ( ke - kb + 1 ) * ( ie - ib + 1 ), MY_REAL , MPI_SUM , comm3d , mpierr ) end subroutine sumy_ibm subroutine sumx_ibm ( sumx , var , ib , ie , jb , je , kb , ke , II ) ! This routine sums up a variable over the x direction, ! only including the fluid cells. implicit none integer :: ib , ie , jb , je , kb , ke real :: sumx ( jb : je , kb : ke ) real :: sumproc ( jb : je , kb : ke ) real :: var ( ib : ie , jb : je , kb : ke ) integer :: II ( ib : ie , jb : je , kb : ke ) sumproc = 0. sumx = 0. sumproc = sum ( var ( ib : ie , jb : je , kb : ke ) * II ( ib : ie , jb : je , kb : ke ), DIM = 1 ) call MPI_ALLREDUCE ( sumproc ( jb : je , kb : ke ), sumx ( jb : je , kb : ke ), ( ke - kb + 1 ) * ( je - jb + 1 ), MY_REAL , MPI_SUM , comm3d , mpierr ) end subroutine sumx_ibm end module","tags":"","url":"sourcefile/modmpi.f90.html"},{"title":"modthermodynamics.f90 – uDALES","text":"This file depends on sourcefile~~modthermodynamics.f90~~EfferentGraph sourcefile~modthermodynamics.f90 modthermodynamics.f90 sourcefile~modfields.f90 modfields.f90 sourcefile~modthermodynamics.f90->sourcefile~modfields.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~modthermodynamics.f90->sourcefile~modglobal.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~modthermodynamics.f90->sourcefile~modmpi.f90 sourcefile~modsurfdata.f90 modsurfdata.f90 sourcefile~modthermodynamics.f90->sourcefile~modsurfdata.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~modthermodynamics.f90~~AfferentGraph sourcefile~modthermodynamics.f90 modthermodynamics.f90 sourcefile~modstartup.f90 modstartup.f90 sourcefile~modstartup.f90->sourcefile~modthermodynamics.f90 sourcefile~program.f90 program.f90 sourcefile~program.f90->sourcefile~modthermodynamics.f90 sourcefile~program.f90->sourcefile~modstartup.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !>\\file modthermodynamics.f90 !! Do the thermodynamics !> !! Do the thermodynamics !> !! Timeseries of the most relevant parameters. Written to tmser1.expnr and tmsurf.expnr !! If netcdf is true, this module leads the tmser.expnr.nc output !!  \\author Pier Siebesma, K.N.M.I. !!  \\author Stephan de Roode,TU Delft !!  \\author Thijs Heus,MPI-M !!  \\par Revision list !  This file is part of DALES. ! ! DALES is free software; you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation; either version 3 of the License, or ! (at your option) any later version. ! ! DALES is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !  Copyright 1993-2009 Delft University of Technology, Wageningen University, Utrecht University, KNMI ! module modthermodynamics implicit none !   private public :: thermodynamics , calc_halflev public :: lqlnr logical :: lqlnr = . false . !< switch for ql calc. with Newton-Raphson (on/off) real , allocatable :: th0av (:) real :: chi_half = 0.5 !< set wet, dry or intermediate (default) mixing over the cloud edge real , allocatable :: thv0 (:,:,:) contains !> Allocate and initialize arrays subroutine initthermodynamics use modglobal , only : kb , ke , kh , ib , ie , jb , je implicit none allocate ( th0av ( kb : ke + kh )) allocate ( thv0 ( ib : ie , jb : je , kb : ke + kh )) th0av = 0. end subroutine initthermodynamics !> Do moist thermodynamics. !! Calculate the liquid water content, do the microphysics, calculate the mean hydrostatic pressure, calculate the fields at the half levels, and finally calculate the virtual potential temperature. subroutine thermodynamics use modglobal , only : lmoist , timee , kb , ke , kh , ib , ih , ie , jb , jh , je , rlv , cp , rslabs , rd , rv , libm , eps1 use modfields , only : thl0 , thl0h , qt0 , qt0h , ql0 , ql0h , presf , presh , exnf , exnh , thvh , thv0h , qt0av , ql0av , thvf , rhof , IIc , IIw , IIcs , IIws use modmpi , only : slabsum , avexy_ibm , myid !ILS13 added variables behind \"exnh\" implicit none integer :: k if ( timee == 0 ) call diagfld if ( lmoist ) then call thermo ( thl0 , qt0 , ql0 , presf , exnf ) end if call diagfld call calc_halflev !calculate halflevel values of qt0 and thl0 if ( lmoist ) then call thermo ( thl0h , qt0h , ql0h , presh , exnh ) end if call calthv !ILS13 introduced from DALES4.0   13.05.2015 thvh = 0. !    call slabsum(thvh,kb,ke+kh,thv0h(:,:,kb:ke+kh),ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) !redefine halflevel thv using calculated thv !    thvh = thvh/rslabs call avexy_ibm ( thvh ( kb : ke + kh ), thv0h ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIw ( ib : ie , jb : je , kb : ke + kh ), IIws ( kb : ke + kh ),. false .) !    if (libm) then !      call avexy_ibm(thvh(kb:ke),thv0h(ib:ie,jb:je,kb:ke),ib,ie,jb,je,kb,ke,IIw(ib:ie,jb:je,kb:ke),IIws(kb:ke)) !    else !      call slabsum(thvh,kb,ke+kh,thv0h(:,:,kb:ke+kh),ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) !     !redefine halflevel thv using calculated thv !     thvh = thvh/rslabs !    end if thvh ( kb ) = th0av ( kb ) * ( 1 + ( rv / rd - 1 ) * qt0av ( kb ) - rv / rd * ql0av ( kb )) ! override first level if ( abs ( thvh ( kb + 1 )) < eps1 ) then thvh ( kb + 1 ) = th0av ( kb + 1 ) * ( 1 + ( rv / rd - 1 ) * qt0av ( kb + 1 ) - rv / rd * ql0av ( kb + 1 )) ! override second level if all blocks at kb end if !    where (thvh==0) !override slabs completely covered by blocks !      thvh = th0av(kb)*(1+(rv/rd-1)*qt0av(kb)-rv/rd*ql0av(kb)) !    endwhere do k = kb , ke + kh !    thv0(ib+ih:ie,jb+jh:je,k) = (thl0(ib+ih:ie,jb+ih:je,k)+rlv*ql0(ib+ih:ie,jb+ih:je,k)/(cp*exnf(k)))*(1+(rv/rd-1)*qt0(ib+ih:ie,jb+ih:je,k)-rv/rd*ql0(ib+ih:ie,jb+ih:je,k)) thv0 ( ib : ie , jb : je , k ) = ( thl0 ( ib : ie , jb : je , k ) + rlv * ql0 ( ib : ie , jb : je , k ) / ( cp * exnf ( k ))) * ( 1 + ( rv / rd - 1 ) * qt0 ( ib : ie , jb : je , k ) - rv / rd * ql0 ( ib : ie , jb : je , k )) enddo thvf = 0.0 !write(*,*) \"thv0\",thv0 !    call slabsum(thvf,kb,ke+kh,thv0,ib,ie+ih,jb,je+jh,kb,ke+kh,ib+ih,ie,jb+ih,je,kb,ke+kh) !    call slabsum(thvf,kb,ke+kh,thv0,ib,ie,jb,je,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) call avexy_ibm ( thvf ( kb : ke + kh ), thv0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) !    write(*,*) 'IIc(2,2,:), myid' , IIc(12,2,:), myid !    where (thvf==0) !override slabs completely covered by blocks !      thvf = th0av(kb)*(1+(rv/rd-1)*qt0av(kb)-rv/rd*ql0av(kb)) !    endwhere !    thvf = thvf/rslabs !write(*,*) \"thvf\",thvf !write(*,*) \"exnf\",exnf !    do k=1,k1 !      rhof(k) = presf(k)/(rd*thvf(k)*exnf(k)) !    end do end subroutine thermodynamics !> Cleans up after the run subroutine exitthermodynamics implicit none deallocate ( th0av ) end subroutine exitthermodynamics !> Calculate thetav and dthvdz subroutine calthv use modglobal , only : lmoist , ib , ie , jb , je , kb , ke , kh , zf , zh , dzh , rlv , rd , rv , cp , eps1 use modfields , only : thl0 , thl0h , ql0 , ql0h , qt0 , qt0h , sv0 , exnf , exnh , thv0h , dthvdz use modsurfdata , only : dthldz , dqtdz implicit none integer i , j , k real qs real c1 , c2 , dq , dth , dthv , temp real a_dry , b_dry , a_moist , b_moist , c_liquid , epsilon , eps_I , chi_sat , chi real del_thv_sat , del_thv_dry dthvdz = 0.0 if ( lmoist ) then do k = kb , ke + kh do j = jb , je do i = ib , ie thv0h ( i , j , k ) = ( thl0h ( i , j , k ) + rlv * ql0h ( i , j , k ) / ( cp * exnh ( k ))) & * ( 1 + ( rv / rd - 1 ) * qt0h ( i , j , k ) - rv / rd * ql0h ( i , j , k )) end do end do end do do k = kb + 1 , ke do j = jb , je do i = ib , ie ! !         default thv jump computed unsaturated ! epsilon = rd / rv eps_I = 1 / epsilon - 1. !cstep approx 0.608 a_dry = 1. + eps_I * qt0 ( i , j , k ) b_dry = eps_I * thl0 ( i , j , k ) dth = thl0 ( i , j , k + 1 ) - thl0 ( i , j , k - 1 ) dq = qt0 ( i , j , k + 1 ) - qt0 ( i , j , k - 1 ) del_thv_dry = a_dry * dth + b_dry * dq dthv = del_thv_dry if ( ql0 ( i , j , k ) > 0 ) then !include moist thermodynamics temp = thl0 ( i , j , k ) * exnf ( k ) + ( rlv / cp ) * ql0 ( i , j , k ) qs = qt0 ( i , j , k ) - ql0 ( i , j , k ) a_moist = ( 1. - qt0 ( i , j , k ) + qs / epsilon * ( 1. + rlv / ( rv * temp ))) & / ( 1. + rlv ** 2 * qs / ( cp * rv * temp ** 2 )) b_moist = a_moist * rlv / cp - temp c_liquid = a_dry * rlv / cp - thl0 ( i , j , k ) / epsilon del_thv_sat = a_moist * dth + b_moist * dq chi = 2 * chi_half * ( zf ( k ) - zf ( k - 1 )) / ( dzh ( k ) + dzh ( k + 1 )) chi_sat = c_liquid * ql0 ( i , j , k ) / ( del_thv_dry - del_thv_sat ) if ( chi < chi_sat ) then !mixed parcel is saturated dthv = del_thv_sat end if end if dthvdz ( i , j , k ) = dthv / ( dzh ( k + 1 ) + dzh ( k )) end do end do end do do j = jb , je do i = ib , ie dthvdz ( i , j , kb ) = 0. end do end do else !      thv0h = thl0h thv0h = thl0h (:,:, kb : ke + kh ) do k = kb + 1 , ke do j = jb , je do i = ib , ie dthvdz ( i , j , k ) = ( thl0 ( i , j , k + 1 ) - thl0 ( i , j , k - 1 )) / ( dzh ( k + 1 ) + dzh ( k )) end do end do end do do j = jb , je do i = ib , ie dthvdz ( i , j , kb ) = 0. end do end do end if !CvH remove WHERE !where (abs(dthvdz)<eps1) !  dthvdz = sign(eps1,dthvdz) !end where do k = kb , ke do j = jb , je do i = ib , ie if ( abs ( dthvdz ( i , j , k )) < eps1 ) then dthvdz ( i , j , k ) = sign ( eps1 , dthvdz ( i , j , k )) end if end do end do end do end subroutine calthv !> Calculate diagnostic slab averaged fields. !!     Calculates slab averaged fields assuming !!     hydrostatic equilibrium for: u,v,theta_l,theta_v, !!     qt,ql,exner,pressure and the density !! \\author      Pier Siebesma   K.N.M.I.     06/01/1995 subroutine diagfld use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , khc , nsv , zh , zf , rslabs , grav , rlv , cp , rd , rv , pref0 use modfields , only : u0 , v0 , thl0 , qt0 , ql0 , sv0 , u0av , v0av , thl0av , qt0av , ql0av , sv0av , & presf , presh , exnf , exnh , rhof , thvf , IIc , IIcs , IIu , IIus , IIv , IIvs use modsurfdata , only : thls , ps use modmpi , only : slabsum , myid , avexy_ibm implicit none real tv integer k , n !!********************************************************* !!  1.0   calculate average profiles of u,v,thl,qt and ql * !!        assuming hydrostatic equilibrium                * !!********************************************************* ! initialise local MPI arrays u0av = 0.0 v0av = 0.0 thl0av = 0.0 th0av = 0.0 qt0av = 0.0 ql0av = 0.0 sv0av = 0. !CvH changed momentum array dimensions to same value as scalars! !  call slabsum(u0av  ,kb,ke+kh,u0  ,ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) !    call slabsum(u0av  ,kb,ke+kh,u0(:,:,kb:ke+kh)  ,ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) call avexy_ibm ( u0av ( kb : ke + kh ), u0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIu ( ib : ie , jb : je , kb : ke + kh ), IIus ( kb : ke + kh ),. false .) !  call slabsum(v0av  ,kb,ke+kh,v0  ,ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) !    call slabsum(v0av  ,kb,ke+kh,v0(:,:,kb:ke+kh)  ,ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) call avexy_ibm ( v0av ( kb : ke + kh ), v0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIv ( ib : ie , jb : je , kb : ke + kh ), IIvs ( kb : ke + kh ),. false .) !  call slabsum(thl0av,kb,ke+kh,thl0,ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) !    call slabsum(thl0av,kb,ke+kh,thl0(:,:,kb:ke+kh),ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) call avexy_ibm ( thl0av ( kb : ke + kh ), thl0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) !write(*,*) 'thl0av(kb), thl0av(kb+1)', thl0av(kb), thl0av(kb+1) !if (IIbl == 0) then ! as lEB applies blocks to kb and masking matrices average this to zero !  thl0av(kb) = thl0av(kb+1) !end if !  call slabsum(qt0av ,kb,ke+kh,qt0 ,ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) !    call slabsum(qt0av ,kb,ke+kh,qt0(:,:,kb:ke+kh) ,ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) call avexy_ibm ( qt0av ( kb : ke + kh ), qt0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) !    call slabsum(ql0av ,kb,ke+kh,ql0 ,ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) call avexy_ibm ( ql0av ( kb : ke + kh ), ql0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) exnf = 1 - grav * zf / ( cp * thls ) exnh = 1 - grav * zh / ( cp * thls ) th0av = thl0av + ( rlv / cp ) * ql0av / exnf !write(*,*) 'thl0av',thl0av !write(*,*) 'th0av',th0av do n = 1 , nsv !       call slabsum(sv0av(kb,n),kb,ke+kh,sv0(ib-ih,jb-jh,kb,n),ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) call avexy_ibm ( sv0av ( kb : ke + khc , n ), sv0 ( ib : ie , jb : je , kb : ke + khc , n ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + khc ), IIcs ( kb : ke + khc ),. false .) end do !    sv0av = sv0av/rslabs !*********************************************************** !  2.0   calculate average profile of pressure at full and * !        half levels, assuming hydrostatic equilibrium.    * !*********************************************************** !    2.1 Use first guess of theta, then recalculate theta call fromztop exnf = ( presf / pref0 ) ** ( rd / cp ) th0av = thl0av + ( rlv / cp ) * ql0av / exnf !    2.2 Use new updated value of theta for determination of pressure call fromztop !*********************************************************** !  3.0   Construct density profiles and exner function     * !       for further use in the program                     * !*********************************************************** !    3.1 determine exner exnh ( kb ) = ( ps / pref0 ) ** ( rd / cp ) exnf ( kb ) = ( presf ( kb ) / pref0 ) ** ( rd / cp ) do k = kb + 1 , ke + kh exnf ( k ) = ( presf ( k ) / pref0 ) ** ( rd / cp ) exnh ( k ) = ( presh ( k ) / pref0 ) ** ( rd / cp ) end do thvf ( kb ) = th0av ( kb ) * exnf ( kb ) * ( 1 + ( rv / rd - 1 ) * qt0av ( kb ) - rv / rd * ql0av ( kb )) rhof ( kb ) = presf ( kb ) / ( rd * thvf ( kb )) !    3.2 determine rho do k = kb + 1 , ke !+kh    ? !   write(*,*) \"exnf(k)\",exnf(k) !   write(*,*) \"th0av(k)\",th0av(k) !   write(*,*) \"qt0av(k)\",qt0av(k) !   write(*,*) \"ql0av(k)\",ql0av(k) thvf ( k ) = th0av ( k ) * exnf ( k ) * ( 1. + ( rv / rd - 1 ) * qt0av ( k ) - rv / rd * ql0av ( k )) rhof ( k ) = presf ( k ) / ( rd * thvf ( k )) end do return end subroutine diagfld !> Calculates slab averaged pressure !!      Input :  zf,zh,theta and qt profile !!      Output:  pressure profile at full and !!               half levels !! !!      Method: Using hydrostatic equilibrium !! !!                              -g*pref0**(rd/cp) !! =====>       dp**(rd/cp)/dz = -------------- !!                                 cp*thetav !! \\author Pier Siebesma   K.N.M.I.     06/01/1995 subroutine fromztop use modglobal , only : kmax , kb , ke , kh , dzf , dzh , rv , rd , cp , tmelt , zf , grav , pref0 , lEB use modfields , only : qt0av , ql0av , presf , presh , thvh , thvf , IIcs use modsurfdata , only : ps , thvs implicit none integer k real rdocp real , allocatable , dimension (:) :: thetah , qth , qlh allocate ( thetah ( kb : ke + kh ), qth ( kb : ke + kh ), qlh ( kb : ke + kh )) rdocp = rd / cp !************************************************** !    1.0 Determine theta and qt at half levels    * !************************************************** do k = kb + 1 , ke + kh thetah ( k ) = ( th0av ( k ) * dzf ( k - 1 ) + th0av ( k - 1 ) * dzf ( k )) / ( 2 * dzh ( k )) qth ( k ) = ( qt0av ( k ) * dzf ( k - 1 ) + qt0av ( k - 1 ) * dzf ( k )) / ( 2 * dzh ( k )) qlh ( k ) = ( ql0av ( k ) * dzf ( k - 1 ) + ql0av ( k - 1 ) * dzf ( k )) / ( 2 * dzh ( k )) end do !************************************************** !     2.1  calculate pressures at full levels     * !          assuming hydrostatic equilibrium       * !************************************************** !     1: lowest level: use thvs thvh ( kb ) = thvs presf ( kb ) = ps ** rdocp - & grav * ( pref0 ** rdocp ) * zf ( kb ) / ( cp * thvh ( kb )) presf ( kb ) = presf ( kb ) ** ( 1. / rdocp ) !     2: higher levels do k = kb + 1 , ke + kh thvh ( k ) = thetah ( k ) * ( 1 + ( rv / rd - 1 ) * qth ( k ) - rv / rd * qlh ( k )) presf ( k ) = presf ( k - 1 ) ** rdocp - grav * ( pref0 ** rdocp ) * dzh ( k ) / ( cp * thvh ( k )) presf ( k ) = presf ( k ) ** ( 1. / rdocp ) end do !************************************************** !     2.2   calculate pressures at half levels    * !           assuming hydrostatic equilibrium      * !************************************************** presh ( kb ) = ps thvf ( kb ) = th0av ( kb ) * ( 1 + ( rv / rd - 1 ) * qt0av ( kb ) - rv / rd * ql0av ( kb )) do k = kb + 1 , ke + kh thvf ( k ) = th0av ( k ) * ( 1 + ( rv / rd - 1 ) * qt0av ( k ) - rv / rd * ql0av ( k )) presh ( k ) = presh ( k - 1 ) ** rdocp - grav * ( pref0 ** rdocp ) * dzf ( k - 1 ) / ( cp * thvf ( k - 1 )) presh ( k ) = presh ( k ) ** ( 1. / rdocp ) end do deallocate ( thetah , qth , qlh ) return end subroutine fromztop !> Calculates liquid water content. !!     Given theta_l and q_tot the liquid water content !!     is calculated, making an \"all-or-nothing\" assumption. !!     if lfull=true   ==> ql at full levels on output !!     if lfull=false  ==> ql at half levels on output !! !! \\author Hans Cuijpers   I.M.A.U. !! \\author Pier Siebesma   K.N.M.I.     06/01/1995 subroutine thermo ( thl , qt , ql , pressure , exner ) !  use modglobal, only : ih,jh,i1,j1,k1,es0,at,bt,rd,rv,rlv,cp,tmelt use modglobal , only : ih , jh , ib , ie , jb , je , kb , ke , kh , es0 , at , bt , rd , rv , rlv , cp , tmelt use modsurfdata , only : thls implicit none integer i , j , k real tl , es , qs , qsl , b1 !  real, intent(in)  :: qt(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh),thl(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh),exner(kb:ke+kh),pressure(kb:ke+kh) real , intent ( in ) :: qt ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ), thl ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ), exner ( kb : ke + kh ), pressure ( kb : ke + kh ) real , intent ( out ) :: ql ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ) real :: Tnr , qsatur , Tnr_old integer :: niter , nitert if ( lqlnr ) then !mc      calculation of T with Newton-Raphson method !mc      first guess is Tnr=tl !mc nitert = 0 do k = kb , ke + kh do j = jb , je do i = ib , ie tl = thl ( i , j , k ) * exner ( k ) Tnr = tl Tnr_old = 0. do while ( abs ( Tnr - Tnr_old ) / Tnr > 1e-5 ) niter = niter + 1 Tnr_old = Tnr es = es0 * exp ( at * ( Tnr - tmelt ) / ( Tnr - bt )) qsatur = rd / rv * es / ( pressure ( k ) - ( 1 - rd / rv ) * es ) Tnr = Tnr - ( Tnr + ( rlv / cp ) * qsatur - tl - & ( rlv / cp ) * qt ( i , j , k )) / ( 1 + ( rlv ** 2 * qsatur ) / & ( rv * cp * Tnr ** 2 )) end do nitert = max ( nitert , niter ) niter = 0 ql ( i , j , k ) = dim ( qt ( i , j , k ) - qsatur , 0. ) end do end do end do else do k = kb , ke + kh do j = jb , je do i = ib , ie tl = thl ( i , j , k ) * exner ( k ) es = es0 * exp ( at * ( tl - tmelt ) / ( tl - bt )) qsl = rd / rv * es / ( pressure ( k ) - ( 1 - rd / rv ) * es ) b1 = rlv ** 2 / ( tl ** 2 * cp * rv ) qs = qsl * ( 1. + b1 * qt ( i , j , k )) / ( 1. + b1 * qsl ) ql ( i , j , k ) = dim ( qt ( i , j , k ) - qs , 0. ) end do end do end do end if return end subroutine thermo !> Calculates the scalars at half levels. !! If the kappa advection scheme is active, interpolation needs to be done consistently. subroutine calc_halflev use modglobal , only : ib , ie , jb , je , kb , ke , kh , dzf , dzh , iadv_thl , iadv_qt , iadv_kappa use modfields , only : thl0 , thl0h , qt0 , qt0h use modsurfdata , only : qts , thls implicit none integer :: i , j , k !      do  k=kb+1,ke+kh do k = kb , ke + kh do j = jb , je do i = ib , ie thl0h ( i , j , k ) = ( thl0 ( i , j , k ) * dzf ( k - 1 ) + thl0 ( i , j , k - 1 ) * dzf ( k )) / ( 2 * dzh ( k )) end do end do end do thl0h ( ib : ie , jb : je , kb ) = thls !      do  k=kb+1,ke+kh do k = kb , ke + kh do j = jb , je do i = ib , ie qt0h ( i , j , k ) = ( qt0 ( i , j , k ) * dzf ( k - 1 ) + qt0 ( i , j , k - 1 ) * dzf ( k )) / ( 2 * dzh ( k )) end do end do end do qt0h ( ib : ie , jb : je , kb ) = qts end subroutine calc_halflev end module modthermodynamics","tags":"","url":"sourcefile/modthermodynamics.f90.html"},{"title":"modEB.f90 – uDALES","text":"This file depends on sourcefile~~modeb.f90~~EfferentGraph sourcefile~modeb.f90 modEB.f90 sourcefile~initfac.f90 initfac.f90 sourcefile~modeb.f90->sourcefile~initfac.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~modeb.f90->sourcefile~modglobal.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~modeb.f90->sourcefile~modmpi.f90 sourcefile~modstat_nc.f90 modstat_nc.f90 sourcefile~modeb.f90->sourcefile~modstat_nc.f90 sourcefile~initfac.f90->sourcefile~modglobal.f90 sourcefile~initfac.f90->sourcefile~modmpi.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 sourcefile~modstat_nc.f90->sourcefile~modglobal.f90 sourcefile~modstat_nc.f90->sourcefile~modmpi.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~modeb.f90~~AfferentGraph sourcefile~modeb.f90 modEB.f90 sourcefile~program.f90 program.f90 sourcefile~program.f90->sourcefile~modeb.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !!> \\file modEB.f90 !!!  Energy balance on facets ! !> !!  \\author Ivo Suter ! ! !  This file is part of uDALES. ! ! This program is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! This program is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !  Copyright 2006-2021 the uDALES Team. ! module modEB use modglobal use mpi implicit none public :: EB , initEB , intqH , updateGR integer :: nstatT = 2 , nstatEB = 6 , ncidT , ncidEB , nrecT = 0 , nrecEB = 0 character ( 80 ), allocatable :: ncstatT (:,:), ncstatEB (:,:) character ( 80 ) :: Tname = \"facT.xxx.nc\" , EBname = 'facEB.xxx.nc' character ( 80 ), dimension ( 1 , 4 ) :: tncstatT , tncstatEB real , allocatable :: varsT (:,:,:), varsEB (:,:) save contains !functions to invert matrices pure function matinv3 ( A ) result ( B ) !pure makes sure that no variable outside the function can possibly be changed !! calculates the inverse of a 3×3 matrix. real , intent ( in ) :: A ( 3 , 3 ) !! matrix real :: B ( 3 , 3 ) !! inverse matrix real :: detinv !inverse determinant of the matrix detinv = 1 / ( A ( 1 , 1 ) * A ( 2 , 2 ) * A ( 3 , 3 ) - A ( 1 , 1 ) * A ( 2 , 3 ) * A ( 3 , 2 ) & - A ( 1 , 2 ) * A ( 2 , 1 ) * A ( 3 , 3 ) + A ( 1 , 2 ) * A ( 2 , 3 ) * A ( 3 , 1 ) & + A ( 1 , 3 ) * A ( 2 , 1 ) * A ( 3 , 2 ) - A ( 1 , 3 ) * A ( 2 , 2 ) * A ( 3 , 1 )) !inverse of the matrix B ( 1 , 1 ) = + detinv * ( A ( 2 , 2 ) * A ( 3 , 3 ) - A ( 2 , 3 ) * A ( 3 , 2 )) B ( 2 , 1 ) = - detinv * ( A ( 2 , 1 ) * A ( 3 , 3 ) - A ( 2 , 3 ) * A ( 3 , 1 )) B ( 3 , 1 ) = + detinv * ( A ( 2 , 1 ) * A ( 3 , 2 ) - A ( 2 , 2 ) * A ( 3 , 1 )) B ( 1 , 2 ) = - detinv * ( A ( 1 , 2 ) * A ( 3 , 3 ) - A ( 1 , 3 ) * A ( 3 , 2 )) B ( 2 , 2 ) = + detinv * ( A ( 1 , 1 ) * A ( 3 , 3 ) - A ( 1 , 3 ) * A ( 3 , 1 )) B ( 3 , 2 ) = - detinv * ( A ( 1 , 1 ) * A ( 3 , 2 ) - A ( 1 , 2 ) * A ( 3 , 1 )) B ( 1 , 3 ) = + detinv * ( A ( 1 , 2 ) * A ( 2 , 3 ) - A ( 1 , 3 ) * A ( 2 , 2 )) B ( 2 , 3 ) = - detinv * ( A ( 1 , 1 ) * A ( 2 , 3 ) - A ( 1 , 3 ) * A ( 2 , 1 )) B ( 3 , 3 ) = + detinv * ( A ( 1 , 1 ) * A ( 2 , 2 ) - A ( 1 , 2 ) * A ( 2 , 1 )) end function pure function matinv4 ( A ) result ( B ) !! calculates the inverse of a 4×4 matrix. real , intent ( in ) :: A ( 4 , 4 ) !! matrix real :: B ( 4 , 4 ) !! inverse matrix real :: detinv !inverse determinant of the matrix detinv = & 1 / ( A ( 1 , 1 ) * ( A ( 2 , 2 ) * ( A ( 3 , 3 ) * A ( 4 , 4 ) - A ( 3 , 4 ) * A ( 4 , 3 )) + A ( 2 , 3 ) * ( A ( 3 , 4 ) * A ( 4 , 2 ) & - A ( 3 , 2 ) * A ( 4 , 4 )) + A ( 2 , 4 ) * ( A ( 3 , 2 ) * A ( 4 , 3 ) - A ( 3 , 3 ) * A ( 4 , 2 ))) & - A ( 1 , 2 ) * ( A ( 2 , 1 ) * ( A ( 3 , 3 ) * A ( 4 , 4 ) - A ( 3 , 4 ) * A ( 4 , 3 )) + A ( 2 , 3 ) * ( A ( 3 , 4 ) * A ( 4 , 1 ) & - A ( 3 , 1 ) * A ( 4 , 4 )) + A ( 2 , 4 ) * ( A ( 3 , 1 ) * A ( 4 , 3 ) - A ( 3 , 3 ) * A ( 4 , 1 ))) & + A ( 1 , 3 ) * ( A ( 2 , 1 ) * ( A ( 3 , 2 ) * A ( 4 , 4 ) - A ( 3 , 4 ) * A ( 4 , 2 )) + A ( 2 , 2 ) * ( A ( 3 , 4 ) * A ( 4 , 1 ) & - A ( 3 , 1 ) * A ( 4 , 4 )) + A ( 2 , 4 ) * ( A ( 3 , 1 ) * A ( 4 , 2 ) - A ( 3 , 2 ) * A ( 4 , 1 ))) & - A ( 1 , 4 ) * ( A ( 2 , 1 ) * ( A ( 3 , 2 ) * A ( 4 , 3 ) - A ( 3 , 3 ) * A ( 4 , 2 )) + A ( 2 , 2 ) * ( A ( 3 , 3 ) * A ( 4 , 1 ) & - A ( 3 , 1 ) * A ( 4 , 3 )) + A ( 2 , 3 ) * ( A ( 3 , 1 ) * A ( 4 , 2 ) - A ( 3 , 2 ) * A ( 4 , 1 )))) !inverse of the matrix B ( 1 , 1 ) = detinv * ( A ( 2 , 2 ) * ( A ( 3 , 3 ) * A ( 4 , 4 ) - A ( 3 , 4 ) * A ( 4 , 3 )) + A ( 2 , 3 ) * ( A ( 3 , 4 ) * A ( 4 , 2 ) & - A ( 3 , 2 ) * A ( 4 , 4 )) + A ( 2 , 4 ) * ( A ( 3 , 2 ) * A ( 4 , 3 ) - A ( 3 , 3 ) * A ( 4 , 2 ))) B ( 2 , 1 ) = detinv * ( A ( 2 , 1 ) * ( A ( 3 , 4 ) * A ( 4 , 3 ) - A ( 3 , 3 ) * A ( 4 , 4 )) + A ( 2 , 3 ) * ( A ( 3 , 1 ) * A ( 4 , 4 ) & - A ( 3 , 4 ) * A ( 4 , 1 )) + A ( 2 , 4 ) * ( A ( 3 , 3 ) * A ( 4 , 1 ) - A ( 3 , 1 ) * A ( 4 , 3 ))) B ( 3 , 1 ) = detinv * ( A ( 2 , 1 ) * ( A ( 3 , 2 ) * A ( 4 , 4 ) - A ( 3 , 4 ) * A ( 4 , 2 )) + A ( 2 , 2 ) * ( A ( 3 , 4 ) * A ( 4 , 1 ) & - A ( 3 , 1 ) * A ( 4 , 4 )) + A ( 2 , 4 ) * ( A ( 3 , 1 ) * A ( 4 , 2 ) - A ( 3 , 2 ) * A ( 4 , 1 ))) B ( 4 , 1 ) = detinv * ( A ( 2 , 1 ) * ( A ( 3 , 3 ) * A ( 4 , 2 ) - A ( 3 , 2 ) * A ( 4 , 3 )) + A ( 2 , 2 ) * ( A ( 3 , 1 ) * A ( 4 , 3 ) & - A ( 3 , 3 ) * A ( 4 , 1 )) + A ( 2 , 3 ) * ( A ( 3 , 2 ) * A ( 4 , 1 ) - A ( 3 , 1 ) * A ( 4 , 2 ))) B ( 1 , 2 ) = detinv * ( A ( 1 , 2 ) * ( A ( 3 , 4 ) * A ( 4 , 3 ) - A ( 3 , 3 ) * A ( 4 , 4 )) + A ( 1 , 3 ) * ( A ( 3 , 2 ) * A ( 4 , 4 ) & - A ( 3 , 4 ) * A ( 4 , 2 )) + A ( 1 , 4 ) * ( A ( 3 , 3 ) * A ( 4 , 2 ) - A ( 3 , 2 ) * A ( 4 , 3 ))) B ( 2 , 2 ) = detinv * ( A ( 1 , 1 ) * ( A ( 3 , 3 ) * A ( 4 , 4 ) - A ( 3 , 4 ) * A ( 4 , 3 )) + A ( 1 , 3 ) * ( A ( 3 , 4 ) * A ( 4 , 1 ) & - A ( 3 , 1 ) * A ( 4 , 4 )) + A ( 1 , 4 ) * ( A ( 3 , 1 ) * A ( 4 , 3 ) - A ( 3 , 3 ) * A ( 4 , 1 ))) B ( 3 , 2 ) = detinv * ( A ( 1 , 1 ) * ( A ( 3 , 4 ) * A ( 4 , 2 ) - A ( 3 , 2 ) * A ( 4 , 4 )) + A ( 1 , 2 ) * ( A ( 3 , 1 ) * A ( 4 , 4 ) & - A ( 3 , 4 ) * A ( 4 , 1 )) + A ( 1 , 4 ) * ( A ( 3 , 2 ) * A ( 4 , 1 ) - A ( 3 , 1 ) * A ( 4 , 2 ))) B ( 4 , 2 ) = detinv * ( A ( 1 , 1 ) * ( A ( 3 , 2 ) * A ( 4 , 3 ) - A ( 3 , 3 ) * A ( 4 , 2 )) + A ( 1 , 2 ) * ( A ( 3 , 3 ) * A ( 4 , 1 ) & - A ( 3 , 1 ) * A ( 4 , 3 )) + A ( 1 , 3 ) * ( A ( 3 , 1 ) * A ( 4 , 2 ) - A ( 3 , 2 ) * A ( 4 , 1 ))) B ( 1 , 3 ) = detinv * ( A ( 1 , 2 ) * ( A ( 2 , 3 ) * A ( 4 , 4 ) - A ( 2 , 4 ) * A ( 4 , 3 )) + A ( 1 , 3 ) * ( A ( 2 , 4 ) * A ( 4 , 2 ) & - A ( 2 , 2 ) * A ( 4 , 4 )) + A ( 1 , 4 ) * ( A ( 2 , 2 ) * A ( 4 , 3 ) - A ( 2 , 3 ) * A ( 4 , 2 ))) B ( 2 , 3 ) = detinv * ( A ( 1 , 1 ) * ( A ( 2 , 4 ) * A ( 4 , 3 ) - A ( 2 , 3 ) * A ( 4 , 4 )) + A ( 1 , 3 ) * ( A ( 2 , 1 ) * A ( 4 , 4 ) & - A ( 2 , 4 ) * A ( 4 , 1 )) + A ( 1 , 4 ) * ( A ( 2 , 3 ) * A ( 4 , 1 ) - A ( 2 , 1 ) * A ( 4 , 3 ))) B ( 3 , 3 ) = detinv * ( A ( 1 , 1 ) * ( A ( 2 , 2 ) * A ( 4 , 4 ) - A ( 2 , 4 ) * A ( 4 , 2 )) + A ( 1 , 2 ) * ( A ( 2 , 4 ) * A ( 4 , 1 ) & - A ( 2 , 1 ) * A ( 4 , 4 )) + A ( 1 , 4 ) * ( A ( 2 , 1 ) * A ( 4 , 2 ) - A ( 2 , 2 ) * A ( 4 , 1 ))) B ( 4 , 3 ) = detinv * ( A ( 1 , 1 ) * ( A ( 2 , 3 ) * A ( 4 , 2 ) - A ( 2 , 2 ) * A ( 4 , 3 )) + A ( 1 , 2 ) * ( A ( 2 , 1 ) * A ( 4 , 3 ) & - A ( 2 , 3 ) * A ( 4 , 1 )) + A ( 1 , 3 ) * ( A ( 2 , 2 ) * A ( 4 , 1 ) - A ( 2 , 1 ) * A ( 4 , 2 ))) B ( 1 , 4 ) = detinv * ( A ( 1 , 2 ) * ( A ( 2 , 4 ) * A ( 3 , 3 ) - A ( 2 , 3 ) * A ( 3 , 4 )) + A ( 1 , 3 ) * ( A ( 2 , 2 ) * A ( 3 , 4 ) & - A ( 2 , 4 ) * A ( 3 , 2 )) + A ( 1 , 4 ) * ( A ( 2 , 3 ) * A ( 3 , 2 ) - A ( 2 , 2 ) * A ( 3 , 3 ))) B ( 2 , 4 ) = detinv * ( A ( 1 , 1 ) * ( A ( 2 , 3 ) * A ( 3 , 4 ) - A ( 2 , 4 ) * A ( 3 , 3 )) + A ( 1 , 3 ) * ( A ( 2 , 4 ) * A ( 3 , 1 ) & - A ( 2 , 1 ) * A ( 3 , 4 )) + A ( 1 , 4 ) * ( A ( 2 , 1 ) * A ( 3 , 3 ) - A ( 2 , 3 ) * A ( 3 , 1 ))) B ( 3 , 4 ) = detinv * ( A ( 1 , 1 ) * ( A ( 2 , 4 ) * A ( 3 , 2 ) - A ( 2 , 2 ) * A ( 3 , 4 )) + A ( 1 , 2 ) * ( A ( 2 , 1 ) * A ( 3 , 4 ) & - A ( 2 , 4 ) * A ( 3 , 1 )) + A ( 1 , 4 ) * ( A ( 2 , 2 ) * A ( 3 , 1 ) - A ( 2 , 1 ) * A ( 3 , 2 ))) B ( 4 , 4 ) = detinv * ( A ( 1 , 1 ) * ( A ( 2 , 2 ) * A ( 3 , 3 ) - A ( 2 , 3 ) * A ( 3 , 2 )) + A ( 1 , 2 ) * ( A ( 2 , 3 ) * A ( 3 , 1 ) & - A ( 2 , 1 ) * A ( 3 , 3 )) + A ( 1 , 3 ) * ( A ( 2 , 1 ) * A ( 3 , 2 ) - A ( 2 , 2 ) * A ( 3 , 1 ))) end function function gaussji ( c , d , n ) result ( a ) !Linear equation solution by Gauss-Jordan elimination, used to find inverse of matrix c. !possibly slow for large \"c\" (LAPACK better?) !c needs to be square and have dimension n !c(1:n,1:n) is an input matrix stored in an array of physical dimensions n by n. !d(1:n,1:n) is an input matrix containing the n by n identity matrix. !On  output, a(1:n,1:n) (and b(1:n,1:n)) are the inverse of c !Parameter: NMAX is  the  largest  anticipated  value  of n. integer :: n real , intent ( in ) :: c ( n , n ) !WILL BE OVERWRITTEN!! real , intent ( in ) :: d ( n , n ) real :: a ( n , n ), b ( n , n ) integer , parameter :: NMAX = 50 integer :: m , i , icol , irow , j , k , l , ll , indxc ( NMAX ), indxr ( NMAX ), ipiv ( NMAX ) !The integer arrays ipiv, indxr, and indxc are  used for bookkeeping  on the pivoting. REAL :: big , dum , pivinv a = c b = d m = n do j = 1 , n ipiv ( j ) = 0 end do do i = 1 , n !This  is  the  main  loop  over  the  columns  to  be  reduced. big = 0. do j = 1 , n !This  is  the  outer  loop  of  the  search  for  a  pivot  element. if ( ipiv ( j ) . ne . 1 ) then do k = 1 , n if ( ipiv ( k ) . eq . 0 ) then if ( abs ( a ( j , k )) . ge . big ) then big = abs ( a ( j , k )) irow = j icol = k endif !else if (ipiv(k).gt.1) then !pause 'singular matrix in gaussj' end if end do end if end do ipiv ( icol ) = ipiv ( icol ) + 1 !We  now  have  the  pivot  element,  so  we  interchange  rows,  if  needed,  to  put  the  pivot !element  on  the  diagonal.  The  columns  are  not  physically  interchanged,  only  relabeled: !indxc(i), the column of the ith pivot element, is the ith column that is reduced, while !indxr(i) is  the  row in  which  that  pivot  element  was  originally  located.  If !indxr(i) /= indxc(i) there  is  an  implied  column  interchange.  With  this  form  of  bookkeeping,  the !solution b's  will  end  up  in  the  correct  order,  and  the  inverse  matrix  will  be  scrambled by  columns if ( irow . ne . icol ) then do l = 1 , n dum = a ( irow , l ) a ( irow , l ) = a ( icol , l ) a ( icol , l ) = dum end do do l = 1 , m dum = b ( irow , l ) b ( irow , l ) = b ( icol , l ) b ( icol , l ) = dum enddo endif !We are now ready to divide the pivot row by the pivot element, located at irow and icol. indxr ( i ) = irow indxc ( i ) = icol !if (a(icol,icol).eq.0.) pause 'singular matrix in gaussj' pivinv = 1. / a ( icol , icol ) a ( icol , icol ) = 1. do l = 1 , n a ( icol , l ) = a ( icol , l ) * pivinv end do do l = 1 , m b ( icol , l ) = b ( icol , l ) * pivinv end do do ll = 1 , n !Next,  we  reduce  the  rows, except for the  pivot  one, of course. if ( ll . ne . icol ) then dum = a ( ll , icol ) a ( ll , icol ) = 0. do l = 1 , n a ( ll , l ) = a ( ll , l ) - a ( icol , l ) * dum end do do l = 1 , m b ( ll , l ) = b ( ll , l ) - b ( icol , l ) * dum end do end if end do end do !This is the end of the main loop over columns of the reduction. do l = n , 1 , - 1 !It  only  remains  to  unscramble  the  solution  in  view !of  the  column  interchanges.  We  do  this  by  in- !terchanging pairs of columns in the reverse order !that the permutation was built  up. if ( indxr ( l ) . ne . indxc ( l )) then do k = 1 , n dum = a ( k , indxr ( l )) a ( k , indxr ( l )) = a ( k , indxc ( l )) a ( k , indxc ( l )) = dum end do end if end do return !And  we  are  done. end function gaussji subroutine intqH !time integration of heat and latent heat from facets use modglobal , only : nfcts , dt , rk3step , lEB use initfac , only : faccth , fachfsum , fachf , fachfi , facef , facefi , facefsum use modmpi , only : nprocs , myid , comm3d , mpierr , mpi_sum , my_real real :: dummy integer :: n if (. not . lEB ) return if ( rk3step . eq . 3 ) then !sum over all processors since a facet can be split onto more than one processor fachfsum = 0. facefsum = 0. call MPI_ALLREDUCE ( fachf ( 1 : nfcts ), fachfsum ( 1 : nfcts ), nfcts , MY_REAL , MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( facef ( 1 : nfcts ), facefsum ( 1 : nfcts ), nfcts , MY_REAL , MPI_SUM , comm3d , mpierr ) if ( myid == 0 ) then !time summation of total facet heatlux (will be divided by dtEB in EB to get time mean flux) do n = 1 , nfcts fachfi ( n ) = fachfi ( n ) + dt * fachfsum ( n ) !sum up the fluxes over time facefi ( n ) = facefi ( n ) + dt * facefsum ( n ) end do end if end if fachf = 0. fachfsum = 0. facefsum = 0. facef = 0. end subroutine intqH subroutine initEB !initialise everything necessary to calculate the energy balance use modglobal , only : AM , BM , CM , DM , EM , FM , GM , HM , IDM , inAM , bb , w , dumv , Tdash , bldT , nfcts , nfaclyrs use initfac , only : facd , faccp , faclam , fackappa , netsw , facem , fachf , facef , fachfi , facT , facLWin , facefi , facwsoil , facf , facets , facTdash , facqsat , facf , fachurel use modmpi , only : myid , comm3d , mpierr , MY_REAL , nprocs , cmyid use modstat_nc , only : open_nc , define_nc , ncinfo , writestat_dims_nc integer :: i , j , k , l , m , n real :: dum if (. not . lEB ) return allocate ( AM ( 1 : nfaclyrs + 1 , 1 : nfaclyrs + 1 )) allocate ( inAM ( 1 : nfaclyrs + 1 , 1 : nfaclyrs + 1 )) allocate ( CM ( 1 : nfaclyrs + 1 , 1 : nfaclyrs + 1 )) allocate ( bb ( 1 : nfaclyrs + 1 )) allocate ( BM ( 1 : nfaclyrs + 1 , 1 : nfaclyrs + 1 )) allocate ( DM ( 1 : nfaclyrs + 1 , 1 : nfaclyrs + 1 )) allocate ( EM ( 1 : nfaclyrs + 1 , 1 : nfaclyrs + 1 )) allocate ( FM ( 1 : nfaclyrs + 1 , 1 : nfaclyrs + 1 )) allocate ( GM ( 1 : nfaclyrs + 1 , 1 : nfaclyrs + 1 )) allocate ( HM ( 1 : nfaclyrs + 1 , 1 : nfaclyrs + 1 )) allocate ( IDM ( 1 : nfaclyrs + 1 , 1 : nfaclyrs + 1 )) allocate ( w ( 1 : nfaclyrs + 1 )) allocate ( dumv ( 1 : nfaclyrs + 1 )) allocate ( Tdash ( 1 : nfaclyrs + 1 )) BM = 0. ; DM = 0. ; EM = 0. ; FM = 0. ; GM = 0. ; HM = 0. ; w = 0. ; dumv = 0. ; Tdash = 0. ; AM = 0. ; inAM = 0. ; CM = 0. ; IDM = 0. ; bb = 0. do j = 1 , nfaclyrs + 1 IDM ( j , j ) = 1.0 end do !Fortran is column major, i.e. left dimensions should be iterated first ! e.g.  (1,1)->(2,1)->(3,1)->(1,2)->... since they are next to each other on memory !first index moves \"up and down\" second \"left and right\" (as always) m = 1 ; !position along columns do j = 2 , nfaclyrs + 1 AM ( j , m ) = 0.5 AM ( j , m + 1 ) = 0.5 m = m + 1 end do AM ( 1 , 1 ) = 1.0 if ( nfaclyrs == 3 ) then inAM = matinv4 ( AM ) !!alternatively !inAM=matinv3(AM) !!or else inAM = gaussji ( AM , IDM , nfaclyrs + 1 ) end if ! write facet temperatures to facT.xxx.nc, and energies to facEB.xxx.nc if ( lwriteEBfiles ) then Tname ( 6 : 8 ) = cexpnr EBname ( 7 : 9 ) = cexpnr allocate ( ncstatT ( nstatT , 4 )) call ncinfo ( tncstatT ( 1 ,:), 't' , 'Time' , 's' , 'time' ) call ncinfo ( ncstatT ( 1 ,:), 'T' , 'Temperature' , 'K' , 'flt' ) call ncinfo ( ncstatT ( 2 ,:), 'dTdz' , 'Temperature gradient' , 'K/m' , 'flt' ) allocate ( ncstatEB ( nstatEB , 4 )) call ncinfo ( tncstatEB ( 1 ,:), 't' , 'Time' , 's' , 'time' ) call ncinfo ( ncstatEB ( 1 ,:), 'netsw' , 'Net shortwave' , 'W/m&#94;2' , 'ft' ) call ncinfo ( ncstatEB ( 2 ,:), 'LWin' , 'Incoming longwave' , 'W/m&#94;2' , 'ft' ) call ncinfo ( ncstatEB ( 3 ,:), 'LWout' , 'Outgoing longwave' , 'W/m&#94;2' , 'ft' ) call ncinfo ( ncstatEB ( 4 ,:), 'hf' , 'Sensible heat' , 'W/m&#94;2' , 'ft' ) call ncinfo ( ncstatEB ( 5 ,:), 'ef' , 'Latent heat' , 'W/m&#94;2' , 'ft' ) call ncinfo ( ncstatEB ( 6 ,:), 'WGR' , 'Water content' , '?' , 'ft' ) if ( myid == 0 ) then call open_nc ( Tname , ncidT , nrecT , nfcts = nfcts , nlyrs = nfaclyrs + 1 ) call open_nc ( EBname , ncidEB , nrecEB , nfcts = nfcts ) if ( nrecT == 0 ) then call define_nc ( ncidT , 1 , tncstatT ) call writestat_dims_nc ( ncidT ) end if if ( nrecEB == 0 ) then call define_nc ( ncidEB , 1 , tncstatEB ) call writestat_dims_nc ( ncidEB ) end if call define_nc ( ncidT , nstatT , ncstatT ) call define_nc ( ncidEB , nstatEB , ncstatEB ) endif !myid==0 end if end subroutine initEB subroutine calclw !calculate the longwave exchange between facets use modglobal , only : nfcts , boltz , skyLW , nnz use initfac , only : facem , vf , svf , faca , facT , facLWin , facets , vfsparse , ivfsparse , jvfsparse integer :: n , m , i , j real :: ltemp = 0. if ( lvfsparse ) then facLWin = svf * skyLW * facem do n = 1 , nnz i = ivfsparse ( n ) j = jvfsparse ( n ) facLWin ( i ) = facLWin ( i ) + vfsparse ( n ) * facem ( i ) * facem ( j ) * boltz * facT ( j , 1 ) ** 4 end do else do n = 1 , nfcts !if (facets(n) < -100) cycle ltemp = 0. do m = 1 , nfcts !for n, sum over all other m facets !ltemp = ltemp + vf(m, n)*faca(m)/faca(n)*facem(m)*boltz*facT(m, 1)**4 ![W/m2] ltemp = ltemp + vf ( n , m ) * facem ( m ) * boltz * facT ( m , 1 ) ** 4 ![W/m2] end do facLWin ( n ) = ( ltemp + svf ( n ) * skyLW ) * facem ( n ) end do end if end subroutine calclw subroutine updateGR !updates soil and vegetation resistance to evaporation !updates soil moisture ! ! based on ERA40 surface scheme ! van den Hurk 2000 ! plants ! E = max(0,vegetation% * rhoa * (qa-qsat(TGR)) * 1/(rc+ra)) !no dew!! ! rc=rsmin/LAI*f1(K)*f2(WGS)*f3(D)*f4(T) ! ra,qa,qsat ! f3(D) is 1 for small plants ! bare soil ! E = max(0,(1-vegetation%) * rhoa * (qa-qsat(TGR)*hu) * (1/(rs+ra)) use modglobal , only : nfcts , rlv , rlvi , rhoa , cp , wfc , wwilt , wsoil , rsmin , GRLAI , tEB , rsmax , lconstW use initfac , only : netSW , faccth , fachurel , faclGR , facwsoil , facf , facef , facT , facefi , facqsat , facd , faca , qsat integer :: n real :: vfraction = 0.8 !fraction of GR covered in vegetation, should be made into a proper model parameter (-> modglobal) real :: dum do n = 1 , nfcts if ( faclGR ( n )) then !facefi is actually the accumulated moisture flux, has to be converted to energy flux to calculate temperature !yet actually the moisture flux is needed for water budget, i.e. currently many operations cancel each other e.g. X*Lv/Lv !facefi is the sum over all gridcells of a facet, thus has to be averaged by dividing by number of cells in that facet !units of facefi are kgW/kgA*m/s facefi ( n ) = facefi ( n ) / tEB / faca ( n ) * rhoa * rlv !mean heat flux since last EB calculation (time average) if (. not . lconstW ) then !remove water from soil facwsoil ( n ) = max ( facwsoil ( n ) + facefi ( n ) * tEB * rlvi / facd ( n , 1 ), 0. ) !ils13, careful this assumes water only being present in the first layer!!! end if !update canopy resistance used in wf_gr fachurel ( n ) = max ( min ( 1.0 , 0.5 * ( 1.0 - cos ( 3.14159 * facwsoil ( n ) / wfc ))), 0. ) !relative humidity above soil facf ( n , 1 ) = 1. / min ( 1.0 , ( 0.004 * netSW ( n ) + 0.05 ) / ( 0.81 * ( 0.004 * netSW ( n ) + 1 ))) !f1 facf ( n , 2 ) = 1. / min ( max ( 0.001 , ( facwsoil ( n ) - wwilt ) / ( wfc - wwilt )), 1.0 ) !f2 !f3 drops out because it is for high vegetation only facf ( n , 3 ) = 1. / max (( 1 - 0.0016 * ( 298 - facT ( n , 1 )) ** 2 ), 0.001 ) !f4 !store resistance for plants facf ( n , 4 ) = min ( rsmin / GRLAI * facf ( n , 1 ) * facf ( n , 2 ) * facf ( n , 3 ), rsmax ) !store resistance for soil facf ( n , 5 ) = min ( rsmin * facf ( n , 2 ), rsmax ) dum = facT ( n , 1 ) facqsat ( n ) = qsat ( dum ) end if end do end subroutine updateGR subroutine EB !calculates the energy balance for every facet use modglobal , only : nfcts , boltz , tEB , AM , BM , CM , DM , EM , FM , GM , HM , inAM , bb , w , dumv , Tdash , timee , dtEB , tnextEB , rk3step , rhoa , cp , lEB , ntrun , lwriteEBfiles , nfaclyrs use initfac , only : faclam , faccp , netsw , facem , fachf , facef , fachfi , facT , facLWin , faca , facefi , facf , facets , facTdash , facqsat , facwsoil , facf , fachurel , facd , fackappa use modmpi , only : myid , comm3d , mpierr , MY_REAL , nprocs , cmyid use modstat_nc , only : writestat_nc , writestat_1D_nc , writestat_2D_nc real :: ca = 0. , cb = 0. , cc = 0. , cd = 0. , ce = 0. , cf = 0. real :: ab = 0. integer :: l , n , m , i , j character ( 19 ) name if (. not . ( lEB )) return !calculate latent heat flux from vegetation and soil call intqH !calculate energy balance, update facet temperature and soil moisture if (( rk3step . eq . 3 ) . and . ( timee . ge . tnextEB )) then if ( myid . eq . 0 ) then tEB = timee - tEB !time since last calculation of energy balance !write (*, *) \"doing EB, time since last EB:\", tEB !calculate time mean, facet area mean latent heat flux and update green roof !ILS13 02.05.18 ABOUT updateGR: convert latent heatflux E properly should be done before temperature calculatation. BUT the rest of updateGR should be done after! !update green roof call updateGR !get longwave fluxes for all facets call calclw !get time mean, facet area mean sensible heat flux do n = 1 , nfcts fachfi ( n ) = fachfi ( n ) / tEB / faca ( n ) * rhoa * cp !mean heat flux since last EB calculation (time average) !since fachf is the sum over all cells making up a facet we need to divide by the number of cells, assuming a given density to convert to W/m2 end do !solve the system: !see Suter 2018 !A * T'= bb + B * T,   where T' = dT/dz !C * d/dtT + D d/dtT'= e * T' ! !-> T(n+1)=(F-G*dt)&#94;-1*(F*T+w*dt) !where F=(C + D*A&#94;-1*B), G=(E*A&#94;-1*B), w=(E*A&#94;-1*bb) do n = 1 , nfcts if ( facets ( n ) < - 100 ) cycle !calculate wallflux and update surface temperature !! define time dependent fluxes ab = boltz * facem ( n ) * ( facT ( n , 1 ) ** 3 ) / faclam ( n , 1 ) ! ab*T is the Stefan-Boltzman law bb ( 1 ) = - ( netsw ( n ) + facLWin ( n ) + fachfi ( n ) + facefi ( n )) / faclam ( n , 1 ) !net surface flux !!define the matrices to solve wall heat flux !! CREATE MATRICES BASED ON WALL PROPERTIES i = 1 ; m = 0 ; !position along columns, placeholder for layerindex since only 3 layers implemented (initfac.f90) do j = 1 , nfaclyrs m = j !!CARE!!! ONLY 3 LAYERS ARE CURRENTLY BEING READ FROM INPUT FILES. PROPERTIES OF LAYER 3 ARE USED FOR SUBSEQUENT LAYERS!!! ca = 1. / facd ( n , m ) BM ( j + 1 , i ) =- ca BM ( j + 1 , i + 1 ) = ca EM ( j , i ) =- faclam ( n , m ) EM ( j , i + 1 ) = faclam ( n , m + 1 ) cb = faccp ( n , m ) * facd ( n , m ) / 2. CM ( j , i ) = cb CM ( j , i + 1 ) = cb ca = faccp ( n , m ) * facd ( n , m ) ** 2 / 1 2. DM ( j , i ) = ca DM ( j , i + 1 ) =- ca i = i + 1 end do CM ( nfaclyrs + 1 , nfaclyrs + 1 ) = 1. BM ( 1 , 1 ) = ab w = matmul ( EM , matmul ( inAM , bb )) * tEB !easier than loop and sum HM = matmul ( inAM , BM ) FM = CM + matmul ( DM , HM ) GM = matmul ( EM , HM ) HM = FM - GM * tEB if ( nfaclyrs == 3 ) then GM = matinv4 ( HM ) else GM = gaussji ( HM , IDM , nfaclyrs + 1 ) end if !instead of inverting matrix HM and multiplying by GM (=HM&#94;-1) it would be waster to do a  left matrix division HM\\x is faster than (HM&#94;-1)*x dumv = matmul ( GM , ( matmul ( FM , facT ( n ,:)) + w )) facT ( n , :) = dumv !calculate Temperature gradient dT/dz=>Tdash so we can output it !ground heat flux = lambda dT/dz w = matmul ( BM , dumv ) facTdash ( n , :) = matmul ( inAM , ( bb + w )) !end if end do if ( lwriteEBfiles ) then if ( myid == 0 ) then allocate ( varsT ( nfcts , nfaclyrs + 1 , nstatT )) varsT (:,:, 1 ) = facT ( 1 : nfcts , 1 : nfaclyrs + 1 ) varsT (:,:, 2 ) = facTdash ( 1 : nfcts , 1 : nfaclyrs + 1 ) call writestat_nc ( ncidT , 1 , tncstatT ,( / timee / ), nrecT ,. true .) call writestat_2D_nc ( ncidT , nstatT , ncstatT , varsT , nrecT , nfcts , nfaclyrs + 1 ) deallocate ( varsT ) allocate ( varsEB ( nfcts , nstatEB )) varsEB (:, 1 ) = netsw ( 1 : nfcts ) varsEB (:, 2 ) = facLWin ( 1 : nfcts ) varsEB (:, 3 ) = boltz * facem ( 1 : nfcts ) * facT ( 1 : nfcts , 1 ) ** 4 varsEB (:, 4 ) = fachfi ( 1 : nfcts ) varsEB (:, 5 ) = facefi ( 1 : nfcts ) varsEB (:, 6 ) = facwsoil ( 1 : nfcts ) ! add longwave out call writestat_nc ( ncidEB , 1 , tncstatEB ,( / timee / ), nrecEB ,. true .) call writestat_1D_nc ( ncidEB , nstatEB , ncstatEB , varsEB , nrecEB , nfcts ) deallocate ( varsEB ) end if !myid end if tEB = timee !set time of last calculation of energy balance to current time tnextEB = NINT (( timee + dtEB )) * 1.0 !rounded to nearest integer  (e.g. if current time is 10.013s and dtEb=10s, then the next energy balance will be calculated at t>=20s) !write (*, *) \"time, time next EB\", timee, tnextEB do n = 1 , nfcts fachfi ( n ) = 0. facefi ( n ) = 0. end do end if !myid==0 !write (*, *) \"bcasting facT\" call MPI_BCAST ( facT ( 0 : nfcts , 1 : nfaclyrs + 1 ), ( nfaclyrs + 1 ) * ( nfcts + 1 ), MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( tnextEB , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( facqsat ( 0 : nfcts ), nfcts + 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( facf ( 0 : nfcts , 1 : 5 ), ( nfcts + 1 ) * 5 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( fachurel ( 0 : nfcts ), nfcts + 1 , MY_REAL , 0 , comm3d , mpierr ) !call MPI_BCAST(facwsoil(0:nfcts), nfcts + 1, MY_REAL, 0, comm3d, mpierr) end if !time>tnextEB end subroutine EB end module modEB","tags":"","url":"sourcefile/modeb.f90.html"},{"title":"advec_kappa.f90 – uDALES","text":"This file depends on sourcefile~~advec_kappa.f90~~EfferentGraph sourcefile~advec_kappa.f90 advec_kappa.f90 sourcefile~modfields.f90 modfields.f90 sourcefile~advec_kappa.f90->sourcefile~modfields.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~advec_kappa.f90->sourcefile~modglobal.f90 sourcefile~modibmdata.f90 modibmdata.f90 sourcefile~advec_kappa.f90->sourcefile~modibmdata.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> \\file advec_kappa.f90 !!  Does advection with a kappa limiter scheme. !! \\par Revision list !! \\par Authors !! \\see Hundsdorfer et al 1995 !! !! For advection of scalars that need to be strictly monotone (for example chemically reacting species) !! the kappa scheme has been implemented: !! \\latexonly !! \\begin{eqnarray} !!  F_{i-\\frac{1}{2}}&#94;{\\kappa} &=& \\fav{u}_{i-\\frac{1}{2}} !!  \\left[\\phi_{i-1}+\\frac{1}{2}\\kappa_{i-\\frac{1}{2}}\\left(\\phi_{i-1}-\\phi_{i-2}\\right)\\right], !! \\end{eqnarray} !! in case $\\fav{u}>0$. $\\kappa_{i-\\smfrac{1}{2}}$ serves as a switch between higher order advection and !! first order upwind in case of strong upwind gradients of $\\phi$. !! \\endlatexonly !! This makes the scheme monotone, but also rather dissipative. !! !  This file is part of DALES. ! ! DALES is free software; you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation; either version 3 of the License, or ! (at your option) any later version. ! ! DALES is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !  Copyright 1993-2009 Delft University of Technology, Wageningen University, Utrecht University, KNMI ! !> Advection at cell center subroutine advecc_kappa ( hi , hj , hk , var , varp ) !  use modglobal, only : i1,i2,ih,j1,j2,jh,k1,kmax,dxi,dyi,dzi use modglobal , only : ib , ie , ihc , jb , je , jhc , kb , ke , khc , dxhci , dyi , dzhci , dxfc , dzfc , dxfci , dzfci , libm use modibmdata , only : nxwallsnorm , nywallsnorm , nzwallsnorm , xwallsnorm , & ywallsnorm , zwallsnorm , nywallsp , nywallsm , ywallsp , ywallsm use modfields , only : u0 , v0 , w0 implicit none real , external :: rlim integer , intent ( in ) :: hi !< size of halo in i integer , intent ( in ) :: hj !< size of halo in j integer , intent ( in ) :: hk !< size of halo in k real , dimension ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ), intent ( in ) :: var !< Input: the cell centered field real , dimension ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ), intent ( inout ) :: varp !< Output: the tendency real , dimension ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ) :: duml ! 3d dummy variable: lower cell side real , dimension ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ) :: dumu ! 3d dummy variable: upper cell side integer i , j , k , il , iu , jl , ju , kl , ku , n real :: cf , d1 , d2 dumu (:, :, :) = 0. duml (:, :, :) = 0. ! -d(uc)/dx (stretched grid) do k = kb , ke do j = jb , je do i = ib , ie + 1 if ( u0 ( i , j , k ) > 0 ) then d1 = ( var ( i - 1 , j , k ) - var ( i - 2 , j , k )) * dxhci ( i - 1 ) d2 = ( var ( i , j , k ) - var ( i - 1 , j , k )) * dxhci ( i ) cf = var ( i - 1 , j , k ) else d1 = ( var ( i , j , k ) - var ( i + 1 , j , k )) * dxhci ( i + 1 ) d2 = ( var ( i - 1 , j , k ) - var ( i , j , k )) * dxhci ( i ) cf = var ( i , j , k ) end if cf = cf + dxfc ( i ) * rlim ( d1 , d2 ) dumu ( i - 1 , j , k ) = - cf * u0 ( i , j , k ) * dxfci ( i - 1 ) !swapped the -1s here !tg3315 !now also swapped the signs... duml ( i , j , k ) = cf * u0 ( i , j , k ) * dxfci ( i ) end do end do end do varp (:,:,:) = varp (:,:,:) + dumu (:,:,:) + duml (:,:,:) dumu (:,:,:) = 0. duml (:,:,:) = 0. ! -d(vc)/dy (no stretched grid) do k = kb , ke do j = jb , je + 1 do i = ib , ie if ( v0 ( i , j , k ) > 0 ) then d1 = var ( i , j - 1 , k ) - var ( i , j - 2 , k ) d2 = var ( i , j , k ) - var ( i , j - 1 , k ) cf = var ( i , j - 1 , k ) else d1 = var ( i , j , k ) - var ( i , j + 1 , k ) d2 = var ( i , j - 1 , k ) - var ( i , j , k ) cf = var ( i , j , k ) end if cf = cf + rlim ( d1 , d2 ) duml ( i , j , k ) = cf * v0 ( i , j , k ) * dyi !tg3315 dumu ( i , j - 1 , k ) = - cf * v0 ( i , j , k ) * dyi end do end do end do varp (:,:,:) = varp (:,:,:) + dumu (:,:,:) + duml (:,:,:) dumu (:,:,:) = 0. duml (:,:,:) = 0. ! -d(wc)/dz (stretched grid) !  do k=kb,ke+1 do k = kb + 1 , ke + 1 do j = jb , je do i = ib , ie if ( w0 ( i , j , k ) > 0 ) then d1 = ( var ( i , j , k - 1 ) - var ( i , j , k - 2 )) * dzhci ( k - 1 ) d2 = ( var ( i , j , k ) - var ( i , j , k - 1 )) * dzhci ( k ) cf = var ( i , j , k - 1 ) else d1 = ( var ( i , j , k ) - var ( i , j , k + 1 )) * dzhci ( k + 1 ) d2 = ( var ( i , j , k - 1 ) - var ( i , j , k )) * dzhci ( k ) cf = var ( i , j , k ) end if cf = cf + dzfc ( k ) * rlim ( d1 , d2 ) duml ( i , j , k ) = cf * w0 ( i , j , k ) * dzfci ( k ) !tg3315 swapped dumu ( i , j , k - 1 ) = - cf * w0 ( i , j , k ) * dzfci ( k - 1 ) end do end do end do varp (:,:,:) = varp (:,:,:) + dumu (:,:,:) + duml (:,:,:) return end subroutine advecc_kappa !> Determination of the limiter function real function rlim ( d1 , d2 ) use modglobal , only : eps1 implicit none real , intent ( in ) :: d1 !< Scalar flux at 1.5 cells upwind real , intent ( in ) :: d2 !< Scalar flux at 0.5 cells upwind real ri , phir ri = ( d2 + eps1 ) / ( d1 + eps1 ) phir = max ( 0. , min ( 2. * ri , min ( 1. / 3. + 2. / 3. * ri , 2. ))) rlim = 0.5 * phir * d1 end function rlim","tags":"","url":"sourcefile/advec_kappa.f90.html"},{"title":"tstep.f90 – uDALES","text":"This file depends on sourcefile~~tstep.f90~~EfferentGraph sourcefile~tstep.f90 tstep.f90 sourcefile~modchem.f90 modchem.f90 sourcefile~tstep.f90->sourcefile~modchem.f90 sourcefile~modfields.f90 modfields.f90 sourcefile~tstep.f90->sourcefile~modfields.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~tstep.f90->sourcefile~modglobal.f90 sourcefile~modinletdata.f90 modinletdata.f90 sourcefile~tstep.f90->sourcefile~modinletdata.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~tstep.f90->sourcefile~modmpi.f90 sourcefile~modsubgriddata.f90 modsubgriddata.f90 sourcefile~tstep.f90->sourcefile~modsubgriddata.f90 sourcefile~modchem.f90->sourcefile~modfields.f90 sourcefile~modchem.f90->sourcefile~modglobal.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> \\file tstep.f90 !!  Performs the time integration !> !!  Performs the time integration !> !! Tstep uses adaptive timestepping and 3rd order Runge Kutta time integration. !! The adaptive timestepping chooses it's delta_t according to the courant number !! and the diffusion number, depending on the advection scheme in use. !! !!  \\author Jasper Tomas, TU Delft !!  \\author Chiel van Heerwaarden, Wageningen University !!  \\author Thijs Heus,MPI-M !! \\see Wicker and Skamarock 2002 !!  \\par Revision list !  This file is part of DALES. ! ! DALES is free software; you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation; either version 3 of the License, or ! (at your option) any later version. ! ! DALES is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !  Copyright 1993-2009 Delft University of Technology, Wageningen University, Utrecht University, KNMI ! !> Determine time step size dt in initialization and update time variables !! !! The size of the timestep Delta t is determined adaptively, and is limited by both the Courant-Friedrichs-Lewy criterion CFL !! \\latexonly !! \\begin{equation} !! \\CFL = \\mr{max}\\left(\\left|\\frac{u_i \\Delta t}{\\Delta x_i}\\right|\\right), !! \\end{equation} !! and the diffusion number $d$. The timestep is further limited by the needs of other modules, e.g. the statistics. !! \\endlatexonly subroutine tstep_update use modglobal , only : ib , ie , jb , je , rk3step , timee , runtime , dtmax , dt , ntimee , ntrun , courant , diffnr ,& kb , ke , dx , dxi , dx2i , dyi , dy2i , dzh , dt_lim , ladaptive , timeleft , dt , lwarmstart ,& dzh2i use modfields , only : um , vm , wm use modsubgriddata , only : ekm , ekh use modmpi , only : myid , comm3d , mpierr , mpi_max , my_real implicit none integer :: i , j , k , imin , kmin real , save :: courtot =- 1. , diffnrtot =- 1. real :: courtotl , courold , diffnrtotl , diffnrold !  logical,save  :: spinup=.true. logical , save :: spinup = . false . if ( lwarmstart ) spinup = . false . rk3step = mod ( rk3step , 3 ) + 1 if ( rk3step == 1 ) then ! Initialization if ( spinup ) then write ( 6 , * ) '!spinup!' if ( ladaptive ) then courold = courtot diffnrold = diffnrtot courtotl = 0. diffnrtotl = 0. do k = kb , ke do j = jb , je do i = ib , ie courtotl = max ( courtotl ,( abs ( um ( i , j , k )) * dxi + abs ( vm ( i , j , k )) * dyi + abs ( wm ( i , j , k )) / dzh ( k )) * dt ) !          diffnrtotl = max(diffnrtotl,  ekm(i,j,k)*(1/dzh(k)**2 + dxh2i(i) + dy2i)*dt ) diffnrtotl = max ( diffnrtotl , ekm ( i , j , k ) * ( dzh2i ( k ) + dx2i + dy2i ) * dt , & ekh ( i , j , k ) * ( dzh2i ( k ) + dx2i + dy2i ) * dt ) end do end do end do call MPI_ALLREDUCE ( courtotl , courtot , 1 , MY_REAL , MPI_MAX , comm3d , mpierr ) call MPI_ALLREDUCE ( diffnrtotl , diffnrtot , 1 , MY_REAL , MPI_MAX , comm3d , mpierr ) if ( diffnrold > 0 ) then dt = min ( dtmax , dt * courant / courtot , dt * diffnr / diffnrtot ) if (( abs ( courtot - courold ) / courold < 0.1 ) . and . ( abs ( diffnrtot - diffnrold ) / diffnrold < 0.1 )) then spinup = . false . end if end if dt = dt dt_lim = timeleft timee = timee + dt timeleft = timeleft - dt ntimee = ntimee + 1 ntrun = ntrun + 1 else dt = 2 * dt if ( dt >= dtmax ) then dt = dtmax spinup = . false . end if end if ! Normal time loop else !spinup = .false. if ( ladaptive ) then courtotl = 0. diffnrtotl = 1e-5 do k = kb , ke do j = jb , je do i = ib , ie courtotl = max ( courtotl ,( abs ( um ( i , j , k )) * dxi + abs ( vm ( i , j , k )) * dyi + abs ( wm ( i , j , k )) / dzh ( k )) * dt ) diffnrtotl = max ( diffnrtotl , ekm ( i , j , k ) * ( dzh2i ( k ) + dx2i + dy2i ) * dt ,& ekh ( i , j , k ) * ( dzh2i ( k ) + dx2i + dy2i ) * dt ) !          if (diffnrtotl ==  ekh(i,j,k)*(dzh2i(k) + dxh2i(i) + dy2i)*dt) then !           imin = i !           kmin = k !          end if end do end do end do !     write(6,*) 'Peclet criterion at proc,i,k = ', myid,imin,kmin call MPI_ALLREDUCE ( courtotl , courtot , 1 , MY_REAL , MPI_MAX , comm3d , mpierr ) call MPI_ALLREDUCE ( diffnrtotl , diffnrtot , 1 , MY_REAL , MPI_MAX , comm3d , mpierr ) if ( courtot <= 0 ) then write ( 6 , * ) 'courtot=0!' end if if ( diffnrtot <= 0 ) then write ( 6 , * ) 'diffnrtot=0!' end if dt = min ( dtmax , dt * courant / courtot , dt * diffnr / diffnrtot ) timeleft = timeleft - dt dt_lim = timeleft timee = timee + dt ntimee = ntimee + 1 ntrun = ntrun + 1 else dt = dtmax ntimee = ntimee + 1 ntrun = ntrun + 1 timee = timee + dt timeleft = timeleft - dt end if end if end if end subroutine tstep_update !> Time integration is done by a third order Runge-Kutta scheme. !! !! \\latexonly !! With $f&#94;n(\\phi&#94;n)$ the right-hand side of the appropriate equation for variable !! $\\phi=\\{\\fav{u},\\fav{v},\\fav{w},e&#94;{\\smfrac{1}{2}},\\fav{\\varphi}\\}$, $\\phi&#94;{n+1}$ !! at $t+\\Delta t$ is calculated in three steps: !! \\begin{eqnarray} !! \\phi&#94;{*} &=&\\phi&#94;n + \\frac{\\Delta t}{3}f&#94;n(\\phi&#94;n)\\nonumber\\\\\\\\ !! \\phi&#94;{**} &=&\\phi&#94;{n} + \\frac{\\Delta t}{2}f&#94;{*}(\\phi&#94;{*})\\nonumber\\\\\\\\ !! \\phi&#94;{n+1} &=&\\phi&#94;{n} + \\Delta t f&#94;{**}(\\phi&#94;{**}), !! \\end{eqnarray} !! with the asterisks denoting intermediate time steps. !! \\endlatexonly !! \\see Wicker and Skamarock, 2002 subroutine tstep_integrate use modglobal , only : ib , ie , jb , jgb , je , kb , ke , nsv , dt , rk3step , e12min , lmoist , timee , ntrun ,& linoutflow , iinletgen , ltempeq , idriver , BCtopm , BCtopm_pressure , BCxm_periodic , BCym_periodic , & dzf , dzhi , dzf , dxf , ifixuinf , thlsrc , lchem , ibrank , ierank , jerank , jbrank , BCxm , BCym , ihc , jhc , khc , dyi , dxfi , BCxT , BCxq , BCxs , BCyT , BCyq , BCys use modmpi , only : cmyid , myid , nprocs use modfields , only : u0 , um , up , v0 , vm , vp , w0 , wm , wp ,& thl0 , thlm , thlp , qt0 , qtm , qtp , e120 , e12m , e12p , sv0 , svm , svp , uouttot ,& wouttot , dpdxl , dgdt , momfluxb , tfluxb , qfluxb , thl0c use modinletdata , only : totalu , di_test , dr , thetar , thetai , displ , irecy , & dti_test , dtr , thetati , thetatr , q0 , lmoi , lmor , utaui , utaur ,& storetdriver , nstepread , nstepreaddriver , irecydriver use modsubgriddata , only : loneeqn , ekm , ekh use modchem , only : chem use decomp_2d , only : exchange_halo_z use modpois , only : pij , dpdztop implicit none integer i , j , k , n , m real rk3coef , rk3coefi rk3coef = dt / ( 4. - dble ( rk3step )) rk3coefi = 1. / rk3coef if ( ifixuinf == 2 ) then dpdxl (:) = dpdxl (:) + dgdt * rk3coef !    if(ltempeq) then !      thlsrc = thlsrc + thlsrcdt*rk3coef !    end if !    write(6,*) 'dpdx = ', dpdxl(kb) end if if ( loneeqn ) then do k = kb , ke do j = jb , je do i = ib , ie u0 ( i , j , k ) = um ( i , j , k ) + rk3coef * up ( i , j , k ) v0 ( i , j , k ) = vm ( i , j , k ) + rk3coef * vp ( i , j , k ) w0 ( i , j , k ) = wm ( i , j , k ) + rk3coef * wp ( i , j , k ) e120 ( i , j , k ) = e12m ( i , j , k ) + rk3coef * e12p ( i , j , k ) e120 ( i , j , k ) = max ( e12min , e120 ( i , j , k )) e12m ( i , j , k ) = max ( e12min , e12m ( i , j , k )) do n = 1 , nsv sv0 ( i , j , k , n ) = svm ( i , j , k , n ) + rk3coef * svp ( i , j , k , n ) enddo enddo enddo end do else do k = kb , ke do j = jb , je do i = ib , ie u0 ( i , j , k ) = um ( i , j , k ) + rk3coef * up ( i , j , k ) v0 ( i , j , k ) = vm ( i , j , k ) + rk3coef * vp ( i , j , k ) w0 ( i , j , k ) = wm ( i , j , k ) + rk3coef * wp ( i , j , k ) do n = 1 , nsv sv0 ( i , j , k , n ) = svm ( i , j , k , n ) + rk3coef * svp ( i , j , k , n ) enddo enddo enddo enddo end if if ( lchem . and . rk3coef == dt ) then call chem end if if ( ltempeq ) then do k = kb , ke do j = jb , je do i = ib , ie thl0 ( i , j , k ) = thlm ( i , j , k ) + rk3coef * thlp ( i , j , k ) enddo enddo enddo thl0c ( ib : ie , jb : je , kb : ke ) = thl0 ( ib : ie , jb : je , kb : ke ) end if if ( lmoist ) then do k = kb , ke do j = jb , je do i = ib , ie qt0 ( i , j , k ) = qtm ( i , j , k ) + rk3coef * qtp ( i , j , k ) enddo enddo enddo end if if (( BCxm . ne . BCxm_periodic ) . and . ierank ) then u0 ( ie + 1 , jb : je , kb : ke ) = um ( ie + 1 , jb : je , kb : ke ) + rk3coef * up ( ie + 1 , jb : je , kb : ke ) end if if (( BCym . ne . BCym_periodic ) . and . jerank ) then v0 ( ib : ie , je + 1 , kb : ke ) = vm ( ib : ie , je + 1 , kb : ke ) + rk3coef * vp ( ib : ie , je + 1 , kb : ke ) end if if ( BCtopm . eq . BCtopm_pressure ) then ! do i=ib,ie !   do j=jb,je !     ! w0(i,j,ke+1) = w0(i,j,ke) - dzhi(ke)*((u0(i+1,j,ke)-u0(i,j,ke))*dxfi(i) + & !     !                                       (v0(i,j+1,ke)-v0(i,j,ke))*dyi) !     ! if (myid ==0 .and. (i==32 .and. j==1)) write(*,*) rk3coefi*(w0(i,j,ke) - dzhi(ke)*((u0(i+1,j,ke)-u0(i,j,ke))*dxfi(i) + & !     ! (v0(i,j+1,ke)-v0(i,j,ke))*dyi) - wm(i,j,ke+1)), & !     ! dpdztop(i,j), & !     ! 2*pij(ke)*dzhi(ke+1) !     ! !     ! wp(i,j,ke+1) = rk3coefi*(w0(i,j,ke) - dzhi(ke)*((u0(i+1,j,ke)-u0(i,j,ke))*dxfi(i) + & !     !            (v0(i,j+1,ke)-v0(i,j,ke))*dyi) - wm(i,j,ke+1)) !     ! wp(i,j,ke+1) = 2*pij(ke)*dzhi(ke+1) !   end do ! end do w0 ( ib : ie , jb : je , ke + 1 ) = wm ( ib : ie , jb : je , ke + 1 ) + rk3coef * wp ( ib : ie , jb : je , ke + 1 ) end if !  Write some statistics to monitoring file if (( myid == 0 ) . and . ( rk3step == 3 )) then open ( unit = 11 , file = 'monitor' // cmyid // '.txt' , position = 'append' ) if ( iinletgen == 1 ) then write ( 11 , 3001 ) timee elseif ( idriver == 1 ) then write ( 11 , '(I4)' ) nstepreaddriver write ( 11 , 3001 ) timee , u0 ( irecydriver , 1 , 32 ) ! elseif (idriver == 2) then ! write(11, '(I4)') nstepreaddriver ! write(11, 3001) timee, storetdriver(nstepreaddriver), u0(irecydriver, 1, 32) else write ( 11 , 3001 ) timee end if 3001 format ( 13 ( 6e14 . 6 )) close ( 11 ) if ( ifixuinf == 2 ) then open ( unit = 11 , file = 'dpdx___.txt' , position = 'append' ) write ( 11 , 3002 ) timee , dpdxl ( kb ) 3002 format ( 13 ( 6e20 . 12 )) close ( 11 ) if ( ltempeq ) then open ( unit = 11 , file = 'thlsrc.txt' , position = 'append' ) write ( 11 , 3002 ) timee , thlsrc 3003 format ( 13 ( 6e20 . 12 )) close ( 11 ) end if end if endif up = 0. vp = 0. wp = 0. thlp = 0. svp = 0. e12p = 0. qtp = 0. if ( rk3step == 3 ) then um = u0 vm = v0 wm = w0 thlm = thl0 e12m = e120 svm = sv0 qtm = qt0 end if end subroutine tstep_integrate","tags":"","url":"sourcefile/tstep.f90.html"},{"title":"modstatsdump.f90 – uDALES","text":"This file depends on sourcefile~~modstatsdump.f90~~EfferentGraph sourcefile~modstatsdump.f90 modstatsdump.f90 sourcefile~modfields.f90 modfields.f90 sourcefile~modstatsdump.f90->sourcefile~modfields.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~modstatsdump.f90->sourcefile~modglobal.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~modstatsdump.f90->sourcefile~modmpi.f90 sourcefile~modstat_nc.f90 modstat_nc.f90 sourcefile~modstatsdump.f90->sourcefile~modstat_nc.f90 sourcefile~modstatistics.f90 modstatistics.f90 sourcefile~modstatsdump.f90->sourcefile~modstatistics.f90 sourcefile~modsubgrid.f90 modsubgrid.f90 sourcefile~modstatsdump.f90->sourcefile~modsubgrid.f90 sourcefile~modsurfdata.f90 modsurfdata.f90 sourcefile~modstatsdump.f90->sourcefile~modsurfdata.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 sourcefile~modstat_nc.f90->sourcefile~modglobal.f90 sourcefile~modstat_nc.f90->sourcefile~modmpi.f90 sourcefile~modstatistics.f90->sourcefile~modfields.f90 sourcefile~modstatistics.f90->sourcefile~modglobal.f90 sourcefile~modstatistics.f90->sourcefile~modmpi.f90 sourcefile~modstatistics.f90->sourcefile~modstat_nc.f90 sourcefile~modstatistics.f90->sourcefile~modsurfdata.f90 sourcefile~modsubgriddata.f90 modsubgriddata.f90 sourcefile~modstatistics.f90->sourcefile~modsubgriddata.f90 sourcefile~modsubgrid.f90->sourcefile~modfields.f90 sourcefile~modsubgrid.f90->sourcefile~modglobal.f90 sourcefile~modsubgrid.f90->sourcefile~modmpi.f90 sourcefile~modsubgrid.f90->sourcefile~modsurfdata.f90 sourcefile~modboundary.f90 modboundary.f90 sourcefile~modsubgrid.f90->sourcefile~modboundary.f90 sourcefile~modinletdata.f90 modinletdata.f90 sourcefile~modsubgrid.f90->sourcefile~modinletdata.f90 sourcefile~modsubgrid.f90->sourcefile~modsubgriddata.f90 sourcefile~modboundary.f90->sourcefile~modfields.f90 sourcefile~modboundary.f90->sourcefile~modglobal.f90 sourcefile~modboundary.f90->sourcefile~modmpi.f90 sourcefile~modboundary.f90->sourcefile~modsurfdata.f90 sourcefile~modboundary.f90->sourcefile~modinletdata.f90 sourcefile~modboundary.f90->sourcefile~modsubgriddata.f90 sourcefile~moddriver.f90 moddriver.f90 sourcefile~modboundary.f90->sourcefile~moddriver.f90 sourcefile~moddriver.f90->sourcefile~modfields.f90 sourcefile~moddriver.f90->sourcefile~modglobal.f90 sourcefile~moddriver.f90->sourcefile~modmpi.f90 sourcefile~moddriver.f90->sourcefile~modinletdata.f90 sourcefile~modsave.f90 modsave.f90 sourcefile~moddriver.f90->sourcefile~modsave.f90 sourcefile~modsave.f90->sourcefile~modfields.f90 sourcefile~modsave.f90->sourcefile~modglobal.f90 sourcefile~modsave.f90->sourcefile~modmpi.f90 sourcefile~modsave.f90->sourcefile~modsurfdata.f90 sourcefile~modsave.f90->sourcefile~modinletdata.f90 sourcefile~modsave.f90->sourcefile~modsubgriddata.f90 sourcefile~initfac.f90 initfac.f90 sourcefile~modsave.f90->sourcefile~initfac.f90 sourcefile~modibmdata.f90 modibmdata.f90 sourcefile~modsave.f90->sourcefile~modibmdata.f90 sourcefile~initfac.f90->sourcefile~modglobal.f90 sourcefile~initfac.f90->sourcefile~modmpi.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~modstatsdump.f90~~AfferentGraph sourcefile~modstatsdump.f90 modstatsdump.f90 sourcefile~program.f90 program.f90 sourcefile~program.f90->sourcefile~modstatsdump.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> \\file modstatsdump.f90 !!  Dumps statistics of various fields !> !!  \\author Tom Grylls, ICL May 25 2016 ! !  This file is part of uDALES. ! ! This program is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! This program is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !  Copyright 2006-2021 the uDALES Team. ! module modstatsdump use mpi use modglobal , only : dt , lydump , lytdump , ltkedump , lxydump , lxytdump , ltdump , lmintdump , ifoutput !,nstat use modmpi , only : myid implicit none private PUBLIC :: initstatsdump , statsdump , exitstatsdump save !NetCDF variables integer :: ncidy , ncidyt , ncidtke , ncidxy , ncidkslice , ncidislice , ncidjslice , ncidxyt , ncidtr , nrecy = 0 , nrecyt = 0 , nrectke = 0 , nrecxy = 0 ,& nreckslice = 0 , nrecislice = 0 , nrecjslice = 0 , nrecxyt = 0 , nrectr = 0 , nstatyt = 34 , nstaty = 14 , nstattke = 8 , nstatxy = 15 , nstatkslice = 5 , nstatislice = 5 , nstatjslice = 5 ,& nstatxyt = 23 , ncidt , nrect = 0 , nstatt = 32 , nstattr = 10 , ncidmint , nrecmint = 0 , nstatmint = 6 character ( 80 ) :: yname = 'ydump.xxx.nc' character ( 80 ) :: ytname = 'ytdump.xxx.nc' character ( 80 ) :: tkename = 'tkedump.xxx.nc' character ( 80 ) :: xyname = 'xydump.xxx.nc' character ( 80 ) :: xytname = 'xytdump.xxx.nc' character ( 80 ) :: tname = 'tdump.xxx.xxx.xxx.nc' character ( 80 ) :: mintname = 'mintdump.xxx.xxx.xxx.nc' character ( 80 ) :: kslicename = 'kslicedump.xxx.xxx.xxx.nc' character ( 80 ) :: islicename = 'islicedump.xxx.xxx.xxx.nc' character ( 80 ) :: jslicename = 'jslicedump.xxx.xxx.xxx.nc' character ( 80 ) :: trname = 'treedump.xxx.xxx.xxx.nc' character ( 80 ), dimension ( 1 , 4 ) :: tncstaty character ( 80 ), dimension ( 1 , 4 ) :: tncstatyt character ( 80 ), dimension ( 1 , 4 ) :: tncstattke character ( 80 ), dimension ( 1 , 4 ) :: tncstatxy character ( 80 ), dimension ( 1 , 4 ) :: tncstatkslice character ( 80 ), dimension ( 1 , 4 ) :: tncstatislice character ( 80 ), dimension ( 1 , 4 ) :: tncstatjslice character ( 80 ), dimension ( 1 , 4 ) :: tncstatxyt character ( 80 ), dimension ( 1 , 4 ) :: tncstatt character ( 80 ), dimension ( 1 , 4 ) :: tncstattr character ( 80 ), dimension ( 1 , 4 ) :: tncstatmint integer :: klow , khigh , i , j , k real :: tsamplep , tstatsdumpp , tsample , tstatsdump contains !-------------------------- !> Initializing statsdump. Read out the namelist, initializing the variables !------------------------- subroutine initstatsdump use modmpi , only : my_real , mpierr , comm3d , mpi_logical , mpi_integer , mpi_character , cmyid , cmyidx , cmyidy use modglobal , only : imax , jmax , kmax , cexpnr , ifnamopt , fname_options , ib , ie , jb , je , kb , ke , ladaptive , btime ,& nsv , lkslicedump , lislicedump , ljslicedump , ltreedump , ib , ie , islice , islicerank , isliceloc , jslice , jslicerank , jsliceloc use modstat_nc , only : open_nc , define_nc , ncinfo , writestat_dims_nc use modfields , only : ncstaty , ncstatyt , ncstattke , ncstatxy , ncstatkslice , ncstatislice , ncstatjslice , ncstatxyt , ncstatt , ncstattr , ncstatmint use decomp_2d , only : zstart , zend implicit none integer :: ierr namelist / NAMSTATSDUMP / & lydump , tsample , klow , khigh , tstatsdump , lytdump , ltkedump , lxydump , lxytdump , ltdump , ltreedump , lmintdump ! maybe removed; NAMSTATSDUMP is not in use anymore allocate ( ncstaty ( nstaty , 4 )) allocate ( ncstatyt ( nstatyt , 4 )) allocate ( ncstattke ( nstattke , 4 )) allocate ( ncstatxy ( nstatxy , 4 )) allocate ( ncstatkslice ( nstatkslice , 4 )) allocate ( ncstatislice ( nstatislice , 4 )) allocate ( ncstatjslice ( nstatjslice , 4 )) allocate ( ncstatxyt ( nstatxyt , 4 )) allocate ( ncstatt ( nstatt , 4 )) allocate ( ncstattr ( nstattr , 4 )) allocate ( ncstatmint ( nstatmint , 4 )) klow = kb khigh = ke if ( myid == 0 ) then open ( ifnamopt , file = fname_options , status = 'old' , iostat = ierr ) read ( ifnamopt , NAMSTATSDUMP , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions NAMSTATSDUMP' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif !write(6 ,NAMSTATSDUMP) close ( ifnamopt ) end if call MPI_BCAST ( klow , 1 , MPI_INTEGER , 0 , comm3d , ierr ) !have to do this? just want nc for first CPU call MPI_BCAST ( khigh , 1 , MPI_INTEGER , 0 , comm3d , ierr ) call MPI_BCAST ( nstatt , 1 , MPI_INTEGER , 0 , comm3d , ierr ) call MPI_BCAST ( nstatmint , 1 , MPI_INTEGER , 0 , comm3d , ierr ) ! call MPI_BCAST(nstaty      ,1,MPI_INTEGER,0,comm3d,ierr) call MPI_BCAST ( ncstatyt , 80 , MPI_CHARACTER , 0 , comm3d , mpierr ) call MPI_BCAST ( ncstaty , 80 , MPI_CHARACTER , 0 , comm3d , mpierr ) call MPI_BCAST ( ncstattke , 80 , MPI_CHARACTER , 0 , comm3d , mpierr ) call MPI_BCAST ( ncstatxy , 80 , MPI_CHARACTER , 0 , comm3d , mpierr ) call MPI_BCAST ( ncstatxyt , 80 , MPI_CHARACTER , 0 , comm3d , mpierr ) call MPI_BCAST ( ncstatt , 80 , MPI_CHARACTER , 0 , comm3d , mpierr ) call MPI_BCAST ( ncstatmint , 80 , MPI_CHARACTER , 0 , comm3d , mpierr ) !call MPI_BCAST(ltdump      ,1,MPI_LOGICAL,0,comm3d,ierr)      ! maybe removed; unnecessary broadcast; this variable already broadcasted in modstartup !call MPI_BCAST(ltreedump   ,1,MPI_LOGICAL,0,comm3d,ierr)      ! maybe removed; unnecessary broadcast; this variable already broadcasted in modstartup call MPI_BCAST ( lmintdump , 1 , MPI_LOGICAL , 0 , comm3d , ierr ) !> Generate y-averaged NetCDF: ydump.xxx.nc if ( lydump ) then yname ( 7 : 9 ) = cexpnr call ncinfo ( tncstaty ( 1 ,:), 'time' , 'Time' , 's' , 'time' ) call ncinfo ( ncstaty ( 1 ,:), 'uy' , 'Streamwise velocity' , 'm/s' , 'm0tt' ) call ncinfo ( ncstaty ( 2 ,:), 'vy' , 'Spanwise velocity' , 'm/s' , 't0tt' ) call ncinfo ( ncstaty ( 3 ,:), 'wy' , 'Vertical velocity' , 'm/s' , 't0mt' ) call ncinfo ( ncstaty ( 4 ,:), 'thly' , 'Temperature' , 'K' , 't0tt' ) call ncinfo ( ncstaty ( 5 ,:), 'qty' , 'Moisture' , 'kg/kg' , 't0tt' ) call ncinfo ( ncstaty ( 6 ,:), 'sca1y' , 'Scalar field 1' , 'kg/m&#94;3' , 't0tt' ) call ncinfo ( ncstaty ( 7 ,:), 'sca2y' , 'Scalar field 2' , 'kg/m&#94;3' , 't0tt' ) call ncinfo ( ncstaty ( 8 ,:), 'sca3y' , 'Scalar field 3' , 'kg/m&#94;3' , 't0tt' ) call ncinfo ( ncstaty ( 9 ,:), 'upwpy' , 'Turbulent mom. flux' , 'm&#94;2/s&#94;2' , 'm0mt' ) call ncinfo ( ncstaty ( 10 ,:), 'wpthlpy' , 'Turbulent heat flux' , 'K m/s' , 't0mt' ) call ncinfo ( ncstaty ( 11 ,:), 'usgsy' , 'SGS mom. flux' , 'm&#94;2/s&#94;2' , 'm0mt' ) call ncinfo ( ncstaty ( 12 ,:), 'thlsgsy' , 'SGS heat flux' , 'K m/s' , 't0mt' ) call ncinfo ( ncstaty ( 13 ,:), 'uwyik' , 'Advective mom. flux' , 'm&#94;2/s&#94;2' , 'm0mt' ) call ncinfo ( ncstaty ( 14 ,:), 'wthlyk' , 'Advective heat flux' , 'K m/s' , 't0mt' ) if ( myid == 0 ) then call open_nc ( yname , ncidy , nrecy , n1 = imax , n3 = khigh - klow + 1 ) if ( nrecy == 0 ) then call define_nc ( ncidy , 1 , tncstaty ) call writestat_dims_nc ( ncidy ) end if call define_nc ( ncidy , nstaty , ncstaty ) endif !myid==0 endif !> Generate time and y averaged NetCDF: ytdump.xxx.nc if ( lytdump ) then ytname ( 8 : 10 ) = cexpnr call ncinfo ( tncstatyt ( 1 ,:), 'time' , 'Sampling time' , 's' , 'time' ) call ncinfo ( ncstatyt ( 1 ,:), 'uyt' , 'Streamwise velocity' , 'm/s' , 'm0tt' ) call ncinfo ( ncstatyt ( 2 ,:), 'vyt' , 'Spanwise velocity' , 'm/s' , 't0tt' ) call ncinfo ( ncstatyt ( 3 ,:), 'wyt' , 'Vertical velocity' , 'm/s' , 't0mt' ) call ncinfo ( ncstatyt ( 4 ,:), 'thlyt' , 'Temperature' , 'K' , 't0tt' ) call ncinfo ( ncstatyt ( 5 ,:), 'qtyt' , 'Moisture' , 'kg/kg' , 't0tt' ) call ncinfo ( ncstatyt ( 6 ,:), 'sca1yt' , 'Scalar field 1' , 'kg/m&#94;3' , 't0tt' ) call ncinfo ( ncstatyt ( 7 ,:), 'sca2yt' , 'Scalar field 2' , 'kg/m&#94;3' , 't0tt' ) call ncinfo ( ncstatyt ( 8 ,:), 'sca3yt' , 'Scalar field 3' , 'kg/m&#94;3' , 't0tt' ) call ncinfo ( ncstatyt ( 9 ,:), 'upwpyt' , 'Turbulent mom. flux' , 'm&#94;2/s&#94;2' , 'm0mt' ) call ncinfo ( ncstatyt ( 10 ,:), 'wpthlpyt' , 'Turbulent heat flux' , 'K m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 11 ,:), 'wpqtpyt' , 'Turbulent moisture flux' , 'kg/kg m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 12 ,:), 'wpsca1tpyt' , 'Turbulent scalar flux' , 'M m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 13 ,:), 'wpsca2tpyt' , 'Turbulent scalar flux' , 'M m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 14 ,:), 'wpsca3tpyt' , 'Turbulent scalar flux' , 'M m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 15 ,:), 'uwyt' , 'Kinematic mom. flux' , 'm&#94;2/s&#94;2' , 'm0mt' ) call ncinfo ( ncstatyt ( 16 ,:), 'wthlyt' , 'Kinematic heat flux' , 'K m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 17 ,:), 'wqtyt' , 'Kinematic moisture flux' , 'K m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 18 ,:), 'wsca1yt' , 'Kinematic scalar flux' , 'K m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 19 ,:), 'wsca2yt' , 'Kinematic scalar flux' , 'K m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 20 ,:), 'wsca3yt' , 'Kinematic scalar flux' , 'K m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 21 ,:), 'upupyt' , 'mom. variance' , 'm&#94;2/s&#94;2' , 't0tt' ) call ncinfo ( ncstatyt ( 22 ,:), 'wpwpyt' , 'mom. variance' , 'm&#94;2/s&#94;2' , 't0tt' ) call ncinfo ( ncstatyt ( 23 ,:), 'thlpthlpyt' , 'temp. variance' , 'K&#94;2' , 't0tt' ) call ncinfo ( ncstatyt ( 24 ,:), 'qtpqtpyt' , 'moisture. variance' , 'kg&#94;2/kg&#94;2' , 't0tt' ) call ncinfo ( ncstatyt ( 25 ,:), 'sca1tpsca1pyt' , 'scalar. variance' , 'M&#94;2' , 't0tt' ) call ncinfo ( ncstatyt ( 26 ,:), 'sca2tpsca2pyt' , 'scalar. variance' , 'M&#94;2' , 't0tt' ) call ncinfo ( ncstatyt ( 27 ,:), 'sca3tpsca3pyt' , 'scalar. variance' , 'M&#94;2' , 't0tt' ) call ncinfo ( ncstatyt ( 28 ,:), 'usgsyt' , 'SGS mom. flux' , 'm&#94;2/s&#94;2' , 'm0mt' ) call ncinfo ( ncstatyt ( 29 ,:), 'wsgsyt' , 'SGS mom. flux' , 'm&#94;2/s&#94;2' , 't0mt' ) call ncinfo ( ncstatyt ( 30 ,:), 'thlsgsyt' , 'SGS heat flux' , 'K m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 31 ,:), 'qtsgsyt' , 'SGS moisture flux' , 'kg/kg m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 32 ,:), 'sca1sgsyt' , 'SGS scalar flux' , 'M m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 33 ,:), 'sca2sgsyt' , 'SGS scalar flux' , 'M m/s' , 't0mt' ) call ncinfo ( ncstatyt ( 34 ,:), 'sca3sgsyt' , 'SGS scalar flux' , 'M m/s' , 't0mt' ) if ( myid == 0 ) then call open_nc ( ytname , ncidyt , nrecyt , n1 = imax , n3 = khigh - klow + 1 ) if ( nrecyt == 0 ) then call define_nc ( ncidyt , 1 , tncstatyt ) call writestat_dims_nc ( ncidyt ) end if call define_nc ( ncidyt , nstatyt , ncstatyt ) endif !myid==0 endif !> Generate y and x averaged NetCDF: xydump.xxx.nc if ( lxydump ) then xyname ( 8 : 10 ) = cexpnr call ncinfo ( tncstatxy ( 1 ,:), 'time' , 'Time' , 's' , 'time' ) call ncinfo ( ncstatxy ( 1 ,:), 'uxy' , 'Streamwise velocity' , 'm/s' , 'tt' ) call ncinfo ( ncstatxy ( 2 ,:), 'vxy' , 'Spanwise velocity' , 'm/s' , 'tt' ) call ncinfo ( ncstatxy ( 3 ,:), 'wxy' , 'Vertical velocity' , 'm/s' , 'mt' ) call ncinfo ( ncstatxy ( 4 ,:), 'thlxy' , 'Temperature' , 'K' , 'tt' ) call ncinfo ( ncstatxy ( 5 ,:), 'qtxy' , 'Moisture' , 'kg/kg' , 'tt' ) call ncinfo ( ncstatxy ( 6 ,:), 'pxy' , 'Pressure' , 'm&#94;2/s&#94;2' , 'tt' ) call ncinfo ( ncstatxy ( 7 ,:), 'upwpxy' , 'Mom. flux' , 'm&#94;2/s&#94;2' , 'mt' ) call ncinfo ( ncstatxy ( 8 ,:), 'wpthlpxy' , 'Heat flux' , 'Km/s' , 'mt' ) call ncinfo ( ncstatxy ( 9 ,:), 'vpwpxy' , 'Mom. flux' , 'Km/s' , 'mt' ) call ncinfo ( ncstatxy ( 10 ,:), 'usgsxy' , 'SGS mom. flux' , 'm&#94;2/s&#94;2' , 'mt' ) call ncinfo ( ncstatxy ( 11 ,:), 'thlsgsxy' , 'SGS heat flux' , 'Km/s' , 'mt' ) call ncinfo ( ncstatxy ( 12 ,:), 'vsgsxy' , 'SGS mom. flux' , 'm&#94;2/s&#94;2' , 'mt' ) call ncinfo ( ncstatxy ( 13 ,:), 'uwxyik' , 'Advective mom. flux' , 'm&#94;2/s&#94;2' , 'mt' ) call ncinfo ( ncstatxy ( 14 ,:), 'wthlxy' , 'Advective heat flux' , 'K m/s' , 'mt' ) call ncinfo ( ncstatxy ( 15 ,:), 'vwxy' , 'Advective mom. flux' , 'm&#94;2/s&#94;2' , 'mt' ) if ( myid == 0 ) then call open_nc ( xyname , ncidxy , nrecxy , n3 = khigh - klow + 1 ) if ( nrecxy == 0 ) then call define_nc ( ncidxy , 1 , tncstatxy ) call writestat_dims_nc ( ncidxy ) end if call define_nc ( ncidxy , nstatxy , ncstatxy ) end if end if !> Generate time, y and x averaged NetCDF: xytdump.xxx.nc if ( lxytdump ) then xytname ( 9 : 11 ) = cexpnr call ncinfo ( tncstatxyt ( 1 ,:), 'time' , 'Time' , 's' , 'time' ) call ncinfo ( ncstatxyt ( 1 ,:), 'uxyt' , 'Streamwise velocity' , 'm/s' , 'tt' ) call ncinfo ( ncstatxyt ( 2 ,:), 'vxyt' , 'Spanwise velocity' , 'm/s' , 'tt' ) call ncinfo ( ncstatxyt ( 3 ,:), 'wxyt' , 'Vertical velocity' , 'm/s' , 'mt' ) call ncinfo ( ncstatxyt ( 4 ,:), 'thlxyt' , 'Temperature' , 'K' , 'tt' ) call ncinfo ( ncstatxyt ( 5 ,:), 'qtxyt' , 'Moisture' , 'kg/kg' , 'tt' ) call ncinfo ( ncstatxyt ( 6 ,:), 'pxyt' , 'Pressure' , 'm&#94;2/s&#94;2' , 'tt' ) call ncinfo ( ncstatxyt ( 7 ,:), 'upwpxyt' , 'Turbulent mom. flux' , 'm&#94;2/s&#94;2' , 'mt' ) call ncinfo ( ncstatxyt ( 8 ,:), 'wpthlpxyt' , 'Turbulent heat flux' , 'K m/s' , 'mt' ) call ncinfo ( ncstatxyt ( 9 ,:), 'vpwpxyt' , 'Turbulent mom. flux' , 'm&#94;2/s&#94;2' , 'mt' ) call ncinfo ( ncstatxyt ( 10 ,:), 'upvpxyt' , 'Turbulent mom. flux' , 'm&#94;2/s&#94;2' , 'mt' ) call ncinfo ( ncstatxyt ( 11 ,:), 'uwxyt' , 'Kinematic mom. flux' , 'm&#94;2/s&#94;2' , 'mt' ) call ncinfo ( ncstatxyt ( 12 ,:), 'wthlxyt' , 'Kinematic heat flux' , 'K m/s' , 'mt' ) call ncinfo ( ncstatxyt ( 13 ,:), 'uvxyt' , 'Kinematic mom. flux' , 'm&#94;2/s&#94;2' , 'mt' ) call ncinfo ( ncstatxyt ( 14 ,:), 'vwxyt' , 'Kinematic mom. flux' , 'm&#94;2/s&#94;2' , 'mt' ) call ncinfo ( ncstatxyt ( 15 ,:), 'wwxyt' , 'Kinematic mom. flux' , 'm&#94;2/s&#94;2' , 'mt' ) call ncinfo ( ncstatxyt ( 16 ,:), 'usgsxyt' , 'SGS mom. flux' , 'm&#94;2/s&#94;2' , 'mt' ) call ncinfo ( ncstatxyt ( 17 ,:), 'thlsgsxyt' , 'SGS heat flux' , 'K m/s' , 'mt' ) call ncinfo ( ncstatxyt ( 18 ,:), 'vsgsxyt' , 'SGS mom. flux' , 'K m/s' , 'mt' ) call ncinfo ( ncstatxyt ( 19 ,:), 'thlpthlptxy' , 'Temp. variance' , 'K&#94;2' , 'tt' ) call ncinfo ( ncstatxyt ( 20 ,:), 'upuptxyc' , 'u variance' , 'm&#94;2/s&#94;2' , 'tt' ) call ncinfo ( ncstatxyt ( 21 ,:), 'vpvptxyc' , 'v variance' , 'm&#94;2/s&#94;2' , 'tt' ) call ncinfo ( ncstatxyt ( 22 ,:), 'wpwptxyc' , 'w variance' , 'm&#94;2/s&#94;2' , 'tt' ) call ncinfo ( ncstatxyt ( 23 ,:), 'tketxyc' , 'tke' , 'm&#94;2/s&#94;2' , 'tt' ) if ( myid == 0 ) then call open_nc ( xytname , ncidxyt , nrecxyt , n3 = khigh - klow + 1 ) if ( nrecxyt == 0 ) then call define_nc ( ncidxyt , 1 , tncstatxyt ) call writestat_dims_nc ( ncidxyt ) end if call define_nc ( ncidxyt , nstatxyt , ncstatxyt ) end if end if !> Generate time averaged NetCDF: tdump.xxx.nc if ( ltdump ) then tname ( 7 : 9 ) = cmyidx tname ( 11 : 13 ) = cmyidy tname ( 15 : 17 ) = cexpnr call ncinfo ( tncstatt ( 1 ,:), 'time' , 'Time' , 's' , 'time' ) call ncinfo ( ncstatt ( 1 ,:), 'ut' , 'Streamwise velocity' , 'm/s' , 'mttt' ) call ncinfo ( ncstatt ( 2 ,:), 'vt' , 'Spanwise velocity' , 'm/s' , 'tmtt' ) call ncinfo ( ncstatt ( 3 ,:), 'wt' , 'Vertical velocity' , 'm/s' , 'ttmt' ) call ncinfo ( ncstatt ( 4 ,:), 'thlt' , 'Temperature' , 'K' , 'tttt' ) call ncinfo ( ncstatt ( 5 ,:), 'qtt' , 'Moisture' , 'kg/kg' , 'tttt' ) call ncinfo ( ncstatt ( 6 ,:), 'pt' , 'Pressure' , 'm&#94;2/s&#94;2' , 'tttt' ) call ncinfo ( ncstatt ( 7 ,:), 'sca1t' , 'Concentration field 1' , 'g/m&#94;3' , 'tttt' ) call ncinfo ( ncstatt ( 8 ,:), 'sca2t' , 'Concentration field 2' , 'g/m&#94;3' , 'tttt' ) call ncinfo ( ncstatt ( 9 ,:), 'sca3t' , 'Concentration field 3' , 'g/m&#94;3' , 'tttt' ) call ncinfo ( ncstatt ( 10 ,:), 'sca4t' , 'Concentration field 4' , 'g/m&#94;3' , 'tttt' ) call ncinfo ( ncstatt ( 11 ,:), 'PSS' , 'PSS defect' , 'gm/s' , 'tttt' ) call ncinfo ( ncstatt ( 12 ,:), 'upwpt' , 'Turbulent momentum flux' , 'm&#94;2/s&#94;2' , 'mtmt' ) call ncinfo ( ncstatt ( 13 ,:), 'vpwpt' , 'Turbulent momentum flux' , 'm&#94;2/s&#94;2' , 'tmmt' ) call ncinfo ( ncstatt ( 14 ,:), 'upvpt' , 'Turbulent momentum flux' , 'm&#94;2/s&#94;2' , 'mmtt' ) call ncinfo ( ncstatt ( 15 ,:), 'wpthlpt' , 'Turbulent heat flux' , 'K m/s' , 'ttmt' ) call ncinfo ( ncstatt ( 16 ,:), 'wpsca1pt' , 'Turbulent flux 1' , 'gm/s' , 'ttmt' ) call ncinfo ( ncstatt ( 17 ,:), 'wpsca2pt' , 'Turbulent flux 2' , 'gm/s' , 'ttmt' ) call ncinfo ( ncstatt ( 18 ,:), 'wpsca3pt' , 'Turbulent flux 3' , 'gm/s' , 'ttmt' ) call ncinfo ( ncstatt ( 19 ,:), 'wpsca4pt' , 'Turbulent flux 4' , 'gm/s' , 'ttmt' ) call ncinfo ( ncstatt ( 20 ,:), 'thlpthlpt' , 'Temperature variance' , 'K&#94;2' , 'tttt' ) call ncinfo ( ncstatt ( 21 ,:), 'upuptc' , 'u variance' , 'm&#94;2/s&#94;2' , 'tttt' ) call ncinfo ( ncstatt ( 22 ,:), 'vpvptc' , 'v variance' , 'm&#94;2/s&#94;2' , 'tttt' ) call ncinfo ( ncstatt ( 23 ,:), 'wpwptc' , 'w variance' , 'm&#94;2/s&#94;2' , 'tttt' ) call ncinfo ( ncstatt ( 24 ,:), 'tketc' , 'TKE' , 'm&#94;2/s&#94;2' , 'tttt' ) call ncinfo ( ncstatt ( 25 ,:), 'sca1psca1pt' , 'Concentration variance 1' , 'g&#94;2/m&#94;6' , 'tttt' ) call ncinfo ( ncstatt ( 26 ,:), 'sca2psca2pt' , 'Concentration variance 2' , 'g&#94;2/m&#94;6' , 'tttt' ) call ncinfo ( ncstatt ( 27 ,:), 'sca3psca3pt' , 'Concentration variance 3' , 'g&#94;2/m&#94;6' , 'tttt' ) call ncinfo ( ncstatt ( 28 ,:), 'sca4psca4pt' , 'Concentration variance 4' , 'g&#94;2/m&#94;6' , 'tttt' ) call ncinfo ( ncstatt ( 29 ,:), 'sv1sgs' , 'SGS flux 1' , 'gm/s' , 'ttmt' ) call ncinfo ( ncstatt ( 30 ,:), 'sv2sgs' , 'SGS flux 2' , 'gm/s' , 'ttmt' ) call ncinfo ( ncstatt ( 31 ,:), 'sv3sgs' , 'SGS flux 3' , 'gm/s' , 'ttmt' ) call ncinfo ( ncstatt ( 32 ,:), 'sv4sgs' , 'SGS flux 4' , 'gm/s' , 'ttmt' ) ! call ncinfo(ncstatt(33,:),'sca1t_max','Max concentration field 1'   ,'g/m&#94;3'  ,'tttt'  ) ! call ncinfo(ncstatt(34,:),'sca2t_max','Max concentration field 2'   ,'g/m&#94;3'  ,'tttt'  ) ! call ncinfo(ncstatt(35,:),'sca3t_max','Max concentration field 3'   ,'g/m&#94;3'  ,'tttt'  ) ! call ncinfo(ncstatt(36,:),'sca4t_max','Max concentration field 4'   ,'g/m&#94;3'  ,'tttt'  ) !      if (myid==0) then call open_nc ( tname , ncidt , nrect , n1 = imax , n2 = jmax , n3 = khigh - klow + 1 ) if ( nrect == 0 ) then call define_nc ( ncidt , 1 , tncstatt ) call writestat_dims_nc ( ncidt ) end if call define_nc ( ncidt , nstatt , ncstatt ) !      end if end if if ( lmintdump ) then mintname ( 10 : 12 ) = cmyidx mintname ( 14 : 16 ) = cmyidy mintname ( 18 : 20 ) = cexpnr call ncinfo ( tncstatmint ( 1 ,:), 'time' , 'Time' , 's' , 'time' ) call ncinfo ( ncstatmint ( 1 ,:), 'ut' , 'Streamwise velocity' , 'm/s' , 'mttt' ) call ncinfo ( ncstatmint ( 2 ,:), 'vt' , 'Spanwise velocity' , 'm/s' , 'tmtt' ) call ncinfo ( ncstatmint ( 3 ,:), 'wt' , 'Vertical velocity' , 'm/s' , 'ttmt' ) call ncinfo ( ncstatmint ( 4 ,:), 'thlt' , 'Temperature' , 'K' , 'tttt' ) call ncinfo ( ncstatmint ( 5 ,:), 'qtt' , 'Moisture' , 'kg/kg' , 'tttt' ) call ncinfo ( ncstatmint ( 6 ,:), 'pt' , 'Pressure' , 'm&#94;2/s&#94;2' , 'tttt' ) !      if (myid==0) then call open_nc ( mintname , ncidmint , nrecmint , n1 = imax , n2 = jmax , n3 = khigh - klow + 1 ) if ( nrecmint == 0 ) then call define_nc ( ncidmint , 1 , tncstatmint ) call writestat_dims_nc ( ncidmint ) end if call define_nc ( ncidmint , nstatmint , ncstatmint ) !      end if end if !> Generate time averaged NetCDF: treedump.xxx.nc if ( ltreedump ) then trname ( 10 : 12 ) = cmyidx trname ( 14 : 16 ) = cmyidy trname ( 18 : 20 ) = cexpnr call ncinfo ( tncstattr ( 1 ,:), 'time' , 'Time' , 's' , 'time' ) call ncinfo ( ncstattr ( 1 ,:), 'tr_u' , 'Drag in x' , 'm/s&#94;2' , 'tttt' ) call ncinfo ( ncstattr ( 2 ,:), 'tr_v' , 'Drag in y' , 'm/s&#94;2' , 'tttt' ) call ncinfo ( ncstattr ( 3 ,:), 'tr_w' , 'Drag in z' , 'm/s&#94;2' , 'ttmt' ) call ncinfo ( ncstattr ( 4 ,:), 'tr_thl' , 'Temp source/ sink' , 'K/s' , 'tttt' ) call ncinfo ( ncstattr ( 5 ,:), 'tr_qt' , 'Moisture source sink' , '1/s' , 'tttt' ) call ncinfo ( ncstattr ( 6 ,:), 'tr_qtR' , 'Moisture source sink' , '1/s' , 'tttt' ) call ncinfo ( ncstattr ( 7 ,:), 'tr_qtA' , 'Moisture source sink' , '1/s' , 'tttt' ) call ncinfo ( ncstattr ( 8 ,:), 'tr_sv1' , 'Scalar source sink' , 'kg/m&#94;3s' , 'tttt' ) call ncinfo ( ncstattr ( 9 ,:), 'tr_sv2' , 'Scalar source sink' , 'kg/m&#94;3s' , 'tttt' ) call ncinfo ( ncstattr ( 10 ,:), 'tr_omega' , 'Decoupling factor' , '-' , 'tttt' ) !      if (myid==0) then call open_nc ( trname , ncidtr , nrectr , n1 = imax , n2 = jmax , n3 = khigh - klow + 1 ) if ( nrectr == 0 ) then call define_nc ( ncidtr , 1 , tncstattr ) call writestat_dims_nc ( ncidtr ) end if call define_nc ( ncidtr , nstattr , ncstattr ) !      end if end if !> Generate time, y and x averaged NetCDF for tke budget: tkedump.xxx.nc if ( ltkedump ) then tkename ( 9 : 11 ) = cexpnr call ncinfo ( tncstattke ( 1 ,:), 'time' , 'Time' , 's' , 'time' ) call ncinfo ( ncstattke ( 1 ,:), 'p_b' , 'p_bant production or consumption term' , 'm&#94;2/s&#94;3' , 'tt' ) call ncinfo ( ncstattke ( 2 ,:), 't_p' , 'total viscous transport (?)' , 'm&#94;2/s&#94;3' , 'tt' ) call ncinfo ( ncstattke ( 3 ,:), 'adv' , 'Advection by mean wind' , 'm&#94;2/s&#94;3' , 'tt' ) call ncinfo ( ncstattke ( 4 ,:), 't_t' , 'Total turb???' , 'm&#94;2/s&#94;3' , 'tt' ) call ncinfo ( ncstattke ( 5 ,:), 't_sgs' , 'total SGS  term' , 'm&#94;2/s&#94;3' , 'tt' ) call ncinfo ( ncstattke ( 6 ,:), 'p_t' , 'Shear production term' , 'm&#94;2/s&#94;3' , 'tt' ) call ncinfo ( ncstattke ( 7 ,:), 't_v' , 'Resolved viscous dissipation term' , 'm&#94;2/s&#94;3' , 'tt' ) call ncinfo ( ncstattke ( 8 ,:), 'd_sgs' , 'SGS dissipation term' , 'm&#94;2/s&#94;3' , 'tt' ) if ( myid == 0 ) then call open_nc ( tkename , ncidtke , nrectke , n3 = khigh - klow + 1 ) if ( nrectke == 0 ) then call define_nc ( ncidtke , 1 , tncstattke ) call writestat_dims_nc ( ncidtke ) end if call define_nc ( ncidtke , nstattke , ncstattke ) endif !myid==0 endif !> Generate sliced NetCDF: slicedump.xxx.xxx.nc if ( lkslicedump ) then kslicename ( 12 : 14 ) = cmyidx kslicename ( 16 : 18 ) = cmyidy kslicename ( 20 : 22 ) = cexpnr call ncinfo ( tncstatkslice ( 1 ,:), 'time' , 'Time' , 's' , 'time' ) call ncinfo ( ncstatkslice ( 1 ,:), 'u_kslice' , 'Streamwise velocity at kslice' , '-' , 'mt0t' ) call ncinfo ( ncstatkslice ( 2 ,:), 'v_kslice' , 'Spanwise velocity at kslice' , '-' , 'tm0t' ) call ncinfo ( ncstatkslice ( 3 ,:), 'w_kslice' , 'Vertical velocity at kslice' , '-' , 'tt0t' ) call ncinfo ( ncstatkslice ( 4 ,:), 'thl_kslice' , 'Potential temperature at kslice' , '-' , 'tt0t' ) call ncinfo ( ncstatkslice ( 5 ,:), 'qt_kslice' , 'Specific humidity at kslice' , '-' , 'tt0t' ) call open_nc ( kslicename , ncidkslice , nreckslice , n1 = imax , n2 = jmax ) if ( nreckslice == 0 ) then call define_nc ( ncidkslice , 1 , tncstatkslice ) call writestat_dims_nc ( ncidkslice ) end if call define_nc ( ncidkslice , nstatkslice , ncstatkslice ) end if if ( lislicedump ) then islicename ( 12 : 14 ) = cmyidx islicename ( 16 : 18 ) = cmyidy islicename ( 20 : 22 ) = cexpnr call ncinfo ( tncstatislice ( 1 ,:), 'time' , 'Time' , 's' , 'time' ) call ncinfo ( ncstatislice ( 1 ,:), 'u_islice' , 'Streamwise velocity at islice' , '-' , '0ttt' ) call ncinfo ( ncstatislice ( 2 ,:), 'v_islice' , 'Spanwise velocity at islice' , '-' , '0mtt' ) call ncinfo ( ncstatislice ( 3 ,:), 'w_islice' , 'Vertical velocity at islice' , '-' , '0tmt' ) call ncinfo ( ncstatislice ( 4 ,:), 'thl_islice' , 'Potential temperature at islice' , '-' , '0ttt' ) call ncinfo ( ncstatislice ( 5 ,:), 'qt_islice' , 'Specific humidity at islice' , '-' , '0ttt' ) if (( islice >= zstart ( 1 )) . and . ( islice <= zend ( 1 ))) then islicerank = . true . isliceloc = islice - zstart ( 1 ) + 1 else islicerank = . false . end if if ( islicerank ) then call open_nc ( islicename , ncidislice , nrecislice , n2 = jmax , n3 = khigh - klow + 1 ) if ( nrecislice == 0 ) then call define_nc ( ncidislice , 1 , tncstatislice ) call writestat_dims_nc ( ncidislice ) end if call define_nc ( ncidislice , nstatislice , ncstatislice ) end if end if if ( ljslicedump ) then jslicename ( 12 : 14 ) = cmyidx jslicename ( 16 : 18 ) = cmyidy jslicename ( 20 : 22 ) = cexpnr call ncinfo ( tncstatjslice ( 1 ,:), 'time' , 'Time' , 's' , 'time' ) call ncinfo ( ncstatjslice ( 1 ,:), 'u_jslice' , 'Streamwise velocity at jslice' , '-' , 'm0tt' ) call ncinfo ( ncstatjslice ( 2 ,:), 'v_jslice' , 'Spanwise velocity at jslice' , '-' , 't0tt' ) call ncinfo ( ncstatjslice ( 3 ,:), 'w_jslice' , 'Vertical velocity at jslice' , '-' , 't0mt' ) call ncinfo ( ncstatjslice ( 4 ,:), 'thl_jslice' , 'Potential temperature at jslice' , '-' , 't0tt' ) call ncinfo ( ncstatjslice ( 5 ,:), 'qt_jslice' , 'Specific humidity at jslice' , '-' , 't0tt' ) if (( jslice >= zstart ( 2 )) . and . ( jslice <= zend ( 2 ))) then jslicerank = . true . jsliceloc = jslice - zstart ( 2 ) + 1 else jslicerank = . false . end if if ( jslicerank ) then call open_nc ( jslicename , ncidjslice , nrecjslice , n1 = imax , n3 = khigh - klow + 1 ) if ( nrecjslice == 0 ) then call define_nc ( ncidjslice , 1 , tncstatjslice ) call writestat_dims_nc ( ncidjslice ) end if call define_nc ( ncidjslice , nstatjslice , ncstatjslice ) end if end if !> Set times to zero so works for warm starts... could have issues with warmstarts here... tsamplep = 0. tstatsdumpp = 0. end subroutine initstatsdump !------------------------- !> Generate and write statistics into NetCDF file format !------------------------- subroutine statsdump use modfields , only : um , up , vm , wm , svm , qtm , thlm , pres0 , ncstaty , ncstatxy , ncstatyt , ncstattke , ncstatmint ,& ncstatkslice , ncstatislice , ncstatjslice , t_t , t_v , t_p , t_sgs , d_sgs , p_b , p_t , adv ,& IIc , IIu , IIv , IIw , IIuw , IIvw , IIct , IIwt , IIut , IIvt , IIuwt , IIuv ,& IIcs , IIws , IIus , IIvs , IIuws , IIvws , IIuvs ,& vyt , uyt , wyt , thlyt , qtyt ,& sca1yt , sca2yt , sca3yt , thlsgsyt , qtsgsyt , sv1sgsyt , sv2sgsyt , sv3sgsyt , usgsyt , wsgsyt ,& usgsxyt , thlsgsxyt , vsgsxyt , uwtik , vwtjk , uvtij , utik , wtik , wtjk , vtjk , utij , vtij ,& wthltk , wqttk , thlthlt , qtqtt , sv1sv1t , sv2sv2t , sv3sv3t , sv4sv4t , wmt , thltk , qttk , thlt , uxyt , vxyt , wxyt , thlxyt ,& ncstatxyt , qtxyt , pxyt , ncstatt , uutc , vvtc , wwtc , utc , vtc , wtc ,& umt , vmt , sv1t , sv2t , sv3t , sv4t , sv1tk , sv2tk , sv3tk , sv4tk , wsv1tk , wsv2tk , wsv3tk , wsv4tk ,& sv1sgst , sv2sgst , sv3sgst , sv4sgst , qtt , pt , PSSt ,& !,sv1max,sv2max,sv3max,sv4max ncstattr , tr_u , tr_ut , tr_v , tr_vt , tr_w , tr_wt , tr_thl , tr_thlt , tr_qt , tr_qtR ,& tr_qtA , tr_qtt , tr_qtRt , tr_qtAt , tr_sv , tr_sv1t , PSSt , tr_sv2t , tr_omega , tr_omegat use modglobal , only : ib , ie , ih , ihc , xf , xh , jb , je , jhc , jgb , jge , dy , dyi , jh , ke , kb , kh , khc , rk3step ,& timee , cexpnr , tsample , tstatsdump , tstatstart , jtot , imax , jmax , dzf ,& ltempeq , zh , dxf , dzf , dzh2i , lprofforc , lscasrcl ,& lkslicedump , lislicedump , ljslicedump , lchem , dzhi , dzfi , dzhiq , dxhi , lmoist , nsv ,& k1 , JNO2 , lchem , kslice , islice , jslice , isliceloc , jsliceloc , islicerank , jslicerank ,& ltreedump !  use modsubgriddata,   only : ekm,sbshr use modstat_nc , only : writestat_nc , writestat_1D_nc use modmpi , only : myid , cmyid , my_real , mpi_sum , avey_ibm , mpierr ,& comm3d , avexy_ibm , nprocs use modsurfdata , only : thls use modsubgrid , only : ekh , ekm use modstatistics , only : genstats , tkestats implicit none !> Create fields to be used in statistics ! interpolated fields !  real, dimension(ib:ie,jb:je,kb:ke)     :: umc !  real, dimension(ib:ie,jb:je,kb:ke)     :: vmc !  real, dimension(ib:ie,jb:je,kb:ke)     :: wmc ! real, dimension(ib:ie,jb:je,kb:ke+kh)     :: thlk ! real, dimension(ib:ie,jb:je,kb:ke+kh)     :: qtk ! real, dimension(ib:ie,jb:je,kb:ke+kh)     :: uik ! real, dimension(ib:ie,jb:je,kb:ke+kh)     :: wik ! real, dimension(ib:ie,jb:je,kb:ke+kh)     :: vjk ! real, dimension(ib:ie,jb:je,kb:ke+kh)     :: wjk ! real, dimension(ib:ie,jb:je,kb:ke+kh)     :: uij ! real, dimension(ib:ie,jb:je,kb:ke+kh)     :: vij ! real, dimension(ib:ie,jb:je,kb:ke+kh)     :: uc ! real, dimension(ib:ie,jb:je,kb:ke+kh)     :: vc ! real, dimension(ib:ie,jb:je,kb:ke+kh)     :: wc real , allocatable :: thlk (:,:,:) real , allocatable :: qtk (:,:,:) real , allocatable :: uik (:,:,:) real , allocatable :: wik (:,:,:) real , allocatable :: vjk (:,:,:) real , allocatable :: wjk (:,:,:) real , allocatable :: uij (:,:,:) real , allocatable :: vij (:,:,:) real , allocatable :: uc (:,:,:) real , allocatable :: vc (:,:,:) real , allocatable :: wc (:,:,:) ! SGS fluxes ! real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh)     :: thlsgs ! real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh)     :: qtsgs ! real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh)     :: usgs ! real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh)     :: vsgs ! real, dimension(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh)     :: wsgs real , allocatable :: thlsgs (:,:,:) real , allocatable :: qtsgs (:,:,:) real , allocatable :: usgs (:,:,:) real , allocatable :: vsgs (:,:,:) real , allocatable :: wsgs (:,:,:) ! t-averaged fields ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: sv1k ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: sv2k ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: sv3k ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: sv4k ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: wpsv1p ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: wpsv2p ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: wpsv3p ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: wpsv4p ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: sv1sgs ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: sv2sgs ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: sv3sgs ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: sv4sgs real , allocatable :: sv1k (:,:,:) real , allocatable :: sv2k (:,:,:) real , allocatable :: sv3k (:,:,:) real , allocatable :: sv4k (:,:,:) real , allocatable :: sv1sgs (:,:,:) real , allocatable :: sv2sgs (:,:,:) real , allocatable :: sv3sgs (:,:,:) real , allocatable :: sv4sgs (:,:,:) real , allocatable :: wpsv1p (:,:,:) real , allocatable :: wpsv2p (:,:,:) real , allocatable :: wpsv3p (:,:,:) real , allocatable :: wpsv4p (:,:,:) real , allocatable :: sv1psv1pt (:,:,:) real , allocatable :: sv2psv2pt (:,:,:) real , allocatable :: sv3psv3pt (:,:,:) real , allocatable :: sv4psv4pt (:,:,:) real , allocatable :: PSS (:,:,:) ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: upwptik ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: vpwptjk ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: upvptij ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: wpthlptk ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: thlpthlpt ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: upuptc ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: vpvptc ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: wpwptc ! real, dimension(ib:ie,jb:je,kb:ke+kh)        :: tketc real , allocatable :: upwptik (:,:,:) real , allocatable :: vpwptjk (:,:,:) real , allocatable :: upvptij (:,:,:) real , allocatable :: wpthlptk (:,:,:) real , allocatable :: thlpthlpt (:,:,:) real , allocatable :: upuptc (:,:,:) real , allocatable :: vpvptc (:,:,:) real , allocatable :: wpwptc (:,:,:) real , allocatable :: tketc (:,:,:) ! y-averaged fields real , dimension ( ib : ie , kb : ke ) :: uy real , dimension ( ib : ie , kb : ke ) :: vy real , dimension ( ib : ie , kb : ke ) :: wy real , dimension ( ib : ie , kb : ke ) :: thly real , dimension ( ib : ie , kb : ke ) :: qty real , dimension ( ib : ie , kb : ke ) :: sca1y real , dimension ( ib : ie , kb : ke ) :: sca2y real , dimension ( ib : ie , kb : ke ) :: sca3y real , dimension ( ib : ie , kb : ke ) :: usgsy real , dimension ( ib : ie , kb : ke ) :: wsgsy real , dimension ( ib : ie , kb : ke ) :: thlsgsy real , dimension ( ib : ie , kb : ke ) :: qtsgsy real , dimension ( ib : ie , kb : ke ) :: sv1sgsy real , dimension ( ib : ie , kb : ke ) :: sv2sgsy real , dimension ( ib : ie , kb : ke ) :: sv3sgsy real , dimension ( ib : ie , kb : ke ) :: uwyik real , dimension ( ib : ie , kb : ke ) :: wthlyk real , dimension ( ib : ie , kb : ke ) :: wqtyk ! real, dimension(ib:ie,kb:ke)                 :: wsv1yk ! real, dimension(ib:ie,kb:ke)                 :: wsv2yk real , dimension ( ib : ie , kb : ke ) :: wyik real , dimension ( ib : ie , kb : ke ) :: uyik real , dimension ( ib : ie , kb : ke ) :: thlyk real , dimension ( ib : ie , kb : ke ) :: upwpyik real , dimension ( ib : ie , kb : ke ) :: wpthlpyk ! ty-averaged fluxes real , dimension ( ib : ie , kb : ke ) :: upwptyik real , dimension ( ib : ie , kb : ke ) :: wpthlptyk real , dimension ( ib : ie , kb : ke ) :: wpqtptyk real , dimension ( ib : ie , kb : ke ) :: wpsv1ptyk real , dimension ( ib : ie , kb : ke ) :: wpsv2ptyk real , dimension ( ib : ie , kb : ke ) :: wpsv3ptyk real , dimension ( ib : ie , kb : ke ) :: upuptyc real , dimension ( ib : ie , kb : ke ) :: vpvptyc real , dimension ( ib : ie , kb : ke ) :: wpwptyc real , dimension ( ib : ie , kb : ke ) :: qtpqtpty real , dimension ( ib : ie , kb : ke ) :: thlpthlpty real , dimension ( ib : ie , kb : ke ) :: sv1psv1pty real , dimension ( ib : ie , kb : ke ) :: sv2psv2pty real , dimension ( ib : ie , kb : ke ) :: sv3psv3pty real , dimension ( ib : ie , kb : ke ) :: uwtyik real , dimension ( ib : ie , kb : ke ) :: wthltyk real , dimension ( ib : ie , kb : ke ) :: wqttyk real , dimension ( ib : ie , kb : ke ) :: wsv1tyk real , dimension ( ib : ie , kb : ke ) :: wsv2tyk real , dimension ( ib : ie , kb : ke ) :: wsv3tyk ! xy-averaged fields real , dimension ( kb : ke + kh ) :: uxy real , dimension ( kb : ke + kh ) :: vxy real , dimension ( kb : ke + kh ) :: wxy real , dimension ( kb : ke + kh ) :: thlxy real , dimension ( kb : ke + kh ) :: qtxy real , dimension ( kb : ke + kh ) :: pxy real , dimension ( kb : ke + kh ) :: usgsxy real , dimension ( kb : ke + kh ) :: thlsgsxy real , dimension ( kb : ke + kh ) :: vsgsxy real , dimension ( kb : ke + kh ) :: sca1xy real , dimension ( kb : ke + kh ) :: uwxyik real , dimension ( kb : ke + kh ) :: vwxyjk real , dimension ( kb : ke + kh ) :: wthlxyk real , dimension ( kb : ke + kh ) :: thlxyk real , dimension ( kb : ke + kh ) :: wxyik real , dimension ( kb : ke + kh ) :: uxyik real , dimension ( kb : ke + kh ) :: vxyjk real , dimension ( kb : ke + kh ) :: wxyjk real , dimension ( kb : ke + kh ) :: upwpxyik real , dimension ( kb : ke + kh ) :: wpthlpxyk real , dimension ( kb : ke + kh ) :: vpwpxyjk ! txy-averaged fields real , dimension ( kb : ke + kh ) :: upwptxyik real , dimension ( kb : ke + kh ) :: wpthlptxyk real , dimension ( kb : ke + kh ) :: thlpthlptxy real , dimension ( kb : ke + kh ) :: upuptxyc real , dimension ( kb : ke + kh ) :: vpvptxyc real , dimension ( kb : ke + kh ) :: wpwptxyc real , dimension ( kb : ke + kh ) :: tketxyc real , dimension ( kb : ke + kh ) :: vpwptxyjk real , dimension ( kb : ke + kh ) :: upvptxyij real , dimension ( kb : ke + kh ) :: uwtxyik real , dimension ( kb : ke + kh ) :: wthltxyk real , dimension ( kb : ke + kh ) :: vwtxyjk real , dimension ( kb : ke + kh ) :: wwtxyk real , dimension ( kb : ke + kh ) :: uvtxyij real , allocatable :: field (:,:), varsy (:,:,:), varsyt (:,:,:), varstke (:,:), varsxy (:,:),& varkslice (:,:,:), varislice (:,:,:), varjslice (:,:,:), varsxyt (:,:), varst (:,:,:,:), varstr (:,:,:,:), varsmint (:,:,:,:) real :: tstatsdumppi , emom integer :: i , j , k , ip , im , jp , jm , kp , km integer :: writecounter = 1 integer :: reclength if ( timee < tstatstart ) return if (. not .( lytdump . or . lydump . or . lxydump . or . lxytdump . or . ltdump . or . lmintdump & . or . lkslicedump . or . lislicedump . or . ljslicedump )) return allocate ( thlk ( ib : ie , jb : je , kb : ke + kh )) allocate ( qtk ( ib : ie , jb : je , kb : ke + kh )) allocate ( uik ( ib : ie , jb : je , kb : ke + kh )) allocate ( wik ( ib : ie , jb : je , kb : ke + kh )) allocate ( vjk ( ib : ie , jb : je , kb : ke + kh )) allocate ( wjk ( ib : ie , jb : je , kb : ke + kh )) allocate ( uij ( ib : ie , jb : je , kb : ke + kh )) allocate ( vij ( ib : ie , jb : je , kb : ke + kh )) allocate ( uc ( ib : ie , jb : je , kb : ke + kh )) allocate ( vc ( ib : ie , jb : je , kb : ke + kh )) allocate ( wc ( ib : ie , jb : je , kb : ke + kh )) allocate ( thlsgs ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( qtsgs ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( usgs ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( vsgs ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( wsgs ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( sv1k ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv2k ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv3k ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv4k ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv1sgs ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv2sgs ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv3sgs ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv4sgs ( ib : ie , jb : je , kb : ke + kh )) allocate ( wpsv1p ( ib : ie , jb : je , kb : ke + kh )) allocate ( wpsv2p ( ib : ie , jb : je , kb : ke + kh )) allocate ( wpsv3p ( ib : ie , jb : je , kb : ke + kh )) allocate ( wpsv4p ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv1psv1pt ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv2psv2pt ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv3psv3pt ( ib : ie , jb : je , kb : ke + kh )) allocate ( sv4psv4pt ( ib : ie , jb : je , kb : ke + kh )) allocate ( PSS ( ib : ie , jb : je , kb : ke + kh )) allocate ( upwptik ( ib : ie , jb : je , kb : ke + kh )) allocate ( vpwptjk ( ib : ie , jb : je , kb : ke + kh )) allocate ( upvptij ( ib : ie , jb : je , kb : ke + kh )) allocate ( wpthlptk ( ib : ie , jb : je , kb : ke + kh )) allocate ( thlpthlpt ( ib : ie , jb : je , kb : ke + kh )) allocate ( upuptc ( ib : ie , jb : je , kb : ke + kh )) allocate ( vpvptc ( ib : ie , jb : je , kb : ke + kh )) allocate ( wpwptc ( ib : ie , jb : je , kb : ke + kh )) allocate ( tketc ( ib : ie , jb : je , kb : ke + kh )) ! thlk=0.;qtk=0.;uik=0.;wik=0.;vjk=0.;wjk=0.;uij=0.;vij=0.;uc=0.;vc=0.;wc=0.;thlsgs=0.;qtsgs=0.;usgs=0.;vsgs=0.;wsgs=0.;sv1k=0.;sv2k=0.;sv3k=0.;sv4k=0.;sv1sgs=0.;sv2sgs=0.;sv3sgs=0.;sv4sgs=0.;wpsv1p=0.;wpsv2p=0. ! wpsv3p=0.;wpsv4p=0.;sv1psv1pt=0.;sv2psv2pt=0.;sv3psv3pt=0.;sv4psv4pt=0.;PSS=0.;upwptik=0.;vpwptjk=0.;upvptij=0.;wpthlptk=0.;thlpthlpt=0.;upuptc=0.;vpvptc=0.;wpwptc=0.;tketc=0. ! upwptyik=0.;wpthlptyk=0.;wpqtptyk=0.;wpsv1ptyk=0.;wpsv2ptyk=0.;wpsv3ptyk=0.;uwtyik=0.;wthltyk=0.;wqttyk=0.;wsv1tyk=0.;wsv2tyk=0.;wsv3tyk=0.;upuptyc=0.;wpwptyc=0.;thlpthlpty=0. ! qtpqtpty=0.;sv1psv1pty=0.;sv2psv2pty=0.;sv3psv3pty=0. if (. not . rk3step == 3 ) return if ( tsamplep > tsample ) then if ( lytdump . or . lydump . or . lxydump . or . lxytdump . or . ltdump . or . lmintdump ) then ! wpthlptyk=0.;wpqtptyk=0.;wpsv1ptyk=0.;wpsv2ptyk=0. tstatsdumppi = 1. / tstatsdumpp !> Perform required interpolations for flux calculations !  tg3315 for non-equidistant x and z-grids this needs to change do k = kb , ke + kh do j = jb , je do i = ib , ie uik ( i , j , k ) = 0.5 * dzhi ( k ) * ( um ( i , j , k ) * dzf ( k - 1 ) + um ( i , j , k - 1 ) * dzf ( k )) wik ( i , j , k ) = 0.5 * dxhi ( i ) * ( wm ( i , j , k ) * dxf ( i - 1 ) + wm ( i - 1 , j , k ) * dxf ( i )) vjk ( i , j , k ) = 0.5 * dzhi ( k ) * ( vm ( i , j , k ) * dzf ( k - 1 ) + vm ( i , j , k - 1 ) * dzf ( k )) wjk ( i , j , k ) = 0.5 * ( wm ( i , j , k ) + wm ( i , j - 1 , k )) uij ( i , j , k ) = 0.5 * ( um ( i , j , k ) + um ( i , j - 1 , k )) vij ( i , j , k ) = 0.5 * dxhi ( i ) * ( vm ( i , j , k ) * dxf ( i - 1 ) + vm ( i - 1 , j , k ) * dxf ( i )) uc ( i , j , k ) = 0.5 * dxhi ( i ) * ( um ( i , j , k ) * dxf ( i - 1 ) + um ( i - 1 , j , k ) * dxf ( i )) vc ( i , j , k ) = 0.5 * ( vm ( i , j , k ) + vm ( i , j - 1 , k )) wc ( i , j , k ) = 0.5 * ( wm ( i , j , k + 1 ) + wm ( i , j , k ) ) ! SGS fluxes ! interps ekm to cell corner (uw) emom = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) * dxf ( i - 1 ) + ekm ( i - 1 , j , k ) * dxf ( i ) ) + & dzf ( k ) * ( ekm ( i , j , k - 1 ) * dxf ( i - 1 ) + ekm ( i - 1 , j , k - 1 ) * dxf ( i ) ) ) * dxhi ( i ) * dzhiq ( k ) usgs ( i , j , k ) = emom * ( ( um ( i , j , k ) - um ( i , j , k - 1 )) * dzhi ( k ) & + ( wm ( i , j , k ) - wm ( i - 1 , j , k )) * dxhi ( i )) ! interps ekm to cell corner (vw) emom = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) + ekm ( i , j - 1 , k ) ) + & dzf ( k ) * ( ekm ( i , j , k - 1 ) + ekm ( i , j - 1 , k - 1 ) ) ) * dzhiq ( k ) vsgs ( i , j , k ) = emom * ( ( vm ( i , j , k ) - vm ( i , j , k - 1 )) * dzhi ( k ) & + ( wm ( i , j , k ) - wm ( i , j - 1 , k )) * dyi ) end do end do end do do k = kb , ke do j = jb , je do i = ib , ie wsgs ( i , j , k ) = ( ekm ( i , j , k ) * ( wm ( i , j , k + 1 ) - wm ( i , j , k )) * dzfi ( k ) & - ekm ( i , j , k - 1 ) * ( wm ( i , j , k ) - wm ( i , j , k - 1 )) * dzfi ( k - 1 ) ) * 2. & * dzhi ( k ) ! tg3315 check this end do end do end do if ( ltempeq ) then do k = kb , ke + kh do j = jb , je do i = ib , ie thlk ( i , j , k ) = 0.5 * dzhi ( k ) * ( thlm ( i , j , k ) * dzf ( k - 1 ) + thlm ( i , j , k - 1 ) * dzf ( k )) end do end do end do do k = kb , ke !> SGS fluxes thlsgs (:,:, k ) = 0.5 * ( dzf ( k - 1 ) * ekh (:,:, k ) + dzf ( k ) * ekh (:,:, k - 1 )) & * ( thlm (:,:, k ) - thlm (:,:, k - 1 )) * dzh2i ( k ) end do end if if ( lmoist ) then do k = kb , ke + kh do j = jb , je do i = ib , ie qtk ( i , j , k ) = 0.5 * dzhi ( k ) * ( qtm ( i , j , k ) * dzf ( k - 1 ) + qtm ( i , j , k - 1 ) * dzf ( k )) end do end do end do do k = kb , ke !> SGS fluxes qtsgs (:,:, k ) = 0.5 * ( dzf ( k - 1 ) * ekh (:,:, k ) + dzf ( k ) * ekh (:,:, k - 1 )) & * ( qtm (:,:, k ) - qtm (:,:, k - 1 )) * dzh2i ( k ) end do end if if ( nsv > 0 ) then do k = kb , ke do j = jb , je do i = ib , ie sv1k ( i , j , k ) = 0.5 * dzhi ( k ) * ( svm ( i , j , k , 1 ) * dzf ( k - 1 ) + svm ( i , j , k - 1 , 1 ) * dzf ( k )) end do end do end do do k = kb , ke sv1sgs ( ib : ie , jb : je , k ) = 0.5 * ( dzf ( k - 1 ) * ekh ( ib : ie , jb : je , k ) + dzf ( k ) * ekh ( ib : ie , jb : je , k - 1 )) & * ( svm ( ib : ie , jb : je , k , 1 ) - svm ( ib : ie , jb : je , k - 1 , 1 )) * dzh2i ( k ) end do end if if ( nsv > 1 ) then do k = kb , ke + kh do j = jb , je do i = ib , ie sv2k ( i , j , k ) = 0.5 * dzhi ( k ) * ( svm ( i , j , k , 2 ) * dzf ( k - 1 ) + svm ( i , j , k - 1 , 2 ) * dzf ( k )) end do end do end do do k = kb , ke sv2sgs ( ib : ie , jb : je , k ) = 0.5 * ( dzf ( k - 1 ) * ekh ( ib : ie , jb : je , k ) + dzf ( k ) * ekh ( ib : ie , jb : je , k - 1 )) & * ( svm ( ib : ie , jb : je , k , 2 ) - svm ( ib : ie , jb : je , k - 1 , 2 )) * dzh2i ( k ) end do end if if ( nsv > 2 ) then do k = kb , ke + kh do j = jb , je do i = ib , ie sv3k ( i , j , k ) = 0.5 * dzhi ( k ) * ( svm ( i , j , k , 3 ) * dzf ( k - 1 ) + svm ( i , j , k - 1 , 3 ) * dzf ( k )) end do end do end do do k = kb , ke sv3sgs ( ib : ie , jb : je , k ) = 0.5 * ( dzf ( k - 1 ) * ekh ( ib : ie , jb : je , k ) + dzf ( k ) * ekh ( ib : ie , jb : je , k - 1 )) & * ( svm ( ib : ie , jb : je , k , 3 ) - svm ( ib : ie , jb : je , k - 1 , 3 )) * dzh2i ( k ) end do end if if ( nsv > 3 ) then do k = kb , ke + kh do j = jb , je do i = ib , ie sv4k ( i , j , k ) = 0.5 * dzhi ( k ) * ( svm ( i , j , k , 4 ) * dzf ( k - 1 ) + svm ( i , j , k - 1 , 4 ) * dzf ( k )) end do end do end do do k = kb , ke sv4sgs ( ib : ie , jb : je , k ) = 0.5 * ( dzf ( k - 1 ) * ekh ( ib : ie , jb : je , k ) + dzf ( k ) * ekh ( ib : ie , jb : je , k - 1 )) & * ( svm ( ib : ie , jb : je , k , 4 ) - svm ( ib : ie , jb : je , k - 1 , 4 )) * dzh2i ( k ) end do end if if (( nsv > 2 ) . and . ( lchem . eqv . . true .)) then do k = kb , ke do j = jb , je do i = ib , ie if (( ABS ( svm ( i , j , k , 2 )) . gt . 1.e-40 ) . and . ( IIc ( i , j , k ) == 1 )) then PSS ( i , j , k ) = ( ( ( k1 * ( svm ( i , j , k , 1 ) / 3 0. ) * ( svm ( i , j , k , 3 ) / 4 8. )) / ( JNO2 * ( svm ( i , j , k , 2 ) / 4 6. )) ) - 1 ) * 100 end if end do end do end do end if !!>> CALCS FOR INST. STATS !> Note: More computationally efficient to spatially average mean quantities first & !        for time dependant stats, hence the .or.s. Assuming homogeneity in y. !> Average in y-direction if ( lydump . or . lytdump ) then uy = 0. ; vy = 0. ; wy = 0. ; uwyik = 0. ; usgsy = 0. ; wsgsy = 0. ; thly = 0. ; wthlyk = 0. ; thlsgsy = 0. qty = 0. ; wqtyk = 0. ; qtsgsy = 0. ; sca1y = 0. ; sv1sgsy = 0. ; sv2sgsy = 0. ; sca2y = 0. ; sca3y = 0. ; sv3sgsy = 0. call avey_ibm ( uy , um ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIu ( ib : ie , jb : je , kb : ke ), IIut ( ib : ie , kb : ke )) call avey_ibm ( vy , vm ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIv ( ib : ie , jb : je , kb : ke ), IIvt ( ib : ie , kb : ke )) call avey_ibm ( wy , wm ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( uwyik , uik ( ib : ie , jb : je , kb : ke ) * wik ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIuw ( ib : ie , jb : je , kb : ke ), IIuwt ( ib : ie , kb : ke )) call avey_ibm ( usgsy , usgs ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIuw ( ib : ie , jb : je , kb : ke ), IIuwt ( ib : ie , kb : ke )) call avey_ibm ( wsgsy , wsgs ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) if ( ltempeq ) then call avey_ibm ( thly , thlm ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke ), IIct ( ib : ie , kb : ke )) call avey_ibm ( wthlyk , wm ( ib : ie , jb : je , kb : ke ) * thlk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( thlsgsy , thlsgs ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) end if if ( lmoist ) then call avey_ibm ( qty , qtm ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke ), IIct ( ib : ie , kb : ke )) call avey_ibm ( wqtyk , wm ( ib : ie , jb : je , kb : ke ) * qtk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( qtsgsy , qtsgs ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) end if if ( nsv > 0 ) then call avey_ibm ( sca1y , svm ( ib : ie , jb : je , kb : ke , 1 ), ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke ), IIct ( ib : ie , kb : ke )) ! call avey_ibm(wsv1yk,wm(ib:ie,jb:je,kb:ke)*sv1k(ib:ie,jb:je,kb:ke),ib,ie,jb,je,kb,ke,IIw(ib:ie,jb:je,kb:ke),IIwt(ib:ie,kb:ke)) call avey_ibm ( sv1sgsy , sv1sgs ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) end if if ( nsv > 1 ) then call avey_ibm ( sca2y , svm ( ib : ie , jb : je , kb : ke , 2 ), ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke ), IIct ( ib : ie , kb : ke )) ! call avey_ibm(wsv2yk,wm(ib:ie,jb:je,kb:ke)*sv2k(ib:ie,jb:je,kb:ke),ib,ie,jb,je,kb,ke,IIw(ib:ie,jb:je,kb:ke),IIwt(ib:ie,kb:ke)) call avey_ibm ( sv2sgsy , sv2sgs ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) end if if ( nsv > 2 ) then call avey_ibm ( sca3y , svm ( ib : ie , jb : je , kb : ke , 3 ), ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke ), IIct ( ib : ie , kb : ke )) call avey_ibm ( sv3sgsy , sv3sgs ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) end if end if ! lydump .or. lytdump if ( lydump ) then uwyik = 0. ; wthlyk = 0. ; uyik = 0. ; wyik = 0. ; thlyk = 0. ; wpthlpyk = 0. call avey_ibm ( uwyik , uik ( ib : ie , jb : je , kb : ke ) * wik ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIuw ( ib : ie , jb : je , kb : ke ), IIuwt ( ib : ie , kb : ke )) call avey_ibm ( uyik , uik ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIuw ( ib : ie , jb : je , kb : ke ), IIuwt ( ib : ie , kb : ke )) call avey_ibm ( wyik , wik ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIuw ( ib : ie , jb : je , kb : ke ), IIuwt ( ib : ie , kb : ke )) if ( ltempeq ) then call avey_ibm ( wthlyk , wm ( ib : ie , jb : je , kb : ke ) * thlk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( thlyk , thlk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) end if upwpyik = uwyik - uyik * wyik if ( ltempeq ) then wpthlpyk = wthlyk - wy * thlyk where ( IIwt == 0 ) wpthlpyk = - 99 9.0 endwhere end if where ( IIuwt == 0 ) upwpyik = - 99 9.0 endwhere end if ! lydump !> tg3315 10.07.18 - in any case where averaging spatially can assume homogeneity and therefore average !  spatially first? Perhaps not due to UCL...? Would save space but goes against triple decomposition !  definition !> Average in x and y-direction if ( lxydump . or . lxytdump ) then uxy = 0. ; vxy = 0. ; wxy = 0. ; thlxy = 0. ; qtxy = 0. ; pxy = 0. ; usgsxy = 0. ; thlsgsxy = 0. ; sca1xy = 0. ; vsgsxy = 0. !> Spatial averages of mean quantities call avexy_ibm ( uxy ( kb : ke + kh ), um ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIu ( ib : ie , jb : je , kb : ke + kh ), IIus ( kb : ke + kh ),. false .) call avexy_ibm ( vxy ( kb : ke + kh ), vm ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIv ( ib : ie , jb : je , kb : ke + kh ), IIvs ( kb : ke + kh ),. false .) call avexy_ibm ( wxy ( kb : ke + kh ), wm ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIw ( ib : ie , jb : je , kb : ke + kh ), IIws ( kb : ke + kh ),. false .) if ( ltempeq ) then call avexy_ibm ( thlxy ( kb : ke + kh ), thlm ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) call avexy_ibm ( thlsgsxy ( kb : ke + kh ), thlsgs ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIw ( ib : ie , jb : je , kb : ke + kh ), IIws ( kb : ke + kh ),. false .) end if if ( lmoist ) then call avexy_ibm ( qtxy ( kb : ke + kh ), qtm ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) end if call avexy_ibm ( pxy ( kb : ke + kh ), pres0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) call avexy_ibm ( usgsxy ( kb : ke + kh ), usgs ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIuw ( ib : ie , jb : je , kb : ke + kh ), IIuws ( kb : ke + kh ),. false .) call avexy_ibm ( vsgsxy ( kb : ke + kh ), vsgs ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIvw ( ib : ie , jb : je , kb : ke + kh ), IIvws ( kb : ke + kh ),. false .) end if ! lxydump .or. lxytdump if ( lxydump ) then uwxyik = 0. ; vwxyjk = 0. ; uxyik = 0. ; wxyik = 0. ; vxyjk = 0. ; wxyjk = 0. ; wthlxyk = 0. ; thlxyk = 0. ; wpthlpxyk = 0. call avexy_ibm ( uwxyik ( kb : ke + kh ), uik ( ib : ie , jb : je , kb : ke + kh ) * wik ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIuw ( ib : ie , jb : je , kb : ke + kh ), IIuws ( kb : ke + kh ),. true .) call avexy_ibm ( vwxyjk ( kb : ke + kh ), vjk ( ib : ie , jb : je , kb : ke + kh ) * wjk ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIvw ( ib : ie , jb : je , kb : ke + kh ), IIvws ( kb : ke + kh ),. true .) call avexy_ibm ( uxyik ( kb : ke + kh ), uik ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIuw ( ib : ie , jb : je , kb : ke + kh ), IIuws ( kb : ke + kh ),. true .) call avexy_ibm ( wxyik ( kb : ke + kh ), wik ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIuw ( ib : ie , jb : je , kb : ke + kh ), IIuws ( kb : ke + kh ),. true .) call avexy_ibm ( wxyjk ( kb : ke + kh ), wjk ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIvw ( ib : ie , jb : je , kb : ke + kh ), IIvws ( kb : ke + kh ),. true .) call avexy_ibm ( vxyjk ( kb : ke + kh ), vjk ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIvw ( ib : ie , jb : je , kb : ke + kh ), IIvws ( kb : ke + kh ),. true .) if ( ltempeq ) then call avexy_ibm ( wthlxyk ( kb : ke + kh ), wm ( ib : ie , jb : je , kb : ke + kh ) * thlk ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIw ( ib : ie , jb : je , kb : ke + kh ), IIws ( kb : ke + kh ),. true .) call avexy_ibm ( thlxyk ( kb : ke + kh ), thlk ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIw ( ib : ie , jb : je , kb : ke + kh ), IIws ( kb : ke + kh ),. true .) end if upwpxyik = uwxyik - uxyik * wxyik vpwpxyjk = vwxyjk - vxyjk * wxyjk if ( ltempeq ) then wpthlpxyk = wthlxyk - wxy * thlxyk end if end if ! lxydump !!>> CALCS FOR TIME DEPENDANT (AVERAGED) STATS !> Average 1-D fields in time if ( lxytdump ) then uxyt ( kb : ke + kh ) = ( uxyt ( kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + uxy ( kb : ke + kh ) * tsamplep ) * tstatsdumppi vxyt ( kb : ke + kh ) = ( vxyt ( kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + vxy ( kb : ke + kh ) * tsamplep ) * tstatsdumppi wxyt ( kb : ke + kh ) = ( wxyt ( kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + wxy ( kb : ke + kh ) * tsamplep ) * tstatsdumppi qtxyt ( kb : ke + kh ) = ( qtxyt ( kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + qtxy ( kb : ke + kh ) * tsamplep ) * tstatsdumppi pxyt ( kb : ke + kh ) = ( pxyt ( kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + pxy ( kb : ke + kh ) * tsamplep ) * tstatsdumppi usgsxyt ( kb : ke + kh ) = ( usgsxyt ( kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + usgsxy ( kb : ke + kh ) * tsamplep ) * tstatsdumppi vsgsxyt ( kb : ke + kh ) = ( vsgsxyt ( kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + vsgsxy ( kb : ke + kh ) * tsamplep ) * tstatsdumppi if ( ltempeq ) then thlsgsxyt ( kb : ke + kh ) = ( thlsgsxyt ( kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + thlsgsxy ( kb : ke + kh ) * tsamplep ) * tstatsdumppi thlxyt ( kb : ke + kh ) = ( thlxyt ( kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + thlxy ( kb : ke + kh ) * tsamplep ) * tstatsdumppi end if end if ! lxytdump !> Average 2-D fields in time if ( lytdump ) then if ( myid == 0 ) then vyt ( ib : ie , kb : ke ) = ( vyt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + vy ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi uyt ( ib : ie , kb : ke ) = ( uyt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + uy ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi wyt ( ib : ie , kb : ke ) = ( wyt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + wy ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi usgsyt ( ib : ie , kb : ke ) = ( usgsyt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + usgsy ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi wsgsyt ( ib : ie , kb : ke ) = ( wsgsyt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + wsgsy ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi if ( ltempeq ) then thlyt ( ib : ie , kb : ke ) = ( thlyt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + thly ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi thlsgsyt ( ib : ie , kb : ke ) = ( thlsgsyt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + thlsgsy ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi end if if ( lmoist ) then qtyt ( ib : ie , kb : ke ) = ( qtyt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + qty ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi qtsgsyt ( ib : ie , kb : ke ) = ( qtsgsyt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + qtsgsy ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi end if if ( nsv > 0 ) then sca1yt ( ib : ie , kb : ke ) = ( sca1yt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + sca1y ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi sv1sgsyt ( ib : ie , kb : ke ) = ( sv1sgsyt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + sv1sgsy ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi end if if ( nsv > 1 ) then sca2yt ( ib : ie , kb : ke ) = ( sca2yt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + sca2y ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi sv2sgsyt ( ib : ie , kb : ke ) = ( sv2sgsyt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + sv2sgsy ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi end if if ( nsv > 2 ) then sca3yt ( ib : ie , kb : ke ) = ( sca3yt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + sca3y ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi sv3sgsyt ( ib : ie , kb : ke ) = ( sv3sgsyt ( ib : ie , kb : ke ) * ( tstatsdumpp - tsamplep ) + sv3sgsy ( ib : ie , kb : ke ) * tsamplep ) * tstatsdumppi end if end if ! myid end if !lytdump ! Average 3-D fields in time ! tg3315 may be possible to do less calculations by splitting up ! some calcs not necessary for xyt or yt... if ( lxytdump . or . lytdump . or . ltdump . or . lmintdump ) then uwtik (:,:, kb : ke + kh ) = ( uwtik (:,:, kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + wik (:,:, kb : ke + kh ) * uik (:,:, kb : ke + kh ) * tsamplep ) * tstatsdumppi vwtjk (:,:, kb : ke + kh ) = ( vwtjk (:,:, kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + wjk (:,:, kb : ke + kh ) * vjk (:,:, kb : ke + kh ) * tsamplep ) * tstatsdumppi uvtij (:,:, kb : ke + kh ) = ( uvtij (:,:, kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + uij (:,:, kb : ke + kh ) * vij (:,:, kb : ke + kh ) * tsamplep ) * tstatsdumppi uutc ( ib : ie , jb : je , kb : ke + kh ) = ( uutc ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + uc ( ib : ie , jb : je , kb : ke + kh ) * uc ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi vvtc ( ib : ie , jb : je , kb : ke + kh ) = ( vvtc ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + vc ( ib : ie , jb : je , kb : ke + kh ) * vc ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi wwtc ( ib : ie , jb : je , kb : ke + kh ) = ( wwtc ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + wc ( ib : ie , jb : je , kb : ke + kh ) * wc ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi utik (:,:, kb : ke + kh ) = ( utik (:,:, kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + uik (:,:, kb : ke + kh ) * tsamplep ) * tstatsdumppi wtik (:,:, kb : ke + kh ) = ( wtik (:,:, kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + wik (:,:, kb : ke + kh ) * tsamplep ) * tstatsdumppi vtjk (:,:, kb : ke + kh ) = ( vtjk (:,:, kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + vjk (:,:, kb : ke + kh ) * tsamplep ) * tstatsdumppi wtjk (:,:, kb : ke + kh ) = ( wtjk (:,:, kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + wjk (:,:, kb : ke + kh ) * tsamplep ) * tstatsdumppi utij (:,:, kb : ke + kh ) = ( utij (:,:, kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + uij (:,:, kb : ke + kh ) * tsamplep ) * tstatsdumppi vtij (:,:, kb : ke + kh ) = ( vtij (:,:, kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + vij (:,:, kb : ke + kh ) * tsamplep ) * tstatsdumppi umt ( ib : ie , jb : je , kb : ke + kh ) = ( umt ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + um ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi vmt ( ib : ie , jb : je , kb : ke + kh ) = ( vmt ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + vm ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi wmt ( ib : ie , jb : je , kb : ke + kh ) = ( wmt ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + wm ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi utc ( ib : ie , jb : je , kb : ke + kh ) = ( utc ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + uc ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi vtc ( ib : ie , jb : je , kb : ke + kh ) = ( vtc ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + vc ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi wtc ( ib : ie , jb : je , kb : ke + kh ) = ( wtc ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + wc ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi pt ( ib : ie , jb : je , kb : ke + kh ) = ( pt ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + pres0 ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi if ( ltempeq ) then wthltk ( ib : ie , jb : je , kb : ke + kh ) = ( wthltk ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + thlk ( ib : ie , jb : je , kb : ke + kh ) * wm ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi thlthlt ( ib : ie , jb : je , kb : ke + kh ) = ( thlthlt ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + thlm ( ib : ie , jb : je , kb : ke + kh ) * thlm ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi thltk ( ib : ie , jb : je , kb : ke + kh ) = ( thltk ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + thlk ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi thlt ( ib : ie , jb : je , kb : ke + kh ) = ( thlt ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + thlm ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi end if if ( lmoist ) then wqttk ( ib : ie , jb : je , kb : ke + kh ) = ( wqttk ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + qtk ( ib : ie , jb : je , kb : ke + kh ) * wm ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi qtqtt ( ib : ie , jb : je , kb : ke + kh ) = ( qtqtt ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + qtm ( ib : ie , jb : je , kb : ke + kh ) * qtm ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi qttk ( ib : ie , jb : je , kb : ke + kh ) = ( qttk ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + qtk ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi qtt ( ib : ie , jb : je , kb : ke + kh ) = ( qtt ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + qtm ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi end if if ( nsv > 0 ) then sv1t ( ib : ie , jb : je , kb : ke + kh ) = ( sv1t ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + svm ( ib : ie , jb : je , kb : ke + kh , 1 ) * tsamplep ) * tstatsdumppi sv1tk ( ib : ie , jb : je , kb : ke + kh ) = ( sv1tk ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + sv1k ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi wsv1tk ( ib : ie , jb : je , kb : ke + kh ) = ( wsv1tk ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + wm ( ib : ie , jb : je , kb : ke + kh ) * sv1k ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi sv1sgst ( ib : ie , jb : je , kb : ke + kh ) = ( sv1sgst ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + sv1sgs ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi sv1sv1t ( ib : ie , jb : je , kb : ke + kh ) = ( sv1sv1t ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + svm ( ib : ie , jb : je , kb : ke + kh , 1 ) * svm ( ib : ie , jb : je , kb : ke + kh , 1 ) * tsamplep ) * tstatsdumppi ! sv1max(ib:ie,jb:je,kb:ke) = max(sv1max(ib:ie,jb:je,kb:ke),svm(ib:ie,jb:je,kb:ke,1)) end if if (( lchem . eqv . . true .) . and . ( nsv > 2 )) then PSSt ( ib : ie , jb : je , kb : ke + kh ) = ( PSSt ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + PSS ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi end if if ( nsv > 1 ) then sv2t ( ib : ie , jb : je , kb : ke + kh ) = ( sv2t ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + svm ( ib : ie , jb : je , kb : ke + kh , 2 ) * tsamplep ) * tstatsdumppi sv2tk ( ib : ie , jb : je , kb : ke + kh ) = ( sv2tk ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + sv2k ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi wsv2tk ( ib : ie , jb : je , kb : ke + kh ) = ( wsv2tk ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + wm ( ib : ie , jb : je , kb : ke + kh ) * sv2k ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi sv2sgst ( ib : ie , jb : je , kb : ke + kh ) = ( sv2sgst ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + sv2sgs ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi sv2sv2t ( ib : ie , jb : je , kb : ke + kh ) = ( sv2sv2t ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + svm ( ib : ie , jb : je , kb : ke + kh , 2 ) * svm ( ib : ie , jb : je , kb : ke + kh , 2 ) * tsamplep ) * tstatsdumppi ! sv2max(ib:ie,jb:je,kb:ke) = max(sv2max(ib:ie,jb:je,kb:ke),svm(ib:ie,jb:je,kb:ke,2)) end if if ( nsv > 2 ) then sv3t ( ib : ie , jb : je , kb : ke + kh ) = ( sv3t ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + svm ( ib : ie , jb : je , kb : ke + kh , 3 ) * tsamplep ) * tstatsdumppi sv3tk ( ib : ie , jb : je , kb : ke + kh ) = ( sv3tk ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + sv3k ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi wsv3tk ( ib : ie , jb : je , kb : ke + kh ) = ( wsv3tk ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + wm ( ib : ie , jb : je , kb : ke + kh ) * sv3k ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi sv3sgst ( ib : ie , jb : je , kb : ke + kh ) = ( sv3sgst ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + sv3sgs ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi sv3sv3t ( ib : ie , jb : je , kb : ke + kh ) = ( sv3sv3t ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + svm ( ib : ie , jb : je , kb : ke + kh , 3 ) * svm ( ib : ie , jb : je , kb : ke + kh , 3 ) * tsamplep ) * tstatsdumppi ! sv3max(ib:ie,jb:je,kb:ke) = max(sv3max(ib:ie,jb:je,kb:ke),svm(ib:ie,jb:je,kb:ke,3)) end if if ( nsv > 3 ) then sv4t ( ib : ie , jb : je , kb : ke + kh ) = ( sv4t ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + svm ( ib : ie , jb : je , kb : ke + kh , 4 ) * tsamplep ) * tstatsdumppi sv4tk ( ib : ie , jb : je , kb : ke + kh ) = ( sv4tk ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + sv4k ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi wsv4tk ( ib : ie , jb : je , kb : ke + kh ) = ( wsv4tk ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + wm ( ib : ie , jb : je , kb : ke + kh ) * sv4k ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi sv4sgst ( ib : ie , jb : je , kb : ke + kh ) = ( sv4sgst ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + sv4sgs ( ib : ie , jb : je , kb : ke + kh ) * tsamplep ) * tstatsdumppi sv4sv4t ( ib : ie , jb : je , kb : ke + kh ) = ( sv4sv4t ( ib : ie , jb : je , kb : ke + kh ) * ( tstatsdumpp - tsamplep ) + svm ( ib : ie , jb : je , kb : ke + kh , 4 ) * svm ( ib : ie , jb : je , kb : ke + kh , 4 ) * tsamplep ) * tstatsdumppi ! sv4max(ib:ie,jb:je,kb:ke) = max(sv4max(ib:ie,jb:je,kb:ke),svm(ib:ie,jb:je,kb:ke,4)) end if end if !lxytdump .or. lytdump .or. ltdump ! Other 3-D fields specifically for tdump !if (ltdump) then ! bss116 already calculated above ! wmt(ib:ie,jb:je,kb:ke+kh) = (wmt(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + wm(ib:ie,jb:je,kb:ke+kh)*tsamplep)*tstatsdumppi ! sv1t(ib:ie,jb:je,kb:ke+kh) = (sv1t(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + svm(ib:ie,jb:je,kb:ke+kh,1)*tsamplep)*tstatsdumppi ! sv2t(ib:ie,jb:je,kb:ke+kh) = (sv2t(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + svm(ib:ie,jb:je,kb:ke+kh,2)*tsamplep)*tstatsdumppi ! sv3t(ib:ie,jb:je,kb:ke+kh) = (sv3t(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + svm(ib:ie,jb:je,kb:ke+kh,3)*tsamplep)*tstatsdumppi ! ! sv4t(ib:ie,jb:je,kb:ke+kh) = (sv4t(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + svm(ib:ie,jb:je,kb:ke+kh,4)*tsamplep)*tstatsdumppi ! sv1tk(ib:ie,jb:je,kb:ke+kh) = (sv1tk(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + sv1k(ib:ie,jb:je,kb:ke+kh)*tsamplep)*tstatsdumppi ! sv2tk(ib:ie,jb:je,kb:ke+kh) = (sv2tk(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + sv2k(ib:ie,jb:je,kb:ke+kh)*tsamplep)*tstatsdumppi ! sv3tk(ib:ie,jb:je,kb:ke+kh) = (sv3tk(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + sv3k(ib:ie,jb:je,kb:ke+kh)*tsamplep)*tstatsdumppi ! sv4tk(ib:ie,jb:je,kb:ke+kh) = (sv4tk(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + sv4k(ib:ie,jb:je,kb:ke+kh)*tsamplep)*tstatsdumppi ! wsv1tk(ib:ie,jb:je,kb:ke+kh) = (wsv1tk(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + wm(ib:ie,jb:je,kb:ke+kh)*sv1k(ib:ie,jb:je,kb:ke+kh)*tsamplep)*tstatsdumppi ! wsv2tk(ib:ie,jb:je,kb:ke+kh) = (wsv2tk(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + wm(ib:ie,jb:je,kb:ke+kh)*sv2k(ib:ie,jb:je,kb:ke+kh)*tsamplep)*tstatsdumppi ! wsv3tk(ib:ie,jb:je,kb:ke+kh) = (wsv3tk(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + wm(ib:ie,jb:je,kb:ke+kh)*sv3k(ib:ie,jb:je,kb:ke+kh)*tsamplep)*tstatsdumppi ! wsv4tk(ib:ie,jb:je,kb:ke+kh) = (wsv4tk(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + wm(ib:ie,jb:je,kb:ke+kh)*sv4k(ib:ie,jb:je,kb:ke+kh)*tsamplep)*tstatsdumppi ! sv1sgst(ib:ie,jb:je,kb:ke+kh) = (sv1sgst(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + sv1sgs(ib:ie,jb:je,kb:ke+kh)*tsamplep)*tstatsdumppi ! sv2sgst(ib:ie,jb:je,kb:ke+kh) = (sv2sgst(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + sv2sgs(ib:ie,jb:je,kb:ke+kh)*tsamplep)*tstatsdumppi ! sv3sgst(ib:ie,jb:je,kb:ke+kh) = (sv3sgst(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + sv3sgs(ib:ie,jb:je,kb:ke+kh)*tsamplep)*tstatsdumppi ! sv4sgst(ib:ie,jb:je,kb:ke+kh) = (sv4sgst(ib:ie,jb:je,kb:ke+kh)*(tstatsdumpp-tsamplep) + sv4sgs(ib:ie,jb:je,kb:ke+kh)*tsamplep)*tstatsdumppi !end if ! ltdump if ( ltreedump ) then tr_ut ( ib : ie , jb : je , kb : ke ) = ( tr_ut ( ib : ie , jb : je , kb : ke ) * ( tstatsdumpp - tsamplep ) + tr_u ( ib : ie , jb : je , kb : ke ) * tsamplep ) * tstatsdumppi tr_vt ( ib : ie , jb : je , kb : ke ) = ( tr_vt ( ib : ie , jb : je , kb : ke ) * ( tstatsdumpp - tsamplep ) + tr_v ( ib : ie , jb : je , kb : ke ) * tsamplep ) * tstatsdumppi tr_wt ( ib : ie , jb : je , kb : ke ) = ( tr_wt ( ib : ie , jb : je , kb : ke ) * ( tstatsdumpp - tsamplep ) + tr_w ( ib : ie , jb : je , kb : ke ) * tsamplep ) * tstatsdumppi if ( ltempeq ) then tr_thlt ( ib : ie , jb : je , kb : ke ) = ( tr_thlt ( ib : ie , jb : je , kb : ke ) * ( tstatsdumpp - tsamplep ) + tr_thl ( ib : ie , jb : je , kb : ke ) * tsamplep ) * tstatsdumppi end if if ( lmoist ) then tr_qtt ( ib : ie , jb : je , kb : ke ) = ( tr_qtt ( ib : ie , jb : je , kb : ke ) * ( tstatsdumpp - tsamplep ) + tr_qt ( ib : ie , jb : je , kb : ke ) * tsamplep ) * tstatsdumppi tr_qtRt ( ib : ie , jb : je , kb : ke ) = ( tr_qtRt ( ib : ie , jb : je , kb : ke ) * ( tstatsdumpp - tsamplep ) + tr_qtR ( ib : ie , jb : je , kb : ke ) * tsamplep ) * tstatsdumppi tr_qtAt ( ib : ie , jb : je , kb : ke ) = ( tr_qtAt ( ib : ie , jb : je , kb : ke ) * ( tstatsdumpp - tsamplep ) + tr_qtA ( ib : ie , jb : je , kb : ke ) * tsamplep ) * tstatsdumppi tr_omegat ( ib : ie , jb : je , kb : ke ) = ( tr_omegat ( ib : ie , jb : je , kb : ke ) * ( tstatsdumpp - tsamplep ) + tr_omega ( ib : ie , jb : je , kb : ke ) * tsamplep ) * tstatsdumppi end if if ( nsv > 0 ) then tr_sv1t ( ib : ie , jb : je , kb : ke ) = ( tr_sv1t ( ib : ie , jb : je , kb : ke ) * ( tstatsdumpp - tsamplep ) + tr_sv ( ib : ie , jb : je , kb : ke , 1 ) * tsamplep ) * tstatsdumppi tr_sv2t ( ib : ie , jb : je , kb : ke ) = ( tr_sv2t ( ib : ie , jb : je , kb : ke ) * ( tstatsdumpp - tsamplep ) + tr_sv ( ib : ie , jb : je , kb : ke , 2 ) * tsamplep ) * tstatsdumppi end if end if !      where (IIuwt==0) !        upwpyik    = -999 !        upwpytik   = -999 !      endwhere end if ! lytdump .or. lydump .or. lxydump .or. lxytdump .or. ltdump .or. lmintdump ! Write y-averaged statistics every tsample if ( lydump ) then if ( myid == 0 ) then allocate ( field ( ib : ie , kb : ke )) allocate ( varsy ( imax , khigh - klow + 1 , nstaty )) varsy = 0. varsy (:,:, 1 ) = uy ( ib : ie , kb : ke ) varsy (:,:, 2 ) = vy ( ib : ie , kb : ke ) varsy (:,:, 3 ) = wy ( ib : ie , kb : ke ) varsy (:,:, 4 ) = thly ( ib : ie , kb : ke ) varsy (:,:, 5 ) = qty ( ib : ie , kb : ke ) varsy (:,:, 6 ) = sca1y ( ib : ie , kb : ke ) varsy (:,:, 7 ) = sca2y ( ib : ie , kb : ke ) varsy (:,:, 8 ) = sca3y ( ib : ie , kb : ke ) varsy (:,:, 9 ) = upwpyik ( ib : ie , kb : ke ) varsy (:,:, 10 ) = wpthlpyk ( ib : ie , kb : ke ) varsy (:,:, 11 ) = usgsy ( ib : ie , kb : ke ) varsy (:,:, 12 ) = thlsgsy ( ib : ie , kb : ke ) varsy (:,:, 13 ) = uwyik ( ib : ie , kb : ke ) varsy (:,:, 14 ) = wthlyk ( ib : ie , kb : ke ) call writestat_nc ( ncidy , 1 , tncstaty ,( / timee / ), nrecy ,. true .) call writestat_nc ( ncidy , nstaty , ncstaty , varsy , nrecy , imax , khigh - klow + 1 ) deallocate ( field , varsy ) endif !myid endif !lydump ! Write xy-averaged statistics every tsample if ( lxydump ) then if ( myid == 0 ) then call writestat_nc ( ncidxy , 1 , tncstatxy ,( / timee / ), nrecxy ,. true .) allocate ( varsxy ( khigh - klow + 1 , nstatxy )) varsxy (:, 1 ) = uxy ( kb : ke ) varsxy (:, 2 ) = vxy ( kb : ke ) varsxy (:, 3 ) = wxy ( kb : ke ) varsxy (:, 4 ) = thlxy ( kb : ke ) varsxy (:, 5 ) = qtxy ( kb : ke ) varsxy (:, 6 ) = pxy ( kb : ke ) varsxy (:, 7 ) = upwpxyik ( kb : ke ) varsxy (:, 8 ) = wpthlpxyk ( kb : ke ) varsxy (:, 9 ) = vpwpxyjk ( kb : ke ) varsxy (:, 10 ) = usgsxy ( kb : ke ) varsxy (:, 11 ) = thlsgsxy ( kb : ke ) !wdthldtc(kb:ke) varsxy (:, 12 ) = vsgsxy ( kb : ke ) varsxy (:, 13 ) = uwxyik ( kb : ke ) varsxy (:, 14 ) = wthlxyk ( kb : ke ) varsxy (:, 15 ) = vwxyjk ( kb : ke ) call writestat_1D_nc ( ncidxy , nstatxy , ncstatxy , varsxy , nrecxy , khigh - klow + 1 ) end if !myid end if !lxydump if ( lkslicedump ) then allocate ( varkslice ( imax , jmax , nstatkslice )) call writestat_nc ( ncidkslice , 1 , tncstatkslice ,( / timee / ), nreckslice ,. true .) varkslice (:,:, 1 ) = um ( ib : ie , jb : je , kslice ) varkslice (:,:, 2 ) = vm ( ib : ie , jb : je , kslice ) varkslice (:,:, 3 ) = 0.5 * ( wm ( ib : ie , jb : je , kslice ) + wm ( ib : ie , jb : je , kslice + 1 )) ! assumes equidistant varkslice (:,:, 4 ) = thlm ( ib : ie , jb : je , kslice ) varkslice (:,:, 5 ) = qtm ( ib : ie , jb : je , kslice ) call writestat_nc ( ncidkslice , nstatkslice , ncstatkslice , varkslice , nreckslice , imax , jmax ) endif if ( lislicedump ) then if ( islicerank ) then allocate ( varislice ( jmax , khigh - klow + 1 , nstatislice )) call writestat_nc ( ncidislice , 1 , tncstatislice ,( / timee / ), nrecislice ,. true .) varislice (:,:, 1 ) = 0.5 * ( um ( isliceloc , jb : je , kb : ke ) + um ( isliceloc + 1 , jb : je , kb : ke )) varislice (:,:, 2 ) = vm ( isliceloc , jb : je , kb : ke ) varislice (:,:, 3 ) = wm ( isliceloc , jb : je , kb : ke ) varislice (:,:, 4 ) = thlm ( isliceloc , jb : je , kb : ke ) varislice (:,:, 5 ) = qtm ( isliceloc , jb : je , kb : ke ) call writestat_nc ( ncidislice , nstatislice , ncstatislice , varislice , nrecislice , jmax , khigh - klow + 1 ) endif endif if ( ljslicedump ) then if ( jslicerank ) then allocate ( varjslice ( imax , khigh - klow + 1 , nstatjslice )) call writestat_nc ( ncidjslice , 1 , tncstatjslice ,( / timee / ), nrecjslice ,. true .) varjslice (:,:, 1 ) = um ( ib : ie , jsliceloc , kb : ke ) varjslice (:,:, 2 ) = 0.5 * ( vm ( ib : ie , jsliceloc , kb : ke ) + vm ( ib : ie , jsliceloc + 1 , kb : ke )) varjslice (:,:, 3 ) = wm ( ib : ie , jsliceloc , kb : ke ) varjslice (:,:, 4 ) = thlm ( ib : ie , jsliceloc , kb : ke ) varjslice (:,:, 5 ) = qtm ( ib : ie , jsliceloc , kb : ke ) call writestat_nc ( ncidjslice , nstatjslice , ncstatjslice , varjslice , nrecjslice , imax , khigh - klow + 1 ) endif endif if ( ltkedump ) then !call genstats(tsamplep,tstatsdumpp,umc,vmc,wmc) endif tsamplep = dt else !timestatsdumpp < tsample tsamplep = tsamplep + dt endif if ( tstatsdumpp > tstatsdump ) then ! Final calculations and write xyt-averaged statistics every tsample if ( lxytdump ) then wthltxyk = 0. ; uwtxyik = 0. ; vwtxyjk = 0. ; wwtxyk = 0. ; uvtxyij = 0. ; wpthlptxyk = 0. ; upwptxyik = 0. ; vpwptxyjk = 0. ; upvptxyij = 0. ; thlpthlptxy = 0. ; upuptxyc = 0. ; vpvptxyc = 0. ; wpwptxyc = 0. ; tketxyc = 0. !> Advective flux if ( ltempeq ) then call avexy_ibm ( wthltxyk ( kb : ke + kh ), wmt ( ib : ie , jb : je , kb : ke + kh ) * thltk ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIw ( ib : ie , jb : je , kb : ke + kh ), IIws ( kb : ke + kh ),. false .) end if call avexy_ibm ( uwtxyik ( kb : ke + kh ), utik ( ib : ie , jb : je , kb : ke + kh ) * wtik ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIuw ( ib : ie , jb : je , kb : ke + kh ), IIuws ( kb : ke + kh ),. false .) call avexy_ibm ( vwtxyjk ( kb : ke + kh ), vtjk ( ib : ie , jb : je , kb : ke + kh ) * wtjk ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIvw ( ib : ie , jb : je , kb : ke + kh ), IIvws ( kb : ke + kh ),. false .) call avexy_ibm ( wwtxyk ( kb : ke + kh ), wmt ( ib : ie , jb : je , kb : ke + kh ) * wmt ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIw ( ib : ie , jb : je , kb : ke + kh ), IIws ( kb : ke + kh ),. false .) call avexy_ibm ( uvtxyij ( kb : ke + kh ), utij ( ib : ie , jb : je , kb : ke + kh ) * vtij ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIuv ( ib : ie , jb : je , kb : ke + kh ), IIuvs ( kb : ke + kh ),. false .) !> Turbulent fluxes if ( ltempeq ) then call avexy_ibm ( wpthlptxyk ( kb : ke + kh ), wthltk ( ib : ie , jb : je , kb : ke + kh ) - wmt ( ib : ie , jb : je , kb : ke + kh ) * thltk ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIw ( ib : ie , jb : je , kb : ke + kh ), IIws ( kb : ke + kh ),. false .) end if call avexy_ibm ( upwptxyik ( kb : ke + kh ), uwtik ( ib : ie , jb : je , kb : ke + kh ) - utik ( ib : ie , jb : je , kb : ke + kh ) * wtik ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIuw ( ib : ie , jb : je , kb : ke + kh ), IIuws ( kb : ke + kh ),. false .) call avexy_ibm ( vpwptxyjk ( kb : ke + kh ), vwtjk ( ib : ie , jb : je , kb : ke + kh ) - vtjk ( ib : ie , jb : je , kb : ke + kh ) * wtjk ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIvw ( ib : ie , jb : je , kb : ke + kh ), IIvws ( kb : ke + kh ),. false .) call avexy_ibm ( upvptxyij ( kb : ke + kh ), uvtij ( ib : ie , jb : je , kb : ke + kh ) - utij ( ib : ie , jb : je , kb : ke + kh ) * vtij ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIuv ( ib : ie , jb : je , kb : ke + kh ), IIuvs ( kb : ke + kh ),. false .) !> Variances and TKE if ( ltempeq ) then call avexy_ibm ( thlpthlptxy ( kb : ke + kh ), thlthlt ( ib : ie , jb : je , kb : ke + kh ) - thlt ( ib : ie , jb : je , kb : ke + kh ) * thlt ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) end if call avexy_ibm ( upuptxyc ( kb : ke + kh ), uutc ( ib : ie , jb : je , kb : ke + kh ) - utc ( ib : ie , jb : je , kb : ke + kh ) * utc ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) call avexy_ibm ( vpvptxyc ( kb : ke + kh ), vvtc ( ib : ie , jb : je , kb : ke + kh ) - vtc ( ib : ie , jb : je , kb : ke + kh ) * vtc ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) call avexy_ibm ( wpwptxyc ( kb : ke + kh ), wwtc ( ib : ie , jb : je , kb : ke + kh ) - wtc ( ib : ie , jb : je , kb : ke + kh ) * wtc ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) call avexy_ibm ( tketxyc ( kb : ke + kh ), 0.5 * (( wwtc ( ib : ie , jb : je , kb : ke + kh ) - wtc ( ib : ie , jb : je , kb : ke + kh ) * wtc ( ib : ie , jb : je , kb : ke + kh )) + ( vvtc ( ib : ie , jb : je , kb : ke + kh ) - vtc ( ib : ie , jb : je , kb : ke + kh ) * vtc ( ib : ie , jb : je , kb : ke + kh )) + ( uutc ( ib : ie , jb : je , kb : ke + kh ) - utc ( ib : ie , jb : je , kb : ke + kh ) * utc ( ib : ie , jb : je , kb : ke + kh ))), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) if ( myid == 0 ) then call writestat_nc ( ncidxyt , 1 , tncstatxyt ,( / timee / ), nrecxyt ,. true .) allocate ( varsxyt ( khigh - klow + 1 , nstatxyt )) varsxyt (:, 1 ) = uxyt ( kb : ke ) varsxyt (:, 2 ) = vxyt ( kb : ke ) varsxyt (:, 3 ) = wxyt ( kb : ke ) varsxyt (:, 4 ) = thlxyt ( kb : ke ) varsxyt (:, 5 ) = qtxyt ( kb : ke ) varsxyt (:, 6 ) = pxyt ( kb : ke ) varsxyt (:, 7 ) = upwptxyik ( kb : ke ) varsxyt (:, 8 ) = wpthlptxyk ( kb : ke ) varsxyt (:, 9 ) = vpwptxyjk ( kb : ke ) varsxyt (:, 10 ) = upvptxyij ( kb : ke ) varsxyt (:, 11 ) = uwtxyik ( kb : ke ) varsxyt (:, 12 ) = wthltxyk ( kb : ke ) !wdthldtc(kb:ke) varsxyt (:, 13 ) = uvtxyij ( kb : ke ) varsxyt (:, 14 ) = vwtxyjk ( kb : ke ) varsxyt (:, 15 ) = wwtxyk ( kb : ke ) varsxyt (:, 16 ) = usgsxyt ( kb : ke ) !wdthldtw(kb:ke) varsxyt (:, 17 ) = thlsgsxyt ( kb : ke ) varsxyt (:, 18 ) = vsgsxyt ( kb : ke ) varsxyt (:, 19 ) = thlpthlptxy ( kb : ke ) varsxyt (:, 20 ) = upuptxyc ( kb : ke ) varsxyt (:, 21 ) = vpvptxyc ( kb : ke ) varsxyt (:, 22 ) = wpwptxyc ( kb : ke ) varsxyt (:, 23 ) = tketxyc ( kb : ke ) call writestat_1D_nc ( ncidxyt , nstatxyt , ncstatxyt , varsxyt , nrecxyt , khigh - klow + 1 ) end if !myid end if !lxytdump ! Final calculations and write yt-averaged statistics every tsample if ( lytdump ) then !    call MPI_BCAST(sca1yt ,(ke+kh-(kb-kh))*(ie+ih-(ib-ih)),MY_REAL   ,7,comm3d,mpierr) ! Turbulent flux call avey_ibm ( upwptyik , uwtik ( ib : ie , jb : je , kb : ke ) - utik ( ib : ie , jb : je , kb : ke ) * wtik ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIuw ( ib : ie , jb : je , kb : ke ), IIuwt ( ib : ie , kb : ke )) call avey_ibm ( uwtyik , utik ( ib : ie , jb : je , kb : ke ) * wtik ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIuw ( ib : ie , jb : je , kb : ke ), IIuwt ( ib : ie , kb : ke )) call avey_ibm ( upuptyc , uutc ( ib : ie , jb : je , kb : ke ) - utc ( ib : ie , jb : je , kb : ke ) * utc ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke ), IIct ( ib : ie , kb : ke )) call avey_ibm ( vpvptyc , vvtc ( ib : ie , jb : je , kb : ke ) - vtc ( ib : ie , jb : je , kb : ke ) * vtc ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke ), IIct ( ib : ie , kb : ke )) call avey_ibm ( wpwptyc , wwtc ( ib : ie , jb : je , kb : ke ) - wtc ( ib : ie , jb : je , kb : ke ) * wtc ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke ), IIct ( ib : ie , kb : ke )) if ( ltempeq ) then call avey_ibm ( wpthlptyk , wthltk ( ib : ie , jb : je , kb : ke ) - wmt ( ib : ie , jb : je , kb : ke ) * thltk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( wthltyk , wmt ( ib : ie , jb : je , kb : ke ) * thltk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( thlpthlpty , thlthlt ( ib : ie , jb : je , kb : ke ) - thlt ( ib : ie , jb : je , kb : ke ) * thlt ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke ), IIct ( ib : ie , kb : ke )) end if if ( lmoist ) then call avey_ibm ( wpqtptyk , wqttk ( ib : ie , jb : je , kb : ke ) - wmt ( ib : ie , jb : je , kb : ke ) * qttk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( wqttyk , wmt ( ib : ie , jb : je , kb : ke ) * qttk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( qtpqtpty , qtqtt ( ib : ie , jb : je , kb : ke ) - qtt ( ib : ie , jb : je , kb : ke ) * qtt ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke ), IIct ( ib : ie , kb : ke )) end if if ( nsv > 0 ) then call avey_ibm ( wpsv1ptyk , wsv1tk ( ib : ie , jb : je , kb : ke ) - wmt ( ib : ie , jb : je , kb : ke ) * sv1tk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( wsv1tyk , wmt ( ib : ie , jb : je , kb : ke ) * sv1tk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( sv1psv1pty , sv1sv1t ( ib : ie , jb : je , kb : ke ) - sv1t ( ib : ie , jb : je , kb : ke ) * sv1t ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke ), IIct ( ib : ie , kb : ke )) end if if ( nsv > 1 ) then call avey_ibm ( wpsv2ptyk , wsv2tk ( ib : ie , jb : je , kb : ke ) - wmt ( ib : ie , jb : je , kb : ke ) * sv2tk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( wsv2tyk , wmt ( ib : ie , jb : je , kb : ke ) * sv2tk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( sv2psv2pty , sv2sv2t ( ib : ie , jb : je , kb : ke ) - sv2t ( ib : ie , jb : je , kb : ke ) * sv2t ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke ), IIct ( ib : ie , kb : ke )) end if if ( nsv > 2 ) then call avey_ibm ( wpsv3ptyk , wsv3tk ( ib : ie , jb : je , kb : ke ) - wmt ( ib : ie , jb : je , kb : ke ) * sv3tk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( wsv3tyk , wmt ( ib : ie , jb : je , kb : ke ) * sv3tk ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIw ( ib : ie , jb : je , kb : ke ), IIwt ( ib : ie , kb : ke )) call avey_ibm ( sv3psv3pty , sv3sv3t ( ib : ie , jb : je , kb : ke ) - sv3t ( ib : ie , jb : je , kb : ke ) * sv3t ( ib : ie , jb : je , kb : ke ), ib , ie , jb , je , kb , ke , IIc ( ib : ie , jb : je , kb : ke ), IIct ( ib : ie , kb : ke )) end if if ( myid == 0 ) then allocate ( varsyt ( imax , khigh - klow + 1 , nstatyt )) varsyt = 0. call writestat_nc ( ncidyt , 1 , tncstatyt ,( / timee / ), nrecyt ,. true .) varsyt (:,:, 1 ) = uyt ( ib : ie , kb : ke ) varsyt (:,:, 2 ) = vyt ( ib : ie , kb : ke ) varsyt (:,:, 3 ) = wyt ( ib : ie , kb : ke ) varsyt (:,:, 4 ) = thlyt ( ib : ie , kb : ke ) varsyt (:,:, 5 ) = qtyt ( ib : ie , kb : ke ) varsyt (:,:, 6 ) = sca1yt ( ib : ie , kb : ke ) varsyt (:,:, 7 ) = sca2yt ( ib : ie , kb : ke ) varsyt (:,:, 8 ) = sca3yt ( ib : ie , kb : ke ) varsyt (:,:, 9 ) = upwptyik ( ib : ie , kb : ke ) varsyt (:,:, 10 ) = wpthlptyk ( ib : ie , kb : ke ) varsyt (:,:, 11 ) = wpqtptyk ( ib : ie , kb : ke ) varsyt (:,:, 12 ) = wpsv1ptyk ( ib : ie , kb : ke ) varsyt (:,:, 13 ) = wpsv2ptyk ( ib : ie , kb : ke ) varsyt (:,:, 14 ) = wpsv3ptyk ( ib : ie , kb : ke ) varsyt (:,:, 15 ) = uwtyik ( ib : ie , kb : ke ) varsyt (:,:, 16 ) = wthltyk ( ib : ie , kb : ke ) varsyt (:,:, 17 ) = wqttyk ( ib : ie , kb : ke ) varsyt (:,:, 18 ) = wsv1tyk ( ib : ie , kb : ke ) varsyt (:,:, 19 ) = wsv2tyk ( ib : ie , kb : ke ) varsyt (:,:, 20 ) = wsv3tyk ( ib : ie , kb : ke ) varsyt (:,:, 21 ) = upuptyc ( ib : ie , kb : ke ) varsyt (:,:, 22 ) = wpwptyc ( ib : ie , kb : ke ) varsyt (:,:, 23 ) = thlpthlpty ( ib : ie , kb : ke ) varsyt (:,:, 24 ) = qtpqtpty ( ib : ie , kb : ke ) varsyt (:,:, 25 ) = sv1psv1pty ( ib : ie , kb : ke ) varsyt (:,:, 26 ) = sv2psv2pty ( ib : ie , kb : ke ) varsyt (:,:, 27 ) = sv3psv3pty ( ib : ie , kb : ke ) varsyt (:,:, 28 ) = usgsyt ( ib : ie , kb : ke ) varsyt (:,:, 29 ) = wsgsyt ( ib : ie , kb : ke ) varsyt (:,:, 30 ) = thlsgsyt ( ib : ie , kb : ke ) varsyt (:,:, 31 ) = qtsgsyt ( ib : ie , kb : ke ) varsyt (:,:, 32 ) = sv1sgsyt ( ib : ie , kb : ke ) varsyt (:,:, 33 ) = sv2sgsyt ( ib : ie , kb : ke ) varsyt (:,:, 34 ) = sv3sgsyt ( ib : ie , kb : ke ) call writestat_nc ( ncidyt , nstatyt , ncstatyt , varsyt , nrecyt , imax , khigh - klow + 1 ) end if !myid end if !lytdump ! Final calculations and write t-averaged statistics every tsample if ( ltdump ) then ! wpsv1p = wsv1tk - wmt*sv1tk ! wpsv2p = wsv2tk - wmt*sv2tk ! wpsv3p = wsv3tk - wmt*sv3tk ! wpsv4p = wsv4tk - wmt*sv4tk wpthlptk = 0. ; thlpthlpt = 0. !> Turbulent fluxes upwptik = uwtik - utik * wtik vpwptjk = vwtjk - vtjk * wtjk upvptij = uvtij - utij * vtij if ( ltempeq ) then wpthlptk = wthltk - wmt * thltk end if if ( nsv > 0 ) then wpsv1p = wsv1tk - wmt * sv1tk end if if ( nsv > 1 ) then wpsv2p = wsv2tk - wmt * sv2tk end if if ( nsv > 2 ) then wpsv3p = wsv3tk - wmt * sv3tk end if if ( nsv > 3 ) then wpsv4p = wsv4tk - wmt * sv4tk end if !> Variances and TKE if ( ltempeq ) then thlpthlpt = thlthlt - thlt * thlt end if upuptc = uutc - utc * utc vpvptc = vvtc - vtc * vtc wpwptc = wwtc - wtc * wtc tketc = 0.5 * ( upuptc + vpvptc + wpwptc ) if ( nsv > 0 ) then sv1psv1pt = sv1sv1t - sv1t * sv1t end if if ( nsv > 1 ) then sv2psv2pt = sv2sv2t - sv2t * sv2t end if if ( nsv > 2 ) then sv3psv3pt = sv3sv3t - sv3t * sv3t end if if ( nsv > 3 ) then sv4psv4pt = sv4sv4t - sv4t * sv4t end if !      if (myid == 0) then allocate ( varst ( imax , jmax , khigh - klow + 1 , nstatt )) call writestat_nc ( ncidt , 1 , tncstatt ,( / timee / ), nrect ,. true .) varst (:,:,:, 1 ) = umt ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 2 ) = vmt ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 3 ) = wmt ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 4 ) = thlt ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 5 ) = qtt ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 6 ) = pt ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 7 ) = sv1t ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 8 ) = sv2t ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 9 ) = sv3t ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 10 ) = sv4t ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 11 ) = PSSt ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 12 ) = upwptik ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 13 ) = vpwptjk ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 14 ) = upvptij ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 15 ) = wpthlptk ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 16 ) = wpsv1p ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 17 ) = wpsv2p ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 18 ) = wpsv3p ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 19 ) = wpsv4p ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 20 ) = thlpthlpt ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 21 ) = upuptc ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 22 ) = vpvptc ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 23 ) = wpwptc ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 24 ) = tketc ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 25 ) = sv1psv1pt ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 26 ) = sv2psv2pt ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 27 ) = sv3psv3pt ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 28 ) = sv4psv4pt ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 29 ) = sv1sgst ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 30 ) = sv2sgst ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 31 ) = sv3sgst ( ib : ie , jb : je , kb : ke ) varst (:,:,:, 32 ) = sv4sgst ( ib : ie , jb : je , kb : ke ) ! varst(:,:,:,33) = sv1max(ib:ie,jb:je,kb:ke) ! varst(:,:,:,34) = sv2max(ib:ie,jb:je,kb:ke) ! varst(:,:,:,35) = sv3max(ib:ie,jb:je,kb:ke) ! varst(:,:,:,36) = sv4max(ib:ie,jb:je,kb:ke) call writestat_nc ( ncidt , nstatt , ncstatt , varst , nrect , imax , jmax , khigh - klow + 1 ) !        end if !myid deallocate ( varst ) end if !ltdump if ( lmintdump ) then !      if (myid == 0) then allocate ( varsmint ( imax , jmax , khigh - klow + 1 , nstatmint )) call writestat_nc ( ncidmint , 1 , tncstatmint ,( / timee / ), nrecmint ,. true .) varsmint (:,:,:, 1 ) = umt ( ib : ie , jb : je , kb : ke ) varsmint (:,:,:, 2 ) = vmt ( ib : ie , jb : je , kb : ke ) varsmint (:,:,:, 3 ) = wmt ( ib : ie , jb : je , kb : ke ) varsmint (:,:,:, 4 ) = thlt ( ib : ie , jb : je , kb : ke ) varsmint (:,:,:, 5 ) = qtt ( ib : ie , jb : je , kb : ke ) varsmint (:,:,:, 6 ) = pt ( ib : ie , jb : je , kb : ke ) call writestat_nc ( ncidmint , nstatmint , ncstatmint , varsmint , nrecmint , imax , jmax , khigh - klow + 1 ) !        end if !myid deallocate ( varsmint ) end if !lmintdump ! Final calculations and write t-averaged statistics for the trees if ( ltreedump ) then !        if (myid == 0) then allocate ( varstr ( imax , jmax , khigh - klow + 1 , nstattr )) call writestat_nc ( ncidtr , 1 , tncstattr ,( / timee / ), nrectr ,. true .) varstr (:,:,:, 1 ) = tr_ut ( ib : ie , jb : je , kb : ke ) varstr (:,:,:, 2 ) = tr_vt ( ib : ie , jb : je , kb : ke ) varstr (:,:,:, 3 ) = tr_wt ( ib : ie , jb : je , kb : ke ) varstr (:,:,:, 4 ) = tr_thlt ( ib : ie , jb : je , kb : ke ) varstr (:,:,:, 5 ) = tr_qtt ( ib : ie , jb : je , kb : ke ) varstr (:,:,:, 6 ) = tr_qtRt ( ib : ie , jb : je , kb : ke ) varstr (:,:,:, 7 ) = tr_qtAt ( ib : ie , jb : je , kb : ke ) varstr (:,:,:, 8 ) = tr_sv1t ( ib : ie , jb : je , kb : ke ) varstr (:,:,:, 9 ) = tr_sv2t ( ib : ie , jb : je , kb : ke ) varstr (:,:,:, 10 ) = tr_omegat ( ib : ie , jb : je , kb : ke ) call writestat_nc ( ncidtr , nstattr , ncstattr , varstr , nrectr , imax , jmax , khigh - klow + 1 ) !        end if !myid deallocate ( varstr ) end if !ltdump if ( ltkedump ) then call tkestatsdump if ( myid == 0 ) then call writestat_nc ( ncidtke , 1 , tncstattke ,( / timee / ), nrectke ,. true .) allocate ( varstke ( khigh - klow + 1 , nstattke )) varstke (:, 1 ) = p_b ( kb : ke + kh ) varstke (:, 2 ) = t_p ( kb : ke + kh ) varstke (:, 3 ) = adv ( kb : ke + kh ) varstke (:, 4 ) = t_t ( kb : ke + kh ) varstke (:, 5 ) = t_sgs ( kb : ke + kh ) varstke (:, 6 ) = p_t ( kb : ke + kh ) varstke (:, 7 ) = t_v ( kb : ke + kh ) varstke (:, 8 ) = d_sgs ( kb : ke + kh ) call writestat_1D_nc ( ncidtke , nstattke , ncstattke , varstke , nrectke , khigh - klow + 1 ) end if !myid endif !ltkedump tstatsdumpp = dt else !tstatsdumpp < tstatsdump tstatsdumpp = tstatsdumpp + dt endif deallocate ( thlk , qtk , uik , wik , vjk , wjk , uij , vij , uc , vc , wc ) deallocate ( thlsgs , qtsgs , usgs , vsgs , wsgs ) deallocate ( sv1k , sv2k , sv3k , sv4k , sv1sgs , sv2sgs , sv3sgs , sv4sgs , PSS , wpsv1p , wpsv2p , wpsv3p , wpsv4p , sv1psv1pt , sv2psv2pt , sv3psv3pt , sv4psv4pt ) deallocate ( upwptik , vpwptjk , upvptij , wpthlptk , thlpthlpt , upuptc , vpvptc , wpwptc , tketc ) end subroutine statsdump !> tg3315 still under going work to be completed subroutine tkestatsdump use modfields , only : u0 , v0 , w0 , thl0 , uav , vav , wav , uuav , vvav , wwav , uvav , uwav , vwav , thlav , thlthlav , pres0 , thluav , thlvav , thlwav ,& upupav , vpvpav , wpwpav , thlpthlpav , upvpav , upwpav , vpwpav , thlpupav , thlpvpav , thlpwpav , presav ,& strain2av , disssgsav , t_vav , tvmx , tvmy , tvmz , tsgsmx1 , tsgsmx2 , tsgsmy1 , tsgsmy2 , tsgsmz1 , t_sgsav , nusgsav ,& tpm , t_pav , ttmx , ttmy , ttmz , t_tav , p_bav , d_sgsav , p_tav , tkeadv , tsgsmz1 , tsgsmz2 , t_t , t_v , t_p , t_sgs , d_sgs ,& p_b , p_t , adv , IIc , IIcs use modglobal , only : ib , ie , ih , jb , je , jgb , jge , dy , jh , ke , kb , kh , rk3step , timee , cexpnr , tsample , tstatsdump , jtot , imax , dzf ,& dzf , dzfi , dzhi , dxf , dxfi , dyi , dxhi , dy2i , grav , numol , ierank , jerank use modmpi , only : myid , cmyid , my_real , mpi_sum , avey_ibm , mpierr , comm3d , excjs , avexy_ibm use modsurfdata , only : thls use modsubgrid , only : ekh use decomp_2d , only : exchange_halo_z implicit none real , dimension ( ib : ie , jb : je , kb : ke ) :: disssgsfl ! average subgrid visc. * average rate of strain squared : 2*<nu_t>*<Sij>*<Sij> real , dimension ( ib : ie , jb : je , kb : ke ) :: dissresav ! average resolved dissipation: 2*nu*<Sij'*Sij'> = 2*nu*( <Sij*Sij> - <Sij>*<Sij> ) real , dimension ( ib : ie , jb : je , kb : ke ) :: tke ! tke = 0.5*<ui'ui'> real , dimension ( ib : ie , jb : je , kb : ke ) :: mke ! = <ui>d/dxj(<ui><uj>) + <ui>d/dxj(<ui'uj'>) = <ui>d/dxj(<ui*uj>) real , dimension ( ib - 1 : ie + 1 , jb - 1 : je + 1 , kb : ke ) :: dummyx real , dimension ( ib - 1 : ie + 1 , jb - 1 : je + 1 , kb : ke ) :: dummyy real , dimension ( ib : ie , jb : je , kb : ke + 1 ) :: dummyz integer i , j , k , ip , im , jp , jm , kp , km real strainav2 real dummy ! Tvav = (Tvm - <ui>*d/dxj(<Sij>)  ) + 2*nu*<Sij'Sij'> ! Tvm = Tvmx + Tvmy + Tvmz -> therefore: subtraction, then interpolation, ! then addition of 2*nu*<Sij'Sij'> do k = kb , ke km = k - 1 kp = k + 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie im = i - 1 ip = i + 1 !            t_vav(i,j,k) =  0.5*( (tvmx(i,j,k) - (                      & dummyx ( i , j , k ) = ( & ( numol * ( uav ( i + 1 , j , k ) - uav ( i , j , k )) * dxfi ( i ) & - numol * ( uav ( i , j , k ) - uav ( i - 1 , j , k )) * dxfi ( i - 1 ) ) * 2. * dxhi ( i ) & + & ( numol * ( ( uav ( i , jp , k ) - uav ( i , j , k )) * dyi & + ( vav ( i , jp , k ) - vav ( i - 1 , jp , k )) * dxhi ( i )) & - numol * ( ( uav ( i , j , k ) - uav ( i , jm , k )) * dyi & + ( vav ( i , j , k ) - vav ( i - 1 , j , k )) * dxhi ( i )) & ) * dyi & + & ( numol * ( ( uav ( i , j , kp ) - uav ( i , j , k )) * dzhi ( kp ) & + ( wav ( i , j , kp ) - wav ( i - 1 , j , kp )) * dxhi ( i )) & - numol * ( ( uav ( i , j , k ) - uav ( i , j , km )) * dzhi ( k ) & + ( wav ( i , j , k ) - wav ( i - 1 , j , k )) * dxhi ( i )) & ) * dzfi ( k ) ) ! y-direction dummyy ( i , j , k ) = ( & ( numol * ( ( vav ( i + 1 , j , k ) - vav ( i , j , k )) * dxhi ( i + 1 ) & + ( uav ( i + 1 , j , k ) - uav ( i + 1 , jm , k )) * dyi ) & - numol * ( ( vav ( i , j , k ) - vav ( i - 1 , j , k )) * dxhi ( i ) & + ( uav ( i , j , k ) - uav ( i , jm , k )) * dyi ) & ) * dxfi ( i ) & ! = d/dx( Km*(dv/dx + du/dy) ) + & ( numol * ( vav ( i , jp , k ) - vav ( i , j , k )) & - numol * ( vav ( i , j , k ) - vav ( i , jm , k )) ) * 2. * dy2i & ! =d/dy( 2*Km*(dv/dy) ) + & ( numol * ( ( vav ( i , j , kp ) - vav ( i , j , k )) * dzhi ( kp ) & + ( wav ( i , j , kp ) - wav ( i , jm , kp )) * dyi ) & - numol * ( ( vav ( i , j , k ) - vav ( i , j , km )) * dzhi ( k ) & + ( wav ( i , j , k ) - wav ( i , jm , k )) * dyi ) & ) * dzfi ( k ) ) ! = d/dz( Km*(dv/dz + dw/dy) ) ! z-direction dummyz ( i , j , k ) = ( & ( numol * ( ( wav ( i + 1 , j , k ) - wav ( i , j , k )) * dxhi ( i + 1 ) & + ( uav ( i + 1 , j , k ) - uav ( i + 1 , j , km )) * dzhi ( k ) ) & - numol * ( ( wav ( i , j , k ) - wav ( i - 1 , j , k )) * dxhi ( i ) & + ( uav ( i , j , k ) - uav ( i , j , km )) * dzhi ( k ) ) & ) * dxfi ( i ) & + & ( numol * ( ( wav ( i , jp , k ) - wav ( i , j , k )) * dyi & + ( vav ( i , jp , k ) - vav ( i , jp , km )) * dzhi ( k ) ) & - numol * ( ( wav ( i , j , k ) - wav ( i , jm , k )) * dyi & + ( vav ( i , j , k ) - vav ( i , j , km )) * dzhi ( k ) ) & ) * dyi & + & ( numol * ( wav ( i , j , kp ) - wav ( i , j , k )) * dzfi ( k ) & - numol * ( wav ( i , j , k ) - wav ( i , j , km )) * dzfi ( km ) ) * 2. & * dzhi ( k )) strainav2 = ( & (( uav ( ip , j , k ) - uav ( i , j , k )) * dxfi ( i ) ) ** 2 + & (( vav ( i , jp , k ) - vav ( i , j , k )) * dyi ) ** 2 + & (( wav ( i , j , kp ) - wav ( i , j , k )) * dzfi ( k ) ) ** 2 ) strainav2 = strainav2 + 0.125 * ( & (( wav ( i , j , kp ) - wav ( im , j , kp )) * dxhi ( i ) + & ( uav ( i , j , kp ) - uav ( i , j , k )) * dzhi ( kp ) ) ** 2 + & (( wav ( i , j , k ) - wav ( im , j , k )) * dxhi ( i ) + & ( uav ( i , j , k ) - uav ( i , j , km )) * dzhi ( k ) ) ** 2 + & (( wav ( ip , j , k ) - wav ( i , j , k )) * dxhi ( ip ) + & ( uav ( ip , j , k ) - uav ( ip , j , km )) * dzhi ( k ) ) ** 2 + & (( wav ( ip , j , kp ) - wav ( i , j , kp )) * dxhi ( ip ) + & ( uav ( ip , j , kp ) - uav ( ip , j , k )) * dzhi ( kp ) ) ** 2 ) strainav2 = strainav2 + 0.125 * ( & (( uav ( i , jp , k ) - uav ( i , j , k )) * dyi + & ( vav ( i , jp , k ) - vav ( im , jp , k )) * dxhi ( i ) ) ** 2 + & (( uav ( i , j , k ) - uav ( i , jm , k )) * dyi + & ( vav ( i , j , k ) - vav ( im , j , k )) * dxhi ( i ) ) ** 2 + & (( uav ( ip , j , k ) - uav ( ip , jm , k )) * dyi + & ( vav ( ip , j , k ) - vav ( i , j , k )) * dxhi ( ip ) ) ** 2 + & (( uav ( ip , jp , k ) - uav ( ip , j , k )) * dyi + & ( vav ( ip , jp , k ) - vav ( i , jp , k )) * dxhi ( ip ) ) ** 2 ) strainav2 = strainav2 + 0.125 * ( & (( vav ( i , j , kp ) - vav ( i , j , k )) * dzhi ( kp ) + & ( wav ( i , j , kp ) - wav ( i , jm , kp )) * dyi ) ** 2 + & (( vav ( i , j , k ) - vav ( i , j , km )) * dzhi ( k ) + & ( wav ( i , j , k ) - wav ( i , jm , k )) * dyi ) ** 2 + & (( vav ( i , jp , k ) - vav ( i , jp , km )) * dzhi ( k ) + & ( wav ( i , jp , k ) - wav ( i , j , k )) * dyi ) ** 2 + & (( vav ( i , jp , kp ) - vav ( i , jp , k )) * dzhi ( kp ) + & ( wav ( i , jp , kp ) - wav ( i , j , kp )) * dyi ) ** 2 ) dissresav ( i , j , k ) = 2. * numol * ( strain2av ( i , j , k ) - strainav2 ) !resolved dissipation end do end do end do ! call excjs( tvmy   , ib,ie,jb,je,kb,ke,0,1)   ! jb-1 is not used ! call excjs( tsgsmy1, ib,ie,jb,je,kb,ke,0,1)   ! jb-1 is not used ! call excjs( tsgsmy2, ib,ie,jb,je,kb,ke,0,1)   ! jb-1 is not used ! call excjs( dummyy,  ib,ie,jb,je,kb,ke,0,1)   ! jb-1 is not used ! call excjs( ttmy   , ib,ie,jb,je,kb,ke,0,1)   ! jb-1 is not used call exchange_halo_z ( tvmx , opt_zlevel = ( / ih , jh , 0 / )) call exchange_halo_z ( tsgsmx1 , opt_zlevel = ( / ih , jh , 0 / )) call exchange_halo_z ( tsgsmx2 , opt_zlevel = ( / ih , jh , 0 / )) call exchange_halo_z ( dummyx , opt_zlevel = ( / ih , jh , 0 / )) call exchange_halo_z ( ttmx , opt_zlevel = ( / ih , jh , 0 / )) call exchange_halo_z ( tvmy , opt_zlevel = ( / ih , jh , 0 / )) call exchange_halo_z ( tsgsmy1 , opt_zlevel = ( / ih , jh , 0 / )) call exchange_halo_z ( tsgsmy2 , opt_zlevel = ( / ih , jh , 0 / )) call exchange_halo_z ( dummyy , opt_zlevel = ( / ih , jh , 0 / )) call exchange_halo_z ( ttmy , opt_zlevel = ( / ih , jh , 0 / )) ! BC's if ( ierank ) then tvmx ( ie + 1 ,:,:) = tvmx ( ie ,:,:) tsgsmx1 ( ie + 1 ,:,:) = tsgsmx1 ( ie ,:,:) tsgsmx2 ( ie + 1 ,:,:) = tsgsmx2 ( ie ,:,:) dummyx ( ie + 1 ,:,:) = dummyx ( ie ,:,:) ttmx ( ie + 1 ,:,:) = ttmx ( ie ,:,:) end if if ( jerank ) then tvmy (:, je + 1 ,:) = tvmy (:, je ,:) tsgsmy1 (:, je + 1 ,:) = tsgsmy1 (:, je ,:) tsgsmy2 (:, je + 1 ,:) = tsgsmy2 (:, je ,:) dummyy (:, je + 1 ,:) = dummyy (:, je ,:) ttmy (:, je + 1 ,:) = ttmy (:, je ,:) end if tvmz (:,:, ke + 1 ) = tvmz (:,:, ke ) tsgsmz1 (:,:, ke + 1 ) = tsgsmz1 (:,:, ke ) tsgsmz2 (:,:, ke + 1 ) = tsgsmz2 (:,:, ke ) dummyz (:,:, ke + 1 ) = dummyz (:,:, ke ) ttmz (:,:, ke + 1 ) = ttmz (:,:, ke ) do k = kb , ke km = k - 1 kp = k + 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie im = i - 1 ip = i + 1 ! Total viscous dissipation t_vav ( i , j , k ) = 0.5 * ( ( tvmx ( i , j , k ) - dummyx ( i , j , k ) * uav ( i , j , k )) + & ( tvmx ( ip , j , k ) - dummyx ( ip , j , k ) * uav ( ip , j , k ))) & + 0.5 * ( ( tvmy ( i , j , k ) - dummyy ( i , j , k ) * vav ( i , j , k )) + & ( tvmy ( i , jp , k ) - dummyy ( i , jp , k ) * vav ( i , jp , k ))) & + 0.5 * ( ( tvmz ( i , j , k ) - dummyz ( i , j , k ) * wav ( i , j , k )) + & ( tvmz ( i , j , kp ) - dummyz ( i , j , kp ) * wav ( i , j , kp ))) & + dissresav ( i , j , k ) ! d/dxj(2*nu*<ui'Sij'>) = <u_i*d/dxj(2*nu*Sij')> +2*nu*<Sij'Sij'> !      Now the same for subgrid stress !      <d/dxj(2*u_i'*nu_t*Sij)'> = <u_i'*d/dxj(2*nu_t*Sij)'> + <(2*nu_t*Sij)'*Sij'> !                                = <u_i*d/dxj(2*nu_t*Sij)> - !                                  <u_i>*<d/dxj(2*nu_t*Sij)>   + <2*nu_t*Sij*Sij> - !                                  <(2*nu_t*Sij)>*<Sij> !                                = <u_i*d/dxj(2*nu_t*Sij)> - !                                  <u_i>*<d/dxj(2*nu_t*Sij)>   + <2*nu_t*Sij*Sij> - !                                  2*<nu_t>*<Sij>*<Sij> - 2*<nu_t'*Sij'>*<Sij> !--------------------------------------- !Total subgrid TKE !--------------------------------------- ! Mean SGS dissipation disssgsfl ( i , j , k ) = 2. * nusgsav ( i , j , k ) * strainav2 ! = 2*<nu_sgs>*<sij>*<sij> ! TKE tke ( i , j , k ) = 0.5 * ( 0.5 * ( upupav ( ip , j , k ) + upupav ( i , j , k )) + & 0.5 * ( vpvpav ( i , jp , k ) + vpvpav ( i , j , k )) + & 0.5 * ( wpwpav ( i , j , kp ) + wpwpav ( i , j , k ))) ! total SGS t_sgsav ( i , j , k ) = 0.5 * ( ( tsgsmx1 ( i , j , k ) - uav ( i , j , k ) * tsgsmx2 ( i , j , k )) + & ( tsgsmx1 ( ip , j , k ) - uav ( ip , j , k ) * tsgsmx2 ( ip , j , k ))) & + & ! = <2*nu_t*SijSij> - <2*nu_t*Sij>*<Sij> 0.5 * ( ( tsgsmy1 ( i , j , k ) - vav ( i , j , k ) * tsgsmy2 ( i , j , k )) + & ( tsgsmy1 ( i , jp , k ) - vav ( i , jp , k ) * tsgsmy2 ( i , jp , k ))) & + & ! = <2*nu_t*SijSij> - <2*nu_t*Sij>*<Sij> 0.5 * ( ( tsgsmz1 ( i , j , k ) - vav ( i , j , k ) * tsgsmz2 ( i , j , k )) + & ( tsgsmz1 ( i , j , kp ) - vav ( i , j , kp ) * tsgsmz2 ( i , j , kp ))) & + disssgsav ( i , j , k ) - disssgsfl ( i , j , k ) ! -2*<nu_t'Sij'>*<Sij>  should still be added! ! SGS dissipation d_sgsav ( i , j , k ) = - disssgsav ( i , j , k ) + disssgsfl ( i , j , k ) ! +2*<nu_t'Sij'>*<Sij>  should still be added! (is compensated with above) !--------------------------------------- !Total pressure TKE !--------------------------------------- ! Pressure correlation term ! - <uj'*dp'/dxj> = - <uj*dp/dxj> + <uj>*d<p>/dxj t_pav ( i , j , k ) = tpm ( i , j , k ) + & 0.5 * ( uav ( i , j , k ) * ( presav ( i , j , k ) - presav ( i - 1 , j , k )) * dxhi ( i ) + & uav ( i + 1 , j , k ) * ( presav ( i + 1 , j , k ) - presav ( i , j , k )) * dxhi ( i + 1 )) & + & 0.5 * ( vav ( i , j , k ) * ( presav ( i , j , k ) - presav ( i , j - 1 , k )) * dyi + & vav ( i , j + 1 , k ) * ( presav ( i , j + 1 , k ) - presav ( i , j , k )) * dyi ) & + & 0.5 * ( wav ( i , j , k ) * ( presav ( i , j , k ) - presav ( i , j , k - 1 )) * dzhi ( k ) + & wav ( i , j , k + 1 ) * ( presav ( i , j , k + 1 ) - presav ( i , j , k )) * dzhi ( k + 1 )) ! - d/dxj(<0.5*ui'ui'uj'>) = -<uj'd/dxj(<0.5*ui'ui'>) + <ui'uj'><Sij> !                             = -<uj*d/dxj(0.5*ui'ui')> + <uj>*d/dxj(<0.5*ui'ui'> + !                             <ui'uj'><Sij>) !            ttav(i,j,k)   = ttm(i,j,k) - !--------------------------------------- !Total advection TKE !--------------------------------------- !            <advection term N.S. times ui> = MKE + A - Pshear - Tt !            Tt = -<ui'd/dxj(ui'uj')> = -<d/dxj(0.5*ui'ui'uj')> = A + MKE - Pshear - Total !Pshear =Ptav = -<ui'uj'>d/dxj(<Sij>) = -<ui'uj'>d<ui>/dxj ! mechanical or shear production p_tav ( i , j , k ) = - ( & 0.5 * ( upupav ( i , j , k ) + upupav ( ip , j , k )) * ( uav ( ip , j , k ) - uav ( i , j , k )) * dxfi ( i ) + & ! <u'u'>*d<u>/dx 0.25 * ( upvpav ( i , j , k ) * ( uav ( i , j , k ) - uav ( i , jm , k ) ) * dyi + & upvpav ( i , jp , k ) * ( uav ( i , jp , k ) - uav ( i , j , k ) ) * dyi + & upvpav ( ip , j , k ) * ( uav ( ip , j , k ) - uav ( ip , jm , k ) ) * dyi + & upvpav ( ip , jp , k ) * ( uav ( ip , jp , k ) - uav ( ip , j , k ) ) * dyi ) + & ! <u'v'>*d<u>/dy 0.25 * ( upwpav ( i , j , k ) * ( uav ( i , j , k ) - uav ( i , j , km )) * dzhi ( k ) + & upwpav ( i , j , kp ) * ( uav ( i , j , kp ) - uav ( i , j , k )) * dzhi ( kp ) + & upwpav ( ip , j , k ) * ( uav ( ip , j , k ) - uav ( ip , j , km )) * dzhi ( k ) + & upwpav ( ip , j , kp ) * ( uav ( ip , j , kp ) - uav ( ip , j , k )) * dzhi ( kp )) + & ! <u'w'>*d<u>/dz 0.25 * ( upvpav ( i , j , k ) * ( vav ( i , j , k ) - vav ( im , j , k )) * dxhi ( i ) + & upvpav ( ip , j , k ) * ( vav ( ip , j , k ) - vav ( i , j , k )) * dxhi ( ip ) + & upvpav ( i , jp , k ) * ( vav ( i , jp , k ) - vav ( im , jp , k )) * dxhi ( i ) + & upvpav ( ip , jp , k ) * ( vav ( ip , jp , k ) - vav ( i , jp , k )) * dxhi ( ip )) + & ! <u'v'>*d<v>/dx 0.5 * ( vpvpav ( i , j , k ) + vpvpav ( i , jp , k )) * ( vav ( i , jp , k ) - vav ( i , j , k )) * dyi + & ! <v'v'>*d<v>/dy 0.5 * ( vpvpav ( i , j , k ) + vpvpav ( i , jp , k )) * ( vav ( i , jp , k ) - vav ( i , j , k )) * dyi + & ! <v'v'>*d<v>/dy 0.25 * ( vpwpav ( i , j , k ) * ( vav ( i , j , k ) - vav ( i , j , km )) * dzhi ( k ) + & vpwpav ( i , j , kp ) * ( vav ( i , j , kp ) - vav ( i , j , k )) * dzhi ( kp ) + & vpwpav ( i , jp , k ) * ( vav ( i , jp , k ) - vav ( i , jp , km )) * dzhi ( k ) + & vpwpav ( i , jp , kp ) * ( vav ( i , jp , kp ) - vav ( i , jp , k )) * dzhi ( kp )) + & ! <v'w'>*d<v>/dz 0.25 * ( upwpav ( i , j , k ) * ( wav ( i , j , k ) - wav ( im , j , k )) * dxhi ( i ) + & upwpav ( ip , j , k ) * ( wav ( ip , j , k ) - wav ( i , j , k )) * dxhi ( ip ) + & upwpav ( i , j , kp ) * ( wav ( i , j , kp ) - wav ( im , j , kp )) * dxhi ( i ) + & upwpav ( ip , j , kp ) * ( wav ( ip , j , kp ) - wav ( i , j , kp )) * dxhi ( ip )) + & ! <u'w'>*d<w>/dx 0.25 * ( vpwpav ( i , j , k ) * ( wav ( i , j , k ) - wav ( i , jm , k ) ) * dyi + & vpwpav ( i , jp , k ) * ( wav ( i , jp , k ) - wav ( i , j , k ) ) * dyi + & vpwpav ( ip , j , k ) * ( wav ( i , j , kp ) - wav ( i , jm , kp ) ) * dyi + & vpwpav ( ip , jp , k ) * ( wav ( i , jp , kp ) - wav ( i , j , kp ) ) * dyi ) + & ! <v'w'>*d<w>/dy 0.5 * ( wpwpav ( i , j , k ) + wpwpav ( i , j , kp )) * ( wav ( i , j , kp ) - wav ( i , j , k )) * dzfi ( k ) ) ! <w'w'>*d<w>/dz ! Mean kinetic energy term (expected to be small). mke ( i , j , k ) = 0.5 * ( uav ( ip , j , k ) + uav ( i , j , k )) * ( uuav ( ip , j , k ) - uuav ( i , j , k )) * dxfi ( i ) + & !<u>*d<uu>/dx 0.5 * ( uav ( i , j , k ) * ( uvav ( i , jp , k ) - uvav ( i , j , k )) * dyi + & ! <u>*d<uv>/dy uav ( ip , j , k ) * ( uvav ( ip , jp , k ) - uvav ( ip , j , k )) * dyi ) + & 0.5 * ( uav ( i , j , k ) * ( uwav ( i , j , kp ) - uwav ( i , j , k )) * dzfi ( k ) + & ! <u>*d<uw>/dz uav ( ip , j , k ) * ( uwav ( ip , j , kp ) - uwav ( ip , j , k )) * dzfi ( k )) + & 0.5 * ( vav ( i , j , k ) * ( uvav ( ip , j , k ) - uvav ( i , j , k )) * dxfi ( i ) + & ! <v>*d<uv>/dx vav ( i , jp , k ) * ( uvav ( ip , jp , k ) - uvav ( i , jp , k )) * dxfi ( i )) + & 0.5 * ( vav ( i , jp , k ) + vav ( i , j , k )) * ( vvav ( i , jp , k ) - vvav ( i , j , k )) * dyi + & ! <v>*d<vv>/dy 0.5 * ( vav ( i , j , k ) * ( vwav ( i , j , kp ) - vwav ( i , j , k )) * dzfi ( k ) + & ! <v>*d<vw>/dz vav ( i , jp , k ) * ( vwav ( i , jp , kp ) - vwav ( i , jp , k )) * dzfi ( k )) + & 0.5 * ( wav ( i , j , k ) * ( uwav ( ip , j , k ) - uwav ( i , j , k )) * dxfi ( i ) + & ! <w>*d<uw>/dx wav ( i , j , kp ) * ( uwav ( ip , j , kp ) - uwav ( i , j , kp )) * dxfi ( i )) + & 0.5 * ( wav ( i , j , k ) * ( vwav ( i , jp , k ) - vwav ( i , j , k )) * dyi + & ! <w>*d<vw>/dy wav ( i , j , kp ) * ( vwav ( i , jp , kp ) - vwav ( i , j , kp )) * dyi ) + & 0.5 * ( wav ( i , j , kp ) + wav ( i , j , k )) * ( wwav ( i , j , kp ) - wwav ( i , j , k )) * dzfi ( k ) ! <w>*d<ww>/dz ! Advection of TKE tkeadv ( i , j , k ) = 0.5 * ( uav ( i , j , k ) * ( tke ( i , j , k ) - tke ( im , j , k )) * dxhi ( i ) + & ! <u>*de/dx uav ( ip , j , k ) * ( tke ( ip , j , k ) - tke ( i , j , k )) * dxhi ( ip )) + & ! 0.5 * ( vav ( i , j , k ) * ( tke ( i , j , k ) - tke ( i , jm , k )) * dyi + & ! <v>*de/dy vav ( i , jp , k ) * ( tke ( i , jp , k ) - tke ( i , j , k )) * dyi ) + & 0.5 * ( wav ( i , j , k ) * ( tke ( i , j , k ) - tke ( i , j , km )) * dzhi ( k ) + & ! <w>*de/dz wav ( i , j , kp ) * ( tke ( i , j , kp ) - tke ( i , j , k )) * dzhi ( kp )) ! <advection term N.S. times ui> = MKE + A - Pshear - Tt ! Tt = -<ui'd/dxj(ui'uj')> = -<d/dxj(0.5*ui'ui'uj')> = A      +    MKE   - ! Pshear  -   Total !                                                    = tkeadv +    mke   - !                                                    p_tav   -   ttm !        t_tav(i,j,k)   = tkeadv(i,j,k) + mke(i,j,k) - p_tav(i,j,k) - ttm(i,j,k) t_tav ( i , j , k ) = tkeadv ( i , j , k ) + mke ( i , j , k ) - p_tav ( i , j , k ) & - 0.5 * ( ttmx ( i , j , k ) + ttmx ( ip , j , k )) & - 0.5 * ( ttmy ( i , j , k ) + ttmy ( i , jp , k )) & - 0.5 * ( ttmz ( i , j , k ) + ttmz ( i , j , kp )) p_bav ( i , j , k ) = ( grav / thls ) * 0.5 * ( thlpwpav ( i , j , k ) + thlpwpav ( i , j , kp )) !use of thls here...???? end do end do end do ! need updating tg3315 call avexy_ibm ( p_b ( kb : ke + kh ), p_bav (:,:, kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc , IIcs ,. true .) call avexy_ibm ( t_p ( kb : ke + kh ), t_pav (:,:, kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc , IIcs ,. true .) call avexy_ibm ( adv ( kb : ke + kh ), tkeadv (:,:, kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc , IIcs ,. true .) call avexy_ibm ( t_t ( kb : ke + kh ), t_tav (:,:, kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc , IIcs ,. true .) call avexy_ibm ( t_sgs ( kb : ke + kh ), t_sgsav (:,:, kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc , IIcs ,. true .) call avexy_ibm ( p_t ( kb : ke + kh ), p_tav (:,:, kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc , IIcs ,. true .) call avexy_ibm ( d_sgs ( kb : ke + kh ), d_sgsav (:,:, kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc , IIcs ,. true .) call avexy_ibm ( t_v ( kb : ke + kh ), t_vav (:,:, kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc , IIcs ,. true .) end subroutine tkestatsdump !------------------------- !> Clean up when leaving the run !------------------------ subroutine exitstatsdump use modstat_nc , only : exitstat_nc use modglobal , only : ltdump implicit none !       if (lydump) then !         call exitstat_nc(ncid) !       endif ! will doing this ruin the averaging? ... try tg3315 !       if (lytdump) then !         call exitstat_nc(ncidt) !       endif !      if (ltkedump) then !        call exitstat_nc(ncidtke) !      endif !       if (ltdump) then !         call exitstat_nc(ncidt) !       endif end subroutine exitstatsdump end module modstatsdump","tags":"","url":"sourcefile/modstatsdump.f90.html"},{"title":"modfielddump.f90 – uDALES","text":"This file depends on sourcefile~~modfielddump.f90~~EfferentGraph sourcefile~modfielddump.f90 modfielddump.f90 sourcefile~modfields.f90 modfields.f90 sourcefile~modfielddump.f90->sourcefile~modfields.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~modfielddump.f90->sourcefile~modglobal.f90 sourcefile~modibm.f90 modibm.f90 sourcefile~modfielddump.f90->sourcefile~modibm.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~modfielddump.f90->sourcefile~modmpi.f90 sourcefile~modstat_nc.f90 modstat_nc.f90 sourcefile~modfielddump.f90->sourcefile~modstat_nc.f90 sourcefile~modsurfdata.f90 modsurfdata.f90 sourcefile~modfielddump.f90->sourcefile~modsurfdata.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 sourcefile~modibm.f90->sourcefile~modfields.f90 sourcefile~modibm.f90->sourcefile~modglobal.f90 sourcefile~modibm.f90->sourcefile~modmpi.f90 sourcefile~modibm.f90->sourcefile~modstat_nc.f90 sourcefile~modibm.f90->sourcefile~modsurfdata.f90 sourcefile~initfac.f90 initfac.f90 sourcefile~modibm.f90->sourcefile~initfac.f90 sourcefile~modboundary.f90 modboundary.f90 sourcefile~modibm.f90->sourcefile~modboundary.f90 sourcefile~modibmdata.f90 modibmdata.f90 sourcefile~modibm.f90->sourcefile~modibmdata.f90 sourcefile~modsubgriddata.f90 modsubgriddata.f90 sourcefile~modibm.f90->sourcefile~modsubgriddata.f90 sourcefile~modstat_nc.f90->sourcefile~modglobal.f90 sourcefile~modstat_nc.f90->sourcefile~modmpi.f90 sourcefile~initfac.f90->sourcefile~modglobal.f90 sourcefile~initfac.f90->sourcefile~modmpi.f90 sourcefile~modboundary.f90->sourcefile~modfields.f90 sourcefile~modboundary.f90->sourcefile~modglobal.f90 sourcefile~modboundary.f90->sourcefile~modmpi.f90 sourcefile~modboundary.f90->sourcefile~modsurfdata.f90 sourcefile~modboundary.f90->sourcefile~modsubgriddata.f90 sourcefile~moddriver.f90 moddriver.f90 sourcefile~modboundary.f90->sourcefile~moddriver.f90 sourcefile~modinletdata.f90 modinletdata.f90 sourcefile~modboundary.f90->sourcefile~modinletdata.f90 sourcefile~moddriver.f90->sourcefile~modfields.f90 sourcefile~moddriver.f90->sourcefile~modglobal.f90 sourcefile~moddriver.f90->sourcefile~modmpi.f90 sourcefile~moddriver.f90->sourcefile~modinletdata.f90 sourcefile~modsave.f90 modsave.f90 sourcefile~moddriver.f90->sourcefile~modsave.f90 sourcefile~modsave.f90->sourcefile~modfields.f90 sourcefile~modsave.f90->sourcefile~modglobal.f90 sourcefile~modsave.f90->sourcefile~modmpi.f90 sourcefile~modsave.f90->sourcefile~modsurfdata.f90 sourcefile~modsave.f90->sourcefile~initfac.f90 sourcefile~modsave.f90->sourcefile~modibmdata.f90 sourcefile~modsave.f90->sourcefile~modsubgriddata.f90 sourcefile~modsave.f90->sourcefile~modinletdata.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~modfielddump.f90~~AfferentGraph sourcefile~modfielddump.f90 modfielddump.f90 sourcefile~program.f90 program.f90 sourcefile~program.f90->sourcefile~modfielddump.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> \\file modfielddump.f90 !!  Dumps 3D fields of several variables !> !!  Dumps 3D fields of several variables Written to wb*.myid.expnr !! If netcdf is true, this module leads the fielddump.myid.expnr.nc output !!  \\author Jasper Tomas, TU Delft Match 31 2014 !!  \\author Thijs Heus,MPI-M !!  \\par Revision list !! Possibility to write tecplot (formatted!!) file ! !  This file is part of DALES. ! ! DALES is free software; you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation; either version 3 of the License, or ! (at your option) any later version. ! ! DALES is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !  Copyright 1993-2009 Delft University of Technology, Wageningen University, Utrecht University, KNMI ! module modfielddump use mpi use modglobal , only : longint use modfields , only : ncname , ncname1 , ncname2 implicit none private PUBLIC :: initfielddump , fielddump , exitfielddump save !NetCDF variables integer :: ncid , ncid1 , ncid2 , nrec = 0 !  real, pointer :: point type domainptr real , pointer :: point (:,:,:) end type domainptr type ( domainptr ), dimension ( 30 ) :: pfields character ( 80 ) :: fname = 'fielddump.xxx.xxx.xxx.nc' character ( 80 ) :: fname1 = 'fielddump.xxx.xxx.xxx.1.nc' character ( 80 ) :: fname2 = 'fielddump.xxx.xxx.xxx.2.nc' !dimension(nvar,4) :: ncname character ( 80 ), dimension ( 1 , 4 ) :: tncname character ( 80 ), dimension ( 1 , 4 ) :: tncname1 character ( 80 ), dimension ( 1 , 4 ) :: tncname2 integer :: ilow , ihigh , jlow , jhigh , klow , khigh , nvar logical :: ldiracc = . false . !< switch for doing direct access writing (on/off) logical :: lbinary = . false . ! logical :: lhalos contains !> Initializing fielddump. Read out the namelist, initializing the variables subroutine initfielddump use modmpi , only : myid , my_real , mpierr , comm3d , mpi_logical , mpi_integer , cmyidx , cmyidy , mpi_character use modglobal , only : imax , jmax , kmax , imax1 , jmax1 , kmax1 , imax2 , jmax2 , kmax2 , cexpnr , ifnamopt , fname_options , dtmax , kb , ke , ladaptive , dt_lim , btime , nsv , fieldvars , ib , ie , jb , je , kb , ke , ih , jh , lfielddump , ktot , kh use modstat_nc , only : open_nc , define_nc , ncinfo , writestat_dims_nc use modfields , only : u0 , v0 , w0 , thl0 , sv0 , ql0 , qt0 , pres0 , div , dudx , dvdy , dwdz , ru , rv , rw , tau_x , tau_y , tau_z , thl_flux use modpois , only : p , pup , pvp , pwp , rhs , dpupdx , dpvpdy , dpwpdz , xyzrt , Fxy , Fxyz use modibm , only : mask_u , mask_v , mask_w , mask_c implicit none integer :: ierr , n !type(domainptr), dimension(nvar) :: pfields nvar = ( LEN ( trim ( fieldvars )) + 1 ) / 3 if ( nvar == 0 ) then lfielddump = . false . print * , 'empty fieldvars therefore lfielddump = .false. and no instantaneous fields outputted' return else allocate ( ncname ( nvar , 4 )) end if lhalos = . false . if ( lhalos ) then ilow = ib - ih ihigh = ie + ih jlow = jb - jh jhigh = je + jh klow = kb - kh khigh = ke + kh else ilow = ib ihigh = ie jlow = jb jhigh = je klow = kb khigh = ke end if !ils13 13.08.18: why is this broadcast, doesn't every processor do it anyway? call MPI_BCAST ( klow , 1 , MPI_INTEGER , 0 , comm3d , ierr ) call MPI_BCAST ( khigh , 1 , MPI_INTEGER , 0 , comm3d , ierr ) call MPI_BCAST ( lfielddump , 1 , MPI_LOGICAL , 0 , comm3d , ierr ) call MPI_BCAST ( ldiracc , 1 , MPI_LOGICAL , 0 , comm3d , ierr ) call MPI_BCAST ( lbinary , 1 , MPI_LOGICAL , 0 , comm3d , ierr ) call MPI_BCAST ( ncname , 80 , MPI_CHARACTER , 0 , comm3d , mpierr ) call MPI_BCAST ( nvar , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) !    dt_lim = min(dt_lim,tnext) if (. not .( lfielddump )) return fname ( 11 : 13 ) = cmyidx fname ( 15 : 17 ) = cmyidy fname ( 19 : 21 ) = cexpnr call ncinfo ( tncname ( 1 ,:), 'time' , 'Time' , 's' , 'time' ) ! tg3315 reads in fields specified by fieldvars if ( lhalos ) then do n = 1 , nvar select case ( fieldvars ( 3 * n - 2 : 3 * n - 1 )) case ( 'u0' ) call ncinfo ( ncname ( n ,:), 'u' , 'West-East velocity' , 'm/s' , 'mttt' ) pfields ( n )% point => u0 ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ) case ( 'v0' ) call ncinfo ( ncname ( n ,:), 'v' , 'South-North velocity' , 'm/s' , 'tmtt' ) pfields ( n )% point => v0 ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ) case ( 'w0' ) call ncinfo ( ncname ( n ,:), 'w' , 'Vertical velocity' , 'm/s' , 'ttmt' ) pfields ( n )% point => w0 ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ) case ( 'th' ) call ncinfo ( ncname ( n ,:), 'thl' , 'Liquid water potential temperature' , 'K' , 'tttt' ) pfields ( n )% point => thl0 ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ) case ( 'ql' ) call ncinfo ( ncname ( n ,:), 'ql' , 'Liquid water mixing ratio' , '1e-5kg/kg' , 'tttt' ) pfields ( n )% point => ql0 ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ) case ( 'qt' ) call ncinfo ( ncname ( n ,:), 'qt' , 'Total water mixing ratio' , '1e-5kg/kg' , 'tttt' ) pfields ( n )% point => qt0 ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ) case ( 's1' ) call ncinfo ( ncname ( n ,:), 'sca1' , 'scalar 1' , 'M' , 'tttt' ) pfields ( n )% point => sv0 ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke , 1 ) case ( 's2' ) call ncinfo ( ncname ( n ,:), 'sca2' , 'scalar 2' , 'M' , 'tttt' ) pfields ( n )% point => sv0 ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke , 2 ) case ( 's3' ) call ncinfo ( ncname ( n ,:), 'sca3' , 'scalar 3' , 'M' , 'tttt' ) pfields ( n )% point => sv0 ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke , 3 ) case ( 's4' ) call ncinfo ( ncname ( n ,:), 'sca4' , 'scalar 4' , 'M' , 'tttt' ) pfields ( n )% point => sv0 ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke , 4 ) case ( 's5' ) call ncinfo ( ncname ( n ,:), 'sca5' , 'scalar 5' , 'M' , 'tttt' ) pfields ( n )% point => sv0 ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke , 5 ) case ( 'p0' ) call ncinfo ( ncname ( n ,:), 'pres' , 'pressure field' , 'M' , 'tttt' ) pfields ( n )% point => pres0 ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ) ! case('pd') !   call ncinfo(ncname( n,:),'p','pressure correction','M','tttt') !   pfields(n)%point => p(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh) ! case('pu') !   call ncinfo(ncname( n,:),'pup','predicted u','M','mttt') !   pfields(n)%point => pup(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh) ! case('pv') !   call ncinfo(ncname( n,:),'pvp','predicted v','M','tmtt') !   pfields(n)%point => pvp(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh) ! case('pw') !   call ncinfo(ncname( n,:),'pwp','predicted w','M','ttmt') !   pfields(n)%point => pwp(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh) ! case('du') !   call ncinfo(ncname( n,:),'dpupdx','','M','tttt') !   pfields(n)%point => dpupdx(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh) ! case('dv') !   call ncinfo(ncname( n,:),'dpvpdy','','M','tttt') !   pfields(n)%point => dpvpdy(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh) ! case('dw') !   call ncinfo(ncname( n,:),'dpwpdz','','M','tttt') !   pfields(n)%point => dpwpdz(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh) ! case default !   call ncinfo(ncname( n,:),'u','West-East velocity','m/s','mttt') !   pfields(n)%point => u0(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh) end select end do else do n = 1 , nvar select case ( fieldvars ( 3 * n - 2 : 3 * n - 1 )) case ( 'u0' ) call ncinfo ( ncname ( n ,:), 'u' , 'West-East velocity' , 'm/s' , 'mttt' ) pfields ( n )% point => u0 ( ib : ie , jb : je , kb : ke ) case ( 'v0' ) call ncinfo ( ncname ( n ,:), 'v' , 'South-North velocity' , 'm/s' , 'tmtt' ) pfields ( n )% point => v0 ( ib : ie , jb : je , kb : ke ) case ( 'w0' ) call ncinfo ( ncname ( n ,:), 'w' , 'Vertical velocity' , 'm/s' , 'ttmt' ) pfields ( n )% point => w0 ( ib : ie , jb : je , kb : ke ) case ( 'th' ) call ncinfo ( ncname ( n ,:), 'thl' , 'Liquid water potential temperature' , 'K' , 'tttt' ) pfields ( n )% point => thl0 ( ib : ie , jb : je , kb : ke ) case ( 'ql' ) call ncinfo ( ncname ( n ,:), 'ql' , 'Liquid water mixing ratio' , '1e-5kg/kg' , 'tttt' ) pfields ( n )% point => ql0 ( ib : ie , jb : je , kb : ke ) case ( 'qt' ) call ncinfo ( ncname ( n ,:), 'qt' , 'Total water mixing ratio' , '1e-5kg/kg' , 'tttt' ) pfields ( n )% point => qt0 ( ib : ie , jb : je , kb : ke ) case ( 's1' ) call ncinfo ( ncname ( n ,:), 'sca1' , 'scalar 1' , 'M' , 'tttt' ) pfields ( n )% point => sv0 ( ib : ie , jb : je , kb : ke , 1 ) case ( 's2' ) call ncinfo ( ncname ( n ,:), 'sca2' , 'scalar 2' , 'M' , 'tttt' ) pfields ( n )% point => sv0 ( ib : ie , jb : je , kb : ke , 2 ) case ( 's3' ) call ncinfo ( ncname ( n ,:), 'sca3' , 'scalar 3' , 'M' , 'tttt' ) pfields ( n )% point => sv0 ( ib : ie , jb : je , kb : ke , 3 ) case ( 's4' ) call ncinfo ( ncname ( n ,:), 'sca4' , 'scalar 4' , 'M' , 'tttt' ) pfields ( n )% point => sv0 ( ib : ie , jb : je , kb : ke , 4 ) case ( 's5' ) call ncinfo ( ncname ( n ,:), 'sca5' , 'scalar 5' , 'M' , 'tttt' ) pfields ( n )% point => sv0 ( ib : ie , jb : je , kb : ke , 5 ) case ( 'p0' ) call ncinfo ( ncname ( n ,:), 'pres' , 'pressure field' , 'M' , 'tttt' ) pfields ( n )% point => pres0 ( ib : ie , jb : je , kb : ke ) case ( 'tx' ) call ncinfo ( ncname ( n ,:), 'tau_x' , 'stress x' , 'M' , 'mttt' ) pfields ( n )% point => tau_x ( ib : ie , jb : je , kb : ke ) case ( 'ty' ) call ncinfo ( ncname ( n ,:), 'tau_y' , 'stress y' , 'M' , 'tmtt' ) pfields ( n )% point => tau_y ( ib : ie , jb : je , kb : ke ) case ( 'tz' ) call ncinfo ( ncname ( n ,:), 'tau_z' , 'stress z' , 'M' , 'ttmt' ) pfields ( n )% point => tau_z ( ib : ie , jb : je , kb : ke ) case ( 'hf' ) call ncinfo ( ncname ( n ,:), 'thl_flux' , 'heat flux' , 'M' , 'tttt' ) pfields ( n )% point => thl_flux ( ib : ie , jb : je , kb : ke ) case ( 'mu' ) call ncinfo ( ncname ( n ,:), 'mask_u' , 'mask u' , 'M' , 'mttt' ) pfields ( n )% point => mask_u ( ib : ie , jb : je , kb : ke ) case ( 'mv' ) call ncinfo ( ncname ( n ,:), 'mask_v' , 'mask v' , 'M' , 'tmtt' ) pfields ( n )% point => mask_v ( ib : ie , jb : je , kb : ke ) case ( 'mw' ) call ncinfo ( ncname ( n ,:), 'mask_w' , 'mask w' , 'M' , 'ttmt' ) pfields ( n )% point => mask_w ( ib : ie , jb : je , kb : ke ) case ( 'mc' ) call ncinfo ( ncname ( n ,:), 'mask_c' , 'mask c' , 'M' , 'tttt' ) pfields ( n )% point => mask_c ( ib : ie , jb : je , kb : ke ) ! case('pd') !   call ncinfo(ncname( n,:),'p','pressure correction','M','tttt') !   pfields(n)%point => p(ib:ie,jb:je,kb:ke) ! case('pu') !   call ncinfo(ncname( n,:),'pup','predicted u','M','mttt') !   pfields(n)%point => pup(ib:ie,jb:je,kb:ke) ! case('pv') !   call ncinfo(ncname( n,:),'pvp','predicted v','M','tmtt') !   pfields(n)%point => pvp(ib:ie,jb:je,kb:ke) ! case('pw') !   call ncinfo(ncname( n,:),'pwp','predicted w','M','ttmt') !   pfields(n)%point => pwp(ib:ie,jb:je,kb:ke) ! case('rs') !   call ncinfo(ncname( n,:),'rhs','rhs of poisson equation','M','tttt') !   pfields(n)%point => rhs(ib:ie,jb:je,kb:ke) ! case('du') !   call ncinfo(ncname( n,:),'dpupdx','','M','tttt') !   pfields(n)%point => dpupdx(ib:ie,jb:je,kb:ke) ! case('dv') !   call ncinfo(ncname( n,:),'dpvpdy','','M','tttt') !   pfields(n)%point => dpvpdy(ib:ie,jb:je,kb:ke) ! case('dw') !   call ncinfo(ncname( n,:),'dpwpdz','','M','tttt') !   pfields(n)%point => dpwpdz(ib:ie,jb:je,kb:ke) case ( 'di' ) call ncinfo ( ncname ( n ,:), 'div' , 'Divergence after pressure correction' , 'M' , 'tttt' ) pfields ( n )% point => div ( ib : ie , jb : je , kb : ke ) ! case('ft') !   call ncinfo(ncname( n,:),'ft','Fourier transformed data in x and y','M','tttt') !   pfields(n)%point => Fxy(ib:ie,jb:je,kb:ke) ! case('ge') !   call ncinfo(ncname( n,:),'ge','Fourier transformed data in x and y and done GE in z','M','tttt') !   pfields(n)%point => Fxyz(ib:ie,jb:je,kb:ke) ! case('ux') !   call ncinfo(ncname( n,:),'dudx','','M','tttt') !   pfields(n)%point => dudx(ib:ie,jb:je,kb:ke) ! case('vy') !   call ncinfo(ncname( n,:),'dvdy','','M','tttt') !   pfields(n)%point => dvdy(ib:ie,jb:je,kb:ke) ! case('wz') !   call ncinfo(ncname( n,:),'dwdz','','M','tttt') !   pfields(n)%point => dwdz(ib:ie,jb:je,kb:ke) ! case('up') !   call ncinfo(ncname( n,:),'up','','M','tttt') !   pfields(n)%point => ru(ib:ie,jb:je,kb:ke) ! case('vp') !   call ncinfo(ncname( n,:),'vp','','M','tttt') !   pfields(n)%point => rv(ib:ie,jb:je,kb:ke) ! case('wp') !   call ncinfo(ncname( n,:),'wp','','M','tttt') !   pfields(n)%point => rw(ib:ie,jb:je,kb:ke) ! case('rt') !   call ncinfo(ncname( n,:),'xyzrt','Wavenumbers','M','tttt') !   pfields(n)%point => xyzrt(1:sp%zsz(1),1:sp%zsz(2),1:ktot) case default call ncinfo ( ncname ( n ,:), 'u' , 'West-East velocity' , 'm/s' , 'mttt' ) pfields ( n )% point => u0 ( ib : ie , jb : je , kb : ke ) end select end do end if !call ncinfo(ncname( n,:),'u','West-East velocity','m/s','mttt') !call open_nc( fname, ncid, nrec, n1=imax+2, n2=jmax+2, n3=khigh-klow+1) call open_nc ( fname , ncid , nrec , n1 = ihigh - ilow + 1 , n2 = jhigh - jlow + 1 , n3 = khigh - klow + 1 ) if ( nrec == 0 ) then call define_nc ( ncid , 1 , tncname ) call writestat_dims_nc ( ncid ) end if call define_nc ( ncid , nvar , ncname ) !call open_nc( fname, ncid, nrec, n1=imax+2, n2=jmax+2, n3=khigh-klow+1) call open_nc ( fname , ncid , nrec , n1 = ihigh - ilow + 1 , n2 = jhigh - jlow + 1 , n3 = khigh - klow + 1 ) if ( nrec == 0 ) then call define_nc ( ncid , 1 , tncname ) call writestat_dims_nc ( ncid ) end if call define_nc ( ncid , nvar , ncname ) !   ! X-pencil ! !   fname1(11:13) = cmyidx !   fname1(15:17) = cmyidy !   fname1(19:21) = cexpnr !   call ncinfo(tncname1(1,:),'time','Time','s','time') !   call ncinfo(ncname1(1,:),'u','West-East velocity','m/s','mttt') ! !   !write(*,*) \"done defining pfields\" ! !   call open_nc( fname1, ncid1, nrec, n1=imax1+2, n2=jmax1+2, n3=kmax1+2) ! !   if (nrec==0) then !     call define_nc( ncid1, 1, tncname1) !     call writestat_dims_nc(ncid1) !   end if !   call define_nc( ncid1, nvar, ncname1) !   call open_nc( fname1, ncid1, nrec, n1=imax1+2, n2=jmax1+2, n3=kmax1+2) !   ! call open_nc( fname, ncid, nrec, n1=imax+2, n2=jmax+2, n3=khigh-klow+1)  !if want to print ghostcells !   if (nrec==0) then !     call define_nc( ncid1, 1, tncname1) !     call writestat_dims_nc(ncid1) !  end if !  call define_nc( ncid1, nvar, ncname1) ! ! !  ! Y-pencil ! !  fname2(11:13) = cmyidx !  fname2(15:17) = cmyidy !  fname2(19:21) = cexpnr !  call ncinfo(tncname2(1,:),'time','Time','s','time') !  call ncinfo(ncname2( 1,:),'u','West-East velocity','m/s','mttt') ! !  call open_nc( fname2, ncid2, nrec, n1=imax2+2, n2=jmax2+2, n3=kmax2+2) !  if (nrec==0) then !    call define_nc( ncid2, 1, tncname2) !    call writestat_dims_nc(ncid2) !  end if !  call define_nc( ncid2, nvar, ncname2) !  call open_nc( fname2, ncid2, nrec, n1=imax2+2, n2=jmax2+2, n3=kmax2+2) !  ! call open_nc( fname, ncid, nrec, n1=imax+2, n2=jmax+2, n3=khigh-klow+1)  !if want to print ghostcells !  if (nrec==0) then !    call define_nc( ncid2, 1, tncname2) !    call writestat_dims_nc(ncid2) ! end if ! call define_nc( ncid2, nvar, ncname2) end subroutine initfielddump !> Do fielddump. Collect data to truncated (2 byte) integers, and write them to file subroutine fielddump use modfields , only : u0 , v0 , w0 , thl0 , qt0 , ql0 , sv0 , pres0 , u01 , u02 , u0h , um , div , dudx , dvdy , dwdz , tau_x !ILS13 21.04.2015 changed to u0 from um  etc use modsurfdata , only : thls , qts , thvs use modglobal , only : ib , ie , ih , jb , je , jh , ke , kb , kh , rk3step , timee , dt_lim , cexpnr , ifoutput , imax , jmax ,& tfielddump , tnextfielddump , nsv , lfielddump , ktot , fieldvars , imax1 , jmax1 , kmax1 , imax2 , jmax2 , kmax2 , rk3step , dyi , dxfi , dzhi !use modmpi,    only : myid,cmyid !use modsubgriddata, only : ekm,sbshr use modstat_nc , only : writestat_nc use modmpi , only : myid , cmyid implicit none real , allocatable :: vars (:,:,:,:), vars1 (:,:,:,:), vars2 (:,:,:,:) integer i , j , k , n integer :: writecounter = 1 if (. not . (( timee >= tnextfielddump ) . or . ( rk3step == 0 ))) return if (. not . lfielddump ) return if ( rk3step /= 3 . and . rk3step /= 0 ) return do k = kb , ke do j = jb , je do i = ib , ie dudx ( i , j , k ) = ( u0 ( i + 1 , j , k ) - u0 ( i , j , k ) ) * dxfi ( i ) dvdy ( i , j , k ) = ( v0 ( i , j + 1 , k ) - v0 ( i , j , k ) ) * dyi dwdz ( i , j , k ) = ( w0 ( i , j , k + 1 ) - w0 ( i , j , k ) ) * dzhi ( k ) div ( i , j , k ) = ( u0 ( i + 1 , j , k ) - u0 ( i , j , k ) ) * dxfi ( i ) + & ( v0 ( i , j + 1 , k ) - v0 ( i , j , k ) ) * dyi + & ( w0 ( i , j , k + 1 ) - w0 ( i , j , k ) ) * dzhi ( k ) end do end do end do if ( rk3step == 3 ) tnextfielddump = tnextfielddump + tfielddump if ( lhalos ) then allocate ( vars ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh , nvar )); vars = 0 ; do n = 1 , nvar vars ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh , n ) = pfields ( n )% point end do else allocate ( vars ( ib : ie , jb : je , kb : ke , nvar )); vars = 0 ; do n = 1 , nvar vars ( ib : ie , jb : je , kb : ke , n ) = pfields ( n )% point end do end if call writestat_nc ( ncid , 1 , tncname ,( / timee / ), nrec ,. true .) !call writestat_nc(ncid,nvar,ncname,vars,nrec,imax+2,jmax+2,khigh-klow+1) call writestat_nc ( ncid , nvar , ncname , vars , nrec , ihigh - ilow + 1 , jhigh - jlow + 1 , khigh - klow + 1 ) deallocate ( vars ) end subroutine fielddump !> Clean up when leaving the run subroutine exitfielddump use modglobal , only : lfielddump use modstat_nc , only : exitstat_nc implicit none if ( lfielddump ) call exitstat_nc ( ncid ) end subroutine exitfielddump end module modfielddump","tags":"","url":"sourcefile/modfielddump.f90.html"},{"title":"scalsource.f90 – uDALES","text":"This file depends on sourcefile~~scalsource.f90~~EfferentGraph sourcefile~scalsource.f90 scalsource.f90 sourcefile~modfields.f90 modfields.f90 sourcefile~scalsource.f90->sourcefile~modfields.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~scalsource.f90->sourcefile~modglobal.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~scalsource.f90->sourcefile~modmpi.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> \\file scalsource.f90 !> Input point, line or planar scalars !  This file is part of uDALES. ! ! This program is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! This program is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !  Copyright 2006-2021 the uDALES Team. ! !! ############  The below part is the scalsource script used by Tom Grylls. Now commented by DMajumdar. !! If wish to use the below, do not forget to also uncomment Namelist reading of variables xS, yS, zS, SS and sigS !! and broadcasting them in MPI in the modstartup.f90 file.  ############ ! subroutine createscals !   use modglobal,  only : nsv,ib,ie,jb,je,kb,ke,ih,jh,kh,lscasrcr,cexpnr,ifinput,imax,jmax,jtot,& !                          libm,nblocks,xSa,ySa,zSa,lscasrc,xS,yS,zS !   use modfields,  only : scar,scarl !   use modmpi,     only : myid,MY_REAL,comm3d,mpierr !   use initfac,    only : block !   implicit none !   integer :: i,j,k,n,m,p,il,iu,jl,ju,ku !   ! if (lscasrc) then !     ! allocate(xSa(1:nsv)) !     ! allocate(ySa(1:nsv)) !     ! allocate(zSa(1:nsv)) !     ! hard code point source locations !     ! xSa(1:nsv) = (/ 453., 463., 523., 539., 407. /) !     ! ySa(1:nsv) = (/ 375., 371., 327., 341., 325. /) !     ! zSa(1:nsv) = (/ 4.   , 4.   , 4. , 4.  , 4.  /) !     ! all point sources from position defined in namoptions !     ! xSa = xS; ySa = yS; zSa = zS !   ! end if !   if (lscasrcr .AND. nsv.gt.0) then !     ! read 2-D field of point sources for vehicular emissions network !     open (ifinput, file='scals.inp.'//cexpnr) !     do j=jb,jtot !       read(ifinput, *) scar(:,j) !     end do !     scarl(ib:ie,jb:je) = scar(ib:ie,jb+myid*jmax:je+myid*jmax) !     ! Set scarl to 0 if set inside an obstacle !     if (libm) then !       do n=1,nblocks !         il = block(n,1) !         iu = block(n,2) !         jl = block(n,3)-myid*jmax !         ju = block(n,4)-myid*jmax !         ku = block(n,6) !         if (ju < jb .or. jl > je) then !           cycle !         else !           if (ju > je) ju=je !           if (jl < jb) jl=jb !           ! addition due to all blocks at lowest layer !           if (ku>0) then !             scarl(il:iu,jl:ju) = 0. !           end if !         end if !       end do !     end if !   end if !lscasrcr ! end subroutine ! subroutine scalsource !   use modglobal,  only : nsv,ib,ie,jb,je,kb,ke,ih,jh,kh,ihc,jhc,khc,xf,zf,xh,zh,dy,jmax,lchem,& !                          xS,yS,zS,SS,sigS,lscasrc,lscasrcl,lscasrcr,libm,dxfi,dzfi,nblocks,xSa,ySa,zSa !   use modfields,  only : svp,svpp,scar,scarl !   use modmpi,     only : myid,mpierr,MY_REAL,comm3d,MPI_SUM !   use initfac, only : block !   implicit none !   integer :: i,j,k,n,il,iu,jl,ju,kl,ku,ncan !   real :: xL,zL !   real :: dyi !   real :: ra2 = 0. !   real :: scalsum = 0. !   real :: scalsumt = 0. !   real :: Pi = 3.1415927 !   dyi = 1./dy !   ! 2-D network of point sources at lowest level !   if (lscasrcr .AND. nsv.gt.0) then !       if (lchem) then !         svp(ib:ie,jb:je,kb+1,1) = svp(ib:ie,jb:je,kb+1,1) + 0.522*scarl !         svp(ib:ie,jb:je,kb+1,2) = svp(ib:ie,jb:je,kb+1,2) + 0.2*scarl !         svp(ib:ie,jb:je,kb+1,4) = svp(ib:ie,jb:je,kb+1,4) + scarl !       else !         svp(ib:ie,jb:je,kb+1,1) = svp(ib:ie,jb:je,kb+1,1) + scarl !       end if !   end if !lscasrcr !   scalsum = 0. !   !  Input passive scalar point sources !   if (lscasrc .AND. nsv.gt.0) then !     do n=1,nsv !     do k=kb,ke !       do j=jb,je !         do i=ib,ie !             ra2 = (xf(i)-xS)**2 + ((j+myid*jmax-0.5)*dy-yS)**2 + (zf(k)-zS)**2 !           if (ra2 .LE. 9*sigS**2) then !             scalsum = scalsum + dxfi(i) * dyi * dzfi(k) * SS*exp(-ra2/(2*sigS**2)) !             svp(i,j,k,n) = svp(i,j,k,n) + dxfi(i) * dyi * dzfi(k) * SS*exp(-ra2/(2*sigS**2)) !           end if !         end do !       end do !     end do !     end do !     ! Set svpp to 0 when set inside an obstacle !     if (libm) then !       do n=1,nblocks !         il = block(n,1) !         iu = block(n,2) !         kl = block(n,5) !         ku = block(n,6) !         jl = block(n,3)-myid*jmax !         ju = block(n,4)-myid*jmax !         if (ju < jb .or. jl > je) then !           cycle !         else !           if (ju > je) ju=je !           if (jl < jb) jl=jb !           svp(il:iu,jl:ju,kl:ku,:) = 0. !         end if !       end do !     end if !     ! Normalise scalar field to 1/s !     !call MPI_ALLREDUCE(scalsum,scalsumt,1,MY_REAL,MPI_SUM,comm3d,mpierr) !     !svpp(:,:,:,1) = svpp(:,:,:,1) / scalsumt !     !svp(:,:,:,1) = svp(:,:,:,1) + svpp(:,:,:,1) !     scalsum = 0. !   end if !lscasrc !   ! Input passive scalar line sources !   if (lscasrcl .AND. nsv.gt.0) then !   ncan = count(block(:,6)>0) !tg3315 update due to block at lowest level !   zL = zf(kb+1) !     if (nblocks>0) then !       do n = 1,ncan-1 ! not ncan and ncan+1 because we do not want release in first and last canyon for BCxs==2 !         if (n == ncan+1) then   ! Added to run for pollutant in first canyon !           !xL = xh(block(1,1) - (block(2,1) - block(1,2)+1)/2) !           xL = xh(block(1,1)) - 0.5*(xh(block(2,1)) - xh(block(1,2)+1)) ! !          ra2 = (i - (block(1,1) - (block(2,1) - block(1,2))/2.0))**2 + (k)**2 !tg3315 commented for chem validation !         else !cycle through all other canyons !           !xL = xh(block(n,2) + (block(2,1) - block(1,2)+1)/2) !           xL = xh(block(n,2)+1) + 0.5*(xh(block(2,1)) - xh(block(1,2)+1)) ! !          ra2 =(xf(i) - xL)**2 + zf(k)**2 !        end if !         do i=ib,ie !           do k=kb,ke ! !           if (ra2 .LE. 12*sigS**2) then !               !scalsum = scalsum + dxf(i) * jmax * dy * dzf(k) * (SS/2*Pi*sigS**2) * exp(-ra2/(2*sigS**2)) !               !tg3315 use this if we want to normalise th scalar conc. !sums values in building too... ! !              scalsum = scalsum + dy * (je - jb +1) * ( (SS/4.) * & ! !                        (erf((xh(i+1)-xL)/(sqrt(2.)*sigS)) - erf((xh(i)-xL)/(sqrt(2.)*sigS))) * & ! !                        (erf((zh(k+1)-zh(kb+1))/(sqrt(2.)*sigS)) - erf((zh(k)-zh(kb+1))/(sqrt(2.)*sigS))) + & ! !                        (SS/4.) * & ! !                        (erf((xh(i+1)-xL)/(sqrt(2.)*sigS)) - erf((xh(i)-xL)/(sqrt(2.)*sigS))) * & ! !                        (erf((zh(k+1)+zh(kb+1))/(sqrt(2.)*sigS)) - erf((zh(k)+zh(kb+1))/(sqrt(2.)*sigS))) ) ! !                        * dxfi(i) * dzfi(k) !               svp(i,jb:je,k,1) = svp(i,jb:je,k,1) + ( (SS/4.) * & ! SS in g/ms... no normalisation !                         (erf((xh(i+1)-xL)/(sqrt(2.)*sigS)) - erf((xh(i)-xL)/(sqrt(2.)*sigS))) * & !                         (erf((zh(k+1)-zL)/(sqrt(2.)*sigS)) - erf((zh(k)-zL)/(sqrt(2.)*sigS))) + & !                         (SS/4.) * & ! reflection from ground... !                         (erf((xh(i+1)-xL)/(sqrt(2.)*sigS)) - erf((xh(i)-xL)/(sqrt(2.)*sigS))) * & !                         (erf((zh(k)-2*(zh(k)-zh(kb+1))-zL)/(sqrt(2.)*sigS)) - erf((zh(k+1)-2*(zh(k+1)-zh(kb+1))-zL)/(sqrt(2.)*sigS))) ) & !                         * dxfi(i) * dzfi(k) !               !svp(i,jb:je,k,3) = svp(i,jb:je,k,3) + ( (SS/4.) * & ! SS in g/ms... no normalisation !               !          (erf((xh(i+1)-xL)/(sqrt(2.)*sigS)) - erf((xh(i)-xL)/(sqrt(2.)*sigS))) * & !               !          (erf((zh(k+1)-zL)/(sqrt(2.)*sigS)) - erf((zh(k)-zL)/(sqrt(2.)*sigS))) + & !               !          (SS/4.) * & ! reflection from ground... !               !          (erf((xh(i+1)-xL)/(sqrt(2.)*sigS)) - erf((xh(i)-xL)/(sqrt(2.)*sigS))) * & !               !          (erf((zh(k)-2*(zh(k)-zh(kb+1))-zL)/(sqrt(2.)*sigS)) - erf((zh(k+1)-2*(zh(k+1)-zh(kb+1))-zL)/(sqrt(2.)*sigS))) ) & !               !          * dxfi(i) * dzfi(k) ! !            end if !           end do !         end do !       end do !     end if !nblocks !     ! Set svpp to 0 when set inside an obstacle !     if (libm) then !       do n=1,nblocks !         il = block(n,1) !         iu = block(n,2) !         kl = kb !         ku = block(n,6) !         jl = block(n,3)-myid*jmax !         ju = block(n,4)-myid*jmax !         if (ju < jb .or. jl > je) then !           cycle !         else !           if (ju > je) ju=je !           if (jl < jb) jl=jb !           svp(il:iu,jl:ju,kl:ku,:) = 0. !         end if !       end do !     end if !libm !     ! Normalise scalar field to 1/s ! !    call MPI_ALLREDUCE(scalsum,scalsumt,1,MY_REAL,MPI_SUM,comm3d,mpierr) ! !    write(*,*), 'scalsum', scalsum ! !    if (lchem) then !       !svpp(:,:,:,1) = svpp(:,:,:,1) ! !      svp(:,:,:,1) = svp(:,:,:,1) + svpp(:,:,:,1) !       !svp(:,:,:,2) = svp(:,:,:,2) + 0.1518 * svpp(:,:,:,1) ! !    else ! !      svpp(:,:,:,1) = svpp(:,:,:,1)/ scalsumt !tg3315 not normalised 07/11/2017 ! !      svp(:,:,:,1) = svp(:,:,:,1) + svpp(:,:,:,1) !       !svp(:,:,:,2) = svp(:,:,:,2) + 0.1518 * svpp(:,:,:,1) ! !    end if !     svpp = 0. !     scalsum = 0. !   end if !lscasrcl ! end subroutine scalsource !! ############  ****  ############ !! ############  Updated scalar source modelling. DMajumdar  ############ subroutine createscals use modglobal , only : nsv , cexpnr , ifinput , lscasrc , nscasrc , scasrcp , lscasrcl , nscasrcl , scasrcl , lscasrcr use modmpi , only : myid , MY_REAL , comm3d , mpierr implicit none integer :: n , m character :: cnsv character ( 80 ) :: chmess if ( lscasrc . AND . nsv . gt . 0 . AND . nscasrc . gt . 0 ) then allocate ( scasrcp ( nscasrc , 5 , nsv )) ! read global scalar source locations if ( myid == 0 ) then do m = 1 , nsv write ( cnsv , '(i1.1)' ) m open ( ifinput , file = 'scalarsourcep.inp.' // cnsv // '.' // cexpnr ) read ( ifinput , '(a80)' ) chmess read ( ifinput , '(a80)' ) chmess do n = 1 , nscasrc read ( ifinput , * ) & scasrcp ( n , 1 , m ), & scasrcp ( n , 2 , m ), & scasrcp ( n , 3 , m ), & scasrcp ( n , 4 , m ), & scasrcp ( n , 5 , m ) end do close ( ifinput ) end do ! write (6,*) 'nsv, source_n, xS, yS, zS, SS, sigS ' ! do m=1,nsv !   do n=1,nscasrc !     write (6,*) & !           m , & !           n , & !           scasrcp(n,1,m), & !           scasrcp(n,2,m), & !           scasrcp(n,3,m), & !           scasrcp(n,4,m), & !           scasrcp(n,5,m) !   end do ! end do end if call MPI_BCAST ( scasrcp , 5 * nscasrc * nsv , MY_REAL , 0 , comm3d , mpierr ) end if if ( lscasrcl . AND . nsv . gt . 0 . AND . nscasrcl . gt . 0 ) then allocate ( scasrcl ( nscasrcl , 8 , nsv )) ! read global scalar line source locations if ( myid == 0 ) then do m = 1 , nsv write ( cnsv , '(i1.1)' ) m open ( ifinput , file = 'scalarsourcel.inp.' // cnsv // '.' // cexpnr ) read ( ifinput , '(a80)' ) chmess read ( ifinput , '(a80)' ) chmess do n = 1 , nscasrcl read ( ifinput , * ) & scasrcl ( n , 1 , m ), & scasrcl ( n , 2 , m ), & scasrcl ( n , 3 , m ), & scasrcl ( n , 4 , m ), & scasrcl ( n , 5 , m ), & scasrcl ( n , 6 , m ), & scasrcl ( n , 7 , m ), & scasrcl ( n , 8 , m ) end do close ( ifinput ) end do ! write (6,*) 'nsv, source_n, xSb, ySb, zSb, xSe, ySe, zSe, SS, sigS ' ! do m=1,nsv !   do n=1,nscasrcl !     write (6,*) & !           m , & !           n , & !           scasrcl(n,1,m), & !           scasrcl(n,2,m), & !           scasrcl(n,3,m), & !           scasrcl(n,4,m), & !           scasrcl(n,5,m), & !           scasrcl(n,6,m), & !           scasrcl(n,7,m), & !           scasrcl(n,8,m) !   end do ! end do end if call MPI_BCAST ( scasrcl , 8 * nscasrcl * nsv , MY_REAL , 0 , comm3d , mpierr ) end if end subroutine subroutine scalsource use modglobal , only : pi , nsv , ib , ie , jb , je , kb , ke , ih , jh , kh , ihc , jhc , khc , xf , zf , xh , zh , dx , dy , imax , itot , jmax , jtot , lchem ,& xS , yS , zS , xSb , ySb , zSb , xSe , ySe , zSe , SS , sigS , lscasrc , lscasrcl , lscasrcr , libm , dxfi , dzfi , nscasrc , scasrcp , nscasrcl , scasrcl use modfields , only : svp , svpp use modmpi , only : myid , myidx , myidy , mpierr , MY_REAL , comm3d , MPI_SUM implicit none integer :: i , j , k , n , ns real :: dxi , dyi real :: ra2 = 0. real :: scalsum = 0. real :: scalsumt = 0. real :: px = 0. , py = 0. , pz = 0.0 , vx = 0. , vy = 0. , vz = 0. , lsx = 0. , lsy = 0. , lsz = 0. , dot_projection = 0. dxi = 1. / dx dyi = 1. / dy !  Input passive scalar point sources if ( lscasrc . AND . nsv . gt . 0 ) then do n = 1 , nsv do ns = 1 , nscasrc xS = scasrcp ( ns , 1 , n ) yS = scasrcp ( ns , 2 , n ) zS = scasrcp ( ns , 3 , n ) SS = scasrcp ( ns , 4 , n ) sigS = scasrcp ( ns , 5 , n ) do k = kb , ke do j = jb , je do i = ib , ie ra2 = (( i + myidx * imax - 0.5 ) * dx - xS ) ** 2 + (( j + myidy * jmax - 0.5 ) * dy - yS ) ** 2 + ( zf ( k ) - zS ) ** 2 if ( ra2 . LE . 9 * sigS ** 2 ) then svp ( i , j , k , n ) = svp ( i , j , k , n ) + dxi * dyi * dzfi ( k ) * SS * exp ( - ra2 / ( 2 * sigS ** 2 )) end if end do end do end do end do end do end if !lscasrc !  Input passive scalar line sources if ( lscasrcl . AND . nsv . gt . 0 ) then do n = 1 , nsv do ns = 1 , nscasrcl xSb = scasrcl ( ns , 1 , n ) ySb = scasrcl ( ns , 2 , n ) zSb = scasrcl ( ns , 3 , n ) xSe = scasrcl ( ns , 4 , n ) ySe = scasrcl ( ns , 5 , n ) zSe = scasrcl ( ns , 6 , n ) SS = scasrcl ( ns , 7 , n ) sigS = scasrcl ( ns , 8 , n ) lsx = xSe - xSb lsy = ySe - ySb lsz = zSe - zSb do k = kb , ke do j = jb , je do i = ib , ie px = ( i + myidx * imax - 0.5 ) * dx py = ( j + myidy * jmax - 0.5 ) * dy pz = zf ( k ) vx = px - xSb vy = py - ySb vz = pz - zSb dot_projection = ( vx * lsx + vy * lsy + vz * lsz ) / ( lsx * lsx + lsy * lsy + lsz * lsz ) if ( dot_projection < 0.0 ) then ra2 = ( px - xSb ) ** 2 + ( py - ySb ) ** 2 + ( pz - zSb ) ** 2 elseif ( dot_projection > 1.0 ) then ra2 = ( px - xSe ) ** 2 + ( py - ySe ) ** 2 + ( pz - zSe ) ** 2 else ra2 = ( px - ( xSb + dot_projection * lsx )) ** 2 + ( py - ( ySb + dot_projection * lsy )) ** 2 + ( pz - ( zSb + dot_projection * lsz )) ** 2 end if if ( ra2 . LE . 9 * sigS ** 2 ) then svp ( i , j , k , n ) = svp ( i , j , k , n ) + dxi * dyi * dzfi ( k ) * & sqrt ( 2.0 * pi ) * SS * sigS * exp ( - ra2 / ( 2 * sigS ** 2 )) * erf ( sqrt (( 9 * sigS ** 2 - ra2 ) / ( 2 * sigS ** 2 ))) end if end do end do end do end do end do end if !lscasrcl end subroutine scalsource","tags":"","url":"sourcefile/scalsource.f90.html"},{"title":"wfmneutral.f90 – uDALES","text":"This file depends on sourcefile~~wfmneutral.f90~~EfferentGraph sourcefile~wfmneutral.f90 wfmneutral.f90 sourcefile~initfac.f90 initfac.f90 sourcefile~wfmneutral.f90->sourcefile~initfac.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~wfmneutral.f90->sourcefile~modglobal.f90 sourcefile~modibmdata.f90 modibmdata.f90 sourcefile~wfmneutral.f90->sourcefile~modibmdata.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~wfmneutral.f90->sourcefile~modmpi.f90 sourcefile~modsubgriddata.f90 modsubgriddata.f90 sourcefile~wfmneutral.f90->sourcefile~modsubgriddata.f90 sourcefile~initfac.f90->sourcefile~modglobal.f90 sourcefile~initfac.f90->sourcefile~modmpi.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !  This file is part of uDALES. ! ! This program is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! This program is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !  Copyright 2006-2021 the uDALES Team. ! SUBROUTINE wfmneutral ( hi , hj , hk , iout1 , iout2 , iomomflux , utang1 , utang2 , z0 , n , ind , wforient ) !wfmneutral !wf for momentum under neutral conditions !calculating wall function for momentum assuming neutral conditions !follow approach in wfuno !fluxes in m2/s2 USE modglobal , ONLY : dzf , dzfi , dzh2i , dzhi , dzhiq , dy , dyi , dy2i , dyi5 , dxf , dxh , dxfi , dxhi , dxh2i , ib , ie , jb , je , kb , ke , fkar , jmax , rk3step , kmax , jge , jgb USE modsubgriddata , ONLY : ekh , ekm USE modmpi , ONLY : myid USE initfac , ONLY : block USE modibmdata INTEGER i , j , k , jl , ju , kl , ku , il , iu , km , im , jm , ip , jp , kp REAL :: bcmomflux = 0. !temp storage for momentum flux REAL :: ctm = 0. !momentum transfer coefficient REAL :: dummy = 0. !for debugging REAL :: delta = 0. !distance from wall REAL :: logdz2 = 0. !log(delta/z0)**2 REAL :: utang1Int !Interpolated 1st tangential velocity component needed for stability calculation (to T location) REAL :: utang2Int !Interpolated 2nd tangential velocity component needed for stability calculation (to T location) REAL :: fkar2 !fkar&#94;2, von Karman constant squared REAL :: emmo = 0. , epmo = 0. , epom = 0. , emom = 0. , eopm = 0. , eomm = 0. , empo = 0. REAL :: umin = 0.0001 !m&#94;2/s&#94;2 INTEGER , INTENT ( in ) :: hi !<size of halo in i INTEGER , INTENT ( in ) :: hj !<size of halo in j INTEGER , INTENT ( in ) :: hk !<size of halo in k REAL , INTENT ( inout ) :: iout1 ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ) !updated prognostic tangential velocity (component1) REAL , INTENT ( inout ) :: iout2 ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ) !updated prognostic tangential velocity (component2) REAL , INTENT ( inout ) :: iomomflux ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) !a field to save the momentum flux REAL , INTENT ( in ) :: z0 REAL , INTENT ( in ) :: utang1 ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) !tangential velocity field REAL , INTENT ( in ) :: utang2 ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) !second tangential velocity field INTEGER , INTENT ( in ) :: n ! number of the block, used to get i,j,k-indeces INTEGER , INTENT ( in ) :: ind ! in case of y-wall (case 3x & 4x) \"ind\" is used for j-index, otherwise this is irrelevant INTEGER , INTENT ( in ) :: wforient !orientation of the facet see below: !frist digit, orientation of wall, determines iteration indices !second digit, if for momentum or for scalar (necessary because of staggered grid -> which variable to interpolate) !xlow=1,xup=2,yup=3,ylow=4,z=5 !momentum=1 fkar2 = fkar ** 2 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!CASES!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!CASES FOR MOMENTUM!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! SELECT CASE ( wforient ) !!!!!!!!!!!!!!!SPECIAL CASES FOR THE SURFACE!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !can actually be made redundant and just be replaced by standard horizontal case (doesn't really matter though) ! SO: This code is essentially unchanged from uDALES v1, and should probably be moved out of this file in a later release. CASE ( 91 ) !surface momentum flux k = kb ! km = k - 1 ! il = ib iu = ie jl = jb ju = je delta = 0.5 * dzf ( k ) !might need attention on streched grids! as well as the dzfi when updating up logdz2 = LOG ( delta / z0 ) ** 2 DO j = jl , ju !u component DO i = il , iu utang1Int = utang1 ( i , j , k ) utang2Int = ( utang2 ( i , j , k ) + utang2 ( i - 1 , j , k ) + utang2 ( i , j + 1 , k ) + utang2 ( i - 1 , j + 1 , k )) * 0.25 utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) ctm = fkar2 / ( logdz2 ) !dummy = (utang1Int**2)*ctm dummy = abs ( utang1Int ) * sqrt ( utangInt ) * ctm bcmomflux = SIGN ( dummy , utang1Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dzfi ( k ) emom = ( dzf ( km ) * ( ekm ( i , j , k ) * dxf ( i - 1 ) + ekm ( i - 1 , j , k ) * dxf ( i )) + & ! dx is non-equidistant dzf ( k ) * ( ekm ( i , j , km ) * dxf ( i - 1 ) + ekm ( i - 1 , j , km ) * dxf ( i ))) * dxhi ( i ) * dzhiq ( k ) iout1 ( i , j , k ) = iout1 ( i , j , k ) + ( utang1 ( i , j , k ) - utang1 ( i , j , km )) * emom * dzhi ( k ) * dzfi ( k ) - bcmomflux * dzfi ( k ) ! END DO END DO DO j = jl , ju !v component DO i = il , iu utang1Int = ( utang1 ( i , j , k ) + utang1 ( i , j - 1 , k ) + utang1 ( i + 1 , j - 1 , k ) + utang1 ( i + 1 , j , k )) * 0.25 utang2Int = utang2 ( i , j , k ) utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) ctm = fkar2 / ( logdz2 ) !dummy = (utang2Int**2)*ctm dummy = abs ( utang2Int ) * sqrt ( utangInt ) * ctm bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dzfi ( k ) eomm = ( dzf ( km ) * ( ekm ( i , j , k ) + ekm ( i , j - 1 , k )) + dzf ( k ) * ( ekm ( i , j , km ) + ekm ( i , j - 1 , km ))) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) + ( utang2 ( i , j , k ) - utang2 ( i , j , km )) * eomm * dzhi ( k ) * dzfi ( k ) - bcmomflux * dzfi ( k ) ! END DO END DO END SELECT END SUBROUTINE wfmneutral","tags":"","url":"sourcefile/wfmneutral.f90.html"},{"title":"modboundary.f90 – uDALES","text":"This file depends on sourcefile~~modboundary.f90~~EfferentGraph sourcefile~modboundary.f90 modboundary.f90 sourcefile~moddriver.f90 moddriver.f90 sourcefile~modboundary.f90->sourcefile~moddriver.f90 sourcefile~modfields.f90 modfields.f90 sourcefile~modboundary.f90->sourcefile~modfields.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~modboundary.f90->sourcefile~modglobal.f90 sourcefile~modinletdata.f90 modinletdata.f90 sourcefile~modboundary.f90->sourcefile~modinletdata.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~modboundary.f90->sourcefile~modmpi.f90 sourcefile~modsubgriddata.f90 modsubgriddata.f90 sourcefile~modboundary.f90->sourcefile~modsubgriddata.f90 sourcefile~modsurfdata.f90 modsurfdata.f90 sourcefile~modboundary.f90->sourcefile~modsurfdata.f90 sourcefile~moddriver.f90->sourcefile~modfields.f90 sourcefile~moddriver.f90->sourcefile~modglobal.f90 sourcefile~moddriver.f90->sourcefile~modinletdata.f90 sourcefile~moddriver.f90->sourcefile~modmpi.f90 sourcefile~modsave.f90 modsave.f90 sourcefile~moddriver.f90->sourcefile~modsave.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 sourcefile~modsave.f90->sourcefile~modfields.f90 sourcefile~modsave.f90->sourcefile~modglobal.f90 sourcefile~modsave.f90->sourcefile~modinletdata.f90 sourcefile~modsave.f90->sourcefile~modmpi.f90 sourcefile~modsave.f90->sourcefile~modsubgriddata.f90 sourcefile~modsave.f90->sourcefile~modsurfdata.f90 sourcefile~initfac.f90 initfac.f90 sourcefile~modsave.f90->sourcefile~initfac.f90 sourcefile~modibmdata.f90 modibmdata.f90 sourcefile~modsave.f90->sourcefile~modibmdata.f90 sourcefile~initfac.f90->sourcefile~modglobal.f90 sourcefile~initfac.f90->sourcefile~modmpi.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~modboundary.f90~~AfferentGraph sourcefile~modboundary.f90 modboundary.f90 sourcefile~modibm.f90 modibm.f90 sourcefile~modibm.f90->sourcefile~modboundary.f90 sourcefile~modstartup.f90 modstartup.f90 sourcefile~modstartup.f90->sourcefile~modboundary.f90 sourcefile~modstartup.f90->sourcefile~modibm.f90 sourcefile~modsubgrid.f90 modsubgrid.f90 sourcefile~modstartup.f90->sourcefile~modsubgrid.f90 sourcefile~modsubgrid.f90->sourcefile~modboundary.f90 sourcefile~program.f90 program.f90 sourcefile~program.f90->sourcefile~modboundary.f90 sourcefile~program.f90->sourcefile~modibm.f90 sourcefile~program.f90->sourcefile~modstartup.f90 sourcefile~program.f90->sourcefile~modsubgrid.f90 sourcefile~modfielddump.f90 modfielddump.f90 sourcefile~program.f90->sourcefile~modfielddump.f90 sourcefile~modstatsdump.f90 modstatsdump.f90 sourcefile~program.f90->sourcefile~modstatsdump.f90 sourcefile~advec_2nd.f90 advec_2nd.f90 sourcefile~advec_2nd.f90->sourcefile~modibm.f90 sourcefile~modfielddump.f90->sourcefile~modibm.f90 sourcefile~modstatsdump.f90->sourcefile~modsubgrid.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> \\file modboundary.f90 !! All boundary conditions are in this file, except for immersed boundaries. !  This file is part of DALES. ! ! DALES is free software; you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation; either version 3 of the License, or ! (at your option) any later version. ! ! DALES is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !  Copyright 1993-2009 Delft University of Technology, Wageningen University, Utrecht University, KNMI ! !! \\par Revision list !! \\par Authors !! module modboundary use mpi implicit none save private public :: initboundary , boundary , grwdamp , ksp , tqaver , halos , bcp , bcpup , closurebc , & xm_periodic , xT_periodic , xq_periodic , xs_periodic , ym_periodic , yT_periodic , yq_periodic , ys_periodic integer :: ksp = - 1 !<    lowest level of sponge layer real , allocatable :: tsc (:) !<   damping coefficients to be used in grwdamp. real :: rnu0 = 2.75e-3 contains !> !! Initializing Boundary; specifically the sponge layer !> subroutine initboundary use modglobal , only : ib , kb , ke , kh , kmax , pi , zf , iplane use modinletdata , only : irecy implicit none real :: zspb , zspt integer :: k allocate ( tsc ( kb : ke + kh )) ! Sponge layer if ( ksp == - 1 ) then !      ksp  = min(3*kmax/4,kmax - 15) ksp = ( kb - 1 ) + max ( min ( 3 * kmax / 4 , kmax - 15 ), 1 ) end if zspb = zf ( ksp ) zspt = zf ( ke ) tsc ( kb : ksp - 1 ) = 0.0 do k = ksp , ke tsc ( k ) = rnu0 * sin ( 0.5 * pi * ( zf ( k ) - zspb ) / ( zspt - zspb )) ** 2 end do tsc ( ke + 1 ) = tsc ( ke ) irecy = ib + iplane end subroutine initboundary !> !! Fill halo cells, including ghost cells outside domain ! Needs to be called before divergence is calculated subroutine halos use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , ihc , jhc , khc , nsv , & BCxm , BCym , BCxT , BCyT , BCxq , BCyq , BCxs , BCys , & BCxm_periodic , BCxT_periodic , BCxq_periodic , BCxs_periodic , & BCym_periodic , BCyT_periodic , BCyq_periodic , BCys_periodic , & ibrank , ierank , jbrank , jerank use modfields , only : u0 , v0 , w0 , um , vm , wm , thl0 , thlm , qt0 , qtm , sv0 , svm , thl0c use decomp_2d , only : exchange_halo_z implicit none integer i , k , n call exchange_halo_z ( u0 ) call exchange_halo_z ( v0 ) call exchange_halo_z ( w0 ) call exchange_halo_z ( um ) call exchange_halo_z ( vm ) call exchange_halo_z ( wm ) call exchange_halo_z ( thl0 ) call exchange_halo_z ( thlm ) call exchange_halo_z ( thl0c , opt_zlevel = ( / ihc , jhc , khc / )) call exchange_halo_z ( qt0 ) call exchange_halo_z ( qtm ) do n = 1 , nsv call exchange_halo_z ( sv0 (:, :, :, n ), opt_zlevel = ( / ihc , jhc , khc / )) call exchange_halo_z ( svm (:, :, :, n ), opt_zlevel = ( / ihc , jhc , khc / )) enddo if ( ibrank . and . ierank ) then ! not parallelized in x if ( BCxm == BCxm_periodic ) call xm_periodic if ( BCxT == BCxT_periodic ) call xT_periodic if ( BCxq == BCxq_periodic ) call xq_periodic if ( BCxs == BCxs_periodic ) call xs_periodic end if if ( jbrank . and . jerank ) then ! not parallelized in x if ( BCym == BCym_periodic ) call ym_periodic if ( BCyT == BCyT_periodic ) call yT_periodic if ( BCyq == BCyq_periodic ) call yq_periodic if ( BCys == BCys_periodic ) call ys_periodic end if end subroutine halos !> !! Set boundary conditions for the next timestep ! Will result in velocity field being not divergence-free subroutine boundary use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , ihc , jhc , khc , dzf , zh , nsv , & ltempeq , lmoist , luvolflowr , luoutflowr , & BCxm , BCym , BCxT , BCyT , BCxq , BCyq , BCxs , BCys , BCtopm , BCtopT , BCtopq , BCtops , & BCtopm_freeslip , BCtopm_noslip , BCtopm_pressure , & BCtopT_flux , BCtopT_value , BCtopq_flux , BCtopq_value , BCtops_flux , BCtops_value , & BCxm_periodic , BCxm_profile , BCxm_driver , & BCxT_periodic , BCxT_profile , BCxT_driver , & BCxq_periodic , BCxq_profile , BCxq_driver , & BCxs_periodic , BCxs_profile , BCxs_driver , BCxs_custom , & BCym_periodic , BCym_profile , BCyT_periodic , BCyT_profile , & BCyq_periodic , BCyq_profile , BCys_periodic , & ibrank , ierank , jbrank , jerank , e12min , idriver , & Uinf , Vinf , & rk3step , lchunkread use modfields , only : u0 , v0 , w0 , um , vm , wm , thl0 , thlm , qt0 , qtm , e120 , e12m , sv0 , svm , u0av , v0av , uouttot , vouttot , thl0c use modsubgriddata , only : ekh , ekm , loneeqn use modsurfdata , only : thl_top , qt_top , sv_top , wttop , wqtop , wsvtop use modmpi , only : myid , slabsum , avey_ibm use moddriver , only : drivergen , driverchunkread use modinletdata , only : ubulk , vbulk , iangle use decomp_2d , only : exchange_halo_z implicit none real , dimension ( kb : ke ) :: uaverage , vaverage real , dimension ( ib : ie , kb : ke ) :: uavey integer i , k , n ! if not using massflowrate need to set outflow velocity if ( luoutflowr ) then ! do nothing - calculated in modforces elseif (. not . luvolflowr ) then !ubulk = sum(u0av)/(ke-kb+1) do k = kb , ke uaverage ( k ) = u0av ( k ) * dzf ( k ) end do do k = kb , ke vaverage ( k ) = v0av ( k ) * dzf ( k ) end do ! need a method to know if we have all blocks at lowest cell kb ! assuming this for now (hence kb+1) uouttot = sum ( uaverage ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb + 1 )) vouttot = sum ( vaverage ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb + 1 )) else uouttot = ubulk vouttot = vbulk end if ! Bottom BC - many ways of enforcing this but this is simplest ! Other variables handled by bottom wm (:, :, kb ) = 0. w0 (:, :, kb ) = 0. !! Top ! Momentum select case ( BCtopm ) case ( BCtopm_freeslip ) !free-slip = zero-flux call fluxtop ( um , ekm , 0.0 ) call fluxtop ( u0 , ekm , 0.0 ) call fluxtop ( vm , ekm , 0.0 ) call fluxtop ( v0 , ekm , 0.0 ) w0 (:, :, ke + 1 ) = 0.0 wm (:, :, ke + 1 ) = 0.0 if ( loneeqn ) then e120 (:, :, ke + 1 ) = e12min e12m (:, :, ke + 1 ) = e12min end if case ( BCtopm_noslip ) !no-slip = fixed velocity at wall call valuetop ( um , Uinf ) call valuetop ( u0 , Uinf ) call valuetop ( vm , Vinf ) call valuetop ( v0 , Vinf ) w0 (:, :, ke + 1 ) = 0.0 wm (:, :, ke + 1 ) = 0.0 case ( BCtopm_pressure ) call fluxtop ( um , ekm , 0.0 ) call fluxtop ( u0 , ekm , 0.0 ) call fluxtop ( vm , ekm , 0.0 ) call fluxtop ( v0 , ekm , 0.0 ) if ( loneeqn ) then e120 (:, :, ke + 1 ) = e12min e12m (:, :, ke + 1 ) = e12min end if ! w considered in modpois case default write ( 0 , * ) \"ERROR: top boundary type for velocity undefined\" stop 1 end select ! Temperature select case ( BCtopT ) case ( BCtopT_flux ) call fluxtop ( thlm , ekh , wttop ) call fluxtop ( thl0 , ekh , wttop ) do n = 1 , khc thl0c (:,:, ke + n ) = thl0c (:,:, ke + n - 1 ) end do case ( BCtopT_value ) call valuetop ( thlm , thl_top ) call valuetop ( thl0 , thl_top ) case default write ( 0 , * ) \"ERROR: top boundary type for temperature undefined\" stop 1 end select ! Moisture select case ( BCtopq ) case ( BCtopq_flux ) call fluxtop ( qtm , ekh , wqtop ) call fluxtop ( qt0 , ekh , wqtop ) case ( BCtopq_value ) call valuetop ( qtm , qt_top ) call valuetop ( qt0 , qt_top ) case default write ( 0 , * ) \"ERROR: top boundary type for moisture undefined\" stop 1 end select ! Scalars select case ( BCtops ) case ( BCtops_flux ) call fluxtopscal ( wsvtop ) call fluxtopscal ( wsvtop ) case ( BCtops_value ) call valuetopscal ( sv_top ) call valuetopscal ( sv_top ) case default write ( 0 , * ) \"ERROR: top boundary type for scalars undefined\" stop 1 end select if ( idriver == 1 ) call drivergen ! Should be moved elsewhere, as not related to boundary conditions. ! x inlet if ( ibrank ) then ! set inlet ! Momentum select case ( BCxm ) case ( BCxm_periodic ) ! Handled in halos case ( BCxm_profile ) !uouttot = cos(iangle)*ubulk call xmi_profile case ( BCxm_driver ) !uouttot = ubulk ! does this hold for all forcings of precursor simulations? tg3315 if ( rk3step == 0 . or . rk3step == 3 ) then if ( lchunkread ) call driverchunkread call drivergen ! think this should be done at the start of an rk3 loop? end if call xmi_driver case default write ( 0 , * ) \"ERROR: lateral boundary type for veloctiy in x-direction undefined\" stop 1 end select ! Temperature if ( ltempeq ) then select case ( BCxT ) case ( BCxT_periodic ) ! periodic ! Handled in halos case ( BCxT_profile ) ! profile call xTi_profile case ( BCxT_driver ) call xTi_driver case default write ( 0 , * ) \"ERROR: lateral boundary type for temperature in x-direction undefined\" stop 1 end select end if ! Moisture if ( lmoist ) then select case ( BCxq ) case ( BCxq_periodic ) ! Handled in halos case ( BCxq_profile ) call xqi_profile case ( BCxq_driver ) call xqi_driver case default write ( 0 , * ) \"ERROR: lateral boundary type for humidity in x-direction undefined\" stop 1 end select end if ! Scalars if ( nsv > 0 ) then select case ( BCxs ) case ( BCxs_periodic ) ! Handled in halos case ( BCxs_profile ) call xsi_profile case ( BCxs_driver ) call xsi_driver case ( BCxs_custom ) call xsi_custom case default write ( 0 , * ) \"ERROR: lateral boundary type for scalars in x-direction undefined\" stop 1 end select end if end if !ibrank if ( jbrank ) then ! set y inlet ! Momentum select case ( BCym ) case ( BCym_periodic ) ! Handled in halos case ( BCym_profile ) call ymi_profile case default write ( 0 , * ) \"ERROR: lateral boundary type for veloctiy in y-direction undefined\" stop 1 end select ! Temperature if ( ltempeq ) then select case ( BCyT ) case ( BCyT_periodic ) ! Handled in halos case ( BCyT_profile ) call yTi_profile case default write ( 0 , * ) \"ERROR: lateral boundary type for temperature in y-direction undefined\" stop 1 end select end if ! Moisture if ( lmoist ) then select case ( BCyq ) case ( BCyq_periodic ) ! Handled in halos case ( BCyq_profile ) call yqi_profile case default write ( 0 , * ) \"ERROR: lateral boundary type for humidity in y-direction undefined\" stop 1 end select end if if ( nsv > 0 ) then !scalars select case ( BCys ) case ( 1 ) ! Handled in halos case ( 2 ) call ysi_profile case default write ( 0 , * ) \"ERROR: lateral boundary type for scalars in y-direction undefined\" stop 1 end select end if end if !jbrank !> Outlet ! Currently only outflow boundary conditions are convective if ( ierank ) then if ( BCxm . ne . BCxm_periodic ) call xmo_convective if (( BCxT . ne . BCxT_periodic ) . and . ltempeq ) call xTo_convective if (( BCxq . ne . BCxq_periodic ) . and . lmoist ) call xqo_convective if (( BCxs . ne . BCxs_periodic ) . and . nsv > 0 ) call xso_convective end if if ( jerank ) then if ( BCym . ne . BCym_periodic ) call ymo_convective if (( BCyT . ne . BCyT_periodic ) . and . ltempeq ) call yTo_convective if (( BCyq . ne . BCyq_periodic ) . and . lmoist ) call yqo_convective if (( BCys . ne . BCys_periodic ) . and . nsv > 0 ) call yso_convective end if end subroutine boundary subroutine closurebc use modsubgriddata , only : ekm , ekh use modglobal , only : ib , ie , jb , je , kb , ke , ih , jh , kh , numol , prandtlmoli , & ibrank , ierank , jbrank , jerank , BCtopm , BCxm , BCym , & BCtopm_freeslip , BCtopm_noslip , BCtopm_pressure , & BCxm_periodic , BCym_periodic use decomp_2d , only : exchange_halo_z integer i , j call exchange_halo_z ( ekm ) call exchange_halo_z ( ekh ) ! Top and bottom if (( BCtopm . eq . BCtopm_freeslip ) . or . ( BCtopm . eq . BCtopm_pressure )) then do j = jb - 1 , je + 1 do i = ib - 1 , ie + 1 ekm ( i , j , ke + 1 ) = ekm ( i , j , ke ) ! zero-gradient top wall ekh ( i , j , ke + 1 ) = ekh ( i , j , ke ) ! zero-gradient top wall ekm ( i , j , kb - 1 ) = 2. * numol - ekm ( i , j , kb ) ! no-slip lower wall ekh ( i , j , kb - 1 ) = ( 2. * numol * prandtlmoli ) - ekh ( i , j , kb ) ! no-slip lower wall end do end do else if ( BCtopm . eq . BCtopm_noslip ) then do j = jb - 1 , je + 1 do i = ib - 1 , ie + 1 ekm ( i , j , ke + 1 ) = 2. * numol - ekm ( i , j , ke ) ! no-slip top wall ekh ( i , j , ke + 1 ) = ( 2. * numol * prandtlmoli ) - ekh ( i , j , ke ) ! no-slip top wall ekm ( i , j , kb - 1 ) = 2. * numol - ekm ( i , j , kb ) ! no-slip lower wall ekh ( i , j , kb - 1 ) = ( 2. * numol * prandtlmoli ) - ekh ( i , j , kb ) ! no-slip lower wall end do end do end if if ( BCxm . ne . BCxm_periodic ) then ! inflow/outflow if ( ibrank ) then ekm ( ib - 1 , :, :) = ekm ( ib , :, :) ekh ( ib - 1 , :, :) = ekh ( ib , :, :) end if if ( ierank ) then ekm ( ie + 1 , :, :) = ekm ( ie , :, :) ekh ( ie + 1 , :, :) = ekh ( ie , :, :) end if else ! periodic if ( ibrank . and . ierank ) then ekm ( ib - 1 , :, :) = ekm ( ie , :, :) ekm ( ie + 1 , :, :) = ekm ( ib , :, :) ekh ( ib - 1 , :, :) = ekh ( ie , :, :) ekh ( ie + 1 , :, :) = ekh ( ib , :, :) end if end if if ( BCym . ne . BCym_periodic ) then ! inflow/outflow if ( jbrank ) then ekm (:, jb - 1 ,:) = ekm (:, jb ,:) ekh (:, jb - 1 ,:) = ekh (:, jb ,:) end if if ( jerank ) then ekm (:, je + 1 ,:) = ekm (:, je ,:) ekh (:, je + 1 ,:) = ekh (:, je ,:) end if else ! periodic if ( jbrank . and . jerank ) then ekm (:, jb - 1 , :) = ekm (:, je , :) ekm (:, je + 1 , :) = ekm (:, jb , :) ekh (:, jb - 1 , :) = ekh (:, je , :) ekh (:, je + 1 , :) = ekh (:, jb , :) end if end if end subroutine closurebc !>set lateral periodic boundary conditions for momentum in x/i direction subroutine xm_periodic use modglobal , only : ib , ie , ih use modfields , only : u0 , um , v0 , vm , w0 , wm , e120 , e12m use modsubgriddata , only : loneeqn , lsmagorinsky use modmpi , only : excis integer n , m do m = 1 , ih u0 ( ib - m , :, :) = u0 ( ie + 1 - m , :, :) u0 ( ie + m , :, :) = u0 ( ib - 1 + m , :, :) v0 ( ib - m , :, :) = v0 ( ie + 1 - m , :, :) v0 ( ie + m , :, :) = v0 ( ib - 1 + m , :, :) w0 ( ib - m , :, :) = w0 ( ie + 1 - m , :, :) w0 ( ie + m , :, :) = w0 ( ib - 1 + m , :, :) um ( ib - m , :, :) = um ( ie + 1 - m , :, :) um ( ie + m , :, :) = um ( ib - 1 + m , :, :) vm ( ib - m , :, :) = vm ( ie + 1 - m , :, :) vm ( ie + m , :, :) = vm ( ib - 1 + m , :, :) wm ( ib - m , :, :) = wm ( ie + 1 - m , :, :) wm ( ie + m , :, :) = wm ( ib - 1 + m , :, :) end do if ( loneeqn ) then e120 ( ib - m , :, :) = e120 ( ie + 1 - m , :, :) e120 ( ie + m , :, :) = e120 ( ib - 1 + m , :, :) e12m ( ib - m , :, :) = e12m ( ie + 1 - m , :, :) e12m ( ie + m , :, :) = e12m ( ib - 1 + m , :, :) end if return end subroutine xm_periodic !> Sets x/i periodic boundary conditions for the temperature subroutine xT_periodic use modglobal , only : ib , ie , ih , ihc use modfields , only : thl0 , thlm , thl0c integer m do m = 1 , ih thl0 ( ib - m , :, :) = thl0 ( ie + 1 - m , :, :) thl0 ( ie + m , :, :) = thl0 ( ib - 1 + m , :, :) thlm ( ib - m , :, :) = thlm ( ie + 1 - m , :, :) thlm ( ie + m , :, :) = thlm ( ib - 1 + m , :, :) end do do m = 1 , ihc thl0c ( ib - m , :, :) = thl0c ( ie + 1 - m , :, :) thl0c ( ie + m , :, :) = thl0c ( ib - 1 + m , :, :) end do return end subroutine xT_periodic !> Sets x/i periodic boundary conditions for the humidity subroutine xq_periodic use modglobal , only : ib , ie , ih use modfields , only : qt0 , qtm integer m do m = 1 , ih qt0 ( ib - m , :, :) = qt0 ( ie + 1 - m , :, :) qt0 ( ie + m , :, :) = qt0 ( ib - 1 + m , :, :) qtm ( ib - m , :, :) = qtm ( ie + 1 - m , :, :) qtm ( ie + m , :, :) = qtm ( ib - 1 + m , :, :) end do return end subroutine xq_periodic !> Sets x/iperiodic boundary conditions for the scalars subroutine xs_periodic use modglobal , only : ib , ie , ihc use modfields , only : sv0 , svm integer m , n do m = 1 , ihc sv0 ( ib - m , :, :, :) = sv0 ( ie + 1 - m , :, :, :) sv0 ( ie + m , :, :, :) = sv0 ( ib - 1 + m , :, :, :) svm ( ib - m , :, :, :) = svm ( ie + 1 - m , :, :, :) svm ( ie + m , :, :, :) = svm ( ib - 1 + m , :, :, :) end do return end subroutine xs_periodic !>set lateral periodic boundary conditions for momentum in y/j direction subroutine ym_periodic use modglobal , only : ib , ie , jb , je , ih , jh , kb , ke , kh , jmax use modfields , only : u0 , um , v0 , vm , w0 , wm , e120 , e12m , shear use modsubgriddata , only : loneeqn , lsmagorinsky use modmpi , only : excjs integer n , m do m = 1 , ih u0 (:, jb - m , :) = u0 (:, je + 1 - m , :) u0 (:, je + m , :) = u0 (:, jb - 1 + m , :) v0 (:, jb - m , :) = v0 (:, je + 1 - m , :) v0 (:, je + m , :) = v0 (:, jb - 1 + m , :) w0 (:, jb - m , :) = w0 (:, je + 1 - m , :) w0 (:, je + m , :) = w0 (:, jb - 1 + m , :) um (:, jb - m , :) = um (:, je + 1 - m , :) um (:, je + m , :) = um (:, jb - 1 + m , :) vm (:, jb - m , :) = vm (:, je + 1 - m , :) vm (:, je + m , :) = vm (:, jb - 1 + m , :) wm (:, jb - m , :) = wm (:, je + 1 - m , :) wm (:, je + m , :) = wm (:, jb - 1 + m , :) end do if ( loneeqn ) then e120 (:, jb - m , :) = e120 (:, je + 1 - m , :) e120 (:, je + m , :) = e120 (:, jb - 1 + m , :) e12m (:, jb - m , :) = e12m (:, je + 1 - m , :) e12m (:, je + m , :) = e12m (:, jb - 1 + m , :) end if return end subroutine ym_periodic !> Sets y/j periodic boundary conditions for the temperature subroutine yT_periodic use modglobal , only : jb , je , jh , jhc use modfields , only : thl0 , thlm , thl0c use modmpi , only : excjs , myid , nprocs integer m do m = 1 , jh thl0 (:, jb - m , :) = thl0 (:, je + 1 - m , :) thl0 (:, je + m , :) = thl0 (:, jb - 1 + m , :) thlm (:, jb - m , :) = thlm (:, je + 1 - m , :) thlm (:, je + m , :) = thlm (:, jb - 1 + m , :) end do do m = 1 , jhc thl0c (:, jb - m , :) = thl0c (:, je + 1 - m , :) thl0c (:, je + m , :) = thl0c (:, jb - 1 + m , :) end do return end subroutine yT_periodic !> Sets y/j periodic boundary conditions for the humidity subroutine yq_periodic use modglobal , only : jb , je , jh use modfields , only : qt0 , qtm integer m do m = 1 , jh qt0 (:, jb - m , :) = qt0 (:, je + 1 - m , :) qt0 (:, je + m , :) = qt0 (:, jb - 1 + m , :) qtm (:, jb - m , :) = qtm (:, je + 1 - m , :) qtm (:, je + m , :) = qtm (:, jb - 1 + m , :) end do return end subroutine yq_periodic !> Sets y/j periodic boundary conditions for the scalars subroutine ys_periodic use modglobal , only : jb , je , jhc , nsv use modfields , only : sv0 , svm integer n , m do n = 1 , nsv do m = 1 , jhc sv0 (:, jb - m , :, :) = sv0 (:, je + 1 - m , :, :) sv0 (:, je + m , :, :) = sv0 (:, jb - 1 + m , :, :) svm (:, jb - m , :, :) = svm (:, je + 1 - m , :, :) svm (:, je + m , :, :) = svm (:, jb - 1 + m , :, :) end do end do return end subroutine ys_periodic subroutine xmi_profile use modglobal , only : ib , ie , jb , je , kb , ke use modfields , only : u0 , um , v0 , vm , w0 , wm , e120 , e12m , uprof , vprof , e12prof use modsubgriddata , only : loneeqn integer j , k do j = jb - 1 , je + 1 do k = kb , ke + 1 u0 ( ib , j , k ) = uprof ( k ) um ( ib , j , k ) = uprof ( k ) u0 ( ib - 1 , j , k ) = 2 * u0 ( ib , j , k ) - u0 ( ib + 1 , j , k ) ! (u(ib+1)+u(ib-1))/2 = u(ib) um ( ib - 1 , j , k ) = 2 * um ( ib , j , k ) - um ( ib + 1 , j , k ) ! (u(ib+1)+u(ib-1))/2 = u(ib) v0 ( ib - 1 , j , k ) = 2 * vprof ( k ) - v0 ( ib , j , k ) ! (v(ib)+v(ib-1))/2 = vprof vm ( ib - 1 , j , k ) = 2 * vprof ( k ) - vm ( ib , j , k ) ! (v(ib)+v(ib-1))/2 = vprof w0 ( ib - 1 , j , k ) = - w0 ( ib , j , k ) wm ( ib - 1 , j , k ) = - wm ( ib , j , k ) end do end do if ( loneeqn ) then do j = jb - 1 , je + 1 do k = kb , ke + 1 e120 ( ib - 1 , j , k ) = 2 * e12prof ( k ) - e120 ( ib , j , k ) ! (e12(ib)+e12(ib-1))/2=e12prof e12m ( ib - 1 , j , k ) = 2 * e12prof ( k ) - e12m ( ib , j , k ) ! (e12(ib)+e12(ib-1))/2=e12prof end do end do end if end subroutine xmi_profile subroutine xmi_driver use modglobal , only : ib , ie , jb , je , kb , ke use modinletdata , only : u0driver , umdriver , v0driver , vmdriver , w0driver , wmdriver use modfields , only : u0 , um , v0 , vm , w0 , wm , e120 , e12m , e12prof use modsubgriddata , only : loneeqn integer j , k do j = jb - 1 , je + 1 do k = kb , ke !tg3315 removed +1 following above... u0 ( ib , j , k ) = u0driver ( j , k ) !max(0.,u0driver(j,k)) um ( ib , j , k ) = umdriver ( j , k ) !max(0.,umdriver(j,k)) u0 ( ib - 1 , j , k ) = u0driver ( j , k ) !max(0.,u0driver(j,k)) um ( ib - 1 , j , k ) = umdriver ( j , k ) !max(0.,umdriver(j,k)) ! u0(ib-1,j,k)= 2*u0(ib, j, k) - u0(ib + 1, j, k) ! (u(ib+1)+u(ib-1))/2 = u(ib) ! um(ib-1,j,k)= 2*um(ib, j, k) - um(ib + 1, j, k) ! (u(ib+1)+u(ib-1))/2 = u(ib) !v0(ib,j,k)   = v0driver(j,k) !max(0.,v0driver(j,k)) !vm(ib,j,k)   = vmdriver(j,k) !max(0.,vmdriver(j,k)) v0 ( ib - 1 , j , k ) = v0driver ( j , k ) !max(0.,v0driver(j,k)) vm ( ib - 1 , j , k ) = vmdriver ( j , k ) !max(0.,vmdriver(j,k)) end do do k = kb , ke + 1 !w0(ib,j,k)   = w0driver(j,k) !max(0.,w0driver(j,k)) !wm(ib,j,k)   = wmdriver(j,k) !max(0.,wmdriver(j,k)) w0 ( ib - 1 , j , k ) = w0driver ( j , k ) !max(0.,w0driver(j,k)) wm ( ib - 1 , j , k ) = wmdriver ( j , k ) !max(0.,wmdriver(j,k)) end do end do if ( loneeqn ) then do j = jb - 1 , je + 1 do k = kb , ke + 1 ! to be changed in the future: e12 should be taken from recycle plane! !e120(ib-1,j,k) = e120driver(j,k)      ! extrapolate e12 from interior !e12m(ib-1,j,k) = e12mdriver(j,k)      ! extrapolate e12 from interior e120 ( ib - 1 , j , k ) = e120 ( ib , j , k ) ! (e12(ib)+e12(ib-1))/2=e12prof e12m ( ib - 1 , j , k ) = e12m ( ib , j , k ) ! (e12(ib)+e12(ib-1))/2=e12prof end do end do end if end subroutine xmi_driver subroutine xTi_profile use modglobal , only : ib , ie , jb , je , kb , ke use modfields , only : thl0 , thlm , thlprof integer j , k ! set ghost cell ! do j = jb - 1, je + 1 !   do k = kb, ke + 1 !     thl0(ib - 1, j, k) = 2*thlprof(k) - thl0(ib, j, k) !     thlm(ib - 1, j, k) = 2*thlprof(k) - thlm(ib, j, k) !   end do ! end do do j = jb - 1 , je + 1 do k = kb , ke + 1 thl0 ( ib - 1 , j , k ) = thlprof ( k ) thlm ( ib - 1 , j , k ) = thlprof ( k ) end do end do ! set first internal cell as well do j = jb - 1 , je + 1 do k = kb , ke thl0 ( ib , j , k ) = thlprof ( k ) thlm ( ib , j , k ) = thlprof ( k ) end do end do end subroutine xTi_profile subroutine xTi_driver use modglobal , only : ib , ie , jb , je , kb , ke use modinletdata , only : thl0driver , thlmdriver use modfields , only : thl0 , thlm integer j , k do j = jb - 1 , je + 1 do k = kb , ke + 1 thl0 ( ib - 1 , j , k ) = thl0driver ( j , k ) thlm ( ib - 1 , j , k ) = thlmdriver ( j , k ) end do end do end subroutine xTi_driver subroutine xqi_profile use modglobal , only : ib , ie , jb , je , kb , ke use modfields , only : qt0 , qtm , qtprof integer j , k do j = jb - 1 , je + 1 do k = kb , ke + 1 qt0 ( ib - 1 , j , k ) = 2 * qtprof ( k ) - qt0 ( ib , j , k ) qtm ( ib - 1 , j , k ) = 2 * qtprof ( k ) - qtm ( ib , j , k ) end do end do end subroutine xqi_profile subroutine xqi_driver use modglobal , only : ib , ie , jb , je , kb , ke use modinletdata , only : qt0driver , qtmdriver use modfields , only : qt0 , qtm integer j , k do j = jb - 1 , je + 1 do k = kb , ke + 1 qt0 ( ib - 1 , j , k ) = qt0driver ( j , k ) qtm ( ib - 1 , j , k ) = qtmdriver ( j , k ) end do end do end subroutine xqi_driver subroutine xsi_profile use modglobal , only : ib , ie , jb , je , kb , ke , nsv , ihc use modfields , only : sv0 , svm , svprof integer j , k , n , m do j = jb , je do k = kb , ke + 1 do n = 1 , nsv do m = 1 , ihc sv0 ( ib - m , j , k , n ) = 2 * svprof ( k , n ) - sv0 ( ib - m + 1 , j , k , n ) svm ( ib - m , j , k , n ) = 2 * svprof ( k , n ) - svm ( ib - m + 1 , j , k , n ) end do end do end do end do end subroutine xsi_profile subroutine xsi_custom use modglobal , only : ib , ie , jb , je , jtot , kb , ke , nsv , ihc use modfields , only : sv0 , svm , svprof use decomp_2d , only : zstart integer j , k , n , m do j = jb , je if ( j + zstart ( 2 ) - 1 == jtot / 2 ) then do k = kb , ke + 1 do n = 1 , nsv do m = 1 , ihc sv0 ( ib - m , j - 1 : j + 1 , k , n ) = 2 * svprof ( k , n ) - sv0 ( ib - m + 1 , j - 1 : j + 1 , k , n ) svm ( ib - m , j - 1 : j + 1 , k , n ) = 2 * svprof ( k , n ) - svm ( ib - m + 1 , j - 1 : j + 1 , k , n ) end do end do end do end if end do end subroutine xsi_custom subroutine xsi_driver use modglobal , only : ib , ie , ihc , jb , je , jhc , kb , ke , khc , nsv use modinletdata , only : sv0driver , svmdriver use modfields , only : sv0 , svm integer j , k , n , m do j = jb - 1 , je + 1 do k = kb , ke + 1 do n = 1 , nsv do m = 1 , ihc sv0 ( ib - m , j , k , n ) = sv0driver ( j , k , n ) svm ( ib - m , j , k , n ) = svmdriver ( j , k , n ) end do end do end do end do end subroutine xsi_driver subroutine xmo_convective use modglobal , only : ie , dxi , rk3step , dt use modfields , only : u0 , um , v0 , vm , w0 , wm , e120 , e12m , uouttot use modsubgriddata , only : loneeqn real rk3coef rk3coef = dt / ( 4. - dble ( rk3step )) v0 ( ie + 1 , :, :) = v0 ( ie + 1 , :, :) - ( v0 ( ie + 1 , :, :) - v0 ( ie , :, :)) * dxi * rk3coef * uouttot w0 ( ie + 1 , :, :) = w0 ( ie + 1 , :, :) - ( w0 ( ie + 1 , :, :) - w0 ( ie , :, :)) * dxi * rk3coef * uouttot vm ( ie + 1 , :, :) = vm ( ie + 1 , :, :) - ( vm ( ie + 1 , :, :) - vm ( ie , :, :)) * dxi * rk3coef * uouttot wm ( ie + 1 , :, :) = wm ( ie + 1 , :, :) - ( wm ( ie + 1 , :, :) - wm ( ie , :, :)) * dxi * rk3coef * uouttot if ( loneeqn ) then e120 ( ie + 1 , :, :) = e120 ( ie , :, :) - ( e120 ( ie + 1 , :, :) - e120 ( ie , :, :)) * dxi * rk3coef * uouttot e12m ( ie + 1 , :, :) = e12m ( ie , :, :) - ( e12m ( ie + 1 , :, :) - e12m ( ie , :, :)) * dxi * rk3coef * uouttot end if end subroutine xmo_convective subroutine xmo_Neumann use modglobal , only : ie use modfields , only : u0 , um , v0 , vm , w0 , wm , e120 , e12m use modsubgriddata , only : loneeqn v0 ( ie + 1 , :, :) = v0 ( ie , :, :) w0 ( ie + 1 , :, :) = w0 ( ie , :, :) vm ( ie + 1 , :, :) = vm ( ie , :, :) wm ( ie + 1 , :, :) = wm ( ie , :, :) if ( loneeqn ) then e120 ( ie + 1 , :, :) = e120 ( ie , :, :) e12m ( ie + 1 , :, :) = e12m ( ie , :, :) end if end subroutine xmo_Neumann subroutine xTo_convective use modglobal , only : ie , dxi , rk3step , dt use modfields , only : thl0 , thlm , uouttot real rk3coef rk3coef = dt / ( 4. - dble ( rk3step )) thl0 ( ie + 1 , :, :) = thl0 ( ie + 1 , :, :) - ( thl0 ( ie + 1 , :, :) - thl0 ( ie , :, :)) * dxi * rk3coef * uouttot thlm ( ie + 1 , :, :) = thlm ( ie + 1 , :, :) - ( thlm ( ie + 1 , :, :) - thlm ( ie , :, :)) * dxi * rk3coef * uouttot end subroutine xTo_convective subroutine xTo_Neumann use modglobal , only : ie use modfields , only : thl0 , thlm thl0 ( ie + 1 , :, :) = thl0 ( ie , :, :) thlm ( ie + 1 , :, :) = thlm ( ie , :, :) end subroutine xTo_Neumann subroutine xqo_convective use modglobal , only : ie , dxi , rk3step , dt use modfields , only : qt0 , qtm , uouttot real rk3coef rk3coef = dt / ( 4. - dble ( rk3step )) qt0 ( ie + 1 , :, :) = qt0 ( ie , :, :) - ( qt0 ( ie + 1 , :, :) - qt0 ( ie , :, :)) * dxi * rk3coef * uouttot qtm ( ie + 1 , :, :) = qtm ( ie , :, :) - ( qtm ( ie + 1 , :, :) - qtm ( ie , :, :)) * dxi * rk3coef * uouttot end subroutine xqo_convective subroutine xso_convective use modglobal , only : ie , rk3step , dt , dxi , nsv use modfields , only : sv0 , svm , uouttot real rk3coef integer n rk3coef = dt / ( 4. - dble ( rk3step )) do n = 1 , nsv sv0 ( ie + 1 , :, :, n ) = sv0 ( ie + 1 , :, :, n ) - ( sv0 ( ie + 1 , :, :, n ) - sv0 ( ie , :, :, n )) * dxi * rk3coef * uouttot svm ( ie + 1 , :, :, n ) = svm ( ie + 1 , :, :, n ) - ( svm ( ie + 1 , :, :, n ) - svm ( ie , :, :, n )) * dxi * rk3coef * uouttot end do end subroutine xso_convective subroutine xso_Neumann use modglobal , only : ie , ihc , rk3step , dt , dxi , nsv use modfields , only : sv0 , svm real rk3coef integer n , m rk3coef = dt / ( 4. - dble ( rk3step )) do n = 1 , nsv do m = 1 , ihc sv0 ( ie + m , :, :, n ) = sv0 ( ie , :, :, n ) svm ( ie + m , :, :, n ) = svm ( ie , :, :, n ) end do end do end subroutine xso_Neumann subroutine ymi_profile use modglobal , only : ib , ie , jb , je , kb , ke use modfields , only : u0 , um , v0 , vm , w0 , wm , e120 , e12m , uprof , vprof , e12prof use modsubgriddata , only : loneeqn integer i , k do i = ib - 1 , ie + 1 do k = kb , ke + 1 v0 ( i , jb , k ) = vprof ( k ) vm ( i , jb , k ) = vprof ( k ) v0 ( i , jb - 1 , k ) = 2 * v0 ( i , jb , k ) - v0 ( i , jb + 1 , k ) vm ( i , jb - 1 , k ) = 2 * vm ( i , jb , k ) - vm ( i , jb + 1 , k ) u0 ( i , jb - 1 , k ) = 2 * uprof ( k ) - u0 ( i , jb , k ) um ( i , jb - 1 , k ) = 2 * uprof ( k ) - um ( i , jb , k ) w0 ( i , jb - 1 , k ) = - w0 ( i , jb , k ) wm ( i , jb - 1 , k ) = - wm ( i , jb , k ) end do end do if ( loneeqn ) then do i = ib - 1 , ie + 1 do k = kb , ke + 1 e120 ( i , jb - 1 , k ) = 2 * e12prof ( k ) - e120 ( i , jb - 1 , k ) e12m ( i , jb - 1 , k ) = 2 * e12prof ( k ) - e12m ( i , jb - 1 , k ) end do end do end if end subroutine ymi_profile subroutine yTi_profile use modglobal , only : ib , ie , jb , je , kb , ke use modfields , only : thl0 , thlm , thlprof integer i , k do i = ib - 1 , ie + 1 do k = kb , ke + 1 thl0 ( i , jb - 1 , k ) = 2 * thlprof ( k ) - thl0 ( i , jb , k ) thlm ( i , jb - 1 , k ) = 2 * thlprof ( k ) - thlm ( i , jb , k ) end do end do end subroutine yTi_profile subroutine yqi_profile use modglobal , only : ib , ie , jb , je , kb , ke use modfields , only : qt0 , qtm , qtprof integer i , k do i = jb - 1 , ie + 1 do k = kb , ke + 1 qt0 ( i , jb - 1 , k ) = 2 * qtprof ( k ) - qt0 ( i , jb , k ) qtm ( i , jb - 1 , k ) = 2 * qtprof ( k ) - qtm ( i , jb , k ) end do end do end subroutine yqi_profile subroutine ysi_profile use modglobal , only : ib , ie , jb , je , kb , ke , nsv , ihc use modfields , only : sv0 , svm , svprof integer i , k , n , m do i = ib - 1 , ie + 1 do k = kb , ke + 1 do n = 1 , nsv do m = 1 , ihc sv0 ( i , jb - m , k , n ) = 2 * svprof ( k , n ) - sv0 ( i , jb - m + 1 , k , n ) svm ( i , jb - m , k , n ) = 2 * svprof ( k , n ) - svm ( i , jb - m + 1 , k , n ) end do end do end do end do end subroutine ysi_profile subroutine ymo_convective use modglobal , only : je , dyi , rk3step , dt use modfields , only : u0 , um , v0 , vm , w0 , wm , e120 , e12m , vouttot use modsubgriddata , only : loneeqn real rk3coef rk3coef = dt / ( 4. - dble ( rk3step )) ! change to vouttot u0 (:, je + 1 , :) = u0 (:, je + 1 , :) - ( u0 (:, je + 1 , :) - u0 (:, je , :)) * dyi * rk3coef * vouttot um (:, je + 1 , :) = um (:, je + 1 , :) - ( um (:, je + 1 , :) - um (:, je , :)) * dyi * rk3coef * vouttot w0 (:, je + 1 , :) = w0 (:, je + 1 , :) - ( w0 (:, je + 1 , :) - w0 (:, je , :)) * dyi * rk3coef * vouttot wm (:, je + 1 , :) = wm (:, je + 1 , :) - ( wm (:, je + 1 , :) - wm (:, je , :)) * dyi * rk3coef * vouttot if ( loneeqn ) then e120 (:, je + 1 , :) = e120 (:, je + 1 , :) - ( e120 (:, je + 1 , :) - e120 (:, je , :)) * dyi * rk3coef * vouttot e12m (:, je + 1 , :) = e12m (:, je + 1 , :) - ( e12m (:, je + 1 , :) - e12m (:, je , :)) * dyi * rk3coef * vouttot end if end subroutine ymo_convective subroutine yTo_convective use modglobal , only : je , dyi , rk3step , dt use modfields , only : thl0 , thlm , v0 , vouttot real rk3coef rk3coef = dt / ( 4. - dble ( rk3step )) thl0 (:, je + 1 , :) = thl0 (:, je + 1 , :) - ( thl0 (:, je + 1 , :) - thl0 (:, je , :)) * dyi * rk3coef * vouttot thlm (:, je + 1 , :) = thlm (:, je + 1 , :) - ( thlm (:, je + 1 , :) - thlm (:, je , :)) * dyi * rk3coef * vouttot end subroutine yTo_convective subroutine yqo_convective use modglobal , only : je , dyi , rk3step , dt use modfields , only : qt0 , qtm , v0 , vouttot real rk3coef rk3coef = dt / ( 4. - dble ( rk3step )) qt0 (:, je + 1 , :) = qt0 (:, je + 1 , :) - ( qt0 (:, je + 1 , :) - qt0 (:, je , :)) * dyi * rk3coef * vouttot qtm (:, je + 1 , :) = qtm (:, je + 1 , :) - ( qtm (:, je + 1 , :) - qtm (:, je , :)) * dyi * rk3coef * vouttot end subroutine yqo_convective subroutine yso_convective use modglobal , only : je , rk3step , dt , dyi , nsv use modfields , only : sv0 , svm , v0 , vouttot real rk3coef integer n rk3coef = dt / ( 4. - dble ( rk3step )) do n = 1 , nsv sv0 (:, je + 1 , :, n ) = sv0 (:, je + 1 , :, n ) - ( sv0 (:, je + 1 , :, n ) - sv0 (:, je , :, n )) * dyi * rk3coef * vouttot svm (:, je + 1 , :, n ) = svm (:, je + 1 , :, n ) - ( svm (:, je + 1 , :, n ) - svm (:, je , :, n )) * dyi * rk3coef * vouttot end do end subroutine yso_convective subroutine yso_Neumann use modglobal , only : je , jhc , rk3step , dt , dyi , nsv use modfields , only : sv0 , svm real rk3coef integer n , m rk3coef = dt / ( 4. - dble ( rk3step )) do n = 1 , nsv do m = 1 , jhc sv0 (:, je + m , :, n ) = sv0 (:, je , :, n ) svm (:, je + m , :, n ) = svm (:, je , :, n ) end do end do end subroutine yso_Neumann !>set boundary conditions pup,pvp,pwp in subroutine fillps in modpois.f90 subroutine bcpup ( pup , pvp , pwp , rk3coef ) use modglobal , only : ib , ie , jb , je , ih , jh , kb , ke , kh , rk3step , dxi , dyi , dzhi , & ibrank , ierank , jbrank , jerank , BCxm , BCym , BCtopm , & BCtopm_freeslip , BCtopm_noslip , BCtopm_pressure , & BCxm_periodic , BCxm_profile , BCxm_driver , & BCym_periodic , BCym_profile use modfields , only : pres0 , up , vp , wp , um , vm , wm , w0 , u0 , v0 , uouttot , vouttot , uinit , vinit , uprof , vprof , pres0 , IIc , IIcs use modmpi , only : excjs , excis , myid , avexy_ibm use modinletdata , only : u0driver use decomp_2d , only : exchange_halo_z real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ), intent ( inout ) :: pup real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ), intent ( inout ) :: pvp real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ), intent ( inout ) :: pwp real , dimension ( kb : ke + kh ) :: pres0ij real , intent ( in ) :: rk3coef real rk3coefi integer i , j , k rk3coefi = 1. / rk3coef ! if (jbrank) write(*,*) \"jb before exhange_halo \", pvp(ie/2,jb,ke) ! if (jerank) write(*,*) \"je before exhange_halo \", pvp(ie/2,je+1,ke) ! Watch this communication as it is slightly different to normal - ! maybe safer to just resize to kb-kh:ke+kh call exchange_halo_z ( pup , opt_zlevel = ( / ih , jh , 0 / )) call exchange_halo_z ( pvp , opt_zlevel = ( / ih , jh , 0 / )) call exchange_halo_z ( pwp , opt_zlevel = ( / ih , jh , 0 / )) ! if (jbrank) write(*,*) \"jb after exhange_halo \", pvp(ie/2,jb,ke) ! if (jerank) write(*,*) \"je after exhange_halo \", pvp(ie/2,je+1,ke) select case ( BCtopm ) case ( BCtopm_freeslip , BCtopm_noslip ) do j = jb , je do i = ib , ie pwp ( i , j , kb ) = 0. pwp ( i , j , ke + kh ) = 0. end do end do case ( BCtopm_pressure ) call avexy_ibm ( pres0ij ( kb : ke + kh ), pres0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) do j = jb , je do i = ib , ie pwp ( i , j , kb ) = 0. !pwp(i, j, ke + 1) = wm(i, j, ke+1) * rk3coefi - (-pres0ij(ke) - pres0(i,j,ke)) * dzhi(ke+1) ! Doesn't work pwp ( i , j , ke + 1 ) = wm ( i , j , ke + 1 ) * rk3coefi + 2 * pres0ij ( ke ) * dzhi ( ke + 1 ) wp ( i , j , ke + 1 ) = pwp ( i , j , ke + 1 ) - wm ( i , j , ke + 1 ) * rk3coefi end do end do end select !BCtopm select case ( BCxm ) case ( BCxm_periodic ) if ( ibrank . and . ierank ) then ! not parallelised in x do k = kb , ke do j = jb , je pup ( ie + 1 , j , k ) = pup ( ib , j , k ) ! cyclic end do end do end if case ( BCxm_profile ) if ( ibrank ) then do k = kb , ke do j = jb - 1 , je + 1 pup ( ib , j , k ) = uprof ( k ) * rk3coefi up ( ib , j , k ) = 0. end do end do end if if ( ierank ) then do k = kb + 1 , ke do j = jb - 1 , je + 1 ! convective pup ( ie + 1 , j , k ) = um ( ie + 1 , j , k ) * rk3coefi - ( u0 ( ie + 1 , j , k ) - u0 ( ie , j , k )) * dxi * uouttot !u0(ie,j,k) ! du/dt +u*du/dx=0 -> pup(i)=um(i)/rk3coef -um(i)*(um(i)-um(i-1))/dxf(i-1) ! Neumann !pup(ie+1,j,k) = pup(ie,j,k) up ( ie + 1 , j , k ) = pup ( ie + 1 , j , k ) - um ( ie + 1 , j , k ) * rk3coefi end do end do ! Neumann at bottom - performs better with no slip pup ( ie + 1 , :, kb ) = pup ( ie , :, kb ) up ( ie + 1 , :, kb ) = pup ( ie + 1 ,: , kb ) - um ( ie + 1 , :, kb ) * rk3coefi end if case ( BCxm_driver ) if ( ibrank ) then do k = kb , ke do j = jb - 1 , je + 1 pup ( ib , j , k ) = u0driver ( j , k ) * rk3coefi up ( ib , j , k ) = 0. ! u(ib) only evolves according to pressure correction end do end do end if if ( ierank ) then do k = kb , ke do j = jb - 1 , je + 1 pup ( ie + 1 , j , k ) = um ( ie + 1 , j , k ) * rk3coefi - ( u0 ( ie + 1 , j , k ) - u0 ( ie , j , k )) * dxi * uouttot ! du/dt +u*du/dx=0 -> pup(i)=um(i)/rk3coef -um(i)*(um(i)-um(i-1))/dxf(i-1) ! !Neumann !pup(ie+1,j,k) = pup(ie,j,k) up ( ie + 1 , j , k ) = pup ( ie + 1 , j , k ) - um ( ie + 1 , j , k ) * rk3coefi end do end do ! Neumann at bottom - performs better with no slip ! pup(ie+1, :, kb) = pup(ie, :, kb) ! up(ie+1, :, kb) = pup(ie+1, :, kb) - um(ie+1, :, kb) * rk3coefi end if end select ! BCxm select case ( BCym ) case ( BCym_periodic ) if ( jbrank . and . jerank ) then ! not parallelised in y do k = kb , ke do i = ib , ie pvp ( i , je + 1 , k ) = pvp ( i , jb , k ) ! cyclic end do end do end if case ( BCym_profile ) if ( jbrank ) then do k = kb , ke do i = ib - 1 , ie + 1 pvp ( i , jb , k ) = vprof ( k ) * rk3coefi vp ( i , jb , k ) = 0. end do end do end if if ( jerank ) then do k = kb , ke do i = ib - 1 , ie + 1 ! change to vouttot pvp ( i , je + 1 , k ) = vm ( i , je + 1 , k ) * rk3coefi - ( v0 ( i , je + 1 , k ) - v0 ( i , je , k )) * dyi * vouttot vp ( i , je + 1 , k ) = pvp ( i , je + 1 , k ) - vm ( i , je + 1 , k ) * rk3coefi end do end do pvp (:, je + 1 , kb ) = pvp (:, je , kb ) vp (:, je + 1 , kb ) = pvp (:, je + 1 , kb ) - vm (:, je + 1 , kb ) * rk3coefi end if end select end subroutine bcpup !>set pressure boundary conditions subroutine bcp ( p ) use modglobal , only : ib , ie , jb , je , ih , jh , kb , ke , kh , dyi , rk3step , dt , & ibrank , ierank , jbrank , jerank , BCxm , BCym , BCxm_periodic , BCym_periodic use modfields , only : pres0 , up , u0 , um , uouttot , vp , v0 use decomp_2d , only : exchange_halo_z real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ), intent ( inout ) :: p !< pressure integer i , j , k real rk3coef , rk3coefi if ( rk3step == 0 ) then ! dt not defined yet rk3coef = 1. else rk3coef = dt / ( 4. - dble ( rk3step )) end if rk3coefi = 1. / rk3coef call exchange_halo_z ( p ) call exchange_halo_z ( pres0 ) if ( BCxm . eq . BCxm_periodic ) then if ( ibrank . and . ierank ) then do j = jb , je do k = kb , ke p ( ib - 1 , j , k ) = p ( ie , j , k ) p ( ie + 1 , j , k ) = p ( ib , j , k ) !pres0(ib - 1, j, k) = pres0(ie, j, k) !pres0(ie + 1, j, k) = pres0(ib, j, k) end do end do end if else if ( ibrank ) then do k = kb , ke do j = jb - 1 , je + 1 p ( ib - 1 , j , k ) = p ( ib , j , k ) pres0 ( ib - 1 , j , k ) = pres0 ( ib , j , k ) end do end do end if if ( ierank ) then do k = kb , ke do j = jb - 1 , je + 1 p ( ie + 1 , j , k ) = p ( ie , j , k ) pres0 ( ie + 1 , j , k ) = pres0 ( ie , j , k ) end do end do end if end if ! BCxm if ( BCym . eq . BCym_periodic ) then if ( jbrank . and . jerank ) then do i = ib , ie do k = kb , ke p ( i , jb - 1 , k ) = p ( i , je , k ) p ( i , je + 1 , k ) = p ( i , jb , k ) !pres0(ib - 1, j, k) = pres0(ie, j, k) !pres0(ie + 1, j, k) = pres0(ib, j, k) end do end do end if else if ( jbrank ) then do k = kb , ke do i = ib - 1 , ie + 1 p ( i , jb - 1 , k ) = p ( i , jb , k ) pres0 ( i , jb - 1 , k ) = pres0 ( i , jb , k ) enddo enddo end if if ( jerank ) then do k = kb , ke do i = ib - 1 , ie + 1 p ( i , je + 1 , k ) = p ( i , je , k ) pres0 ( i , je + 1 , k ) = pres0 ( i , je , k ) end do end do end if end if !BCym end subroutine bcp !> !! grwdamp damps gravity waves in the upper part of the domain. !> !! The lower limit of the damping region is set by ksp !! Horizontal fluctuations at the top of the domain (for instance gravity waves) !! are damped out by a sponge layer through an additional forcing/source term. !! \\latexonly !! \\begin{eqnarray} !! \\force{i}{sp}(z) &=& -\\frac{1}{t&#94;{\\mr{sp}}}\\left(\\xav{\\fav{u_i}}-\\fav{u_i}\\right), \\\\\\\\ !!  \\source{\\varphi}{sp}(z) &=& -\\frac{1}{t&#94;{\\mr{sp}}}\\left(\\xav{\\varphi}-\\varphi\\right), !! \\end{eqnarray} !! with $t&#94;{\\mr{sp}}$ a relaxation time scale that goes from !! $t&#94;{\\mr{sp}}_0=1/(2.75\\times10&#94;{-3})\\mr{s}\\approx 6$min at the top of the domain !! to infinity at the bottom of the sponge layer. !! \\endlatexonly subroutine grwdamp use modglobal , only : ke , kmax , lcoriol , igrw_damp , geodamptime use modfields , only : up , vp , wp , thlp , qtp , u0 , v0 , w0 , thl0 , qt0 , ug , vg , thl0av , qt0av , u0av , v0av use modmpi , only : myid implicit none integer k select case ( igrw_damp ) case ( 0 ) !do nothing case ( 1 ) do k = ksp , ke up (:, :, k ) = up (:, :, k ) - ( u0 (:, :, k ) - u0av ( k )) * tsc ( k ) vp (:, :, k ) = vp (:, :, k ) - ( v0 (:, :, k ) - v0av ( k )) * tsc ( k ) wp (:, :, k ) = wp (:, :, k ) - w0 (:, :, k ) * tsc ( k ) thlp (:, :, k ) = thlp (:, :, k ) - ( thl0 (:, :, k ) - thl0av ( k )) * tsc ( k ) qtp (:, :, k ) = qtp (:, :, k ) - ( qt0 (:, :, k ) - qt0av ( k )) * tsc ( k ) end do if ( lcoriol ) then do k = ksp , ke up (:, :, k ) = up (:, :, k ) - ( u0 (:, :, k ) - ug ( k )) * (( 1. / ( geodamptime * rnu0 )) * tsc ( k )) vp (:, :, k ) = vp (:, :, k ) - ( v0 (:, :, k ) - vg ( k )) * (( 1. / ( geodamptime * rnu0 )) * tsc ( k )) end do end if case ( 2 ) do k = ksp , ke up (:, :, k ) = up (:, :, k ) - ( u0 (:, :, k ) - ug ( k )) * tsc ( k ) vp (:, :, k ) = vp (:, :, k ) - ( v0 (:, :, k ) - vg ( k )) * tsc ( k ) wp (:, :, k ) = wp (:, :, k ) - w0 (:, :, k ) * tsc ( k ) thlp (:, :, k ) = thlp (:, :, k ) - ( thl0 (:, :, k ) - thl0av ( k )) * tsc ( k ) qtp (:, :, k ) = qtp (:, :, k ) - ( qt0 (:, :, k ) - qt0av ( k )) * tsc ( k ) end do case ( 3 ) do k = ksp , ke up (:, :, k ) = up (:, :, k ) - ( u0 (:, :, k ) - u0av ( k )) * tsc ( k ) vp (:, :, k ) = vp (:, :, k ) - ( v0 (:, :, k ) - v0av ( k )) * tsc ( k ) wp (:, :, k ) = wp (:, :, k ) - w0 (:, :, k ) * tsc ( k ) thlp (:, :, k ) = thlp (:, :, k ) - ( thl0 (:, :, k ) - thl0av ( k )) * tsc ( k ) qtp (:, :, k ) = qtp (:, :, k ) - ( qt0 (:, :, k ) - qt0av ( k )) * tsc ( k ) end do case default write ( 0 , * ) \"ERROR: no gravity wave damping option selected\" stop 1 end select return end subroutine grwdamp subroutine fluxtop ( field , ek , flux ) use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , dzf , dzh , dzhi , eps1 real , intent ( inout ) :: field ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ) real , intent ( in ) :: ek ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ) real , intent ( in ) :: flux ! if ( abs ( flux ) . le . eps1 ) then !it's zero-flux, we don't need to do the calculation field (:, :, ke + 1 ) = field (:, :, ke ) else field (:, :, ke + 1 ) = field (:, :, ke ) + dzh ( ke + 1 ) * flux / ( dzhi ( ke + 1 ) * ( 0.5 * ( dzf ( ke ) * ek (:, :, ke + 1 ) + dzf ( ke + 1 ) * ek (:, :, ke )))) end if ! end subroutine fluxtop subroutine valuetop ( field , val ) use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , dzh , dzf , dzhi , dzfi use modmpi , only : myid real , intent ( inout ) :: field ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ) real , intent ( in ) :: val ! (field(i, j, kp)*dzf(k) + field(i, j, k)*dzf(kp))*dzhi(kp)*0.5 = val !field(:,:,ke+1) = (2.*val*dzh(ke+1) - field(:,:,ke)*dzf(ke+1)) * dzfi(ke) field (:, :, ke + 1 ) = 2 * val - field (:, :, ke ) !if (myid == 0) write(*,*) (field(40, 1, ke+1)*dzf(ke) + field(40, 1, ke)*dzf(ke+1))*dzhi(ke+1)*0.5 end subroutine valuetop subroutine fluxtopscal ( flux ) use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , dzf , dzh , dzhi , nsv , khc use modfields , only : sv0 , svm use modsubgriddata , only : ekh real , intent ( in ) :: flux ( 1 : nsv ) integer :: m , n ! !all the ghost cells have the same value? do m = 1 , khc do n = 1 , nsv sv0 ( ib - ih : ie + ih , jb - jh : je + jh , ke + m , n ) = sv0 ( ib - ih : ie + ih , jb - jh : je + jh , ke , n ) + dzh ( ke + 1 ) * flux ( n ) / ( dzhi ( ke + 1 ) * ( 0.5 * ( dzf ( ke ) * ekh ( ib - ih : ie + ih , jb - jh : je + jh , ke + 1 ) + dzf ( ke + 1 ) * ekh ( ib - ih : ie + ih , jb - jh : je + jh , ke )))) svm ( ib - ih : ie + ih , jb - jh : je + jh , ke + m , n ) = svm ( ib - ih : ie + ih , jb - jh : je + jh , ke , n ) + dzh ( ke + 1 ) * flux ( n ) / ( dzhi ( ke + 1 ) * ( 0.5 * ( dzf ( ke ) * ekh ( ib - ih : ie + ih , jb - jh : je + jh , ke + 1 ) + dzf ( ke + 1 ) * ekh ( ib - ih : ie + ih , jb - jh : je + jh , ke )))) end do end do ! end subroutine fluxtopscal subroutine valuetopscal ( val ) use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , eps1 , nsv , khc use modfields , only : sv0 , svm real , intent ( in ) :: val ( 1 : nsv ) integer :: m , n ! ! all the ghost cells have the same vlaue? do m = 1 , khc do n = 1 , nsv sv0 (: , : , ke + m , n ) = 2 * val ( n ) - sv0 (: , : , ke , n ) svm (: , : , ke + m , n ) = 2 * val ( n ) - svm (: , : , ke , n ) end do end do ! end subroutine valuetopscal !>Set thl, qt and sv(n) equal to slab average at level kmax ! Think this can be removed subroutine tqaver use modmpi , only : comm3d , mpierr , my_real , mpi_sum use modglobal , only : ib , ie , jb , je , ih , jh , kb , ke , nsv , rslabs use modfields , only : thl0 , qt0 , sv0 implicit none real thl0a , qt0a real thl0al , qt0al integer n real , allocatable , dimension (:) :: sv0al , sv0a allocate ( sv0al ( nsv ), sv0a ( nsv )) thl0al = sum ( thl0 ( ib : ie , jb : je , ke )) qt0al = sum ( qt0 ( ib : ie , jb : je , ke )) do n = 1 , nsv sv0al ( n ) = sum ( sv0 ( ib : ie , jb : je , ke , n )) enddo call MPI_ALLREDUCE ( thl0al , thl0a , 1 , MY_REAL , & MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( qt0al , qt0a , 1 , MY_REAL , & MPI_SUM , comm3d , mpierr ) if ( nsv > 0 ) then call MPI_ALLREDUCE ( sv0al , sv0a , nsv , MY_REAL , & MPI_SUM , comm3d , mpierr ) end if thl0a = thl0a / rslabs qt0a = qt0a / rslabs sv0a = sv0a / rslabs thl0 ( ib : ie , jb : je , ke ) = thl0a qt0 ( ib : ie , jb : je , ke ) = qt0a do n = 1 , nsv sv0 ( ib : ie , jb : je , ke , n ) = sv0a ( n ) enddo deallocate ( sv0al , sv0a ) return end subroutine tqaver end module modboundary","tags":"","url":"sourcefile/modboundary.f90.html"},{"title":"modglobal.f90 – uDALES","text":"This file depends on sourcefile~~modglobal.f90~~EfferentGraph sourcefile~modglobal.f90 modglobal.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~modglobal.f90~~AfferentGraph sourcefile~modglobal.f90 modglobal.f90 sourcefile~advec_2nd.f90 advec_2nd.f90 sourcefile~advec_2nd.f90->sourcefile~modglobal.f90 sourcefile~initfac.f90 initfac.f90 sourcefile~advec_2nd.f90->sourcefile~initfac.f90 sourcefile~modfields.f90 modfields.f90 sourcefile~advec_2nd.f90->sourcefile~modfields.f90 sourcefile~modibm.f90 modibm.f90 sourcefile~advec_2nd.f90->sourcefile~modibm.f90 sourcefile~advec_kappa.f90 advec_kappa.f90 sourcefile~advec_kappa.f90->sourcefile~modglobal.f90 sourcefile~advec_kappa.f90->sourcefile~modfields.f90 sourcefile~advec_upw.f90 advec_upw.f90 sourcefile~advec_upw.f90->sourcefile~modglobal.f90 sourcefile~advec_upw.f90->sourcefile~modfields.f90 sourcefile~advection.f90 advection.f90 sourcefile~advection.f90->sourcefile~modglobal.f90 sourcefile~advection.f90->sourcefile~modfields.f90 sourcefile~heatpump.f90 heatpump.f90 sourcefile~heatpump.f90->sourcefile~modglobal.f90 sourcefile~heatpump.f90->sourcefile~modfields.f90 sourcefile~initfac.f90->sourcefile~modglobal.f90 sourcefile~modboundary.f90 modboundary.f90 sourcefile~modboundary.f90->sourcefile~modglobal.f90 sourcefile~moddriver.f90 moddriver.f90 sourcefile~modboundary.f90->sourcefile~moddriver.f90 sourcefile~modboundary.f90->sourcefile~modfields.f90 sourcefile~modchecksim.f90 modchecksim.f90 sourcefile~modchecksim.f90->sourcefile~modglobal.f90 sourcefile~modchecksim.f90->sourcefile~modfields.f90 sourcefile~modchem.f90 modchem.f90 sourcefile~modchem.f90->sourcefile~modglobal.f90 sourcefile~modchem.f90->sourcefile~modfields.f90 sourcefile~moddriver.f90->sourcefile~modglobal.f90 sourcefile~moddriver.f90->sourcefile~modfields.f90 sourcefile~modsave.f90 modsave.f90 sourcefile~moddriver.f90->sourcefile~modsave.f90 sourcefile~modeb.f90 modEB.f90 sourcefile~modeb.f90->sourcefile~modglobal.f90 sourcefile~modeb.f90->sourcefile~initfac.f90 sourcefile~modstat_nc.f90 modstat_nc.f90 sourcefile~modeb.f90->sourcefile~modstat_nc.f90 sourcefile~modfielddump.f90 modfielddump.f90 sourcefile~modfielddump.f90->sourcefile~modglobal.f90 sourcefile~modfielddump.f90->sourcefile~modfields.f90 sourcefile~modfielddump.f90->sourcefile~modibm.f90 sourcefile~modfielddump.f90->sourcefile~modstat_nc.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 sourcefile~modforces.f90 modforces.f90 sourcefile~modforces.f90->sourcefile~modglobal.f90 sourcefile~modforces.f90->sourcefile~modfields.f90 sourcefile~modibm.f90->sourcefile~modglobal.f90 sourcefile~modibm.f90->sourcefile~initfac.f90 sourcefile~modibm.f90->sourcefile~modboundary.f90 sourcefile~modibm.f90->sourcefile~modfields.f90 sourcefile~modibm.f90->sourcefile~modstat_nc.f90 sourcefile~modinlet.f90 modinlet.f90 sourcefile~modinlet.f90->sourcefile~modglobal.f90 sourcefile~modinlet.f90->sourcefile~modfields.f90 sourcefile~modinlet.f90->sourcefile~modsave.f90 sourcefile~modpurifiers.f90 modpurifiers.f90 sourcefile~modpurifiers.f90->sourcefile~modglobal.f90 sourcefile~modpurifiers.f90->sourcefile~modfields.f90 sourcefile~modsave.f90->sourcefile~modglobal.f90 sourcefile~modsave.f90->sourcefile~initfac.f90 sourcefile~modsave.f90->sourcefile~modfields.f90 sourcefile~modstartup.f90 modstartup.f90 sourcefile~modstartup.f90->sourcefile~modglobal.f90 sourcefile~modstartup.f90->sourcefile~modboundary.f90 sourcefile~modstartup.f90->sourcefile~moddriver.f90 sourcefile~modstartup.f90->sourcefile~modfields.f90 sourcefile~modstartup.f90->sourcefile~modforces.f90 sourcefile~modstartup.f90->sourcefile~modibm.f90 sourcefile~modstartup.f90->sourcefile~modinlet.f90 sourcefile~modsubgrid.f90 modsubgrid.f90 sourcefile~modstartup.f90->sourcefile~modsubgrid.f90 sourcefile~modthermodynamics.f90 modthermodynamics.f90 sourcefile~modstartup.f90->sourcefile~modthermodynamics.f90 sourcefile~modtimedep.f90 modtimedep.f90 sourcefile~modstartup.f90->sourcefile~modtimedep.f90 sourcefile~modstat_nc.f90->sourcefile~modglobal.f90 sourcefile~modstatistics.f90 modstatistics.f90 sourcefile~modstatistics.f90->sourcefile~modglobal.f90 sourcefile~modstatistics.f90->sourcefile~modfields.f90 sourcefile~modstatistics.f90->sourcefile~modstat_nc.f90 sourcefile~modstatsdump.f90 modstatsdump.f90 sourcefile~modstatsdump.f90->sourcefile~modglobal.f90 sourcefile~modstatsdump.f90->sourcefile~modfields.f90 sourcefile~modstatsdump.f90->sourcefile~modstat_nc.f90 sourcefile~modstatsdump.f90->sourcefile~modstatistics.f90 sourcefile~modstatsdump.f90->sourcefile~modsubgrid.f90 sourcefile~modsubgrid.f90->sourcefile~modglobal.f90 sourcefile~modsubgrid.f90->sourcefile~modboundary.f90 sourcefile~modsubgrid.f90->sourcefile~modfields.f90 sourcefile~modthermodynamics.f90->sourcefile~modglobal.f90 sourcefile~modthermodynamics.f90->sourcefile~modfields.f90 sourcefile~modtimedep.f90->sourcefile~modglobal.f90 sourcefile~modtimedep.f90->sourcefile~initfac.f90 sourcefile~modtimedep.f90->sourcefile~modfields.f90 sourcefile~modtrees.f90 modtrees.f90 sourcefile~modtrees.f90->sourcefile~modglobal.f90 sourcefile~modtrees.f90->sourcefile~modfields.f90 sourcefile~program.f90 program.f90 sourcefile~program.f90->sourcefile~modglobal.f90 sourcefile~program.f90->sourcefile~heatpump.f90 sourcefile~program.f90->sourcefile~initfac.f90 sourcefile~program.f90->sourcefile~modboundary.f90 sourcefile~program.f90->sourcefile~modchecksim.f90 sourcefile~program.f90->sourcefile~moddriver.f90 sourcefile~program.f90->sourcefile~modeb.f90 sourcefile~program.f90->sourcefile~modfielddump.f90 sourcefile~program.f90->sourcefile~modfields.f90 sourcefile~program.f90->sourcefile~modforces.f90 sourcefile~program.f90->sourcefile~modibm.f90 sourcefile~program.f90->sourcefile~modpurifiers.f90 sourcefile~program.f90->sourcefile~modsave.f90 sourcefile~program.f90->sourcefile~modstartup.f90 sourcefile~program.f90->sourcefile~modstat_nc.f90 sourcefile~program.f90->sourcefile~modstatsdump.f90 sourcefile~program.f90->sourcefile~modsubgrid.f90 sourcefile~program.f90->sourcefile~modthermodynamics.f90 sourcefile~program.f90->sourcefile~modtimedep.f90 sourcefile~program.f90->sourcefile~modtrees.f90 sourcefile~scalsource.f90 scalsource.f90 sourcefile~scalsource.f90->sourcefile~modglobal.f90 sourcefile~scalsource.f90->sourcefile~modfields.f90 sourcefile~tstep.f90 tstep.f90 sourcefile~tstep.f90->sourcefile~modglobal.f90 sourcefile~tstep.f90->sourcefile~modchem.f90 sourcefile~tstep.f90->sourcefile~modfields.f90 sourcefile~wf_gr.f90 wf_gr.f90 sourcefile~wf_gr.f90->sourcefile~modglobal.f90 sourcefile~wf_gr.f90->sourcefile~initfac.f90 sourcefile~wf_uno.f90 wf_uno.f90 sourcefile~wf_uno.f90->sourcefile~modglobal.f90 sourcefile~wf_uno.f90->sourcefile~initfac.f90 sourcefile~wfmneutral.f90 wfmneutral.f90 sourcefile~wfmneutral.f90->sourcefile~modglobal.f90 sourcefile~wfmneutral.f90->sourcefile~initfac.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> \\file modglobal.f90 !!  Declares the global constants !> !! \\author Jasper Tomas, TU Delft 31 March 2014 !!  Declares the global constants !> !  This file is part of DALES. ! ! DALES is free software; you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation; either version 3 of the License, or ! (at your option) any later version. ! ! DALES is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !  Copyright 1993-2009 Delft University of Technology, Wageningen University, Utrecht University, KNMI ! module modglobal implicit none save integer :: poisrcheck = 0 ! switch to check if it is the first (RK) time step ! Simulation dimensions (parconst.f90) integer :: itot = 96 ! Used to be called imax integer :: jtot = 96 integer :: ktot = 96 ! Rename to ktot? integer :: imax integer :: imax1 integer :: imax2 integer :: isen integer :: jmax integer :: jmax1 integer :: jmax2 integer :: jsen integer :: kmax integer :: kmax1 integer :: kmax2 integer :: ib integer :: ie integer :: jb integer :: je integer :: jgb ! global j range - remove eventually integer :: jge ! global j range - remove eventually integer :: offset integer :: kb integer :: ke integer :: nsv = 0 !< Number of additional scalar fields integer :: nvar = 0 character ( 50 ) :: fieldvars = '' integer :: ih = 3 integer :: jh = 3 integer :: kh = 1 integer :: ihc = 2 ! used in k-scheme integer :: jhc = 2 ! used in k-scheme integer :: khc = 2 ! used in k-scheme integer :: nblocks = 0 ! no. of blocks in IBM integer , allocatable :: block (:,:) integer :: nfcts = - 1 ! no. of wall facets integer :: iplane ! ib+iplane is the plane that is stored when lstoreplane=.true. integer :: nstore = 1002 ! number of rk steps in inletfile. This should be a multiple of three! character ( 90 ) :: fname_options = 'namoptions' integer , parameter :: longint = 8 logical :: lwarmstart = . false . !<   flag for \"cold\" or \"warm\" start logical :: lstratstart = . false . logical :: lfielddump = . false . !< switch to enable the fielddump logical :: lreadscal = . false . !<   flag for reading scalar pollutant field (warm start) !Switches for boundary conditions !momentum (m), temperature (T), humidity (q) and scalars (s) !lateral in x/i direction (x), in y/j direction (y) at the top (top) and at the bottom (bot) !> x direction ! momentum integer , parameter :: BCxm_periodic = 1 integer , parameter :: BCxm_profile = 2 integer , parameter :: BCxm_driver = 3 ! temperature integer , parameter :: BCxT_periodic = 1 integer , parameter :: BCxT_profile = 2 integer , parameter :: BCxT_driver = 3 ! moisture integer , parameter :: BCxq_periodic = 1 integer , parameter :: BCxq_profile = 2 integer , parameter :: BCxq_driver = 3 ! scalars integer , parameter :: BCxs_periodic = 1 integer , parameter :: BCxs_profile = 2 integer , parameter :: BCxs_driver = 3 integer , parameter :: BCxs_custom = 4 ! Used to demonstrate flow ! set defaults integer :: BCxm = BCxm_periodic integer :: BCxT = BCxT_periodic integer :: BCxq = BCxq_periodic integer :: BCxs = BCxs_periodic !> y direction ! momentum integer , parameter :: BCym_periodic = 1 integer , parameter :: BCym_profile = 2 ! temperature integer , parameter :: BCyT_periodic = 1 integer , parameter :: BCyT_profile = 2 ! moisture integer , parameter :: BCyq_periodic = 1 integer , parameter :: BCyq_profile = 2 ! scalars integer , parameter :: BCys_periodic = 1 integer , parameter :: BCys_profile = 2 ! set defaults integer :: BCym = BCym_periodic integer :: BCyT = BCyT_periodic integer :: BCyq = BCyq_periodic integer :: BCys = BCys_periodic !> top ! momentum integer , parameter :: BCtopm_freeslip = 1 ! zero flux integer , parameter :: BCtopm_noslip = 2 ! fixed velocity integer , parameter :: BCtopm_pressure = 3 ! vertical velocity can vary according to pressure gradient ! temperature integer , parameter :: BCtopT_flux = 1 ! determined by flux wttop integer , parameter :: BCtopT_value = 2 ! determined by value thl_top ! moisture integer , parameter :: BCtopq_flux = 1 ! determined by flux wqtop integer , parameter :: BCtopq_value = 2 ! determined by value qt_top ! scalars integer , parameter :: BCtops_flux = 1 ! determined by flux wstop integer , parameter :: BCtops_value = 2 ! determined by value sv_top ! set defaults integer :: BCtopm = BCtopm_freeslip integer :: BCtopT = BCtopT_flux integer :: BCtopq = BCtopq_flux integer :: BCtops = BCtops_flux !> bottom ! tangential velocities (vertical is always impermeable) integer , parameter :: BCbotm_freeslip = 1 ! do nothing integer , parameter :: BCbotm_wf = 2 ! wall function integer , parameter :: BCbotm_wfneutral = 3 ! neutral wall function ! temperature integer , parameter :: BCbotT_flux = 1 ! determined by wtsurf integer , parameter :: BCbotT_wf = 2 ! wall function ! moisture integer , parameter :: BCbotq_flux = 1 ! determined by wtsurf ! scalars integer , parameter :: BCbots_flux = 1 ! zero flux ! set defaults integer :: BCbotm = BCbotm_wf integer :: BCbotT = BCbotT_flux integer :: BCbotq = BCbotq_flux integer :: BCbots = BCbots_flux integer :: BCzp = 1 ! 1: solve poisson equation using GE. 2: solve using cosine transform real :: ds = 0 ! Shifted boundary conditions integer :: iinletgen = 0 !<  0: no inletgen, 1: turb. inlet generator (Lund (1998)), 2: read inlet from file integer :: idriver = 0 !<  0: no inlet driver store, 1: Save inlet driver data, 2: read inlet driver data from file logical :: linoutflow = . false . !<  switch for periodic BC in both horizontal directions (false) or inflow/outflow in i and periodic in j. logical :: lzerogradtop = . false . !<  switch for zero gradient BC's at top wall (iinletgen 1 and 2 are seperate). logical :: lzerogradtopscal = . false . ! logical :: lbuoyancy = . false . !<  switch for buoyancy force in modforces logical :: ltempeq = . false . !<  switch for solving temperature equation (either with or without buoyancy term) logical :: lscalrec = . false . !< logical :: lSIRANEinout = . false . !< logical :: ltempinout = . false . !<  seperate switch for inflow/outflow BC for temperature (only necessary when linoutflow.eqv..false.). logical :: lmoistinout = . false . !<  seperate switch for inflow/outflow BC for moisture (only necessary when linoutflow.eqv..false.). logical :: lper2inout = . false . !<  switch that determines type of restart: .true. means switching from periodic to in/outflow: inlet profile is read from prof.inp logical :: libm = . true . !<  switch that determines whether the Immersed Boundary Method is turned on logical :: lwalldist = . false . !<  switch that determines whether the wall distances should be computed logical :: lles = . true . !<  switch that determines whether the subgrid model is turned on or constant ekm and ekh are used (DNS) logical :: linletRA = . false . !<  switch that determines whether a Running Average should be used (.true.) in inlet generator logical :: lfixinlet = . false . !<  switch that determines whether the average inlet profiles can evolve or not (only used when iinletgen=1,2) logical :: lfixutauin = . false . !<  switch that determines whether the utau is kept fixed at the inlet (only used when iinletgen=1,2) logical :: lscasrc = . false . ! logical :: lscasrcl = . false . !tg3315 logical :: lydump = . false . !<  switch to output y-averaged statistics every tsample logical :: lytdump = . false . !<  switch to output y- and time- averaged statistics every tstatsdump logical :: lxydump = . false . !<  switch to output x- and y-avewraged statistics every tsample logical :: lxytdump = . false . !<  switch to output x-, y- and time-averaged statistics every tstatsdump logical :: lscasrcr = . false . !<  switch for network of point sources at lowest level logical :: ltkedump = . false . !tg3315 logical :: lkslicedump = . false . !<  switch to output slices in the xy-plane every tsample logical :: lislicedump = . false . !<  switch to output slices in the yz-plane every tsample logical :: ljslicedump = . false . !<  switch to output slices in the xz-plane every tsample integer :: kslice = 1 ! k at which to output slice in xy-plane integer :: islice = 1 ! i at which to output slice in yz-plane integer :: jslice = 1 ! j at which to output slice in xz-plane integer :: isliceloc ! local islice on core logical :: islicerank ! cpu that islice is on integer :: jsliceloc ! local jslice on core logical :: jslicerank ! cpu that jslice is on logical :: ltdump = . false . !<  switch to output time-averaged statistics every tstatsdump logical :: lmintdump = . false . !<  switch to output prognostic statistics every tstatsdump logical :: ltrees = . false . !<  switch to turn on trees module logical :: lpurif = . false . !<  switch to turn on purifiers module logical :: ltreedump = . false . !<  switch to output tree results time-averaged statistics every tstatsdump logical :: lreadminl = . false . !<  switch for reading mean inlet/recycle plane profiles (used in inletgenerator) logical :: lwallfunc = . true . !<  switch that determines whether wall functions are used to compute the wall-shear stress logical :: luoutflowr = . false . !<  switch that determines whether u-velocity is corrected to get a fixed outflow rate logical :: lvoutflowr = . false . !<  switch that determines whether u-velocity is corrected to get a fixed outflow rate logical :: luvolflowr = . false . !<  switch that determines whether u-velocity is corrected to get a fixed volume flow rate logical :: lvvolflowr = . false . !<  switch that determines whether u-velocity is corrected to get a fixed volume flow rate logical :: lstoreplane = . false . !<  switch that determines whether i-plane data is stored. logical :: lstorexy = . false . !xy files stored logical :: lreadmean = . false . !<  switch that determines whether mean variables should be read from means#myid#.#expnr# logical :: lstat = . false . logical :: lEB = . false . logical :: lwriteEBfiles = . false . logical :: lwritefac = . false . real :: dtfac = 1 0. real :: tfac = 0. !time of last calculation of facet quantites real :: tnextfac = 0. !time for next calculation of facet energy balance logical :: lperiodicEBcorr = . false . ! Switch used to correct periodic heat build up. integer :: sinkbase = 0 ! This is the z index above which a sink is applied in periodicEBcorr scheme real :: fraction = 1 ! Fraction of excess heat removed by volume sink in periodic energy balance correction. logical :: lvfsparse = . false . !< whether to read in view factors in sparse format integer :: nnz !< number of non-zero view factors logical :: lconstW = . false . ! The evaporated water can be removed from the soil (lconstW=false) or the soil moisture can be assumed as constant in time (lconstW=true) logical :: lfacTlyrs = . false . !  logical :: ifixuinf   = .true. !dpdxl relaxed to have Uinf 1. dpdx = (1/dt)*(Uh-Uinf)2. d/dt(dpdx) = 1/tau*(Uh-Uinf) integer :: ifixuinf = 0 logical :: lvinf = . false . !use Vinf instead of Uinf for the fixed velocity at infinity logical :: lrandomize = . true . logical :: ibrank logical :: ierank logical :: jbrank logical :: jerank real :: freestreamav = 0. ! real :: freestrtmpav = 0. ! !<  Global constants modconst.f90 !< File numbers integer , parameter :: ifinput = 1 integer , parameter :: ifoutput = 2 integer , parameter :: ifnamopt = 3 real , parameter :: pi = 3.141592653589793116 real , parameter :: grav = 9.81 !<    *gravity acceleration. real , parameter :: rd = 28 7.04 !<    *gas constant for dry air. real , parameter :: rv = 46 1.5 !<    *gas constant for water vapor. real , parameter :: cp = 100 4. !<    *specific heat at constant pressure (dry air). real , parameter :: rlv = 2.26e6 !<    *latent heat for vaporisation. real , parameter :: rlvi = 1 / rlv !inverse real , parameter :: ep = rd / rv !<    0.622 real , parameter :: ep2 = rv / rd - 1. !<    0.61 !< real,parameter :: cv       = cp-rd            !<    716.96 real , parameter :: rcp = rd / cp !<    0.286 real , parameter :: cpr = cp / rd !<    3.50 real , parameter :: rlvocp = rlv / cp !<    2.49 real , parameter :: mair = 2 8.967 !< Molar mass of air real , parameter :: rhoa = 1.2 !density of air used in some calculations real :: wfc = 31 3. !water content at field capacity (kg/m3) real :: wwilt = 17 1. !water ocntent at wilting point (kg/m3) real :: wgrmax = 45 0. !maximum water content (kg/m3) real :: rsmin = 11 0. !minimum resistance of soil/plant real :: rsmax = 500 0. !maximum resistance of soil/plant real :: GRLAI = 2. !Leave area index of green roof real :: wsoil = 0. !water content of soil (kg/m3) real :: bldT = 0. !building internal temperature, currently also ground temperature at a depth equal to floor facet thickness real :: flrT = 0. !ground internal temperature real :: skyLW = 0. !longwave radiation from the sky real :: gres = 0. !saturation vapour pressure of green roof real :: grqs = 0. !saturation humidity of green roof real :: grdqdt = 0. !gradient of saturation humidity for green roof real , parameter :: numol = 1.5e-5 !< kinematic viscosity for couette flow Re=5000 (Re=Uinf*H/(2*nu)) H=1, Uinf=1 real , parameter :: numoli = 1. / numol !< 1/numol real , parameter :: prandtlmol = 0.71 !< Prandtl number (for air at 300K). Fluid property! real , parameter :: prandtlmoli = 1. / prandtlmol !< Inverse of Prandtl number real :: prandtlturb = prandtlmol integer :: iwallmom = 2 , iwalltemp = 1 , iwallmoist = 1 , iwallscal = 1 real , parameter :: rhow = 0.998e3 !<    * Density of water real , parameter :: pref0 = 1.e5 !<    *standard pressure used in exner function. real , parameter :: tmelt = 27 3.16 !<    *temperature of melting of ice. real , parameter :: es0 = 61 0.78 !<    * constants used for computation real , parameter :: at = 1 7.27 !<    * of saturation mixing ratio real , parameter :: bt = 3 5.86 !<    * using Tetens Formula. !      real,parameter :: ekmin    = 1.e-6            !<    *minimum value for k-coefficient. real , parameter :: ekmin = 1.e-12 !<    *minimum value for k-coefficient. real , parameter :: e12min = 5.e-5 !<    *minimum value for TKE. real :: fkar = 0.41 !<   *Von Karman constant real , parameter :: eps1 = 1.e-10 !<    *very small number* real , parameter :: epscloud = 1.e-5 !<    *limit for cloud calculation 0.01 g/kg real , parameter :: boltz = 5.67e-8 !<    *Stefan-Boltzmann constant real , parameter , dimension ( 3 ) :: xhat = ( / 1. , 0. , 0. / ) real , parameter , dimension ( 3 ) :: yhat = ( / 0. , 1. , 0. / ) real , parameter , dimension ( 3 ) :: zhat = ( / 0. , 0. , 1. / ) real , parameter , dimension ( 3 ) :: vec0 = ( / 0. , 0. , 0. / ) ! zero vector logical :: lprofforc = . false . !<  nudge flow to a profile ! logical :: lcoriol = . false . !<  switch for coriolis force integer :: igrw_damp = 0 !< switch to enable gravity wave damping real :: geodamptime = 720 0. !< time scale for nudging to geowind in sponge layer, prevents oscillations real :: uflowrate = 1. !< fixed flow rate used for u-velocity correction real :: vflowrate = 1. !< fixed flow rate used for v-velocity correction real :: Uinf = 0. !< fixed U_inf (used in inlet generator), also in conjunction with ifixuinf real :: Vinf = 0. !fixed V_inf real :: inletav = 0. !< averaging interval for inlet generator real :: totinletav = 0. !< averaging interval for inlet generator (used in Running Average) real :: om22 !<    *2.*omega_earth*cos(lat) real :: om23 !<    *2.*omega_earth*sin(lat) real :: om22_gs !<    *2.*omega_earth*cos(lat) real :: om23_gs !<    *2.*omega_earth*sin(lat) real :: xlat = 5 2. !<    *latitude  in degrees. real :: xlon = 0. !<    *longitude in degrees. !scalar source in fluid domain real , allocatable :: xSa (:) real , allocatable :: ySa (:) real , allocatable :: zSa (:) real :: xS = 0. , yS = 0. , zS = 0. real :: xSb = 0. , ySb = 0. , zSb = 0. real :: xSe = 0. , ySe = 0. , zSe = 0. real :: SS = 0. real :: sigS = 0. integer :: nscasrc = 0 !< number of scalar point sources integer :: nscasrcl = 0 !< number of scalar line sources real , allocatable :: scasrcp (:,:,:) !< field with data from scalarsourcep.inp.xxx containing coordinates of the source points, strength and standard deviation real , allocatable :: scasrcl (:,:,:) !< field with data from scalarsourcel.inp.xxx containing coordinates of the end points of line sources, strength per unit length and standard deviation !trees integer , allocatable :: tree (:,:) !< field with data from tree.inp.xxx integer :: ntree_max = 0 integer :: ntrees = 0 !real, allocatable :: ladz(:)                  !< field with leaf area density data real :: cd = 0. , ud = 0. , Qstar = 0. , dQdt = 0. , dec = 0. , lad = 0. , lsize = 0. , r_s = 0. !< current set of tree parameters ! volumetric drag coefficient, deposition velocity, net radiation, dQ*/dt , extinction coefficient, leaf area density, characteristic leaf size, stomatal resistance, respectively real :: tr_A = 0. logical :: lnudge = . false . !< switch for applying nudging at the top of the domain logical :: lnudgevel = . true . !< switch for nudging velocities real :: tnudge = 6 0. !< time scale for nudging integer :: nnudge = 0 !< number of points from kb to start nudging !chemistry logical :: lchem = . false . ! switch for basic chemistry real :: k1 = 0. , JNO2 = 0. ! k1 = rate constant (O3 + NO -> NO2 + 02 ), JNO2 = NO2 photolysis rate !purifiers integer , allocatable :: purif (:,:) !< field with data from purif.inp.xxx integer :: npurif = 0 real :: Qpu = 0. , epu = 0. !< flowrate and efficiency of purifiers ! Heat pump logical :: lheatpump = . false . !< switch for heat pump logical :: lfan_hp = . true . !< switch for heat pump fan on/off integer :: nhppoints = 0 !< number of heat pump grid points real :: QH_dot_hp = 0. !< Total rate of heat extracted from the ambient air by the heat pump (W) real :: Q_dot_hp = 0. !< Total volume flux going out from the heat pump in vertical direction(m&#94;3/s) ! Poisson solver integer , parameter :: POISS_FFT2D = 0 , & POISS_CYC = 1 , & POISS_FFT3D = 2 , & POISS_FFT2D_2DECOMP = 3 integer :: ipoiss = POISS_FFT2D !Advection scheme integer , parameter :: iadv_upw = 1 !< first order upwind scheme integer , parameter :: iadv_cd2 = 2 !< second order central difference scheme integer , parameter :: iadv_kappa = 7 !< Kappa scheme integer :: iadv_mom = 2 , iadv_tke = - 1 , iadv_thl = - 1 , iadv_qt = - 1 , iadv_sv ( 100 ) = - 1 logical :: lmoist = . false . !<   switch to calculate moisture fields ! Global variables (modvar.f90) real :: xday = 1. !<     * day number real :: xtime = 0. !<     * GMT time real :: runtime = 30 0. !<     * simulation time in secs real :: dtmax = 2 0. !<     * maximum time integration interval real :: trestart = 1000 0. !<     * each trestart sec. a restart file is written to disk. bss116: per default do not write restart files real :: tfielddump = 1000 0. !< Time step for field outputs real :: tsample = 5. !<    Sample time steps for statistics real :: tstatsdump = 1000 0. !< Time step for statistics outputs tg3315 real :: tstatstart = 0. !< Starting time of statistic computation real :: tnextrestart !<     * each trestart sec. a restart file is written to disk real :: tscale !       timescale: domain height*Uinf/utau**2 real :: tnextfielddump !< character ( 90 ) :: startfile = '' !<    * name of the restart file real :: totavtime = 0. !<    * the total time over which the values are averaged in meansXXX.XXX real :: dtEB = 1 0. !time interval between calculations of facet energy balance real :: tEB = 0. !time of last calculation of facet energy balance real :: tnextEB = 0. !time for next calculation of facet energy balance real :: totheatflux = 0. ! Total sensible heat flux from facs into air in one timestep real :: totqflux = 0. ! Total latent heat flux from facs into air in one timestep real :: thres = 5.e-3 !<     * threshold value for inversion height calculations real :: dqt !<     * applied gradient of qt at top of model real :: dtheta !<     * applied gradient of theta at top of model real , allocatable :: dsv (:) !<     * applied gradient of sv(n) at top of model real :: dt !<     * time integration interval !      integer(kind=longint) :: timee             !<     * elapsed time since the \"cold\" start real :: timee !<     * elapsed time since the \"cold\" start !      integer(kind=longint) :: btime             !<     * time of (re)start real :: btime !<     * time of (re)start real :: runavtime !<     * time of starting running average integer :: ntimee !<     * number of timesteps since the cold start integer :: ntrun !<     * number of timesteps since the start of the run real :: timeleft logical :: ladaptive = . false . !<    * adaptive timestepping on or off real :: tdriverstart = 0. !<     * time at which to start recording inlet driver file (only necessary if idriver == 1) real :: tdriverstart_cold = 0. !< to store tdriverstart of cold started simulation while doing warmstart real :: tdriverdump !<     * time in inlet driver simulation at which data dumps are made (idriver == 1) real :: dtdriver = 0.1 !<     * time frequency at which inlet driver data dumps are made (idriver == 1) integer :: driverstore !<     * number of stored driver steps for inlet (automatically calculated) integer :: driverjobnr !<     * Job number of the driver inlet generation run (idriver == 2) character ( 3 ) :: cdriverjobnr logical :: lhdriver = . false . !<     * switch for reading temperature driver files logical :: lqdriver = . false . !<     * switch for reading temperature driver files logical :: lsdriver = . false . !<     * switch for reading scalar driver files logical :: iplanerank = . false . integer :: driverid character ( 3 ) :: cdriverid logical :: lchunkread = . false . !< * logical switch for chunkwise reading of driver files integer :: chunkread_size = 100 !< * chunk size of each reading real :: courant = - 1. real :: diffnr = 0.25 real :: dt_lim integer :: rk3step = 0 integer :: iexpnr = 0 !<     * number of the experiment character ( 3 ) cexpnr real :: thlsrc = 0. ! modphsgrd.f90 real :: dx !<  grid spacing in x-direction real :: dx2 !<  grid spacing in x-direction squared real :: dxi !<  1/dx real :: dxiq !<  1/(dx*4) real :: dxi5 !<  1/(dx*2) real :: dx2i !<  (1/dx)**2 real :: dy !<  grid spacing in y-direction real :: dy2 !<  grid spacing in y-direction squared real :: dz !<  grid spacing in z-direction real :: dyi !<  1/dy real :: dyiq !<  1/(dy*4) real :: dyi5 !<  1/(dy*2) real :: dy2i !<  (1/dy)**2 integer :: nfaclyrs = 3 real , allocatable :: AM (:,:), BM (:,:), CM (:,:), DM (:,:), EM (:,:), FM (:,:), GM (:,:), HM (:,:), inAM (:,:), IDM (:,:) !matrices for the facet energy balance real , allocatable :: bb (:), w (:), dumv (:), Tdash (:) !vector for the facet energy balance real :: rslabs real , allocatable :: dzf (:) !<  thickness of full level real , allocatable :: dzfc (:) !<  thickness of full level (extra ghost nodes (used in k-scheme) real , allocatable :: dzfci (:) !<  1/dzfc real , allocatable :: dzf2 (:) !<  thickness of full level squared real , allocatable :: dzh (:) !<  thickness of half level real , allocatable :: zh (:) !<  height of half level [m] real , allocatable :: zf (:) !<  height of full level [m] real , allocatable :: dzfi (:) !<  1/dzf real , allocatable :: dzfiq (:) !<  0.25*(1/dzf) real , allocatable :: dzfi5 (:) !<  0.5*(1/dzf) real , allocatable :: dzhi (:) !<  1/dzh real , allocatable :: dzhci (:) !<  1/dzh (extra ghost nodes (used in k-scheme) real , allocatable :: dzhiq (:) !<  0.25*(1/dzh) real , allocatable :: dzh2i (:) !<  1/dzh&#94;2 real , allocatable :: zhi (:) !<  1/zh real , allocatable :: zfi (:) !<  1/zf real , allocatable :: dxf (:) !<  thickness of full level real , allocatable :: dxfc (:) !<  thickness of full level (extra ghost nodes (used in k-scheme) real , allocatable :: dxfci (:) !<  1/dxfc real , allocatable :: dxf2 (:) !<  thickness of full level squared real , allocatable :: dxfi (:) !<  = 1/dxf real , allocatable :: dxfiq (:) !<  = 0.25*(1/dxf) real , allocatable :: dxfi5 (:) !<  = 0.5*(1/dxf) real , allocatable :: dxh (:) !<  thickness of half level real , allocatable :: dxhi (:) !<  = 1/dxh real , allocatable :: dxhci (:) !<  = 1/dxh (with extra ghost nodes (used in k-scheme)) real , allocatable :: dxhiq (:) !<  = 0.25*(1/dxh) real , allocatable :: dxh2i (:) !<  = 1/dxh&#94;2 real , allocatable :: xh (:) !<  height of half level [m] real , allocatable :: xf (:) !<  height of full level [m] real , allocatable :: yh (:) !<  height of half level [m] real , allocatable :: yf (:) !<  height of full level [m] real :: xlen = - 1. !<  domain size in x-direction real :: ylen = - 1. !<  domain size in y-direction real , allocatable :: delta (:, :) !<  (dx*dy*dz)**(1/3) logical :: lmomsubs = . false . !<  switch to apply subsidence on the momentum or not character ( 80 ) :: author = '' , version = 'DALES U' contains !> Initialize global settings. !! !! Set courant number, calculate the grid sizes (both computational and physical), and set the coriolis parameter subroutine initglobal use modmpi , only : myid , comm3d , my_real , mpierr use decomp_2d implicit none integer :: advarr ( 4 ) real phi , colat , silat , omega , omega_gs integer :: i , j , k , n character ( 80 ) chmess ! Global constants ! Select advection scheme for scalars. If not set in the options file, the momentum scheme is used if ( iadv_tke < 0 ) iadv_tke = iadv_mom if ( iadv_thl < 0 ) iadv_thl = iadv_mom if ( iadv_qt < 0 ) iadv_qt = iadv_mom !CvH remove where !where (iadv_sv<0)  iadv_sv  = iadv_mom !tg3315 added - only uses kappa advection scheme... do n = 1 , nsv iadv_sv ( n ) = iadv_kappa end do !ends here !timestepping if ( courant < 0 ) then select case ( iadv_mom ) case ( iadv_cd2 ) courant = 1.5 case default courant = 1.4 end select if ( any ( iadv_sv ( 1 : nsv ) == iadv_kappa ) . or . any (( / iadv_thl , iadv_qt , iadv_tke / ) == iadv_kappa )) then courant = min ( courant , 1.1 ) elseif ( any ( iadv_sv ( 1 : nsv ) == iadv_upw ) . or . any (( / iadv_thl , iadv_qt , iadv_tke / ) == iadv_upw )) then courant = min ( courant , 1.1 ) elseif ( any ( iadv_sv ( 1 : nsv ) == iadv_cd2 ) . or . any (( / iadv_thl , iadv_qt , iadv_tke / ) == iadv_cd2 )) then courant = min ( courant , 1.5 ) end if end if ! phsgrid !jmax = jtot/nprocy ! Only in z-pencil and not true generally - uneven no. !imax = itot/nprocx ! Only in z-pencil isen = imax ! Only in z-pencil - replace eventually so it is pencil-independent (in poisson) jsen = jmax ! Only in z-pencil - replace eventually so it is pencil-independent (in poisson) !set the number of ghost cells. NB: This switch has to run in order of required ghost cells advarr = ( / iadv_mom , iadv_tke , iadv_thl , iadv_qt / ) if ( any ( advarr == iadv_kappa )) then ih = 2 jh = 2 kh = 1 ! SO: think this is inconsistent elseif ( any ( advarr == iadv_cd2 ) . or . any ( iadv_sv ( 1 : nsv ) == iadv_cd2 )) then ih = 1 jh = 1 kh = 1 ihc = 1 jhc = 1 khc = 1 end if ! J. Tomas added this for using only kappa scheme for sv(:) if ( any ( iadv_sv ( 1 : nsv ) == iadv_kappa ) . or . ( iadv_thl == iadv_kappa )) then ih = 1 jh = 1 kh = 1 ihc = 2 jhc = 2 khc = 2 end if ! Eventually ib etc should be completely replaced. ! All arrays start at 1, like in 2DECOMP, and end at e.g. zsize(1) = imax in old terminology ib = 1 ! Remove eventually jb = 1 jgb = jb ! global j range (starting at the same as j as the processor j range) jge = jtot ! global j range kb = 1 ! Make redundant !kmax = ktot ! Define indices in terms of 2DECOMP's. Subject to change! z=pencil 'special' for now, but could rename e.g. imax -> imax3 imax1 = xsize ( 1 ) !=itot imax2 = ysize ( 1 ) imax = zsize ( 1 ) jmax1 = xsize ( 2 ) jmax2 = ysize ( 2 ) !=jtot jmax = zsize ( 2 ) kmax1 = xsize ( 3 ) kmax2 = ysize ( 3 ) kmax = zsize ( 3 ) ie = imax je = jmax ke = kmax decomp_main % zlevel = ( / ih , jh , kh / ) if ( zstart ( 1 ) == 1 ) then ibrank = . true . else ibrank = . false . end if if ( zend ( 1 ) == itot ) then ierank = . true . else ierank = . false . end if if ( zstart ( 2 ) == 1 ) then jbrank = . true . else jbrank = . false . end if if ( zend ( 2 ) == jtot ) then jerank = . true . else jerank = . false . end if !write(*,*) \"myid, ibrank, ierank\", myid, ibrank, ierank phi = xlat * pi / 18 0. colat = cos ( phi ) silat = sin ( phi ) omega = 7.292e-5 omega_gs = 7.292e-5 om22 = 2. * omega * colat om23 = 2. * omega * silat om22_gs = 2. * omega_gs * colat om23_gs = 2. * omega_gs * silat ! Variables allocate ( dsv ( nsv )) ! Create the physical grid variables allocate ( dzf ( kb - kh : ke + kh )) allocate ( dzf2 ( kb - kh : ke + kh )) allocate ( dzfi ( kb - kh : ke + kh )) allocate ( dzfiq ( kb - kh : ke + kh )) allocate ( dzfi5 ( kb - kh : ke + kh )) allocate ( dzh ( kb : ke + kh )) allocate ( dzhi ( kb : ke + kh )) allocate ( dzhiq ( kb : ke + kh )) allocate ( dzh2i ( kb : ke + kh )) allocate ( zh ( kb : ke + kh )) allocate ( zf ( kb : ke + kh )) allocate ( dxf ( ib - ih : itot + ih )) allocate ( dxf2 ( ib - ih : itot + ih )) allocate ( dxfi ( ib - ih : itot + ih )) allocate ( dxfiq ( ib - ih : itot + ih )) allocate ( dxfi5 ( ib - ih : itot + ih )) allocate ( dxh ( ib : itot + ih )) allocate ( dxhi ( ib : itot + ih )) allocate ( dxhiq ( ib : itot + ih )) allocate ( dxh2i ( ib : itot + ih )) allocate ( xh ( ib : itot + ih )) allocate ( xf ( ib : itot + ih )) allocate ( yh ( jb : jtot + jh )) allocate ( yf ( jb : jtot + jh )) allocate ( delta ( ib - ih : itot + ih , kb : ke + kh )) rslabs = real ( itot * jtot ) dx = xlen / float ( itot ) dy = ylen / float ( jtot ) ! MPI ! Note, that the loop for reading zf and calculating zh ! has been split so that reading is only done on PE 1 write ( cexpnr , '(i3.3)' ) iexpnr if ( nrank == 0 ) then open ( ifinput , file = 'prof.inp.' // cexpnr ) read ( ifinput , '(a72)' ) chmess read ( ifinput , '(a72)' ) chmess do k = kb , ke read ( ifinput , * ) zf ( k ) end do close ( ifinput ) ! ! J. Tomas: Read the x-coordinates of the cell centers from xgrid.inp.XXX ! ! SO: still reads for now, but need to remove any reference to xf, xh, etc eventually ! open (ifinput, file='xgrid.inp.'//cexpnr) ! read (ifinput, '(a72)') chmess ! read (ifinput, '(a72)') chmess ! ! do i = ib, itot !    read (ifinput, *) xf(i) ! end do ! close (ifinput) end if ! end if nrank==0 ! MPI broadcast ktot elements from zf call MPI_BCAST ( zf , ktot , MY_REAL , 0 , comm3d , mpierr ) ! MPI broadcast itot elements from xf ! call MPI_BCAST(xf, itot, MY_REAL, 0, comm3d, mpierr) zh ( kb ) = 0.0 do k = kb , ke zh ( k + 1 ) = zh ( k ) + 2.0 * ( zf ( k ) - zh ( k )) end do zf ( ke + kh ) = zf ( ke ) + 2.0 * ( zh ( ke + kh ) - zf ( ke )) do k = kb , ke dzf ( k ) = zh ( k + 1 ) - zh ( k ) end do dzf ( ke + 1 ) = dzf ( ke ) dzf ( kb - 1 ) = dzf ( kb ) dzh ( kb ) = 2 * zf ( kb ) do k = kb + 1 , ke + kh dzh ( k ) = zf ( k ) - zf ( k - 1 ) end do ! j. tomas: same trick for x-direction... ! xh(ib) = 0.0 ! do i = ib, itot !    xh(i + 1) = xh(i) + 2.0*(xf(i) - xh(i)) ! end do ! xf(itot + ih) = xf(itot) + 2.0*(xh(itot + ih) - xf(itot)) do i = ib , itot + ih xh ( i ) = ( i - 1 ) * dx xf ( i ) = xh ( i ) + dx / 2 end do do j = jb , jtot + jh yh ( j ) = ( j - 1 ) * dy yf ( j ) = yh ( j ) + dy / 2 end do ! These should be removed eventually do i = ib , itot dxf ( i ) = xh ( i + 1 ) - xh ( i ) end do dxf ( itot + 1 ) = dxf ( itot ) dxf ( ib - 1 ) = dxf ( ib ) dxh ( ib ) = 2 * xf ( ib ) do i = 2 , itot + ih dxh ( i ) = xf ( i ) - xf ( i - 1 ) end do do k = kb , ke + kh do i = ib - ih , itot + ih delta ( i , k ) = ( dxf ( i ) * dy * dzf ( k )) ** ( 1. / 3. ) end do end do !-------------------------------------------------- ! *** Check whether the grid is equidistant ***** !-------------------------------------------------- !if (myid == 0) then !do k=kb,ke+kh !if (.not.(dzf(k).eq.dzf(1))) !      write (6, *) & !      'WARNING, You are working with a non-equidistant grid!!!!' !end if !end do !end if ! end if myid==0 dzhi = 1. / dzh dzfi = 1. / dzf dzf2 = dzf * dzf dxhi = 1. / dxh dxfi = 1. / dxf dxf2 = dxf * dxf dxi = 1. / dx dx2 = dx * dx dyi = 1. / dy dy2 = dy * dy dzhiq = 0.25 * dzhi dzfiq = 0.25 * dzfi dxhiq = 0.25 * dxhi dxfiq = 0.25 * dxfi dyiq = 0.25 * dyi dxiq = 0.25 * dxi dzh2i = dzhi * dzhi dxh2i = dxhi * dxhi dy2i = dyi * dyi dx2i = dxi * dxi dzfi5 = 0.5 * dzfi dxfi5 = 0.5 * dxfi dyi5 = 0.5 * dyi dxi5 = 0.5 * dxi ! Grid used in kappa scheme advection (extra ghost nodes) if ( any ( iadv_sv ( 1 : nsv ) == iadv_kappa ) . or . ( iadv_thl == iadv_kappa )) then allocate ( dzfc ( kb - khc : ke + khc )) allocate ( dxfc ( ib - ihc : itot + ihc )) allocate ( dzfci ( kb - khc : ke + khc )) allocate ( dxfci ( ib - ihc : itot + ihc )) allocate ( dzhci ( kb - 1 : ke + khc )) allocate ( dxhci ( ib - 1 : itot + ihc )) dzfc ( kb - kh : ke + kh ) = dzf ( kb - kh : ke + kh ) dzfc ( kb - khc ) = dzfc ( kb - kh ) dzfc ( ke + khc ) = dzfc ( ke + kh ) dxfc ( ib - ih : itot + ih ) = dxf ( ib - ih : itot + ih ) dxfc ( ib - ihc ) = dxfc ( ib - ih ) dxfc ( itot + ihc ) = dxfc ( itot + ih ) dzhci ( kb : ke + kh ) = dzhi ( kb : ke + kh ) dzhci ( kb - 1 ) = dzhci ( kb ) dzhci ( ke + khc ) = dzhci ( ke + kh ) dxhci ( ib : itot + ih ) = dxhi ( ib : itot + ih ) dxhci ( ib - 1 ) = dxhci ( ib ) dxhci ( itot + ihc ) = dxhci ( itot + ih ) dzfci = 1. / dzfc dxfci = 1. / dxfc end if tnextrestart = trestart tnextfielddump = tfielddump !    tnextstatsdump = tstatsdump timeleft = runtime ! tg3315 previously btime + runtime end subroutine initglobal !> Clean up when leaving the run subroutine exitglobal deallocate ( dsv , dzf , dzh , zh , zf , delta ) end subroutine exitglobal end module modglobal","tags":"","url":"sourcefile/modglobal.f90.html"},{"title":"modibm.f90 – uDALES","text":"This file depends on sourcefile~~modibm.f90~~EfferentGraph sourcefile~modibm.f90 modibm.f90 sourcefile~initfac.f90 initfac.f90 sourcefile~modibm.f90->sourcefile~initfac.f90 sourcefile~modboundary.f90 modboundary.f90 sourcefile~modibm.f90->sourcefile~modboundary.f90 sourcefile~modfields.f90 modfields.f90 sourcefile~modibm.f90->sourcefile~modfields.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~modibm.f90->sourcefile~modglobal.f90 sourcefile~modibmdata.f90 modibmdata.f90 sourcefile~modibm.f90->sourcefile~modibmdata.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~modibm.f90->sourcefile~modmpi.f90 sourcefile~modstat_nc.f90 modstat_nc.f90 sourcefile~modibm.f90->sourcefile~modstat_nc.f90 sourcefile~modsubgriddata.f90 modsubgriddata.f90 sourcefile~modibm.f90->sourcefile~modsubgriddata.f90 sourcefile~modsurfdata.f90 modsurfdata.f90 sourcefile~modibm.f90->sourcefile~modsurfdata.f90 sourcefile~initfac.f90->sourcefile~modglobal.f90 sourcefile~initfac.f90->sourcefile~modmpi.f90 sourcefile~modboundary.f90->sourcefile~modfields.f90 sourcefile~modboundary.f90->sourcefile~modglobal.f90 sourcefile~modboundary.f90->sourcefile~modmpi.f90 sourcefile~modboundary.f90->sourcefile~modsubgriddata.f90 sourcefile~modboundary.f90->sourcefile~modsurfdata.f90 sourcefile~moddriver.f90 moddriver.f90 sourcefile~modboundary.f90->sourcefile~moddriver.f90 sourcefile~modinletdata.f90 modinletdata.f90 sourcefile~modboundary.f90->sourcefile~modinletdata.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 sourcefile~modstat_nc.f90->sourcefile~modglobal.f90 sourcefile~modstat_nc.f90->sourcefile~modmpi.f90 sourcefile~moddriver.f90->sourcefile~modfields.f90 sourcefile~moddriver.f90->sourcefile~modglobal.f90 sourcefile~moddriver.f90->sourcefile~modmpi.f90 sourcefile~moddriver.f90->sourcefile~modinletdata.f90 sourcefile~modsave.f90 modsave.f90 sourcefile~moddriver.f90->sourcefile~modsave.f90 sourcefile~modsave.f90->sourcefile~initfac.f90 sourcefile~modsave.f90->sourcefile~modfields.f90 sourcefile~modsave.f90->sourcefile~modglobal.f90 sourcefile~modsave.f90->sourcefile~modibmdata.f90 sourcefile~modsave.f90->sourcefile~modmpi.f90 sourcefile~modsave.f90->sourcefile~modsubgriddata.f90 sourcefile~modsave.f90->sourcefile~modsurfdata.f90 sourcefile~modsave.f90->sourcefile~modinletdata.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~modibm.f90~~AfferentGraph sourcefile~modibm.f90 modibm.f90 sourcefile~advec_2nd.f90 advec_2nd.f90 sourcefile~advec_2nd.f90->sourcefile~modibm.f90 sourcefile~modfielddump.f90 modfielddump.f90 sourcefile~modfielddump.f90->sourcefile~modibm.f90 sourcefile~modstartup.f90 modstartup.f90 sourcefile~modstartup.f90->sourcefile~modibm.f90 sourcefile~program.f90 program.f90 sourcefile~program.f90->sourcefile~modibm.f90 sourcefile~program.f90->sourcefile~modfielddump.f90 sourcefile~program.f90->sourcefile~modstartup.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !!> \\file modibm.f90 !!!  adds forcing terms for immersed boundaries ! !> !!  \\author Jasper Thomas TU Delft / Ivo Suter Imperial College London ! !  This file is part of DALES. ! ! DALES is free software; you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation; either version 3 of the License, or ! (at your option) any later version. ! ! DALES is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !  Copyright 1993-2009 Delft University of Technology, Wageningen University, Utrecht University, KNMI ! module modibm use mpi use modibmdata !use wf_uno implicit none save public :: initibm , ibmnorm , ibmwallfun , bottom , lbottom , createmasks , & nsolpts_u , nsolpts_v , nsolpts_w , nsolpts_c , & nbndpts_u , nbndpts_v , nbndpts_w , nbndpts_c , & nfctsecs_u , nfctsecs_v , nfctsecs_w , nfctsecs_c , & mask_u , mask_v , mask_w , mask_c abstract interface function interp_velocity ( i , j , k ) real :: interp_velocity ( 3 ) integer , intent ( in ) :: i , j , k end function interp_velocity end interface abstract interface real function interp_temperature ( i , j , k ) integer , intent ( in ) :: i , j , k end function interp_temperature end interface logical :: lbottom = . false . logical :: lnorec = . false . ! read from namoptions integer :: nsolpts_u , nsolpts_v , nsolpts_w , nsolpts_c , & nbndpts_u , nbndpts_v , nbndpts_w , nbndpts_c , & nfctsecs_u , nfctsecs_v , nfctsecs_w , nfctsecs_c real , allocatable , target , dimension (:,:,:) :: mask_u , mask_v , mask_w , mask_c TYPE solid_info_type integer :: nsolpts integer , allocatable :: solpts (:,:) logical , allocatable :: lsolptsrank (:) ! integer , allocatable :: solptsrank (:) ! indices of points on current rank integer :: nsolptsrank integer , allocatable :: solpts_loc (:,:) end TYPE solid_info_type type ( solid_info_type ) :: solid_info_u , solid_info_v , solid_info_w , solid_info_c TYPE bound_info_type integer :: nbndpts integer , allocatable :: bndpts (:,:) ! ijk location of fluid boundary point !real, allocatable    :: intpts(:,:) ! xyz location of boundary intercept point !real, allocatable    :: bndvec(:,:) ! vector from boundary to fluid point (normalised) real , allocatable :: recpts (:,:) ! xyz location of reconstruction point integer , allocatable :: recids_u (:,:) ! ijk location of u grid cell that rec point is in integer , allocatable :: recids_v (:,:) ! ijk location of u grid cell that rec point is in integer , allocatable :: recids_w (:,:) ! ijk location of u grid cell that rec point is in integer , allocatable :: recids_c (:,:) ! ijk location of u grid cell that rec point is in real , allocatable :: bnddst (:) ! distance between surface & bound point integer , allocatable :: bndptsrank (:) ! indices of points on current rank !integer, allocatable :: bndpts_loc(:,:) ! indices of points on current rank logical , allocatable :: lcomprec (:) ! Switch whether reconstruction point is a computational point logical , allocatable :: lskipsec (:) ! Switch whether to skip finding the shear stress at this point integer :: nbndptsrank integer , allocatable :: bndpts_loc (:,:) ! ijk location of fluid boundary point on rank integer :: nfctsecs integer , allocatable :: secbndptids (:) integer , allocatable :: secfacids (:) real , allocatable :: secareas (:) integer , allocatable :: fctsecsrank (:) integer :: nfctsecsrank integer , allocatable :: secfacids_loc (:) real , allocatable :: secareas_loc (:) integer , allocatable :: secbndpts_loc (:,:) real , allocatable :: bnddst_loc (:) real , allocatable :: recpts_loc (:,:) integer , allocatable :: recids_u_loc (:,:) integer , allocatable :: recids_v_loc (:,:) integer , allocatable :: recids_w_loc (:,:) integer , allocatable :: recids_c_loc (:,:) logical , allocatable :: lcomprec_loc (:) logical , allocatable :: lskipsec_loc (:) end TYPE bound_info_type type ( bound_info_type ) :: bound_info_u , bound_info_v , bound_info_w , bound_info_c integer :: nstatfac = 7 , ncidfac , nrecfac = 0 character ( 80 ), allocatable :: ncstatfac (:,:) character ( 80 ) :: facname = 'fac.xxx.nc' character ( 80 ), dimension ( 1 , 4 ) :: tncstatfac real , allocatable :: varsfac (:,:) real , allocatable :: fac_tau_x (:) real , allocatable :: fac_tau_y (:) real , allocatable :: fac_tau_z (:) real , allocatable :: fac_pres (:) real , allocatable :: fac_pres2 (:) real , allocatable :: fac_htc (:) real , allocatable :: fac_cth (:) real , allocatable :: fac_tau_x_av (:) real , allocatable :: fac_tau_y_av (:) real , allocatable :: fac_tau_z_av (:) real , allocatable :: fac_pres_av (:) real , allocatable :: fac_pres2_av (:) real , allocatable :: fac_htc_av (:) real , allocatable :: fac_cth_av (:) contains subroutine initibm use modglobal , only : libm , xh , xf , yh , yf , zh , zf , xhat , yhat , zhat , vec0 , & ib , ie , ih , ihc , jb , je , jh , jhc , kb , ke , kh , khc , nsv , & iwallmom , lmoist , ltempeq , cexpnr , nfcts , lwritefac use decomp_2d , only : exchange_halo_z use modmpi , only : myid use modstat_nc , only : open_nc , define_nc , ncinfo , writestat_dims_nc real , allocatable :: rhs (:,:,:) if (. not . libm ) return solid_info_u % nsolpts = nsolpts_u solid_info_v % nsolpts = nsolpts_v solid_info_w % nsolpts = nsolpts_w call initibmnorm ( 'solid_u.txt' , solid_info_u ) call initibmnorm ( 'solid_v.txt' , solid_info_v ) call initibmnorm ( 'solid_w.txt' , solid_info_w ) ! Define (real) masks ! Hopefully this can be removed eventually if (integer) IIx halos can be communicated ! These are only used in modibm, to cancel subgrid term across solid boundaries allocate ( mask_u ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )); mask_u = 1. allocate ( mask_v ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )); mask_v = 1. allocate ( mask_w ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )); mask_w = 1. mask_w (:,:, kb ) = 0. ! In future this shouldn't be needed? mask_u (:,:, kb - kh ) = 0. mask_v (:,:, kb - kh ) = 0. mask_w (:,:, kb - kh ) = 0. allocate ( rhs ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) call solid ( solid_info_u , mask_u , rhs , 0. , ih , jh , kh ) call solid ( solid_info_v , mask_v , rhs , 0. , ih , jh , kh ) call solid ( solid_info_w , mask_w , rhs , 0. , ih , jh , kh ) call exchange_halo_z ( mask_u ) !, opt_zlevel=(/ih,jh,0/)) call exchange_halo_z ( mask_v ) !, opt_zlevel=(/ih,jh,0/)) call exchange_halo_z ( mask_w ) !, opt_zlevel=(/ih,jh,0/)) if ( iwallmom > 1 ) then bound_info_u % nbndpts = nbndpts_u bound_info_v % nbndpts = nbndpts_v bound_info_w % nbndpts = nbndpts_w bound_info_u % nfctsecs = nfctsecs_u bound_info_v % nfctsecs = nfctsecs_v bound_info_w % nfctsecs = nfctsecs_w call initibmwallfun ( 'fluid_boundary_u.txt' , 'facet_sections_u.txt' , xhat , bound_info_u ) call initibmwallfun ( 'fluid_boundary_v.txt' , 'facet_sections_v.txt' , yhat , bound_info_v ) call initibmwallfun ( 'fluid_boundary_w.txt' , 'facet_sections_w.txt' , zhat , bound_info_w ) end if if ( ltempeq . or . lmoist . or . nsv > 0 . or . lwritefac ) then solid_info_c % nsolpts = nsolpts_c call initibmnorm ( 'solid_c.txt' , solid_info_c ) bound_info_c % nbndpts = nbndpts_c bound_info_c % nfctsecs = nfctsecs_c call initibmwallfun ( 'fluid_boundary_c.txt' , 'facet_sections_c.txt' , vec0 , bound_info_c ) allocate ( mask_c ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )); mask_c = 1. mask_c (:,:, kb - kh ) = 0. call solid ( solid_info_c , mask_c , rhs , 0. , ih , jh , kh ) call exchange_halo_z ( mask_c ) !, opt_zlevel=(/ih,jh,0/)) end if deallocate ( rhs ) ! write facet stresses and pressure to fac.xxx.nc if ( lwritefac ) then allocate ( fac_tau_x ( 1 : nfcts )) allocate ( fac_tau_y ( 1 : nfcts )) allocate ( fac_tau_z ( 1 : nfcts )) allocate ( fac_pres ( 1 : nfcts )) allocate ( fac_pres2 ( 1 : nfcts )) allocate ( fac_htc ( 1 : nfcts )) allocate ( fac_cth ( 1 : nfcts )) fac_tau_x = 0. fac_tau_y = 0. fac_tau_z = 0. fac_pres = 0. fac_pres2 = 0. fac_htc = 0. fac_cth = 0. allocate ( fac_tau_x_av ( 1 : nfcts )) allocate ( fac_tau_y_av ( 1 : nfcts )) allocate ( fac_tau_z_av ( 1 : nfcts )) allocate ( fac_pres_av ( 1 : nfcts )) allocate ( fac_pres2_av ( 1 : nfcts )) allocate ( fac_htc_av ( 1 : nfcts )) allocate ( fac_cth_av ( 1 : nfcts )) fac_tau_x_av = 0. fac_tau_y_av = 0. fac_tau_z_av = 0. fac_pres_av = 0. fac_pres2_av = 0. fac_htc_av = 0. fac_cth_av = 0. facname ( 5 : 7 ) = cexpnr allocate ( ncstatfac ( nstatfac , 4 )) call ncinfo ( tncstatfac ( 1 ,:), 't' , 'Time' , 's' , 'time' ) call ncinfo ( ncstatfac ( 1 ,:), 'tau_x' , 'tau_x' , 'm&#94;2/s&#94;2' , 'ft' ) call ncinfo ( ncstatfac ( 2 ,:), 'tau_y' , 'tau_y' , 'm&#94;2/s&#94;2' , 'ft' ) call ncinfo ( ncstatfac ( 3 ,:), 'tau_z' , 'tau_z' , 'm&#94;2/s&#94;2' , 'ft' ) call ncinfo ( ncstatfac ( 4 ,:), 'pres' , 'pressure' , 'm&#94;2/s&#94;2' , 'ft' ) call ncinfo ( ncstatfac ( 5 ,:), 'htc' , 'heat transfer coefficient' , '' , 'ft' ) call ncinfo ( ncstatfac ( 6 ,:), 'cth' , 'heat transfer coefficient (Ivo)' , '' , 'ft' ) call ncinfo ( ncstatfac ( 7 ,:), 'pres_flc' , 'pressure fluctuation' , '' , 'ft' ) if ( myid == 0 ) then call open_nc ( facname , ncidfac , nrecfac , nfcts = nfcts ) if ( nrecfac == 0 ) then call define_nc ( ncidfac , 1 , tncstatfac ) call writestat_dims_nc ( ncidfac ) end if call define_nc ( ncidfac , nstatfac , ncstatfac ) end if end if end subroutine initibm subroutine initibmnorm ( fname , solid_info ) use modglobal , only : ifinput use modmpi , only : myid , comm3d , mpierr use decomp_2d , only : zstart , zend character ( 11 ), intent ( in ) :: fname type ( solid_info_type ), intent ( inout ) :: solid_info logical :: lsolptsrank ( solid_info % nsolpts ) integer n , m character ( 80 ) chmess allocate ( solid_info % solpts ( solid_info % nsolpts , 3 )) ! read u points if ( myid == 0 ) then open ( ifinput , file = fname ) read ( ifinput , '(a80)' ) chmess do n = 1 , solid_info % nsolpts read ( ifinput , * ) solid_info % solpts ( n , 1 ), solid_info % solpts ( n , 2 ), solid_info % solpts ( n , 3 ) end do close ( ifinput ) end if call MPI_BCAST ( solid_info % solpts , solid_info % nsolpts * 3 , MPI_INTEGER , 0 , comm3d , mpierr ) ! Determine whether points are on this rank solid_info % nsolptsrank = 0 do n = 1 , solid_info % nsolpts if (( solid_info % solpts ( n , 1 ) >= zstart ( 1 ) . and . solid_info % solpts ( n , 1 ) <= zend ( 1 )) . and . & ( solid_info % solpts ( n , 2 ) >= zstart ( 2 ) . and . solid_info % solpts ( n , 2 ) <= zend ( 2 ))) then lsolptsrank ( n ) = . true . solid_info % nsolptsrank = solid_info % nsolptsrank + 1 else lsolptsrank ( n ) = . false . end if end do ! Store points on current rank - only loop through these points allocate ( solid_info % solptsrank ( solid_info % nsolptsrank )) allocate ( solid_info % solpts_loc ( solid_info % nsolptsrank , 3 )) m = 0 do n = 1 , solid_info % nsolpts if ( lsolptsrank ( n )) then m = m + 1 solid_info % solptsrank ( m ) = n solid_info % solpts_loc ( m ,:) = ( / solid_info % solpts ( n , 1 ), solid_info % solpts ( n , 2 ), solid_info % solpts ( n , 3 ) / ) end if end do !write(*,*) \"rank \", myid, \" has \", solid_info%nsolptsrank, \" solid points from \", fname deallocate ( solid_info % solpts ) end subroutine initibmnorm subroutine initibmwallfun ( fname_bnd , fname_sec , dir , bound_info ) use modglobal , only : ifinput , ib , ie , itot , ih , jb , je , jtot , jh , kb , ktot , kh , & xf , yf , zf , xh , yh , zh , dx , dy , dzh , dzf , xhat , yhat , zhat , eps1 use modmpi , only : myid , comm3d , MY_REAL , mpierr use initfac , only : facnorm , facz0 use decomp_2d , only : zstart , zend character ( 20 ), intent ( in ) :: fname_bnd , fname_sec type ( bound_info_type ) :: bound_info real , intent ( in ), dimension ( 3 ) :: dir real , dimension ( ib : itot + ih ) :: xgrid real , dimension ( jb : jtot + jh ) :: ygrid real , dimension ( kb : ktot + kh ) :: zgrid logical , dimension ( bound_info % nbndpts ) :: lbndptsrank logical , dimension ( bound_info % nfctsecs ) :: lfctsecsrank real , dimension ( 3 ) :: norm , p0 , p1 , pxl , pxu , pyl , pyu , pzl , pzu integer , dimension ( 6 ) :: check integer , dimension ( 1 ) :: pos_min_dist real , dimension ( 6 , 3 ) :: inter real , dimension ( 6 ) :: inter_dists real :: xc , yc , zc , xl , yl , zl , xu , yu , zu , checkxl , checkxu , checkyl , checkyu , checkzl , checkzu , inter_dist integer i , j , k , n , m , norm_align , dir_align , pos , p real dst character ( 80 ) chmess allocate ( bound_info % bndpts ( bound_info % nbndpts , 3 )) ! read u points if ( myid == 0 ) then open ( ifinput , file = fname_bnd ) read ( ifinput , '(a80)' ) chmess do n = 1 , bound_info % nbndpts read ( ifinput , * ) bound_info % bndpts ( n , 1 ), bound_info % bndpts ( n , 2 ), bound_info % bndpts ( n , 3 ) end do close ( ifinput ) end if call MPI_BCAST ( bound_info % bndpts , bound_info % nbndpts * 3 , MPI_INTEGER , 0 , comm3d , mpierr ) ! Determine whether points are on this rank bound_info % nbndptsrank = 0 do n = 1 , bound_info % nbndpts if (( bound_info % bndpts ( n , 1 ) >= zstart ( 1 ) . and . bound_info % bndpts ( n , 1 ) <= zend ( 1 )) . and . & ( bound_info % bndpts ( n , 2 ) >= zstart ( 2 ) . and . bound_info % bndpts ( n , 2 ) <= zend ( 2 ))) then lbndptsrank ( n ) = . true . bound_info % nbndptsrank = bound_info % nbndptsrank + 1 else lbndptsrank ( n ) = . false . end if end do !write(*,*) \"rank \", myid, \" has \", bound_info%nbndptsrank, \"points from \", fname_bnd ! Store indices of points on current rank - only loop through these points allocate ( bound_info % bndptsrank ( bound_info % nbndptsrank )) ! index in global list allocate ( bound_info % bndpts_loc ( bound_info % nbndptsrank , 3 )) ! location m = 0 do n = 1 , bound_info % nbndpts if ( lbndptsrank ( n )) then i = bound_info % bndpts ( n , 1 ) - zstart ( 1 ) + 1 j = bound_info % bndpts ( n , 2 ) - zstart ( 2 ) + 1 k = bound_info % bndpts ( n , 3 ) - zstart ( 3 ) + 1 if (( i < ib ) . or . ( i > ie ) . or . ( j < jb ) . or . ( j > je )) then write ( * , * ) \"problem in initibmwallfun\" , i , j stop 1 end if m = m + 1 bound_info % bndptsrank ( m ) = n bound_info % bndpts_loc ( m ,:) = ( / bound_info % bndpts ( n , 1 ), bound_info % bndpts ( n , 2 ), bound_info % bndpts ( n , 3 ) / ) end if end do allocate ( bound_info % secfacids ( bound_info % nfctsecs )) allocate ( bound_info % secareas ( bound_info % nfctsecs )) allocate ( bound_info % secbndptids ( bound_info % nfctsecs )) !allocate(bound_info%intpts(bound_info%nfctsecs,3)) allocate ( bound_info % bnddst ( bound_info % nfctsecs )) !allocate(bound_info%bndvec(bound_info%nfctsecs,3)) allocate ( bound_info % recpts ( bound_info % nfctsecs , 3 )) allocate ( bound_info % recids_u ( bound_info % nfctsecs , 3 )) allocate ( bound_info % recids_v ( bound_info % nfctsecs , 3 )) allocate ( bound_info % recids_w ( bound_info % nfctsecs , 3 )) allocate ( bound_info % recids_c ( bound_info % nfctsecs , 3 )) allocate ( bound_info % lcomprec ( bound_info % nfctsecs )) allocate ( bound_info % lskipsec ( bound_info % nfctsecs )) dir_align = alignment ( dir ) select case ( dir_align ) case ( 1 ) xgrid = xh ygrid = yf zgrid = zf case ( 2 ) xgrid = xf ygrid = yh zgrid = zf case ( 3 ) xgrid = xf ygrid = yf zgrid = zh case ( 0 ) xgrid = xf ygrid = yf zgrid = zf end select if ( myid == 0 ) then open ( ifinput , file = fname_sec ) read ( ifinput , '(a80)' ) chmess do n = 1 , bound_info % nfctsecs read ( ifinput , * ) bound_info % secfacids ( n ), bound_info % secareas ( n ), bound_info % secbndptids ( n ), bound_info % bnddst ( n ) !bound_info%intpts(n,1),  bound_info%intpts(n,2), bound_info%intpts(n,3) end do close ( ifinput ) do n = 1 , bound_info % nfctsecs m = bound_info % secbndptids ( n ) !bound_info%bndvec(n,1) = xgrid(bound_info%bndpts(m,1)) - bound_info%intpts(n,1) !bound_info%bndvec(n,2) = ygrid(bound_info%bndpts(m,2)) - bound_info%intpts(n,2) !bound_info%bndvec(n,3) = zgrid(bound_info%bndpts(m,3)) - bound_info%intpts(n,3) !bound_info%bnddst(n) = norm2(bound_info%bndvec(n,:)) !write(*,*) bound_info%bnddst(n) !bound_info%bndvec(n,:) = bound_info%bndvec(n,:) / bound_info%bnddst(n) norm = facnorm ( bound_info % secfacids ( n ),:) norm_align = alignment ( norm ) if (( dir_align /= 0 . and . dir_align == norm_align ) . or . ( facz0 ( bound_info % secfacids ( n )) < eps1 )) then ! (for velocities) if the facet is aligned with the grid AND in the same direction as the current velocity grid direction ! therefore no tangential component, don't need to calculate shear stress bound_info % lskipsec ( n ) = . true . cycle else bound_info % lskipsec ( n ) = . false . end if if ( log ( bound_info % bnddst ( n ) / facz0 ( bound_info % secfacids ( n ))) > 1. . or . lnorec ) then ! the wall function is well-defined bound_info % lcomprec ( n ) = . true . ! do simple reconstruction else ! need to reconstruct bound_info % lcomprec ( n ) = . false . ! Find reconstruction point ! cell centre (of current grid) xc = xgrid ( bound_info % bndpts ( m , 1 )) yc = ygrid ( bound_info % bndpts ( m , 2 )) zc = zgrid ( bound_info % bndpts ( m , 3 )) ! cell edges xl = xc - dx / 2. xu = xc + dx / 2. yl = yc - dy / 2. yu = yc + dy / 2. zl = zc - dzf ( 1 ) / 2. ! assumes equidistant zu = zc + dzf ( 1 ) / 2. ! assumes equidistant ! points on planes pxl = ( / xl , yc , zc / ) pxu = ( / xu , yc , zc / ) pyl = ( / xc , yl , zc / ) pyu = ( / xc , yu , zc / ) pzl = ( / xc , yc , zl / ) pzu = ( / xc , yc , zu / ) p0 = ( / xc , yc , zc / ) p1 = p0 + norm * sqrt ( 3. ) * ( dx * dy * dzf ( 1 )) ** ( 1. / 3. ) call plane_line_intersection ( xhat , pxl , p0 , p1 , inter ( 1 ,:), check ( 1 ), inter_dists ( 1 )) call plane_line_intersection ( xhat , pxu , p0 , p1 , inter ( 2 ,:), check ( 2 ), inter_dists ( 2 )) call plane_line_intersection ( yhat , pyl , p0 , p1 , inter ( 3 ,:), check ( 3 ), inter_dists ( 3 )) call plane_line_intersection ( yhat , pyu , p0 , p1 , inter ( 4 ,:), check ( 4 ), inter_dists ( 4 )) call plane_line_intersection ( zhat , pzl , p0 , p1 , inter ( 5 ,:), check ( 5 ), inter_dists ( 5 )) call plane_line_intersection ( zhat , pzu , p0 , p1 , inter ( 6 ,:), check ( 6 ), inter_dists ( 6 )) pos_min_dist = minloc ( inter_dists , mask = check == 1 ) pos = pos_min_dist ( 1 ) if ( pos == 0 ) then write ( * , * ) \"ERROR: no intersection found\" stop 1 else bound_info % recpts ( n ,:) = inter ( pos ,:) ! x y z end if ! find which cell the point lies in bound_info % recids_u ( n , 1 ) = findloc ( bound_info % recpts ( n , 1 ) >= xh , . true ., 1 , back = . true .) bound_info % recids_u ( n , 2 ) = findloc ( bound_info % recpts ( n , 2 ) >= yf , . true ., 1 , back = . true .) bound_info % recids_u ( n , 3 ) = findloc ( bound_info % recpts ( n , 3 ) >= zf , . true ., 1 , back = . true .) bound_info % recids_v ( n , 1 ) = findloc ( bound_info % recpts ( n , 1 ) >= xf , . true ., 1 , back = . true .) bound_info % recids_v ( n , 2 ) = findloc ( bound_info % recpts ( n , 2 ) >= yh , . true ., 1 , back = . true .) bound_info % recids_v ( n , 3 ) = findloc ( bound_info % recpts ( n , 3 ) >= zf , . true ., 1 , back = . true .) bound_info % recids_w ( n , 1 ) = findloc ( bound_info % recpts ( n , 1 ) >= xf , . true ., 1 , back = . true .) bound_info % recids_w ( n , 2 ) = findloc ( bound_info % recpts ( n , 2 ) >= yf , . true ., 1 , back = . true .) bound_info % recids_w ( n , 3 ) = findloc ( bound_info % recpts ( n , 3 ) >= zh , . true ., 1 , back = . true .) bound_info % recids_c ( n , 1 ) = findloc ( bound_info % recpts ( n , 1 ) >= xf , . true ., 1 , back = . true .) bound_info % recids_c ( n , 2 ) = findloc ( bound_info % recpts ( n , 2 ) >= yf , . true ., 1 , back = . true .) bound_info % recids_c ( n , 3 ) = findloc ( bound_info % recpts ( n , 3 ) >= zf , . true ., 1 , back = . true .) ! check to see if recids is inside the domain if ( bound_info % recids_u ( m , 1 ) == 0 . or . bound_info % recids_u ( m , 2 ) == 0 . or . bound_info % recids_u ( m , 3 ) == 0 ) then bound_info % lskipsec ( n ) = . true . cycle end if if ( bound_info % recids_v ( m , 1 ) == 0 . or . bound_info % recids_v ( m , 2 ) == 0 . or . bound_info % recids_v ( m , 3 ) == 0 ) then bound_info % lskipsec ( n ) = . true . cycle end if if ( bound_info % recids_w ( m , 1 ) == 0 . or . bound_info % recids_w ( m , 2 ) == 0 . or . bound_info % recids_w ( m , 3 ) == 0 ) then bound_info % lskipsec ( n ) = . true . cycle end if if ( bound_info % recids_c ( m , 1 ) == 0 . or . bound_info % recids_c ( m , 2 ) == 0 . or . bound_info % recids_c ( m , 3 ) == 0 ) then bound_info % lskipsec ( n ) = . true . cycle end if !check recpts is inside the box defined by the corners ! u if (( bound_info % recpts ( n , 1 ) < xh ( bound_info % recids_u ( n , 1 ))) . or . & ( bound_info % recpts ( n , 1 ) > xh ( bound_info % recids_u ( n , 1 ) + 1 ))) then write ( * , * ) \"ERROR: x out of bounds\" stop 1 end if if (( bound_info % recpts ( n , 2 ) < yf ( bound_info % recids_u ( n , 2 ))) . or . & ( bound_info % recpts ( n , 2 ) > yf ( bound_info % recids_u ( n , 2 ) + 1 ))) then write ( * , * ) \"ERROR: y out of bounds\" stop 1 end if if (( bound_info % recpts ( n , 3 ) < zf ( bound_info % recids_u ( n , 3 ))) . or . & ( bound_info % recpts ( n , 3 ) > zf ( bound_info % recids_u ( n , 3 ) + 1 ))) then write ( * , * ) \"ERROR: z out of bounds\" stop 1 end if ! v if (( bound_info % recpts ( n , 1 ) < xf ( bound_info % recids_v ( n , 1 ))) . or . & ( bound_info % recpts ( n , 1 ) > xf ( bound_info % recids_v ( n , 1 ) + 1 ))) then write ( * , * ) \"ERROR: x out of bounds\" stop 1 end if if (( bound_info % recpts ( n , 2 ) < yh ( bound_info % recids_v ( n , 2 ))) . or . & ( bound_info % recpts ( n , 2 ) > yh ( bound_info % recids_v ( n , 2 ) + 1 ))) then write ( * , * ) \"ERROR: y out of bounds\" stop 1 end if if (( bound_info % recpts ( n , 3 ) < zf ( bound_info % recids_v ( n , 3 ))) . or . & ( bound_info % recpts ( n , 3 ) > zf ( bound_info % recids_v ( n , 3 ) + 1 ))) then write ( * , * ) \"ERROR: z out of bounds\" stop 1 end if ! w if (( bound_info % recpts ( n , 1 ) < xf ( bound_info % recids_w ( n , 1 ))) . or . & ( bound_info % recpts ( n , 1 ) > xf ( bound_info % recids_w ( n , 1 ) + 1 ))) then write ( * , * ) \"ERROR: x out of bounds\" stop 1 end if if (( bound_info % recpts ( n , 2 ) < yf ( bound_info % recids_w ( n , 2 ))) . or . & ( bound_info % recpts ( n , 2 ) > yf ( bound_info % recids_w ( n , 2 ) + 1 ))) then write ( * , * ) \"ERROR: y out of bounds\" stop 1 end if if (( bound_info % recpts ( n , 3 ) < zh ( bound_info % recids_w ( n , 3 ))) . or . & ( bound_info % recpts ( n , 3 ) > zh ( bound_info % recids_w ( n , 3 ) + 1 ))) then write ( * , * ) \"ERROR: z out of bounds\" stop 1 end if end if end do end if ! myid==0 call MPI_BCAST ( bound_info % secfacids , bound_info % nfctsecs , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( bound_info % secareas , bound_info % nfctsecs , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( bound_info % secbndptids , bound_info % nfctsecs , MPI_INTEGER , 0 , comm3d , mpierr ) !call MPI_BCAST(bound_info%intpts,      bound_info%nfctsecs*3, MY_REAL,     0, comm3d, mpierr) !call MPI_BCAST(bound_info%bndvec,      bound_info%nfctsecs*3, MY_REAL,     0, comm3d, mpierr) call MPI_BCAST ( bound_info % bnddst , bound_info % nfctsecs , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( bound_info % recpts , bound_info % nfctsecs * 3 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( bound_info % recids_u , bound_info % nfctsecs * 3 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( bound_info % recids_v , bound_info % nfctsecs * 3 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( bound_info % recids_w , bound_info % nfctsecs * 3 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( bound_info % recids_c , bound_info % nfctsecs * 3 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( bound_info % lskipsec , bound_info % nfctsecs , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( bound_info % lcomprec , bound_info % nfctsecs , MPI_LOGICAL , 0 , comm3d , mpierr ) ! Determine whether section needs to be updated by this rank bound_info % nfctsecsrank = 0 do n = 1 , bound_info % nfctsecs if ( lbndptsrank ( bound_info % secbndptids ( n ))) then lfctsecsrank ( n ) = . true . bound_info % nfctsecsrank = bound_info % nfctsecsrank + 1 else lfctsecsrank ( n ) = . false . end if end do ! Store indices of sections on current rank - only loop through these sections allocate ( bound_info % fctsecsrank ( bound_info % nfctsecsrank )) ! allocate local arrays allocate ( bound_info % secfacids_loc ( bound_info % nfctsecsrank )) allocate ( bound_info % secareas_loc ( bound_info % nfctsecsrank )) allocate ( bound_info % secbndpts_loc ( bound_info % nfctsecsrank , 3 )) allocate ( bound_info % bnddst_loc ( bound_info % nfctsecsrank )) allocate ( bound_info % recpts_loc ( bound_info % nfctsecsrank , 3 )) allocate ( bound_info % recids_u_loc ( bound_info % nfctsecsrank , 3 )) allocate ( bound_info % recids_v_loc ( bound_info % nfctsecsrank , 3 )) allocate ( bound_info % recids_w_loc ( bound_info % nfctsecsrank , 3 )) allocate ( bound_info % recids_c_loc ( bound_info % nfctsecsrank , 3 )) allocate ( bound_info % lcomprec_loc ( bound_info % nfctsecsrank )) allocate ( bound_info % lskipsec_loc ( bound_info % nfctsecsrank )) m = 0 do n = 1 , bound_info % nfctsecs if ( lfctsecsrank ( n )) then m = m + 1 bound_info % fctsecsrank ( m ) = n bound_info % secfacids_loc ( m ) = bound_info % secfacids ( n ) ! facet id bound_info % secareas_loc ( m ) = bound_info % secareas ( n ) bound_info % secbndpts_loc ( m ,:) = bound_info % bndpts ( bound_info % secbndptids ( n ),:) ! boundary point location (in global coordinates) if ( bound_info % bndpts ( bound_info % secbndptids ( n ), 1 ) < zstart ( 1 ) . or . bound_info % bndpts ( bound_info % secbndptids ( n ), 1 ) > zend ( 1 )) then write ( * , * ) \"problem in x boundary points on : \" , myid , n , bound_info % secbndptids ( n ), bound_info % bndpts ( bound_info % secbndptids ( n ), 1 ), zstart ( 1 ), zend ( 1 ) end if if ( bound_info % bndpts ( bound_info % secbndptids ( n ), 2 ) < zstart ( 2 ) . or . bound_info % bndpts ( bound_info % secbndptids ( n ), 2 ) > zend ( 2 )) then write ( * , * ) \"problem in y boundary points on rank: \" , myid , n , bound_info % secbndptids ( n ), bound_info % bndpts ( bound_info % secbndptids ( n ), 2 ), zstart ( 2 ), zend ( 2 ) end if bound_info % bnddst_loc ( m ) = bound_info % bnddst ( n ) bound_info % recpts_loc ( m ,:) = bound_info % recpts ( n ,:) bound_info % recids_u_loc ( m ,:) = bound_info % recids_u ( n ,:) bound_info % recids_v_loc ( m ,:) = bound_info % recids_v ( n ,:) bound_info % recids_w_loc ( m ,:) = bound_info % recids_w ( n ,:) bound_info % recids_c_loc ( m ,:) = bound_info % recids_c ( n ,:) bound_info % lcomprec_loc ( m ) = bound_info % lcomprec ( n ) bound_info % lskipsec_loc ( m ) = bound_info % lskipsec ( n ) end if end do deallocate ( bound_info % bndpts ) deallocate ( bound_info % secfacids ) deallocate ( bound_info % secbndptids ) deallocate ( bound_info % bnddst ) deallocate ( bound_info % recpts ) deallocate ( bound_info % recids_u ) deallocate ( bound_info % recids_v ) deallocate ( bound_info % recids_w ) deallocate ( bound_info % recids_c ) deallocate ( bound_info % lcomprec ) deallocate ( bound_info % lskipsec ) end subroutine initibmwallfun subroutine plane_line_intersection ( norm , V0 , P0 , P1 , I , check , dist ) use modglobal , only : vec0 , eps1 implicit none ! determines the intersection of a plane and a line segment ! norm: plane normal ! V0: point on the plane ! P0: start of line segment ! P1: end of line segment ! I: intersection point ! dist: distance from P0 to intersection point ! check: 0 if no intersection !        1 if unique intersection !        2 if line segment is in the plane !        3 if intersection is outside line segment real , intent ( in ), dimension ( 3 ) :: norm , V0 , P0 , P1 real , intent ( out ), dimension ( 3 ) :: I integer , intent ( out ) :: check real , intent ( out ) :: dist real , dimension ( 3 ) :: u , w real :: D , N , sI I = vec0 w = P0 - V0 u = P1 - P0 D = dot_product ( norm , u ) N =- dot_product ( norm , w ) if ( abs ( D ) < eps1 ) then ! line orthogonal to plane normal -> segment parallel to plane if ( abs ( N ) < eps1 ) then ! start point is on the plane -> segment lies in the plane check = 2 return else check = 0 return end if end if sI = N / D I = P0 + sI * u dist = norm2 ( I - P0 ) if (( sI < 0. ) . or . ( sI > 1. )) then check = 3 else check = 1 end if end subroutine plane_line_intersection subroutine ibmnorm use modglobal , only : ih , jh , kh , ihc , jhc , khc , nsv , dzf , zh , kb , ke , kh , nsv , libm , ltempeq , lmoist , iadv_sv , iadv_cd2 , iadv_thl use modfields , only : um , vm , wm , thlm , qtm , svm , up , vp , wp , thlp , qtp , svp , thl0 , qt0 , sv0 , thl0av use modboundary , only : halos use decomp_2d , only : zstart , zend use modmpi , only : myid integer i , j , k , n , m if (. not . libm ) return ! Set internal velocities to zero call solid ( solid_info_u , um , up , 0. , ih , jh , kh ) call solid ( solid_info_v , vm , vp , 0. , ih , jh , kh ) call solid ( solid_info_w , wm , wp , 0. , ih , jh , kh ) ! Scalars ! Solid value does not matter when using second order scheme ! Set interior to a constant and boundary to average of fluid neighbours if ( ltempeq ) then call solid ( solid_info_c , thlm , thlp , sum ( thl0av ( kb : ke ) * dzf ( kb : ke )) / zh ( ke + 1 ), ih , jh , kh , mask_c ) if ( iadv_thl == iadv_cd2 ) call advecc2nd_corr_liberal ( thl0 , thlp ) end if if ( lmoist ) then call solid ( solid_info_c , qtm , qtp , 0. , ih , jh , kh , mask_c ) call advecc2nd_corr_liberal ( qt0 , qtp ) end if do n = 1 , nsv call solid ( solid_info_c , svm (:,:,:, n ), svp (:,:,:, n ), 0. , ihc , jhc , khc , mask_c ) if ( iadv_sv ( n ) == iadv_cd2 ) call advecc2nd_corr_liberal ( sv0 (:,:,:, n ), svp (:,:,:, n )) end do end subroutine ibmnorm subroutine solid ( solid_info , var , rhs , val , hi , hj , hk , mask ) use modglobal , only : ib , ie , jb , je , kb , ke , ih , jh , kh , eps1 use decomp_2d , only : zstart type ( solid_info_type ), intent ( in ) :: solid_info integer , intent ( in ) :: hi , hj , hk real , intent ( inout ) :: var ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) real , intent ( inout ) :: rhs ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ) real , intent ( in ) :: val real , intent ( in ), optional :: mask ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ) real :: count integer :: i , j , k , n , m if ( present ( mask ) . eqv . . false .) then do n = 1 , solid_info % nsolptsrank !n = solid_info%solptsrank(m) i = solid_info % solpts_loc ( n , 1 ) - zstart ( 1 ) + 1 j = solid_info % solpts_loc ( n , 2 ) - zstart ( 2 ) + 1 k = solid_info % solpts_loc ( n , 3 ) - zstart ( 3 ) + 1 var ( i , j , k ) = val rhs ( i , j , k ) = 0. end do else do n = 1 , solid_info % nsolptsrank !n = solid_info%solptsrank(m) i = solid_info % solpts_loc ( n , 1 ) - zstart ( 1 ) + 1 j = solid_info % solpts_loc ( n , 2 ) - zstart ( 2 ) + 1 k = solid_info % solpts_loc ( n , 3 ) - zstart ( 3 ) + 1 var ( i , j , k ) = val rhs ( i , j , k ) = 0. count = 0 ! Attempt to set zero flux BC if ( abs ( mask ( i , j + 1 , k ) - 1. ) < eps1 ) then ! fluid neighbour count = count + 1 var ( i , j , k ) = var ( i , j , k ) + var ( i , j + 1 , k ) rhs ( i , j , k ) = rhs ( i , j , k ) + rhs ( i , j + 1 , k ) end if if ( abs ( mask ( i , j - 1 , k ) - 1. ) < eps1 ) then count = count + 1 var ( i , j , k ) = var ( i , j , k ) + var ( i , j - 1 , k ) rhs ( i , j , k ) = rhs ( i , j , k ) + rhs ( i , j - 1 , k ) end if if ( abs ( mask ( i , j , k + 1 ) - 1. ) < eps1 ) then count = count + 1 var ( i , j , k ) = var ( i , j , k ) + var ( i , j , k + 1 ) rhs ( i , j , k ) = rhs ( i , j , k ) + rhs ( i , j , k + 1 ) end if if ( abs ( mask ( i , j , k - 1 ) - 1. ) < eps1 ) then count = count + 1 var ( i , j , k ) = var ( i , j , k ) + var ( i , j , k - 1 ) rhs ( i , j , k ) = rhs ( i , j , k ) + rhs ( i , j , k - 1 ) end if if ( abs ( mask ( i + 1 , j , k ) - 1. ) < eps1 ) then count = count + 1 var ( i , j , k ) = var ( i , j , k ) + var ( i + 1 , j , k ) rhs ( i , j , k ) = rhs ( i , j , k ) + rhs ( i + 1 , j , k ) end if if ( abs ( mask ( i - 1 , j , k ) - 1. ) < eps1 ) then count = count + 1 var ( i , j , k ) = var ( i , j , k ) + var ( i - 1 , j , k ) rhs ( i , j , k ) = rhs ( i , j , k ) + rhs ( i - 1 , j , k ) end if if ( count > 0 ) then var ( i , j , k ) = ( var ( i , j , k ) - val ) / count rhs ( i , j , k ) = rhs ( i , j , k ) / count end if end do end if end subroutine solid ! subroutine solid_boundary(bound_info, mask, var, rhs, hi, hj, hk) !   use modglobal, only : eps1, ib, ie, ih, jb, je, jh, kb, ke, kh !   use decomp_2d, only : zstart !   ! uDALES 1 approach !   ! Not truly conservative !   type(bound_info_type), intent(in) :: bound_info !   integer, intent(in) :: hi, hj, hk !   real, intent(in)    :: mask(ib-ih:ie+ih,jb-jh:je+jh,kb-kh:ke+kh) !   real, intent(inout) :: var(ib-hi:ie+hi,jb-hj:je+hj,kb-hk:ke+hk) !   real, intent(inout) :: rhs(ib-hi:ie+hi,jb-hj:je+hj,kb   :ke+hk) ! !   integer i, j, k, n, m ! !   do m = 1,bound_info%nbndptsrank !     n = bound_info%bndptsrank(m) !     i = bound_info%bndpts(n,1) - zstart(1) + 1 !     j = bound_info%bndpts(n,2) - zstart(2) + 1 !     k = bound_info%bndpts(n,3) - zstart(3) + 1 ! !     if (abs(mask(i,j+1,k)) < eps1) then !       ! rhs(i,j+1,k) = 0. !       rhs(i,j+1,k) = rhs(i,j,k) !       var(i,j+1,k) = var(i,j,k) !     end if ! !     if (abs(mask(i,j-1,k)) < eps1) then !       ! rhs(i,j-1,k) = 0. !       rhs(i,j-1,k) = rhs(i,j,k) !       var(i,j-1,k) = var(i,j,k) !     end if ! !     if (abs(mask(i,j,k+1)) < eps1) then !       ! rhs(i,j,k+1) = 0. !       rhs(i,j,k+1) = rhs(i,j,k) !       var(i,j,k+1) = var(i,j,k) !     end if ! !     if (abs(mask(i,j,k-1)) < eps1) then !       ! rhs(i,j,k-1) = 0. !       rhs(i,j,k-1) = rhs(i,j,k) !       var(i,j,k-1) = var(i,j,k) !     end if ! !     if (abs(mask(i+1,j,k)) < eps1) then !       ! rhs(i+1,j,k) = 0. !       rhs(i+1,j,k) = rhs(i,j,k) !       var(i+1,j,k) = var(i,j,k) !     end if ! !     if (abs(mask(i-1,j,k)) < eps1) then !       ! rhs(i-1,j,k) = 0. !       rhs(i-1,j,k) = rhs(i,j,k) !       var(i-1,j,k) = var(i,j,k) !     end if ! !   end do ! ! end subroutine subroutine advecc2nd_corr_conservative ( var , rhs ) ! Removes the advection contribution from solid velocities, which should be ! close to zero but are not necessarily due to pressure correction. ! Has a fairly drastic effect on the initial flow, but the scalar is ! conserved throughout the simulation. use modglobal , only : eps1 , ib , ie , ih , jb , je , jh , kb , ke , kh , & dx2i , dxi5 , dy2i , dyi5 , dzf , dzh2i , dzfi , dzhi , dzfi5 use modfields , only : u0 , v0 , w0 use modsubgriddata , only : ekh use decomp_2d , only : zstart real , intent ( in ) :: var ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ) real , intent ( inout ) :: rhs ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ) integer :: i , j , k , n , m do n = 1 , bound_info_c % nbndptsrank !n = bound_info_c%bndptsrank(m) i = bound_info_c % bndpts_loc ( n , 1 ) - zstart ( 1 ) + 1 j = bound_info_c % bndpts_loc ( n , 2 ) - zstart ( 2 ) + 1 k = bound_info_c % bndpts_loc ( n , 3 ) - zstart ( 3 ) + 1 if (( abs ( mask_u ( i + 1 , j , k )) < eps1 ) . or . ( abs ( mask_c ( i + 1 , j , k )) < eps1 )) then rhs ( i , j , k ) = rhs ( i , j , k ) + u0 ( i + 1 , j , k ) * ( var ( i + 1 , j , k ) + var ( i , j , k )) * dxi5 end if if (( abs ( mask_u ( i , j , k )) < eps1 ) . or . ( abs ( mask_c ( i - 1 , j , k )) < eps1 )) then rhs ( i , j , k ) = rhs ( i , j , k ) - u0 ( i , j , k ) * ( var ( i - 1 , j , k ) + var ( i , j , k )) * dxi5 end if if (( abs ( mask_v ( i , j + 1 , k )) < eps1 ) . or . ( abs ( mask_c ( i , j + 1 , k )) < eps1 )) then rhs ( i , j , k ) = rhs ( i , j , k ) + v0 ( i , j + 1 , k ) * ( var ( i , j + 1 , k ) + var ( i , j , k )) * dyi5 end if if (( abs ( mask_v ( i , j , k )) < eps1 ) . or . ( abs ( mask_c ( i , j - 1 , k )) < eps1 )) then rhs ( i , j , k ) = rhs ( i , j , k ) - v0 ( i , j , k ) * ( var ( i , j - 1 , k ) + var ( i , j , k )) * dyi5 end if if (( abs ( mask_w ( i , j , k + 1 )) < eps1 ) . or . ( abs ( mask_c ( i , j , k + 1 )) < eps1 )) then rhs ( i , j , k ) = rhs ( i , j , k ) + w0 ( i , j , k + 1 ) * ( var ( i , j , k + 1 ) * dzf ( k ) + var ( i , j , k ) * dzf ( k + 1 )) * dzhi ( k + 1 ) * dzfi5 ( k ) end if if (( abs ( mask_w ( i , j , k )) < eps1 ) . or . ( abs ( mask_c ( i , j , k - 1 )) < eps1 )) then rhs ( i , j , k ) = rhs ( i , j , k ) - w0 ( i , j , k ) * ( var ( i , j , k - 1 ) * dzf ( k ) + var ( i , j , k ) * dzf ( k - 1 )) * dzhi ( k ) * dzfi5 ( k ) end if end do end subroutine advecc2nd_corr_conservative subroutine advecc2nd_corr_liberal ( var , rhs ) ! Removes the advection contribution from solid scalar points as calculated ! by the 2nd order scheme, and replaces it with a contribution in which the ! value inside the solid is equal to the value outside, thereby modelling ! a zero (advective) flux condition. ! Due to potentially nonzero solid velocities due to the pressure correction, ! the IBM will not be conservative. use modglobal , only : eps1 , ib , ie , ih , jb , je , jh , kb , ke , kh , & dx2i , dxi5 , dy2i , dyi5 , dzf , dzh2i , dzfi , dzhi , dzfi5 use modfields , only : u0 , v0 , w0 use modsubgriddata , only : ekh use decomp_2d , only : zstart real , intent ( in ) :: var ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh ) real , intent ( inout ) :: rhs ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ) integer :: i , j , k , n , m do n = 1 , bound_info_c % nbndptsrank !n = bound_info_c%bndptsrank(m) i = bound_info_c % bndpts_loc ( n , 1 ) - zstart ( 1 ) + 1 j = bound_info_c % bndpts_loc ( n , 2 ) - zstart ( 2 ) + 1 k = bound_info_c % bndpts_loc ( n , 3 ) - zstart ( 3 ) + 1 if ( abs ( mask_c ( i + 1 , j , k )) < eps1 ) then ! var(i+1) is solid rhs ( i , j , k ) = rhs ( i , j , k ) + u0 ( i + 1 , j , k ) * ( var ( i + 1 , j , k ) + var ( i , j , k )) * dxi5 & ! negate contribution added in advection using var(i+1) - u0 ( i + 1 , j , k ) * ( var ( i , j , k ) + var ( i , j , k )) * dxi5 ! add corresponding contribution with var(i+1) = var(i) end if if ( abs ( mask_c ( i - 1 , j , k )) < eps1 ) then ! var(i-1) is solid rhs ( i , j , k ) = rhs ( i , j , k ) - u0 ( i , j , k ) * ( var ( i - 1 , j , k ) + var ( i , j , k )) * dxi5 & ! negate contribution added in advection using var(i-1) + u0 ( i , j , k ) * ( var ( i , j , k ) + var ( i , j , k )) * dxi5 ! add corresponding contribution with var(i-1) = var(i) end if if ( abs ( mask_c ( i , j + 1 , k )) < eps1 ) then ! var(j+1) is solid rhs ( i , j , k ) = rhs ( i , j , k ) + v0 ( i , j + 1 , k ) * ( var ( i , j + 1 , k ) + var ( i , j , k )) * dyi5 & ! negate contribution added in advection using var(j+1) - v0 ( i , j + 1 , k ) * ( var ( i , j , k ) + var ( i , j , k )) * dyi5 ! add corresponding contribution with var(j+1) = var(j) end if if ( abs ( mask_c ( i , j - 1 , k )) < eps1 ) then ! var(j-1) is solid rhs ( i , j , k ) = rhs ( i , j , k ) - v0 ( i , j , k ) * ( var ( i , j - 1 , k ) + var ( i , j , k )) * dyi5 & ! negate contribution added in advection using var(j-1) + v0 ( i , j , k ) * ( var ( i , j , k ) + var ( i , j , k )) * dyi5 ! add corresponding contribution with var(j-1) = var(j) end if if ( abs ( mask_c ( i , j , k + 1 )) < eps1 ) then ! var(k+1) is solid rhs ( i , j , k ) = rhs ( i , j , k ) + w0 ( i , j , k + 1 ) * ( var ( i , j , k + 1 ) * dzf ( k ) + var ( i , j , k ) * dzf ( k + 1 )) * dzhi ( k + 1 ) * dzfi5 ( k ) & ! negate contribution added in advection using var(k+1) - w0 ( i , j , k + 1 ) * ( var ( i , j , k ) * dzf ( k ) + var ( i , j , k ) * dzf ( k + 1 )) * dzhi ( k + 1 ) * dzfi5 ( k ) ! add corresponding contribution with var(k+1) = var(k) end if if ( abs ( mask_c ( i , j , k - 1 )) < eps1 ) then ! var(k-1) is solid rhs ( i , j , k ) = rhs ( i , j , k ) - w0 ( i , j , k ) * ( var ( i , j , k - 1 ) * dzf ( k ) + var ( i , j , k ) * dzf ( k - 1 )) * dzhi ( k ) * dzfi5 ( k ) & ! negate contribution added in advection using var(k-1) + w0 ( i , j , k ) * ( var ( i , j , k ) * dzf ( k ) + var ( i , j , k ) * dzf ( k - 1 )) * dzhi ( k ) * dzfi5 ( k ) ! add corresponding contribution with var(k-1) = var(k) end if end do end subroutine advecc2nd_corr_liberal subroutine diffu_corr ! Negate subgrid rhs contributions from solid points (added by diffu in modsubgrid) use modglobal , only : eps1 , ib , ie , ih , jb , je , jh , kb , ke , kh , & dx2i , dxi5 , dy2i , dyi5 , dzf , dzh2i , dzfi , dzhi , dzfi5 , dzhiq use modfields , only : u0 , up use modsubgriddata , only : ekm use decomp_2d , only : zstart real :: empo , emmo , emop , emom integer :: i , j , k , n , m do n = 1 , bound_info_u % nbndptsrank !n = bound_info_u%bndptsrank(m) i = bound_info_u % bndpts_loc ( n , 1 ) - zstart ( 1 ) + 1 j = bound_info_u % bndpts_loc ( n , 2 ) - zstart ( 2 ) + 1 k = bound_info_u % bndpts_loc ( n , 3 ) - zstart ( 3 ) + 1 if ( abs ( mask_u ( i , j + 1 , k )) < eps1 ) then empo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , j + 1 , k )) + ( ekm ( i - 1 , j , k ) + ekm ( i - 1 , j + 1 , k ))) up ( i , j , k ) = up ( i , j , k ) - empo * ( u0 ( i , j + 1 , k ) - u0 ( i , j , k )) * dy2i end if if ( abs ( mask_u ( i , j - 1 , k )) < eps1 ) then emmo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , j - 1 , k )) + ( ekm ( i - 1 , j - 1 , k ) + ekm ( i - 1 , j , k ))) up ( i , j , k ) = up ( i , j , k ) + emmo * ( u0 ( i , j , k ) - u0 ( i , j - 1 , k )) * dy2i end if if ( abs ( mask_u ( i , j , k + 1 )) < eps1 ) then emop = ( dzf ( k + 1 ) * ( ekm ( i , j , k ) + ekm ( i - 1 , j , k )) + & dzf ( k ) * ( ekm ( i , j , k + 1 ) + ekm ( i - 1 , j , k + 1 ))) * dzhiq ( k + 1 ) up ( i , j , k ) = up ( i , j , k ) - emop * ( u0 ( i , j , k + 1 ) - u0 ( i , j , k )) * dzhi ( k + 1 ) * dzfi ( k ) end if if ( abs ( mask_u ( i , j , k - 1 )) < eps1 ) then emom = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) + ekm ( i - 1 , j , k )) + & dzf ( k ) * ( ekm ( i , j , k - 1 ) + ekm ( i - 1 , j , k - 1 ))) * dzhiq ( k ) up ( i , j , k ) = up ( i , j , k ) + emom * ( u0 ( i , j , k ) - u0 ( i , j , k - 1 )) * dzhi ( k ) * dzfi ( k ) end if end do end subroutine diffu_corr subroutine diffv_corr ! Negate subgrid rhs contributions from solid points (added by diffv in modsubgrid) use modglobal , only : eps1 , ib , ie , ih , jb , je , jh , kb , ke , kh , & dx2i , dxi5 , dy2i , dyi5 , dzf , dzh2i , dzfi , dzhi , dzfi5 , dzhiq use modfields , only : v0 , vp use modsubgriddata , only : ekm use decomp_2d , only : zstart real :: epmo , emmo , eomp , eomm integer :: i , j , k , n , m do n = 1 , bound_info_v % nbndptsrank !n = bound_info_v%bndptsrank(m) i = bound_info_v % bndpts_loc ( n , 1 ) - zstart ( 1 ) + 1 j = bound_info_v % bndpts_loc ( n , 2 ) - zstart ( 2 ) + 1 k = bound_info_v % bndpts_loc ( n , 3 ) - zstart ( 3 ) + 1 if ( abs ( mask_v ( i + 1 , j , k )) < eps1 ) then epmo = 0.25 * ( ekm ( i , j , k ) + ekm ( i , j - 1 , k ) + ekm ( i + 1 , j - 1 , k ) + ekm ( i + 1 , j , k )) vp ( i , j , k ) = vp ( i , j , k ) - epmo * ( v0 ( i + 1 , j , k ) - v0 ( i , j , k )) * dx2i end if if ( abs ( mask_v ( i - 1 , j , k )) < eps1 ) then emmo = 0.25 * ( ekm ( i , j , k ) + ekm ( i , j - 1 , k ) + ekm ( i - 1 , j - 1 , k ) + ekm ( i - 1 , j , k )) vp ( i , j , k ) = vp ( i , j , k ) + emmo * ( v0 ( i , j , k ) - v0 ( i - 1 , j , k )) * dx2i end if if ( abs ( mask_v ( i , j , k + 1 )) < eps1 ) then eomp = ( dzf ( k + 1 ) * ( ekm ( i , j , k ) + ekm ( i , j - 1 , k ) ) + & dzf ( k ) * ( ekm ( i , j , k + 1 ) + ekm ( i , j - 1 , k + 1 ))) * dzhiq ( k + 1 ) vp ( i , j , k ) = vp ( i , j , k ) - eomp * ( v0 ( i , j , k + 1 ) - v0 ( i , j , k )) * dzhi ( k + 1 ) * dzfi ( k ) end if if ( abs ( mask_v ( i , j , k - 1 )) < eps1 ) then eomm = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) + ekm ( i , j - 1 , k ) ) + & dzf ( k ) * ( ekm ( i , j , k - 1 ) + ekm ( i , j - 1 , k - 1 ))) * dzhiq ( k ) vp ( i , j , k ) = vp ( i , j , k ) + eomm * ( v0 ( i , j , k ) - v0 ( i , j , k - 1 )) * dzhi ( k ) * dzfi ( k ) end if end do end subroutine diffv_corr subroutine diffw_corr ! Negate subgrid rhs contributions from solid points (added by diffw in modsubgrid) use modglobal , only : eps1 , ib , ie , ih , jb , je , jh , kb , ke , kh , & dx2i , dxi5 , dy2i , dyi5 , dzf , dzh2i , dzfi , dzhi , dzfi5 , dzhiq use modfields , only : w0 , wp use modsubgriddata , only : ekm use decomp_2d , only : zstart real :: epom , emom , eopm , eomm integer :: i , j , k , n , m do n = 1 , bound_info_w % nbndptsrank !n = bound_info_w%bndptsrank(m) i = bound_info_w % bndpts_loc ( n , 1 ) - zstart ( 1 ) + 1 j = bound_info_w % bndpts_loc ( n , 2 ) - zstart ( 2 ) + 1 k = bound_info_w % bndpts_loc ( n , 3 ) - zstart ( 3 ) + 1 ! Account for solid w points if ( abs ( mask_w ( i + 1 , j , k )) < eps1 ) then epom = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) + ekm ( i + 1 , j , k )) + & dzf ( k ) * ( ekm ( i , j , k - 1 ) + ekm ( i + 1 , j , k - 1 ))) * dzhiq ( k ) wp ( i , j , k ) = wp ( i , j , k ) - epom * ( w0 ( i + 1 , j , k ) - w0 ( i , j , k )) * dx2i end if if ( abs ( mask_w ( i - 1 , j , k )) < eps1 ) then emom = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) + ekm ( i - 1 , j , k )) + & dzf ( k ) * ( ekm ( i , j , k - 1 ) + ekm ( i - 1 , j , k - 1 ))) * dzhiq ( k ) wp ( i , j , k ) = wp ( i , j , k ) + emom * ( w0 ( i , j , k ) - w0 ( i - 1 , j , k )) * dx2i end if if ( abs ( mask_w ( i , j + 1 , k )) < eps1 ) then eopm = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) + ekm ( i , j + 1 , k )) + & dzf ( k ) * ( ekm ( i , j , k - 1 ) + ekm ( i , j + 1 , k - 1 ))) * dzhiq ( k ) wp ( i , j , k ) = wp ( i , j , k ) - eopm * ( w0 ( i , j + 1 , k ) - w0 ( i , j , k )) * dy2i end if if ( abs ( mask_w ( i , j - 1 , k )) < eps1 ) then eomm = ( dzf ( k - 1 ) * ( ekm ( i , j , k ) + ekm ( i , j - 1 , k )) + & dzf ( k ) * ( ekm ( i , j , k - 1 ) + ekm ( i , j - 1 , k - 1 ))) * dzhiq ( k ) wp ( i , j , k ) = wp ( i , j , k ) + eomm * ( w0 ( i , j , k ) - w0 ( i , j - 1 , k )) * dy2i end if end do end subroutine diffw_corr subroutine diffc_corr ( var , rhs , hi , hj , hk ) ! Negate subgrid rhs contributions from solid points (added by diffc in modsubgrid) use modglobal , only : eps1 , ib , ie , jb , je , kb , ke , kh , & dx2i , dxi5 , dy2i , dyi5 , dzf , dzh2i , dzfi , dzhi , dzfi5 use modsubgriddata , only : ekh use decomp_2d , only : zstart integer , intent ( in ) :: hi , hj , hk real , intent ( in ) :: var ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) real , intent ( inout ) :: rhs ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ) integer :: i , j , k , n , m do n = 1 , bound_info_c % nbndptsrank !n = bound_info_c%bndptsrank(m) i = bound_info_c % bndpts_loc ( n , 1 ) - zstart ( 1 ) + 1 j = bound_info_c % bndpts_loc ( n , 2 ) - zstart ( 2 ) + 1 k = bound_info_c % bndpts_loc ( n , 3 ) - zstart ( 3 ) + 1 if ( abs ( mask_c ( i + 1 , j , k )) < eps1 ) then rhs ( i , j , k ) = rhs ( i , j , k ) - 0.5 * ( ekh ( i + 1 , j , k ) + ekh ( i , j , k )) * ( var ( i + 1 , j , k ) - var ( i , j , k )) * dx2i end if if ( abs ( mask_c ( i - 1 , j , k )) < eps1 ) then rhs ( i , j , k ) = rhs ( i , j , k ) + 0.5 * ( ekh ( i , j , k ) + ekh ( i - 1 , j , k )) * ( var ( i , j , k ) - var ( i - 1 , j , k )) * dx2i end if if ( abs ( mask_c ( i , j + 1 , k )) < eps1 ) then rhs ( i , j , k ) = rhs ( i , j , k ) - 0.5 * ( ekh ( i , j + 1 , k ) + ekh ( i , j , k )) * ( var ( i , j + 1 , k ) - var ( i , j , k )) * dy2i end if if ( abs ( mask_c ( i , j - 1 , k )) < eps1 ) then rhs ( i , j , k ) = rhs ( i , j , k ) + 0.5 * ( ekh ( i , j , k ) + ekh ( i , j - 1 , k )) * ( var ( i , j , k ) - var ( i , j - 1 , k )) * dy2i end if if ( abs ( mask_c ( i , j , k + 1 )) < eps1 ) then rhs ( i , j , k ) = rhs ( i , j , k ) - 0.5 * ( dzf ( k + 1 ) * ekh ( i , j , k ) + dzf ( k ) * ekh ( i , j , k + 1 )) & * ( var ( i , j , k + 1 ) - var ( i , j , k )) * dzh2i ( k + 1 ) * dzfi ( k ) end if if ( abs ( mask_c ( i , j , k - 1 )) < eps1 ) then rhs ( i , j , k ) = rhs ( i , j , k ) + 0.5 * ( dzf ( k - 1 ) * ekh ( i , j , k ) + dzf ( k ) * ekh ( i , j , k - 1 )) & * ( var ( i , j , k ) - var ( i , j , k - 1 )) * dzh2i ( k ) * dzfi ( k ) end if end do end subroutine diffc_corr subroutine ibmwallfun use modglobal , only : libm , iwallmom , iwalltemp , xhat , yhat , zhat , ltempeq , lmoist , & ib , ie , ih , ihc , jb , je , jh , jhc , kb , ke , kh , khc , nsv , totheatflux , totqflux , nfcts , rk3step , timee , nfcts , lwritefac , dt , dtfac , tfac , tnextfac use modfields , only : u0 , v0 , w0 , thl0 , qt0 , sv0 , up , vp , wp , thlp , qtp , svp , & tau_x , tau_y , tau_z , thl_flux use modsubgriddata , only : ekm , ekh use modmpi , only : myid , comm3d , MPI_SUM , mpierr , MY_REAL use modstat_nc , only : writestat_nc , writestat_1D_nc , writestat_2D_nc real , allocatable :: rhs (:,:,:) integer n real :: thl_flux_sum , thl_flux_tot , mom_flux_sum , mom_flux_tot logical thl_flux_file_exists , mom_flux_file_exists if (. not . libm ) return allocate ( rhs ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) if ( iwallmom > 1 ) then rhs = up call wallfunmom ( xhat , up , bound_info_u ) tau_x (:,:, kb : ke + kh ) = tau_x (:,:, kb : ke + kh ) + ( up - rhs ) rhs = vp call wallfunmom ( yhat , vp , bound_info_v ) tau_y (:,:, kb : ke + kh ) = tau_y (:,:, kb : ke + kh ) + ( vp - rhs ) rhs = wp call wallfunmom ( zhat , wp , bound_info_w ) tau_z (:,:, kb : ke + kh ) = tau_z (:,:, kb : ke + kh ) + ( wp - rhs ) ! mom_flux_sum = sum(tau_x(ib:ie,jb:je,kb+1:ke) + tau_y(ib:ie,jb:je,kb+1:ke) + tau_z(ib:ie,jb:je,kb+1:ke)) ! call MPI_ALLREDUCE(mom_flux_sum, mom_flux_tot, 1, MY_REAL, MPI_SUM, comm3d, mpierr) ! if (myid == 0) then !    if (rk3step == 3) then !         inquire(file=\"mom_flux.txt\", exist=mom_flux_file_exists) !         if (mom_flux_file_exists) then !           open(12, file=\"mom_flux.txt\", status=\"old\", position=\"append\", action=\"write\") !         else !           open(12, file=\"mom_flux.txt\", status=\"new\", action=\"write\") !         end if !         write(12, *) timee, -mom_flux_tot !         close(12) !    end if ! end if end if call diffu_corr call diffv_corr call diffw_corr if ( ltempeq . or . lmoist . or . lwritefac ) then rhs = thlp totheatflux = 0 ! Reset total heat flux to zero so we only account for that in this step. totqflux = 0 call wallfunheat thl_flux (:,:, kb : ke + kh ) = thl_flux (:,:, kb : ke + kh ) + ( thlp - rhs ) if ( ltempeq ) call diffc_corr ( thl0 , thlp , ih , jh , kh ) if ( lmoist ) call diffc_corr ( qt0 , qtp , ih , jh , kh ) ! thl_flux_sum = sum(thl_flux(ib:ie,jb:je,kb+1:ke)) ! call MPI_ALLREDUCE(thl_flux_sum, thl_flux_tot, 1, MY_REAL, MPI_SUM, comm3d, mpierr) ! if (myid == 0) then !    if (rk3step == 3) then !         inquire(file=\"thl_flux.txt\", exist=thl_flux_file_exists) !         if (thl_flux_file_exists) then !           open(12, file=\"thl_flux.txt\", status=\"old\", position=\"append\", action=\"write\") !         else !           open(12, file=\"thl_flux.txt\", status=\"new\", action=\"write\") !         end if !         write(12, *) timee, thl_flux_tot !         close(12) !    end if ! end if end if do n = 1 , nsv call diffc_corr ( sv0 (:,:,:, n ), svp (:,:,:, n ), ihc , jhc , khc ) end do deallocate ( rhs ) if ( lwritefac . and . rk3step == 3 ) then if ( myid == 0 ) then fac_tau_x_av = fac_tau_x_av + dt * fac_tau_x fac_tau_y_av = fac_tau_y_av + dt * fac_tau_y fac_tau_z_av = fac_tau_z_av + dt * fac_tau_z fac_pres_av = fac_pres_av + dt * fac_pres fac_pres2_av = fac_pres2_av + dt * fac_pres2 fac_htc_av = fac_htc_av + dt * fac_htc fac_cth_av = fac_cth_av + dt * fac_cth if ( timee >= tnextfac ) then tfac = timee - tfac allocate ( varsfac ( nfcts , nstatfac )) varsfac (:, 1 ) = fac_tau_x_av ( 1 : nfcts ) / tfac varsfac (:, 2 ) = fac_tau_y_av ( 1 : nfcts ) / tfac varsfac (:, 3 ) = fac_tau_z_av ( 1 : nfcts ) / tfac varsfac (:, 4 ) = fac_pres_av ( 1 : nfcts ) / tfac varsfac (:, 5 ) = fac_htc_av ( 1 : nfcts ) / tfac varsfac (:, 6 ) = fac_cth_av ( 1 : nfcts ) / tfac varsfac (:, 7 ) = fac_pres2_av ( 1 : nfcts ) / tfac - ( fac_pres_av ( 1 : nfcts ) / dtfac * fac_pres_av ( 1 : nfcts ) / tfac ) call writestat_nc ( ncidfac , 1 , tncstatfac ,( / timee / ), nrecfac ,. true .) call writestat_1D_nc ( ncidfac , nstatfac , ncstatfac , varsfac , nrecfac , nfcts ) deallocate ( varsfac ) tfac = timee tnextfac = NINT (( timee + dtfac )) * 1.0 fac_tau_x_av = 0. fac_tau_y_av = 0. fac_tau_z_av = 0. fac_pres_av = 0. fac_pres2_av = 0. fac_htc_av = 0. fac_cth_av = 0. end if end if !myid end if end subroutine ibmwallfun subroutine wallfunmom ( dir , rhs , bound_info ) use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , xf , yf , zf , xh , yh , zh , & eps1 , fkar , dx , dy , dzf , iwallmom , xhat , yhat , zhat , vec0 , nfcts , lwritefac , rk3step use modfields , only : u0 , v0 , w0 , thl0 , tau_x , tau_y , tau_z use initfac , only : facT , facz0 , facz0h , facnorm , faca use decomp_2d , only : zstart use modmpi , only : comm3d , mpi_sum , mpierr , my_real real , intent ( in ) :: dir ( 3 ) real , intent ( inout ) :: rhs ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ) type ( bound_info_type ) :: bound_info integer i , j , k , n , m , sec , pt , fac real dist , stress , stress_dir , stress_aligned , area , vol , momvol , Tair , Tsurf , x , y , z , & utan , udir , ctm , a , a_is , a_xn , a_yn , a_zn , stress_ix , stress_iy , stress_iz , xrec , yrec , zrec real , dimension ( 3 ) :: uvec , norm , strm , span , stressvec logical :: valid real , dimension ( 1 : nfcts ) :: fac_tau_loc , fac_tau !real, dimension(:), allocatable :: fac_tau, fac_pres procedure ( interp_velocity ), pointer :: interp_velocity_ptr => null () procedure ( interp_temperature ), pointer :: interp_temperature_ptr => null () select case ( alignment ( dir )) case ( 1 ) interp_velocity_ptr => interp_velocity_u interp_temperature_ptr => interp_temperature_u case ( 2 ) interp_velocity_ptr => interp_velocity_v interp_temperature_ptr => interp_temperature_v case ( 3 ) interp_velocity_ptr => interp_velocity_w interp_temperature_ptr => interp_temperature_w end select fac_tau_loc = 0. do sec = 1 , bound_info % nfctsecsrank !sec = bound_info%fctsecsrank(m) ! index of section !n = bound_info%secbndptids(sec) ! index of boundary point area = bound_info % secareas_loc ( sec ) ! area of section fac = bound_info % secfacids_loc ( sec ) ! index of facet norm = facnorm ( fac ,:) ! facet normal if ( bound_info % lskipsec_loc ( sec )) cycle !if (facz0(fac) < eps1) cycle ! i = bound_info%bndpts(n,1) - zstart(1) + 1 ! j = bound_info%bndpts(n,2) - zstart(2) + 1 ! k = bound_info%bndpts(n,3) - zstart(3) + 1 i = bound_info % secbndpts_loc ( sec , 1 ) - zstart ( 1 ) + 1 ! should be on this rank! j = bound_info % secbndpts_loc ( sec , 2 ) - zstart ( 2 ) + 1 ! should be on this rank! k = bound_info % secbndpts_loc ( sec , 3 ) - zstart ( 3 ) + 1 ! should be on this rank! if (( i < ib ) . or . ( i > ie ) . or . ( j < jb ) . or . ( j > je )) then write ( * , * ) \"problem in wallfunmom\" , alignment ( dir ), bound_info % secbndpts_loc ( sec , 1 ), bound_info % secbndpts_loc ( sec , 2 ) stop 1 end if if ( bound_info % lcomprec_loc ( sec ) . or . lnorec ) then uvec = interp_velocity_ptr ( i , j , k ) if ( iwallmom == 2 ) then Tair = interp_temperature_ptr ( i , j , k ) end if dist = bound_info % bnddst_loc ( sec ) else xrec = bound_info % recpts_loc ( sec , 1 ) yrec = bound_info % recpts_loc ( sec , 2 ) zrec = bound_info % recpts_loc ( sec , 3 ) uvec ( 1 ) = trilinear_interp_var ( u0 , bound_info % recids_u_loc ( sec ,:), xh , yf , zf , xrec , yrec , zrec ) uvec ( 2 ) = trilinear_interp_var ( v0 , bound_info % recids_v_loc ( sec ,:), xf , yh , zf , xrec , yrec , zrec ) uvec ( 3 ) = trilinear_interp_var ( w0 , bound_info % recids_w_loc ( sec ,:), xf , yf , zh , xrec , yrec , zrec ) if ( iwallmom == 2 ) Tair = trilinear_interp_var ( thl0 , bound_info % recids_c_loc ( sec ,:), xf , yf , zf , xrec , yrec , zrec ) dist = bound_info % bnddst_loc ( sec ) + norm2 (( / xrec - xf ( bound_info % secbndpts_loc ( sec , 1 )), & yrec - yf ( bound_info % secbndpts_loc ( sec , 2 )), & zrec - zf ( bound_info % secbndpts_loc ( sec , 3 )) / )) end if if ( log ( dist / facz0 ( fac )) <= 1. ) then cycle ! ideally would set a value for dist that gives a resonable (large) flux !dist = facz0(fac)+facz0h(fac) end if if ( is_equal ( uvec , vec0 )) cycle call local_coords ( uvec , norm , span , strm , valid ) if (. not . valid ) cycle utan = dot_product ( uvec , strm ) !utan = max(0.01, utan) ! uDALES 1 ! calcualate momentum transfer coefficient ! make into interface somehow? because iwallmom doesn't change in the loop if ( iwallmom == 2 ) then ! stability included ctm = mom_transfer_coef_stability ( utan , dist , facz0 ( fac ), facz0h ( fac ), Tair , facT ( fac , 1 )) else if ( iwallmom == 3 ) then ! neutral ctm = mom_transfer_coef_neutral ( dist , facz0 ( fac )) end if stress = ctm * utan ** 2 if ( bound_info % lcomprec_loc ( sec )) then a = dot_product ( dir , strm ) stress_dir = a * stress else ! Rotation from local (strm,span,norm) to global (xhat,yhat,zhat) basis ! \\tau'_ij = a_ip a_jq \\tau_pq ! \\tau_pq in local coordinates is something like \\tau \\delta_13, because we only have \\tau_{strm,norm}) a_is = dot_product ( dir , strm ) a_xn = dot_product ( xhat , norm ) a_yn = dot_product ( yhat , norm ) a_zn = dot_product ( zhat , norm ) stress_ix = a_is * a_xn * stress stress_iy = a_is * a_yn * stress stress_iz = a_is * a_zn * stress stressvec ( 1 ) = stress_ix stressvec ( 2 ) = stress_iy stressvec ( 3 ) = stress_iz stress_dir = norm2 ( stressvec ) end if stress_dir = sign ( stress_dir , dot_product ( uvec , dir )) vol = dx * dy * dzf ( k ) momvol = stress_dir * area / vol rhs ( i , j , k ) = rhs ( i , j , k ) - momvol fac_tau_loc ( fac ) = fac_tau_loc ( fac ) + stress_dir * area ! output stresses on facets end do if ( lwritefac . and . rk3step == 3 ) then fac_tau_loc ( 1 : nfcts ) = fac_tau_loc ( 1 : nfcts ) / faca ( 1 : nfcts ) call MPI_ALLREDUCE ( fac_tau_loc ( 1 : nfcts ), fac_tau ( 1 : nfcts ), nfcts , MY_REAL , MPI_SUM , comm3d , mpierr ) select case ( alignment ( dir )) case ( 1 ) fac_tau_x = fac_tau case ( 2 ) fac_tau_y = fac_tau case ( 3 ) fac_tau_z = fac_tau end select end if ! Do time-averaging like in modEB end subroutine wallfunmom subroutine wallfunheat use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , xf , yf , zf , xh , yh , zh , dx , dy , dzh , eps1 , & xhat , yhat , zhat , vec0 , fkar , ltempeq , lmoist , iwalltemp , iwallmoist , lEB , lwritefac , nfcts , rk3step , totheatflux , totqflux use modfields , only : u0 , v0 , w0 , thl0 , thlp , qt0 , qtp , pres0 use initfac , only : facT , facz0 , facz0h , facnorm , fachf , facef , facqsat , fachurel , facf , faclGR , faca use modmpi , only : comm3d , mpi_sum , mpierr , my_real use modsurfdata , only : z0 , z0h use modibmdata , only : bctfxm , bctfxp , bctfym , bctfyp , bctfz use decomp_2d , only : zstart integer i , j , k , n , m , sec , fac real :: dist , flux , area , vol , tempvol , Tair , Tsurf , utan , cth , htc , cveg , hurel , qtair , qwall , resa , resc , ress , xrec , yrec , zrec real , dimension ( 3 ) :: uvec , norm , span , strm real , dimension ( 1 : nfcts ) :: fac_htc_loc , fac_cth_loc , fac_pres_loc , fac_pres2_loc logical :: valid fac_htc_loc = 0. fac_cth_loc = 0. fac_pres_loc = 0. fac_pres2_loc = 0. do sec = 1 , bound_info_c % nfctsecsrank ! sec = bound_info_c%fctsecsrank(m) ! index of section !n =   bound_info_c%secbndptids(sec) ! index of boundary point fac = bound_info_c % secfacids_loc ( sec ) ! index of facet area = bound_info_c % secareas_loc ( sec ) ! area norm = facnorm ( fac ,:) ! i = bound_info_c%bndpts(n,1) - zstart(1) + 1 ! should be on this rank! ! j = bound_info_c%bndpts(n,2) - zstart(2) + 1 ! should be on this rank! ! k = bound_info_c%bndpts(n,3) - zstart(3) + 1 ! should be on this rank! i = bound_info_c % secbndpts_loc ( sec , 1 ) - zstart ( 1 ) + 1 ! should be on this rank! j = bound_info_c % secbndpts_loc ( sec , 2 ) - zstart ( 2 ) + 1 ! should be on this rank! k = bound_info_c % secbndpts_loc ( sec , 3 ) - zstart ( 3 ) + 1 ! should be on this rank! if (( i < ib ) . or . ( i > ie ) . or . ( j < jb ) . or . ( j > je )) then write ( * , * ) \"problem in wallfunheat\" , i , j stop 1 end if fac_pres_loc ( fac ) = fac_pres_loc ( fac ) + pres0 ( i , j , k ) * area ! output pressure on facets fac_pres2_loc ( fac ) = fac_pres2_loc ( fac ) + pres0 ( i , j , k ) * pres0 ( i , j , k ) * area if ( bound_info_c % lskipsec_loc ( sec )) cycle !if (facz0(fac) < eps1) cycle if ( bound_info_c % lcomprec_loc ( sec ) . or . lnorec ) then ! section aligned with grid - use this cell's velocity uvec = interp_velocity_c ( i , j , k ) Tair = thl0 ( i , j , k ) qtair = qt0 ( i , j , k ) dist = bound_info_c % bnddst_loc ( sec ) else ! use velocity at reconstruction point xrec = bound_info_c % recpts_loc ( sec , 1 ) yrec = bound_info_c % recpts_loc ( sec , 2 ) zrec = bound_info_c % recpts_loc ( sec , 3 ) uvec ( 1 ) = trilinear_interp_var ( u0 , bound_info_c % recids_u_loc ( sec ,:), xh , yf , zf , xrec , yrec , zrec ) uvec ( 2 ) = trilinear_interp_var ( v0 , bound_info_c % recids_v_loc ( sec ,:), xf , yh , zf , xrec , yrec , zrec ) uvec ( 3 ) = trilinear_interp_var ( w0 , bound_info_c % recids_w_loc ( sec ,:), xf , yf , zh , xrec , yrec , zrec ) Tair = trilinear_interp_var ( thl0 , bound_info_c % recids_c_loc ( sec ,:), xf , yf , zf , xrec , yrec , zrec ) qtair = trilinear_interp_var ( qt0 , bound_info_c % recids_c_loc ( sec ,:), xf , yf , zf , xrec , yrec , zrec ) ! dist = bound_info_c%bnddst(sec) + norm2((/xrec - xf(bound_info_c%bndpts(n,1)), & !                                           yrec - yf(bound_info_c%bndpts(n,2)), & !                                           zrec - zf(bound_info_c%bndpts(n,3))/)) dist = bound_info_c % bnddst_loc ( sec ) + norm2 (( / xrec - xf ( bound_info_c % secbndpts_loc ( sec , 1 )), & yrec - yf ( bound_info_c % secbndpts_loc ( sec , 2 )), & zrec - zf ( bound_info_c % secbndpts_loc ( sec , 3 )) / )) end if if ( log ( dist / facz0 ( fac )) <= 1. ) then cycle !dist = facz0(fac)+facz0h(fac) end if if ( is_equal ( uvec , vec0 )) cycle call local_coords ( uvec , norm , span , strm , valid ) if (. not . valid ) cycle utan = dot_product ( uvec , strm ) !utan = max(0.01, utan) ! uDALES 1 ! Sensible heat if ( ltempeq ) then if ( iwalltemp == 1 ) then ! probably remove this eventually, only relevant to grid-aligned facets !if     (all(abs(norm - xhat) < eps1)) then if ( is_equal ( norm , xhat )) then flux = bctfxp !elseif (all(abs(norm + xhat) < eps1)) then elseif ( is_equal ( norm , - xhat )) then flux = bctfxm !elseif (all(abs(norm - yhat) < eps1)) then elseif ( is_equal ( norm , yhat )) then flux = bctfyp !elseif (all(abs(norm + yhat) < eps1)) then elseif ( is_equal ( norm , - yhat )) then flux = bctfxm !elseif (all(abs(norm - zhat) < eps1)) then elseif ( is_equal ( norm , zhat )) then flux = bctfz end if elseif ( iwalltemp == 2 ) then call heat_transfer_coef_flux ( utan , dist , facz0 ( fac ), facz0h ( fac ), Tair , facT ( fac , 1 ), cth , flux , htc ) fac_cth_loc ( fac ) = fac_cth_loc ( fac ) + cth * area ! output heat transfer coefficients on facets fac_htc_loc ( fac ) = fac_htc_loc ( fac ) + htc * area ! output heat transfer coefficients on facets end if ! flux [Km/s] ! fluid volumetric sensible heat source/sink = flux * area / volume [K/s] ! facet sensible heat flux = volumetric heat capacity of air * flux * sectionarea / facetarea [W/m&#94;2] thlp ( i , j , k ) = thlp ( i , j , k ) - flux * area / ( dx * dy * dzh ( k )) if ( lEB ) then totheatflux = totheatflux + flux * area ! [Km&#94;3s&#94;-1] This sums the flux over all facets fachf ( fac ) = fachf ( fac ) + flux * area ! [Km&#94;2/s] (will be divided by facetarea(fac) in modEB) end if end if ! Latent heat if ( lmoist . and . faclGR ( fac )) then if ( iwallmoist == 1 ) then ! probably remove this eventually, only relevant to grid-aligned facets if ( is_equal ( norm , xhat )) then flux = bcqfxp elseif ( is_equal ( norm , - xhat )) then flux = bcqfxm elseif ( is_equal ( norm , yhat )) then flux = bcqfyp elseif ( is_equal ( norm , - yhat )) then flux = bcqfym elseif ( is_equal ( norm , zhat )) then flux = bcqfz end if elseif ( iwallmoist == 2 ) then if ( abs ( htc * abs ( utan )) > 0. ) then qwall = facqsat ( fac ) ! saturation humidity hurel = fachurel ( fac ) ! relative humidity resa = 1. / ( htc * abs ( utan )) ! aerodynamic resistance resc = facf ( fac , 4 ) ! canopy resistance ress = facf ( fac , 5 ) ! soil resistance cveg = 0.8 ! vegetation fraction flux = moist_flux ( cveg , resa , qtair , qwall , hurel , resc , ress ) end if end if ! flux [kg/kg m/s] ! fluid volumetric latent heat source/sink = flux * area / volume [kg/kg / s] ! facet latent heat flux = volumetric heat capacity of air * flux * sectionarea / facetarea [W/m&#94;2] totqflux = totqflux + flux * area ! [Km&#94;3s&#94;-1] This sums the flux over all facets qtp ( i , j , k ) = qtp ( i , j , k ) - flux * area / ( dx * dy * dzh ( k )) if ( lEB ) then facef ( fac ) = facef ( fac ) + flux * area ! [Km&#94;2/s] (will be divided by facetarea(fac) in modEB) end if end if end do if ( lwritefac . and . rk3step == 3 ) then fac_cth_loc ( 1 : nfcts ) = fac_cth_loc ( 1 : nfcts ) / faca ( 1 : nfcts ) fac_htc_loc ( 1 : nfcts ) = fac_htc_loc ( 1 : nfcts ) / faca ( 1 : nfcts ) fac_pres_loc ( 1 : nfcts ) = fac_pres_loc ( 1 : nfcts ) / faca ( 1 : nfcts ) fac_pres2_loc ( 1 : nfcts ) = fac_pres2_loc ( 1 : nfcts ) / faca ( 1 : nfcts ) call MPI_ALLREDUCE ( fac_cth_loc ( 1 : nfcts ), fac_cth ( 1 : nfcts ), nfcts , MY_REAL , MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( fac_htc_loc ( 1 : nfcts ), fac_htc ( 1 : nfcts ), nfcts , MY_REAL , MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( fac_pres_loc ( 1 : nfcts ), fac_pres ( 1 : nfcts ), nfcts , MY_REAL , MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( fac_pres2_loc ( 1 : nfcts ), fac_pres2 ( 1 : nfcts ), nfcts , MY_REAL , MPI_SUM , comm3d , mpierr ) end if end subroutine wallfunheat real function trilinear_interp_var ( var , cell , xgrid , ygrid , zgrid , x , y , z ) use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , itot , jtot , ktot use decomp_2d , only : zstart implicit none real , intent ( in ) :: var ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : kb + kh ) integer , intent ( in ) :: cell ( 3 ) ! GLOBAL indices of cell containing the point real , intent ( in ), dimension ( ib : itot + ih ) :: xgrid real , intent ( in ), dimension ( jb : jtot + jh ) :: ygrid real , intent ( in ), dimension ( kb : ktot + kh ) :: zgrid real , intent ( in ) :: x , y , z ! location of point to interpolate at real , dimension ( 8 ) :: corners ( 8 ) real :: x0 , y0 , z0 , x1 , y1 , z1 integer :: i , j , k i = cell ( 1 ) - zstart ( 1 ) + 1 j = cell ( 2 ) - zstart ( 2 ) + 1 k = cell ( 3 ) - zstart ( 3 ) + 1 if (( i < ib - 1 ) . or . ( i > ie + 1 ) . or . ( j < jb - 1 ) . or . ( j > je + 1 )) then write ( * , * ) \"problem in trilinear_interp_var\" , i , j , k stop 1 end if corners = eval_corners ( var , i , j , k ) x0 = xgrid ( cell ( 1 )) y0 = ygrid ( cell ( 2 )) z0 = zgrid ( cell ( 3 )) x1 = xgrid ( cell ( 1 ) + 1 ) y1 = ygrid ( cell ( 2 ) + 1 ) z1 = zgrid ( cell ( 3 ) + 1 ) trilinear_interp_var = trilinear_interp ( x , y , z , x0 , y0 , z0 , x1 , y1 , z1 , corners ) end function trilinear_interp_var function eval_corners ( var , i , j , k ) use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh integer , intent ( in ) :: i , j , k ! LOCAL indices real , intent ( in ) :: var ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : kb + kh ) real , dimension ( 8 ) :: eval_corners ( 8 ) eval_corners ( 1 ) = var ( i , j , k ) !c000 eval_corners ( 2 ) = var ( i + 1 , j , k ) !c100 eval_corners ( 3 ) = var ( i , j + 1 , k ) !c010 eval_corners ( 4 ) = var ( i + 1 , j + 1 , k ) !c110 eval_corners ( 5 ) = var ( i , j , k + 1 ) !c001 eval_corners ( 6 ) = var ( i + 1 , j , k + 1 ) !c101 eval_corners ( 7 ) = var ( i , j + 1 , k + 1 ) !c011 eval_corners ( 8 ) = var ( i + 1 , j + 1 , k + 1 ) !c111 end function eval_corners real function trilinear_interp ( x , y , z , x0 , y0 , z0 , x1 , y1 , z1 , corners ) real , intent ( in ) :: x , y , z , x0 , y0 , z0 , x1 , y1 , z1 , corners ( 8 ) real :: xd , yd , zd xd = ( x - x0 ) / ( x1 - x0 ) yd = ( y - y0 ) / ( y1 - y0 ) zd = ( z - z0 ) / ( z1 - z0 ) ! check all positive trilinear_interp = corners ( 1 ) * ( 1 - xd ) * ( 1 - yd ) * ( 1 - zd ) + & ! c000 corners ( 2 ) * ( xd ) * ( 1 - yd ) * ( 1 - zd ) + & ! c100 corners ( 3 ) * ( 1 - xd ) * ( yd ) * ( 1 - zd ) + & ! c010 corners ( 4 ) * ( xd ) * ( yd ) * ( 1 - zd ) + & ! c110 corners ( 5 ) * ( 1 - xd ) * ( 1 - yd ) * ( zd ) + & ! c001 corners ( 6 ) * ( xd ) * ( 1 - yd ) * ( zd ) + & ! c101 corners ( 7 ) * ( 1 - xd ) * ( yd ) * ( zd ) + & ! c011 corners ( 8 ) * ( xd ) * ( yd ) * ( zd ) ! c111 end function trilinear_interp integer function alignment ( n ) ! returns an integer determining whether a unit vector n is aligned with the ! coordinates axes. use modglobal , only : xhat , yhat , zhat implicit none real , dimension ( 3 ), intent ( in ) :: n ! must be unit vector if ( is_equal ( n , xhat )) then alignment = 1 elseif ( is_equal ( n , yhat )) then alignment = 2 elseif ( is_equal ( n , zhat )) then alignment = 3 elseif ( is_equal ( n , - xhat )) then alignment = - 1 elseif ( is_equal ( n , - yhat )) then alignment = - 2 elseif ( is_equal ( n , - zhat )) then alignment = - 3 else alignment = 0 end if end function alignment ! overload this with real dimension(1) ! could put somewhere else because not specific to ibm logical function is_equal ( a , b ) ! determines whether two vectors are equal to each other within a tolerance of eps1 use modglobal , only : eps1 implicit none real , dimension ( 3 ), intent ( in ) :: a , b if ( all ( abs ( a - b ) < eps1 )) then is_equal = . true . else is_equal = . false . end if end function is_equal function cross_product ( a , b ) ! Calculate the cross product (a x b) implicit none real , dimension ( 3 ) :: cross_product real , dimension ( 3 ), intent ( in ) :: a , b cross_product ( 1 ) = a ( 2 ) * b ( 3 ) - a ( 3 ) * b ( 2 ) cross_product ( 2 ) = a ( 3 ) * b ( 1 ) - a ( 1 ) * b ( 3 ) cross_product ( 3 ) = a ( 1 ) * b ( 2 ) - a ( 2 ) * b ( 1 ) end function cross_product function interp_velocity_u ( i , j , k ) ! interpolates the velocity at u-grid location i,j,k use modfields , only : u0 , v0 , w0 real :: interp_velocity_u ( 3 ) integer , intent ( in ) :: i , j , k interp_velocity_u ( 1 ) = u0 ( i , j , k ) interp_velocity_u ( 2 ) = 0.25 * ( v0 ( i , j , k ) + v0 ( i , j + 1 , k ) + v0 ( i - 1 , j , k ) + v0 ( i - 1 , j + 1 , k )) interp_velocity_u ( 3 ) = 0.25 * ( w0 ( i , j , k ) + w0 ( i , j , k + 1 ) + w0 ( i - 1 , j , k ) + w0 ( i - 1 , j , k + 1 )) !only for equidistant grid! return end function interp_velocity_u function interp_velocity_v ( i , j , k ) ! interpolates the velocity at v-grid location i,j,k use modfields , only : u0 , v0 , w0 real :: interp_velocity_v ( 3 ) integer , intent ( in ) :: i , j , k interp_velocity_v ( 1 ) = 0.25 * ( u0 ( i , j , k ) + u0 ( i + 1 , j , k ) + u0 ( i , j - 1 , k ) + u0 ( i + 1 , j - 1 , k )) interp_velocity_v ( 2 ) = v0 ( i , j , k ) interp_velocity_v ( 3 ) = 0.25 * ( w0 ( i , j , k ) + w0 ( i , j , k + 1 ) + w0 ( i , j - 1 , k ) + w0 ( i , j - 1 , k + 1 )) !only for equidistant grid! return end function interp_velocity_v function interp_velocity_w ( i , j , k ) ! interpolates the velocity at w-grid location i,j,k use modfields , only : u0 , v0 , w0 real :: interp_velocity_w ( 3 ) integer , intent ( in ) :: i , j , k interp_velocity_w ( 1 ) = 0.25 * ( u0 ( i , j , k ) + u0 ( i + 1 , j , k ) + u0 ( i , j - 1 , k ) + u0 ( i + 1 , j - 1 , k )) interp_velocity_w ( 2 ) = v0 ( i , j , k ) interp_velocity_w ( 3 ) = 0.25 * ( w0 ( i , j , k ) + w0 ( i , j , k + 1 ) + w0 ( i , j - 1 , k ) + w0 ( i , j - 1 , k + 1 )) !only for equidistant grid! return end function interp_velocity_w function interp_velocity_c ( i , j , k ) ! interpolates the velocity at c-grid location i,j,k use modfields , only : u0 , v0 , w0 real :: interp_velocity_c ( 3 ) integer , intent ( in ) :: i , j , k interp_velocity_c ( 1 ) = 0.5 * ( u0 ( i , j , k ) + u0 ( i + 1 , j , k )) interp_velocity_c ( 2 ) = 0.5 * ( v0 ( i , j , k ) + v0 ( i , j + 1 , k )) interp_velocity_c ( 3 ) = 0.5 * ( w0 ( i , j , k ) + w0 ( i , j , k + 1 )) return end function interp_velocity_c real function interp_temperature_u ( i , j , k ) ! interpolates the temperature at u-grid location i,j,k use modfields , only : thl0 integer , intent ( in ) :: i , j , k !interp_temperature_u = 0.5 * (thl0(i,j,k) + thl0(i-1,j,k)) interp_temperature_u = 0.5 * ( thl0 ( i , j , k ) * mask_c ( i , j , k ) * ( 2. - mask_c ( i - 1 , j , k )) & + thl0 ( i - 1 , j , k ) * mask_c ( i - 1 , j , k ) * ( 2. - mask_c ( i , j , k ))) return end function interp_temperature_u real function interp_temperature_v ( i , j , k ) ! interpolates the temperature at v-grid location i,j,k use modfields , only : thl0 integer , intent ( in ) :: i , j , k !interp_temperature_v = 0.5 * (thl0(i,j,k) + thl0(i,j-1,k)) interp_temperature_v = 0.5 * ( thl0 ( i , j , k ) * mask_c ( i , j , k ) * ( 2. - mask_c ( i , j - 1 , k )) & + thl0 ( i , j - 1 , k ) * mask_c ( i , j - 1 , k ) * ( 2. - mask_c ( i , j , k ))) return end function interp_temperature_v real function interp_temperature_w ( i , j , k ) ! interpolates the temperature at w-grid location i,j,k use modfields , only : thl0 integer , intent ( in ) :: i , j , k !interp_temperature_w = 0.5 * (thl0(i,j,k) + thl0(i,j,k-1)) interp_temperature_w = 0.5 * ( thl0 ( i , j , k ) * mask_c ( i , j , k ) * ( 2. - mask_c ( i , j , k - 1 )) & + thl0 ( i , j , k - 1 ) * mask_c ( i , j , k - 1 ) * ( 2. - mask_c ( i , j , k ))) return end function interp_temperature_w subroutine local_coords ( uvec , norm , span , strm , valid ) ! returns the local streamwise (strm) and spanwise vectors (span) in the ! plane normal to (norm) containing the velocity vector (uvec) use modglobal , only : vec0 real , intent ( in ), dimension ( 3 ) :: uvec , norm real , intent ( out ), dimension ( 3 ) :: span , strm logical , intent ( out ) :: valid span = cross_product ( norm , uvec ) !if (is_equal(span, (/0.,0.,0./))) then ! velocity is pointing into or outof the surface if ( is_equal ( span , vec0 )) then strm = 0. valid = . false . else span = span / norm2 ( span ) valid = . true . end if strm = cross_product ( span , norm ) end subroutine local_coords real function mom_transfer_coef_stability ( utan , dist , z0 , z0h , Tair , Tsurf ) ! By Ivo Suter. calculates the momentum transfer coefficient based on the ! surface tangential velocity 'utan' at a distance 'dist' from the surface, ! for a surface with momentum roughness length z0 and heat roughness length z0h. ! Stability are included using the air temperature Tair and surface temperature Tsurf. use modglobal , only : grav , fkar , prandtlturb implicit none real , intent ( in ) :: dist , z0 , z0h , Tsurf , Tair , utan real , parameter :: b1 = 9.4 !parameters from uno1995 real , parameter :: b2 = 4.7 real , parameter :: dm = 7.4 real , parameter :: dh = 5.3 real :: dT , Ribl0 , logdz , logdzh , logzh , sqdz , fkar2 , Ribl1 , Fm , Fh , cm , ch , Ctm , M dT = Tair - Tsurf Ribl0 = grav * dist * dT / ( Tsurf * utan ** 2 ) !Eq. 6, guess initial Ri logdz = LOG ( dist / z0 ) logdzh = LOG ( dist / z0h ) logzh = LOG ( z0 / z0h ) sqdz = SQRT ( dist / z0 ) fkar2 = fkar ** 2 IF ( Ribl0 > 0. ) THEN !0.25 approx critical for bulk Richardson number  => stable Fm = 1. / ( 1. + b2 * Ribl0 ) ** 2 !Eq. 4 Fh = Fm !Eq. 4 ELSE ! => unstable cm = ( dm * fkar2 ) / ( logdz ** 2 ) * b1 * sqdz !Eq. 5 ch = ( dh * fkar2 ) / ( logdz ** 2 ) * b1 * sqdz !Eq. 5 Fm = 1. - ( b1 * Ribl0 ) / ( 1. + cm * SQRT ( ABS ( Ribl0 ))) !Eq. 3 Fh = 1. - ( b1 * Ribl0 ) / ( 1. + ch * SQRT ( ABS ( Ribl0 ))) !Eq. 3 END IF M = prandtlturb * logdz * SQRT ( Fm ) / Fh !Eq. 14 Ribl1 = Ribl0 - Ribl0 * prandtlturb * logzh / ( prandtlturb * logzh + M ) !Eq. 17 !interate to get new Richardson number IF ( Ribl1 > 0. ) THEN !0.25 approx critical for bulk Richardson number  => stable Fm = 1. / ( 1. + b2 * Ribl1 ) ** 2 !Eq. 4 ELSE ! => unstable cm = ( dm * fkar2 ) / ( logdz ** 2 ) * b1 * sqdz !Eq. 5 Fm = 1. - ( b1 * Ribl1 ) / ( 1. + cm * SQRT ( ABS ( Ribl1 ))) !Eq. 3 END IF mom_transfer_coef_stability = fkar2 / ( logdz ** 2 ) * Fm !Eq. 7 end function mom_transfer_coef_stability real function mom_transfer_coef_neutral ( dist , z0 ) ! calculates the heat transfer coefficient based on the (neutral) log law, ! for a distance 'dist' and a momentum roughness length 'z0'. use modglobal , only : fkar implicit none real , intent ( in ) :: dist , z0 mom_transfer_coef_neutral = ( fkar / log ( dist / z0 )) ** 2 end function mom_transfer_coef_neutral subroutine heat_transfer_coef_flux ( utan , dist , z0 , z0h , Tair , Tsurf , cth , flux , htc ) use modglobal , only : grav , fkar , prandtlturb implicit none real , intent ( in ) :: dist , z0 , z0h , Tsurf , Tair , utan real , intent ( out ) :: cth , flux , htc real , parameter :: b1 = 9.4 !parameters from Uno1995 real , parameter :: b2 = 4.7 real , parameter :: dm = 7.4 real , parameter :: dh = 5.3 !real :: Pr real :: dT , Ribl0 , logdz , logdzh , logzh , sqdz , fkar2 , Ribl1 , Fm , Fh , cm , ch , M , dTrough !Pr = 1. !Pr = prandtlmol dT = Tair - Tsurf Ribl0 = grav * dist * dT / ( Tsurf * utan ** 2 ) !Eq. 6, guess initial Ri logdz = log ( dist / z0 ) logdzh = log ( dist / z0h ) logzh = log ( z0 / z0h ) sqdz = sqrt ( dist / z0 ) fkar2 = fkar ** 2 cth = 0. flux = 0. if ( Ribl0 > 0. ) then Fm = 1. / ( 1. + b2 * Ribl0 ) ** 2 !Eq. 4 Fh = Fm !Eq. 4 else ! => unstable cm = ( dm * fkar2 ) / ( logdz ** 2 ) * b1 * sqdz !Eq. 5 ch = ( dh * fkar2 ) / ( logdz ** 2 ) * b1 * sqdz !Eq. 5 Fm = 1. - ( b1 * Ribl0 ) / ( 1. + cm * sqrt ( abs ( Ribl0 ))) !Eq. 3 Fh = 1. - ( b1 * Ribl0 ) / ( 1. + ch * sqrt ( abs ( Ribl0 ))) !Eq. 3 end if M = prandtlturb * logdz * sqrt ( Fm ) / Fh !Eq. 14 Ribl1 = Ribl0 - Ribl0 * prandtlturb * logzh / ( prandtlturb * logzh + M ) !Eq. 17 !interate to get new Richardson number if ( Ribl1 > 0. ) then Fm = 1. / ( 1. + b2 * Ribl1 ) ** 2 !Eq. 4 Fh = Fm !Eq. 4 else ! => unstable cm = ( dm * fkar2 ) / ( logdz ** 2 ) * b1 * sqdz !Eq. 5 ch = ( dh * fkar2 ) / ( logdz ** 2 ) * b1 * sqdz !Eq. 5 Fm = 1. - ( b1 * Ribl1 ) / ( 1. + cm * sqrt ( abs ( Ribl1 ))) !Eq. 3 Fh = 1. - ( b1 * Ribl1 ) / ( 1. + ch * sqrt ( abs ( Ribl1 ))) !Eq. 3 end if ! Uno (2) M = prandtlturb * logdz * sqrt ( Fm ) / Fh !Eq. 14 dTrough = dT * 1. / ( prandtlturb * logzh / M + 1. ) !Eq. 13a cth = fkar2 / ( logdz * logdz ) * Fh / prandtlturb ! Ivo's heat transfer coefficient flux = abs ( utan ) * cth * dTrough if ( abs ( abs ( utan ) * dT ) > 0. ) then htc = flux / ( abs ( utan ) * dT ) else htc = 0. end if ! ! Uno (8) ! cth = abs(utan)*fkar2/(logdz*logdzh)*Fh/prandtlturb !Eq. 8 ! flux = cth*dT !Eq. 2, Eq. 8 end subroutine heat_transfer_coef_flux real function moist_flux ( cveg , resa , qtair , qwall , hurel , resc , ress ) real , intent ( in ) :: cveg , resa , qtair , qwall , hurel , resc , ress moist_flux = min ( 0. , cveg * ( qtair - qwall ) / ( resa + resc ) + & ( 1 - cveg ) * ( qtair - qwall * hurel ) / ( resa + ress )) end function moist_flux subroutine bottom ! By Ivo Suter. !kind of obsolete when road facets are being used !vegetated floor not added (could simply be copied from vegetated horizontal facets) use modglobal , only : ib , ie , ih , jh , kb , ke , kh , jb , je , kb , numol , prandtlmol , dzh , nsv , & dxf , dxhi , dzf , dzfi , numoli , ltempeq , khc , lmoist , BCbotT , BCbotq , BCbotm , BCbots , dzh2i , libm use modfields , only : u0 , v0 , e120 , um , vm , w0 , wm , e12m , thl0 , qt0 , sv0 , thlm , qtm , svm , up , vp , wp , thlp , qtp , svp , shear , momfluxb , tfluxb , cth , tau_x , tau_y , tau_z , thl_flux use modsurfdata , only : thlflux , qtflux , svflux , ustar , thvs , wtsurf , wqsurf , thls , z0 , z0h use modsubgriddata , only : ekm , ekh use modmpi , only : myid implicit none integer :: i , j , jp , jm , m e120 (:, :, kb - 1 ) = e120 (:, :, kb ) e12m (:, :, kb - 1 ) = e12m (:, :, kb ) ! wm(:, :, kb) = 0. ! SO moved to modboundary ! w0(:, :, kb) = 0. tau_x (:,:, kb : ke + kh ) = up tau_y (:,:, kb : ke + kh ) = vp tau_z (:,:, kb : ke + kh ) = wp thl_flux (:,:, kb : ke + kh ) = thlp !if (.not.(libm)) then if ( lbottom ) then !momentum if ( BCbotm . eq . 2 ) then call wfuno ( ih , jh , kh , up , vp , thlp , momfluxb , tfluxb , cth , bcTfluxA , u0 , v0 , thl0 , thls , z0 , z0h , 0 , 1 , 91 ) elseif ( BCbotm . eq . 3 ) then call wfmneutral ( ih , jh , kh , up , vp , momfluxb , u0 , v0 , z0 , 0 , 1 , 91 ) else write ( 0 , * ) \"ERROR: bottom boundary type for momentum undefined\" stop 1 end if if ( ltempeq ) then if ( BCbotT . eq . 1 ) then !neumann/fixed flux bc for temperature do j = jb , je do i = ib , ie thlp ( i , j , kb ) = thlp ( i , j , kb ) & + ( & 0.5 * ( dzf ( kb - 1 ) * ekh ( i , j , kb ) + dzf ( kb ) * ekh ( i , j , kb - 1 )) & * ( thl0 ( i , j , kb ) - thl0 ( i , j , kb - 1 )) & * dzh2i ( kb ) & - wtsurf & ) * dzfi ( kb ) end do end do else if ( BCbotT . eq . 2 ) then !wall function bc for temperature (fixed temperature) call wfuno ( ih , jh , kh , up , vp , thlp , momfluxb , tfluxb , cth , bcTfluxA , u0 , v0 , thl0 , thls , z0 , z0h , 0 , 1 , 92 ) else write ( 0 , * ) \"ERROR: bottom boundary type for temperature undefined\" stop 1 end if end if ! ltempeq if ( lmoist ) then if ( BCbotq . eq . 1 ) then !neumann/fixed flux bc for moisture do j = jb , je do i = ib , ie qtp ( i , j , kb ) = qtp ( i , j , kb ) + ( & 0.5 * ( dzf ( kb - 1 ) * ekh ( i , j , kb ) + dzf ( kb ) * ekh ( i , j , kb - 1 )) & * ( qt0 ( i , j , kb ) - qt0 ( i , j , kb - 1 )) & * dzh2i ( kb ) & + wqsurf & ) * dzfi ( kb ) end do end do else write ( 0 , * ) \"ERROR: bottom boundary type for moisture undefined\" stop 1 end if ! end if !lmoist if ( nsv > 0 ) then if ( BCbots . eq . 1 ) then !neumann/fixed flux bc for moisture do j = jb , je do i = ib , ie do m = 1 , nsv svp ( i , j , kb , m ) = svp ( i , j , kb , m ) + ( & 0.5 * ( dzf ( kb - 1 ) * ekh ( i , j , kb ) + dzf ( kb ) * ekh ( i , j , kb - 1 )) & * ( sv0 ( i , j , kb , m ) - sv0 ( i , j , kb - 1 , m )) & * dzh2i ( kb ) & + 0. & ) * dzfi ( kb ) end do end do end do else write ( 0 , * ) \"ERROR: bottom boundary type for scalars undefined\" stop 1 end if ! end if end if tau_x (:,:, kb : ke + kh ) = up - tau_x (:,:, kb : ke + kh ) tau_y (:,:, kb : ke + kh ) = vp - tau_y (:,:, kb : ke + kh ) tau_z (:,:, kb : ke + kh ) = wp - tau_z (:,:, kb : ke + kh ) thl_flux (:,:, kb : ke + kh ) = thlp - thl_flux (:,:, kb : ke + kh ) return end subroutine bottom subroutine createmasks use modglobal , only : libm , ib , ie , ih , ihc , jb , je , jh , jhc , kb , ke , kh , khc , itot , jtot , rslabs use modfields , only : IIc , IIu , IIv , IIw , IIuw , IIvw , IIuv , & IIcs , IIus , IIvs , IIws , IIuws , IIvws , IIuvs , & IIct , IIut , IIvt , IIwt , IIuwt , um , u0 , vm , v0 , wm , w0 use modmpi , only : myid , comm3d , mpierr , MY_REAL , nprocs use decomp_2d , only : zstart , exchange_halo_z integer :: IIcl ( kb : ke + khc ), IIul ( kb : ke + khc ), IIvl ( kb : ke + khc ), IIwl ( kb : ke + khc ), IIuwl ( kb : ke + khc ), IIvwl ( kb : ke + khc ), IIuvl ( kb : ke + khc ) integer :: IIcd ( ib : ie , kb : ke ) integer :: IIwd ( ib : ie , kb : ke ) integer :: IIuwd ( ib : ie , kb : ke ) integer :: IIud ( ib : ie , kb : ke ) integer :: IIvd ( ib : ie , kb : ke ) integer :: i , j , k , n , m ! II*l needn't be defined up to ke_khc, but for now would require large scale changes in modstatsdump so if works leave as is ! tg3315 04/07/18 if (. not . libm ) then IIc (:, :, :) = 1 IIu (:, :, :) = 1 IIv (:, :, :) = 1 IIw (:, :, :) = 1 IIuw (:, :, :) = 1 IIvw (:, :, :) = 1 IIuv (:, :, :) = 1 IIcs (:) = nint ( rslabs ) IIus (:) = nint ( rslabs ) IIvs (:) = nint ( rslabs ) IIws (:) = nint ( rslabs ) IIuws (:) = nint ( rslabs ) IIvws (:) = nint ( rslabs ) IIuvs (:) = nint ( rslabs ) IIct (:, :) = jtot IIut (:, :) = jtot IIvt (:, :) = jtot IIwt (:, :) = jtot IIuwt (:, :) = jtot return end if ! Create masking matrices IIc = 1 ; IIu = 1 ; IIv = 1 ; IIct = 1 ; IIw = 1 ; IIuw = 1 ; IIvw = 1 ; IIuv = 1 ; IIwt = 1 ; IIut = 1 ; IIvt = 1 ; IIuwt = 1 ; IIcs = 1 ; IIus = 1 ; IIvs = 1 ; IIws = 1 ; IIuws = 1 ; IIvws = 1 ; IIuvs = 1 do n = 1 , solid_info_u % nsolptsrank !n = solid_info_u%solptsrank(m) i = solid_info_u % solpts_loc ( n , 1 ) - zstart ( 1 ) + 1 j = solid_info_u % solpts_loc ( n , 2 ) - zstart ( 2 ) + 1 k = solid_info_u % solpts_loc ( n , 3 ) - zstart ( 3 ) + 1 IIu ( i , j , k ) = 0 end do do n = 1 , solid_info_v % nsolptsrank !n = solid_info_v%solptsrank(m) i = solid_info_v % solpts_loc ( n , 1 ) - zstart ( 1 ) + 1 j = solid_info_v % solpts_loc ( n , 2 ) - zstart ( 2 ) + 1 k = solid_info_v % solpts_loc ( n , 3 ) - zstart ( 3 ) + 1 IIv ( i , j , k ) = 0 end do do n = 1 , solid_info_w % nsolptsrank !n = solid_info_w%solptsrank(m) i = solid_info_w % solpts_loc ( n , 1 ) - zstart ( 1 ) + 1 j = solid_info_w % solpts_loc ( n , 2 ) - zstart ( 2 ) + 1 k = solid_info_w % solpts_loc ( n , 3 ) - zstart ( 3 ) + 1 IIw ( i , j , k ) = 0 end do do n = 1 , solid_info_c % nsolptsrank !n = solid_info_c%solptsrank(m) i = solid_info_c % solpts_loc ( n , 1 ) - zstart ( 1 ) + 1 j = solid_info_c % solpts_loc ( n , 2 ) - zstart ( 2 ) + 1 k = solid_info_c % solpts_loc ( n , 3 ) - zstart ( 3 ) + 1 IIc ( i , j , k ) = 0 end do IIw (:, :, kb ) = 0 ; IIuw (:, :, kb ) = 0 ; IIvw (:, :, kb ) = 0 do i = ib , ie do j = jb , je IIuv ( i , j , kb ) = IIu ( i , j , kb ) * IIu ( i , j - 1 , kb ) * IIv ( i , j , kb ) * IIv ( i - 1 , j , kb ) do k = kb + 1 , ke ! Classed as solid (set to zero) unless ALL points in the stencil are fluid IIuv ( i , j , k ) = IIu ( i , j , k ) * IIu ( i , j - 1 , k ) * IIv ( i , j , k ) * IIv ( i - 1 , j , k ) IIuw ( i , j , k ) = IIu ( i , j , k ) * IIu ( i , j , k - 1 ) * IIw ( i , j , k ) * IIw ( i - 1 , j , k ) IIvw ( i , j , k ) = IIv ( i , j , k ) * IIv ( i , j , k - 1 ) * IIw ( i , j , k ) * IIw ( i , j - 1 , k ) end do end do end do ! Can't do this because no interface for integers ! call exchange_halo_z(IIuv, opt_zlevel=(/ihc,jhc,0/)) ! call exchange_halo_z(IIuv, opt_zlevel=(/ihc,jhc,0/)) ! call exchange_halo_z(IIvw, opt_zlevel=(/ihc,jhc,0/)) do k = kb , ke + khc IIcl ( k ) = sum ( IIc ( ib : ie , jb : je , k )) IIul ( k ) = sum ( IIu ( ib : ie , jb : je , k )) IIvl ( k ) = sum ( IIv ( ib : ie , jb : je , k )) IIwl ( k ) = sum ( IIw ( ib : ie , jb : je , k )) IIuwl ( k ) = sum ( IIuw ( ib : ie , jb : je , k )) IIvwl ( k ) = sum ( IIvw ( ib : ie , jb : je , k )) IIuvl ( k ) = sum ( IIuv ( ib : ie , jb : je , k )) enddo call MPI_ALLREDUCE ( IIcl , IIcs , ke + khc - kb + 1 , MPI_INTEGER , & MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( IIul , IIus , ke + khc - kb + 1 , MPI_INTEGER , & MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( IIvl , IIvs , ke + khc - kb + 1 , MPI_INTEGER , & MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( IIwl , IIws , ke + khc - kb + 1 , MPI_INTEGER , & MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( IIuwl , IIuws , ke + khc - kb + 1 , MPI_INTEGER , & MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( IIvwl , IIvws , ke + khc - kb + 1 , MPI_INTEGER , & MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( IIuvl , IIuvs , ke + khc - kb + 1 , MPI_INTEGER , & MPI_SUM , comm3d , mpierr ) IIcd ( ib : ie , kb : ke ) = sum ( IIc ( ib : ie , jb : je , kb : ke ), DIM = 2 ) IIwd ( ib : ie , kb : ke ) = sum ( IIw ( ib : ie , jb : je , kb : ke ), DIM = 2 ) IIuwd ( ib : ie , kb : ke ) = sum ( IIuw ( ib : ie , jb : je , kb : ke ), DIM = 2 ) IIud ( ib : ie , kb : ke ) = sum ( IIu ( ib : ie , jb : je , kb : ke ), DIM = 2 ) IIvd ( ib : ie , kb : ke ) = sum ( IIv ( ib : ie , jb : je , kb : ke ), DIM = 2 ) call MPI_ALLREDUCE ( IIwd ( ib : ie , kb : ke ), IIwt ( ib : ie , kb : ke ), ( ke - kb + 1 ) * ( ie - ib + 1 ), MPI_INTEGER , MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( IIcd ( ib : ie , kb : ke ), IIct ( ib : ie , kb : ke ), ( ke - kb + 1 ) * ( ie - ib + 1 ), MPI_INTEGER , MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( IIuwd ( ib : ie , kb : ke ), IIuwt ( ib : ie , kb : ke ), ( ke - kb + 1 ) * ( ie - ib + 1 ), MPI_INTEGER , MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( IIud ( ib : ie , kb : ke ), IIut ( ib : ie , kb : ke ), ( ke - kb + 1 ) * ( ie - ib + 1 ), MPI_INTEGER , MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( IIvd ( ib : ie , kb : ke ), IIvt ( ib : ie , kb : ke ), ( ke - kb + 1 ) * ( ie - ib + 1 ), MPI_INTEGER , MPI_SUM , comm3d , mpierr ) end subroutine createmasks end module modibm","tags":"","url":"sourcefile/modibm.f90.html"},{"title":"modsubgrid.f90 – uDALES","text":"This file depends on sourcefile~~modsubgrid.f90~~EfferentGraph sourcefile~modsubgrid.f90 modsubgrid.f90 sourcefile~modboundary.f90 modboundary.f90 sourcefile~modsubgrid.f90->sourcefile~modboundary.f90 sourcefile~modfields.f90 modfields.f90 sourcefile~modsubgrid.f90->sourcefile~modfields.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~modsubgrid.f90->sourcefile~modglobal.f90 sourcefile~modinletdata.f90 modinletdata.f90 sourcefile~modsubgrid.f90->sourcefile~modinletdata.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~modsubgrid.f90->sourcefile~modmpi.f90 sourcefile~modsubgriddata.f90 modsubgriddata.f90 sourcefile~modsubgrid.f90->sourcefile~modsubgriddata.f90 sourcefile~modsurfdata.f90 modsurfdata.f90 sourcefile~modsubgrid.f90->sourcefile~modsurfdata.f90 sourcefile~modboundary.f90->sourcefile~modfields.f90 sourcefile~modboundary.f90->sourcefile~modglobal.f90 sourcefile~modboundary.f90->sourcefile~modinletdata.f90 sourcefile~modboundary.f90->sourcefile~modmpi.f90 sourcefile~modboundary.f90->sourcefile~modsubgriddata.f90 sourcefile~modboundary.f90->sourcefile~modsurfdata.f90 sourcefile~moddriver.f90 moddriver.f90 sourcefile~modboundary.f90->sourcefile~moddriver.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 sourcefile~moddriver.f90->sourcefile~modfields.f90 sourcefile~moddriver.f90->sourcefile~modglobal.f90 sourcefile~moddriver.f90->sourcefile~modinletdata.f90 sourcefile~moddriver.f90->sourcefile~modmpi.f90 sourcefile~modsave.f90 modsave.f90 sourcefile~moddriver.f90->sourcefile~modsave.f90 sourcefile~modsave.f90->sourcefile~modfields.f90 sourcefile~modsave.f90->sourcefile~modglobal.f90 sourcefile~modsave.f90->sourcefile~modinletdata.f90 sourcefile~modsave.f90->sourcefile~modmpi.f90 sourcefile~modsave.f90->sourcefile~modsubgriddata.f90 sourcefile~modsave.f90->sourcefile~modsurfdata.f90 sourcefile~initfac.f90 initfac.f90 sourcefile~modsave.f90->sourcefile~initfac.f90 sourcefile~modibmdata.f90 modibmdata.f90 sourcefile~modsave.f90->sourcefile~modibmdata.f90 sourcefile~initfac.f90->sourcefile~modglobal.f90 sourcefile~initfac.f90->sourcefile~modmpi.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~modsubgrid.f90~~AfferentGraph sourcefile~modsubgrid.f90 modsubgrid.f90 sourcefile~modstartup.f90 modstartup.f90 sourcefile~modstartup.f90->sourcefile~modsubgrid.f90 sourcefile~modstatsdump.f90 modstatsdump.f90 sourcefile~modstatsdump.f90->sourcefile~modsubgrid.f90 sourcefile~program.f90 program.f90 sourcefile~program.f90->sourcefile~modsubgrid.f90 sourcefile~program.f90->sourcefile~modstartup.f90 sourcefile~program.f90->sourcefile~modstatsdump.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !!> \\file modsubgrid.f90 !!!  Calculates and applies the Sub Filter Scale diffusion ! !> !!  \\author Jasper Tomas, TU Delft !!  \\author Pier Siebesma, K.N.M.I. !!  \\author Stephan de Roode,TU Delft !!  \\author Chiel van Heerwaarden, Wageningen U.R. !!  \\author Thijs Heus,MPI-M !!  \\par Revision list !! Jasper Tomas: !!   -Implemented Vreman model (2004) !!   -wall-damping applied for 1-equation and Smagorinsky models !!   -factor 2 smaller constant in 1-equation and Smagorinsky models !!  \\todo Documentation !! !  This file is part of DALES. ! ! DALES is free software; you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation; either version 3 of the License, or ! (at your option) any later version. ! ! DALES is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !  Copyright 1993-2009 Delft University of Technology, Wageningen University, Utrecht University, KNMI ! module modsubgrid use mpi use modsubgriddata implicit none save public :: subgrid , initsubgrid , exitsubgrid , subgridnamelist contains subroutine initsubgrid use modglobal , only : ih , ib , ie , jh , jb , je , kb , ke , kh , delta , zf , fkar , & pi , ifnamopt , fname_options use modmpi , only : myid implicit none integer :: i , k real :: ceps , ch real :: mlen call subgridnamelist allocate ( ekm ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( ekh ( ib - ih : ie + ih , jb - jh : je + jh , kb - kh : ke + kh )) allocate ( zlt ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( sbdiss ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( sbshr ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( sbbuo ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh )) allocate ( csz ( ib - ih : ie + ih , kb : ke + kh )) allocate ( damp ( ib : ie , jb : je , kb : ke )) damp = 1. cm = cf / ( 2. * pi ) * ( 1.5 * alpha_kolm ) ** ( - 1.5 ) ch = prandtl ch2 = ch - ch1 ceps = 2. * pi / cf * ( 1.5 * alpha_kolm ) ** ( - 1.5 ) ce1 = ( cn ** 2 ) * ( cm / Rigc - ch1 * cm ) ce2 = ceps - ce1 if ( cs == - 1. ) then csz (:,:) = ( cm ** 3 / ceps ) ** 0.25 !< Smagorinsky constant else csz (:,:) = cs end if end subroutine initsubgrid subroutine subgridnamelist use modglobal , only : pi , ifnamopt , fname_options , lles , lbuoyancy use modmpi , only : myid , nprocs , comm3d , mpierr , my_real , mpi_logical , mpi_integer implicit none integer :: ierr namelist / NAMSUBGRID / & ldelta , lmason , cf , cn , Rigc , Prandtl , lsmagorinsky , lvreman , loneeqn , c_vreman , cs , nmason , lbuoycorr if ( myid == 0 ) then open ( ifnamopt , file = fname_options , status = 'old' , iostat = ierr ) read ( ifnamopt , NAMSUBGRID , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions NAMSUBGRID' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif !write(6 ,NAMSUBGRID) close ( ifnamopt ) end if call MPI_BCAST ( ldelta , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lmason , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( nmason , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lsmagorinsky , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lvreman , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lbuoycorr , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( loneeqn , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( c_vreman , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( cs , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( cf , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( cn , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( Rigc , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( Prandtl , 1 , MY_REAL , 0 , comm3d , mpierr ) prandtli = 1. / Prandtl if (( lsmagorinsky ) . or . ( lvreman ) . or . ( loneeqn )) then lles = . true . endif if ( lbuoyancy ) lbuoycorr = . true . end subroutine subgridnamelist subroutine subgrid ! Diffusion subroutines ! Thijs Heus, Chiel van Heerwaarden, 15 June 2007 use modglobal , only : ih , jh , kh , nsv , lmoist , lles , ib , ie , jb , je , kb , ke , imax , jmax , kmax ,& ihc , jhc , khc , ltempeq use modfields , only : up , vp , wp , e12p , thl0 , thlp , qt0 , qtp , sv0 , svp , shear use modsurfdata , only : ustar , thlflux , qtflux , svflux use modmpi , only : myid , comm3d , mpierr , my_real , nprocs implicit none integer n , proces call closure call diffu ( up ) call diffv ( vp ) call diffw ( wp ) if ( loneeqn ) call diffe ( e12p ) ! only in case of LES with 1-eq subgrid model if ( ltempeq ) call diffc ( ih , jh , kh , thl0 , thlp ) if ( lmoist ) call diffc ( ih , jh , kh , qt0 , qtp ) do n = 1 , nsv call diffc ( ihc , jhc , khc , sv0 (:,:,:, n ), svp (:,:,:, n )) end do if ( loneeqn ) call sources ! only in case of LES with 1-eq subgrid model end subroutine subroutine exitsubgrid implicit none deallocate ( ekm , ekh , zlt , sbdiss , sbbuo , sbshr , csz ) end subroutine exitsubgrid subroutine closure !-----------------------------------------------------------------| !                                                                 | !*** *closure*  calculates K-coefficients                         | !                                                                 | !      Hans Cuijpers   I.M.A.U.   06/01/1995                      | !                                                                 | !     purpose.                                                    | !     --------                                                    | !                                                                 | !     All the K-closure factors are calculated.                   | !                                                                 | !     ekm(i,j,k) = k sub m : for velocity-closure                 | !     ekh(i,j,k) = k sub h : for temperture-closure               | !     ekh(i,j,k) = k sub h = k sub c : for concentration-closure  | !                                                                 | !     We will use the next model for these factors:               | !                                                                 | !     k sub m = 0.12 * l * sqrt(E)                                | !                                                                 | !     k sub h = k sub c = ( 1 + (2*l)/D ) * k sub m               | !                                                                 | !           where : l = mixing length  ( in model = z2 )          | !                   E = subgrid energy                            | !                   D = grid-size distance                        | !                                                                 | !**   interface.                                                  | !     ----------                                                  | !                                                                 | !             *closure* is called from *program*.                 | !                                                                 | !-----------------------------------------------------------------| use modglobal , only : ib , ie , jb , je , kb , ke , kh , ih , jh , jmax , delta , ekmin , grav , zf , fkar , jgb , jge ,& dx , dxi , dxiq , dx2 , dy2 , dyi , dyiq , dzf , dzf2 , dzfi , dzhi , rk3step , rslabs , & numol , numoli , prandtlmoli , lles , rk3step , dzfiq , lbuoyancy , dzh use modfields , only : dthvdz , e120 , u0 , v0 , w0 , thl0 , mindist , wall , shear use modsurfdata , only : dudz , dvdz , thvs , ustar use modmpi , only : excjs , myid , nprocs , comm3d , mpierr , my_real , mpi_sum , slabsumi use modboundary , only : closurebc use modinletdata , only : utaui implicit none real , dimension ( ib : ie ) :: shearbot real :: strain2 , mlen , uhor , distplus , utaubot , a11 , a12 , a13 , & a21 , a22 , a23 , a31 , a32 , a33 , aa , b11 , b12 , b13 , b21 , b22 , & b23 , b33 , bb , const , const2 integer :: i , j , k , kp , km , jp , jm , im , ip , iw , jw , kw , c1 , c2 !  if (lles  .and. rk3step == 1) then        ! compute ekm and ekh only once in complete RK-cycle if ( lsmagorinsky ) then do k = kb , ke kp = k + 1 km = k - 1 do i = ib , ie ip = i + 1 im = i - 1 mlen = csz ( i , k ) * delta ( i , k ) do j = jb , je jp = j + 1 jm = j - 1 ! iw = wall(i,j,k,1)   ! indices of closest wall ! jw = wall(i,j,k,2)-myid*jmax   ! indices of closest wall in local j-index ! kw = wall(i,j,k,3) ! c1 = wall(i,j,k,4)   ! shear stress component ! c2 = wall(i,j,k,5)   ! shear stress component ! if ((jw >= jb-1) .and. (jw <= je+1)) then      ! check if jw is within the halo of this proc !    !write(*,'(A,E9.2,A,E9.2,A,E9.2,A,E9.2)') 'component1:', c1, 'component2:', c2, 'shear c1:', shear(iw,jw,kw,c1), 'shear c2:', shear(iw,jw,kw,c2) !    distplus = mindist(i,j,k)*sqrt(abs(shear(iw,jw,kw,c1))+abs(shear(iw,jw,kw,c2)))*numoli !    damp(i,j,k) = sqrt(1. - exp((-distplus*0.04)**3.))            ! Wall-damping according to Piomelli !    !    write(*,'(A,2(1pE9.2))') 'damp, distplus', damp(i,j,k), distplus ! else damp ( i , j , k ) = 1. ! end if strain2 = (( u0 ( ip , j , k ) - u0 ( i , j , k )) * dxi ) ** 2 & + (( v0 ( i , jp , k ) - v0 ( i , j , k )) * dyi ) ** 2 & + (( w0 ( i , j , kp ) - w0 ( i , j , k )) * dzfi ( k ) ) ** 2 strain2 = strain2 + 0.125 * ( & + (( w0 ( i , j , kp ) - w0 ( im , j , kp )) * dxi + ( u0 ( i , j , kp ) - u0 ( i , j , k )) * dzhi ( kp )) ** 2 & + (( w0 ( i , j , k ) - w0 ( im , j , k )) * dxi + ( u0 ( i , j , k ) - u0 ( i , j , km )) * dzhi ( k )) ** 2 & + (( w0 ( ip , j , k ) - w0 ( i , j , k )) * dxi + ( u0 ( ip , j , k ) - u0 ( ip , j , km )) * dzhi ( k )) ** 2 & + (( w0 ( ip , j , kp ) - w0 ( i , j , kp )) * dxi + ( u0 ( ip , j , kp ) - u0 ( ip , j , k )) * dzhi ( kp )) ** 2 ) strain2 = strain2 + 0.125 * ( & + (( u0 ( i , jp , k ) - u0 ( i , j , k )) * dyi + ( v0 ( i , jp , k ) - v0 ( im , jp , k )) * dxi ) ** 2 & + (( u0 ( i , j , k ) - u0 ( i , jm , k )) * dyi + ( v0 ( i , j , k ) - v0 ( im , j , k )) * dxi ) ** 2 & + (( u0 ( ip , j , k ) - u0 ( ip , jm , k )) * dyi + ( v0 ( ip , j , k ) - v0 ( i , j , k )) * dxi ) ** 2 & + (( u0 ( ip , jp , k ) - u0 ( ip , j , k )) * dyi + ( v0 ( ip , jp , k ) - v0 ( i , jp , k )) * dxi ) ** 2 ) strain2 = strain2 + 0.125 * ( & + (( v0 ( i , j , kp ) - v0 ( i , j , k )) * dzhi ( kp ) + ( w0 ( i , j , kp ) - w0 ( i , jm , kp )) * dyi ) ** 2 & + (( v0 ( i , j , k ) - v0 ( i , j , km )) * dzhi ( k ) + ( w0 ( i , j , k ) - w0 ( i , jm , k )) * dyi ) ** 2 & + (( v0 ( i , jp , k ) - v0 ( i , jp , km )) * dzhi ( k ) + ( w0 ( i , jp , k ) - w0 ( i , j , k )) * dyi ) ** 2 & + (( v0 ( i , jp , kp ) - v0 ( i , jp , k )) * dzhi ( kp ) + ( w0 ( i , jp , kp ) - w0 ( i , j , kp )) * dyi ) ** 2 ) ekm ( i , j , k ) = ( mlen * damp ( i , j , k )) ** 2. * sqrt ( 2. * strain2 ) ekh ( i , j , k ) = ekm ( i , j , k ) * prandtli end do end do end do damp (:,:,:) = max ( damp (:,:,:), dampmin ) ekm (:,:,:) = ekm (:,:,:) + numol ! add molecular viscosity ekh (:,:,:) = ekh (:,:,:) + numol * prandtlmoli ! add molecular diffusivity ! ekm(:,:,:) = max(ekm(:,:,:),ekmin) ! ekh(:,:,:) = max(ekh(:,:,:),ekmin) elseif ( lvreman ) then if (( lbuoyancy ) . and . ( lbuoycorr )) then const = prandtli * grav / ( thvs * sqrt ( 2. * 3. )) do k = kb , ke kp = k + 1 km = k - 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie ! aij = du_j / dx_i ip = i + 1 im = i - 1 a11 = ( u0 ( ip , j , k ) - u0 ( i , j , k )) * dxi a12 = ( v0 ( ip , jp , k ) + v0 ( ip , j , k ) - v0 ( im , jp , k ) - v0 ( im , j , k ) ) * dxiq a13 = ( w0 ( ip , j , kp ) + w0 ( ip , j , k ) - w0 ( im , j , kp ) - w0 ( im , j , k ) ) * dxiq a21 = ( u0 ( ip , jp , k ) + u0 ( i , jp , k ) - u0 ( ip , jm , k ) - u0 ( i , jm , k ) ) * dyiq a22 = ( v0 ( i , jp , k ) - v0 ( i , j , k )) * dyi a23 = ( w0 ( i , jp , kp ) + w0 ( i , jp , k ) - w0 ( i , jm , kp ) - w0 ( i , jm , k ) ) * dyiq a31 = ( & (( u0 ( ip , j , kp ) + u0 ( i , j , kp )) * dzf ( k ) + ( u0 ( ip , j , k ) + u0 ( i , j , k )) * dzf ( kp )) * dzhi ( kp ) & - (( u0 ( ip , j , k ) + u0 ( i , j , k )) * dzf ( km ) + ( u0 ( ip , j , km ) + u0 ( i , j , km )) * dzf ( k )) * dzhi ( k ) & ) & * dzfiq ( k ) a32 = ( & (( v0 ( i , jp , kp ) + v0 ( i , j , kp )) * dzf ( k ) + ( v0 ( i , jp , k ) + v0 ( i , j , k )) * dzf ( kp )) * dzhi ( kp ) & - (( v0 ( i , jp , k ) + v0 ( i , j , k )) * dzf ( km ) + ( v0 ( i , jp , km ) + v0 ( i , j , km )) * dzf ( k )) * dzhi ( k ) & ) & * dzfiq ( k ) a33 = ( w0 ( i , j , kp ) - w0 ( i , j , k )) * dzfi ( k ) aa = a11 * a11 + a21 * a21 + a31 * a31 + & a12 * a12 + a22 * a22 + a32 * a32 + & a13 * a13 + a23 * a23 + a33 * a33 b11 = dx2 * a11 * a11 + dy2 * a21 * a21 + dzf2 ( k ) * a31 * a31 b22 = dx2 * a12 * a12 + dy2 * a22 * a22 + dzf2 ( k ) * a32 * a32 b12 = dx2 * a11 * a12 + dy2 * a21 * a22 + dzf2 ( k ) * a31 * a32 b33 = dx2 * a13 * a13 + dy2 * a23 * a23 + dzf2 ( k ) * a33 * a33 b13 = dx2 * a11 * a13 + dy2 * a21 * a23 + dzf2 ( k ) * a31 * a33 b23 = dx2 * a12 * a13 + dy2 * a22 * a23 + dzf2 ( k ) * a32 * a33 bb = b11 * b22 - b12 * b12 + b11 * b33 - b13 * b13 + b22 * b33 - b23 * b23 dthvdz ( i , j , k ) = ( thl0 ( i , j , k + 1 ) - thl0 ( i , j , k - 1 )) / ( dzh ( k + 1 ) + dzh ( k )) if ( dthvdz ( i , j , k ) <= 0 ) then const2 = ( bb / aa ) else const2 = ( bb / aa ) - ( delta ( i , k ) ** 4 ) * dthvdz ( i , j , k ) * const if ( const2 < 0.0 ) const2 = 0.0 end if ekm ( i , j , k ) = c_vreman * sqrt ( const2 ) ekh ( i , j , k ) = ekm ( i , j , k ) * prandtli end do end do end do !  ekm(:,:,:) = ekm(:,:,:) + numol                             ! add molecular viscosity !  ekh(:,:,:) = ekh(:,:,:) + numol*prandtlmoli                 ! add molecular diffusivity else ! neutral case do k = kb , ke kp = k + 1 km = k - 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie ! aij = du_j / dx_i ip = i + 1 im = i - 1 a11 = ( u0 ( ip , j , k ) - u0 ( i , j , k )) * dxi a12 = ( v0 ( ip , jp , k ) + v0 ( ip , j , k ) - v0 ( im , jp , k ) - v0 ( im , j , k ) ) * dxiq a13 = ( w0 ( ip , j , kp ) + w0 ( ip , j , k ) - w0 ( im , j , kp ) - w0 ( im , j , k ) ) * dxiq a21 = ( u0 ( ip , jp , k ) + u0 ( i , jp , k ) - u0 ( ip , jm , k ) - u0 ( i , jm , k ) ) * dyiq a22 = ( v0 ( i , jp , k ) - v0 ( i , j , k )) * dyi a23 = ( w0 ( i , jp , kp ) + w0 ( i , jp , k ) - w0 ( i , jm , kp ) - w0 ( i , jm , k ) ) * dyiq a31 = ( & (( u0 ( ip , j , kp ) + u0 ( i , j , kp )) * dzf ( k ) + ( u0 ( ip , j , k ) + u0 ( i , j , k )) * dzf ( kp )) * dzhi ( kp ) & - (( u0 ( ip , j , k ) + u0 ( i , j , k )) * dzf ( km ) + ( u0 ( ip , j , km ) + u0 ( i , j , km )) * dzf ( k )) * dzhi ( k ) & ) & * dzfiq ( k ) a32 = ( & (( v0 ( i , jp , kp ) + v0 ( i , j , kp )) * dzf ( k ) + ( v0 ( i , jp , k ) + v0 ( i , j , k )) * dzf ( kp )) * dzhi ( kp ) & - (( v0 ( i , jp , k ) + v0 ( i , j , k )) * dzf ( km ) + ( v0 ( i , jp , km ) + v0 ( i , j , km )) * dzf ( k )) * dzhi ( k ) & ) & * dzfiq ( k ) a33 = ( w0 ( i , j , kp ) - w0 ( i , j , k )) * dzfi ( k ) aa = a11 * a11 + a21 * a21 + a31 * a31 + & a12 * a12 + a22 * a22 + a32 * a32 + & a13 * a13 + a23 * a23 + a33 * a33 b11 = dx2 * a11 * a11 + dy2 * a21 * a21 + dzf2 ( k ) * a31 * a31 b22 = dx2 * a12 * a12 + dy2 * a22 * a22 + dzf2 ( k ) * a32 * a32 b12 = dx2 * a11 * a12 + dy2 * a21 * a22 + dzf2 ( k ) * a31 * a32 b33 = dx2 * a13 * a13 + dy2 * a23 * a23 + dzf2 ( k ) * a33 * a33 b13 = dx2 * a11 * a13 + dy2 * a21 * a23 + dzf2 ( k ) * a31 * a33 b23 = dx2 * a12 * a13 + dy2 * a22 * a23 + dzf2 ( k ) * a32 * a33 bb = b11 * b22 - b12 * b12 + b11 * b33 - b13 * b13 + b22 * b33 - b23 * b23 if ( bb < 0.00000001 ) then ekm ( i , j , k ) = 0. ekh ( i , j , k ) = 0. else ekm ( i , j , k ) = c_vreman * sqrt ( bb / aa ) ekh ( i , j , k ) = ekm ( i , j , k ) * prandtli end if end do end do end do ! ekm(:,:,:) = max(ekm(:,:,:),ekmin) ! ekh(:,:,:) = max(ekh(:,:,:),ekmin) end if ! lbuoyancy ekm (:,:,:) = ekm (:,:,:) + numol ! add molecular viscosity ekh (:,:,:) = ekh (:,:,:) + numol * prandtlmoli ! add molecular diffusivity ! TKE scheme elseif ( loneeqn ) then do k = kb , ke do j = jb , je do i = ib , ie ! iw = wall(i,j,k,1)   ! indices of closest wall ! jw = wall(i,j,k,2)-myid*jmax   ! indices of closest wall in local j-index ! kw = wall(i,j,k,3) ! c1 = wall(i,j,k,4)   ! shear stress component ! c2 = wall(i,j,k,5)   ! shear stress component !ILS13 removed near-wall damping 25.06.2014 !if (jw >= jb-1 .and. jw <= je+1) then      ! check if jw is within the halo of this proc !  distplus = mindist(i,j,k)*sqrt(abs(shear(iw,jw,kw,c1))+abs(shear(iw,jw,kw,c2)))*numoli !  damp(i,j,k) = sqrt(1. - exp((-distplus*0.04)**3.))            ! Wall-damping according to Piomelli !else damp ( i , j , k ) = 1. !end if if (( ldelta ) . or . ( dthvdz ( i , j , k ) <= 0 )) then zlt ( i , j , k ) = delta ( i , k ) ekm ( i , j , k ) = cm * zlt ( i , j , k ) * damp ( i , j , k ) * e120 ( i , j , k ) !* 0.5! LES with near-wall damping !!! added factor 0.5 for shear-driven flow ekh ( i , j , k ) = ( ch1 + ch2 ) * ekm ( i , j , k ) ! maybe ekh should be calculated from (molecular) Prandtl number ekm ( i , j , k ) = ekm ( i , j , k ) + numol ! add molecular viscosity ekh ( i , j , k ) = ekh ( i , j , k ) + numol * prandtlmoli ! add molecular diffusivity else !            zlt(i,j,k) = min(delta(i,k),cn*e120(i,j,k)/sqrt(grav/thvs*abs(dthvdz(i,j,k)))) zlt ( i , j , k ) = min ( delta ( i , k ), cn * e120 ( i , j , k ) / sqrt ( grav / thvs * abs ( dthvdz ( i , j , k )))) !thls is used ekm ( i , j , k ) = cm * zlt ( i , j , k ) * damp ( i , j , k ) * e120 ( i , j , k ) !* 0.5     ! LES with near-wall damping !!! added factor 0.5 for shear-driven flow ekh ( i , j , k ) = ( ch1 + ch2 * zlt ( i , j , k ) / delta ( i , k )) * ekm ( i , j , k ) !  needed in LES! ekm ( i , j , k ) = ekm ( i , j , k ) + numol ! add molecular viscosity ekh ( i , j , k ) = ekh ( i , j , k ) + numol * prandtlmoli ! add molecular diffusivity endif end do end do end do damp (:,:,:) = max ( damp (:,:,:), dampmin ) ! ekm(:,:,:) = max(ekm(:,:,:),ekmin) ! ekh(:,:,:) = max(ekh(:,:,:),ekmin) else ! no subgrid model (DNS!) ekm = numol ekh = numol * prandtlmoli end if !************************************************************* !     Set boundary condition for K-closure factors.          ! Also other BC's!! !************************************************************* call closurebc return end subroutine closure subroutine sources ! only in case of LES computation !-----------------------------------------------------------------| !                                                                 | !*** *sources*                                                    | !      calculates various terms from the subgrid TKE equation     | !                                                                 | !     Hans Cuijpers   I.M.A.U.     06/01/1995                     | !                                                                 | !     purpose.                                                    | !     --------                                                    | !                                                                 | !      Subroutine sources calculates all other terms in the       | !      subgrid energy equation, except for the diffusion terms.   | !      These terms are calculated in subroutine diff.             | !                                                                 | !**   interface.                                                  | !     ----------                                                  | !                                                                 | !     *sources* is called from *program*.                         | !                                                                 | !-----------------------------------------------------------------| use modglobal , only : ib , ie , jb , je , kb , ke , dxi , delta , dy , dyi , dzfi , dzhi , grav , numol , prandtlmol ,& dzh , delta use modfields , only : u0 , v0 , w0 , e120 , e12p , dthvdz , thl0 , thvf use modsurfdata , only : dudz , dvdz , thvs !    use modmpi,       only : myid implicit none real tdef2 , prandtlmoli integer i , j , k , im , ip , jm , jp , km , kp prandtlmoli = 1. / prandtlmol do k = kb + 1 , ke do j = jb , je do i = ib , ie kp = k + 1 km = k - 1 jp = j + 1 jm = j - 1 ip = i + 1 im = i - 1 tdef2 = 2. * ( & (( u0 ( ip , j , k ) - u0 ( i , j , k )) * dxi ) ** 2 & + (( v0 ( i , jp , k ) - v0 ( i , j , k )) * dyi ) ** 2 & + (( w0 ( i , j , kp ) - w0 ( i , j , k )) * dzfi ( k ) ) ** 2 ) tdef2 = tdef2 + 0.25 * ( & (( w0 ( i , j , kp ) - w0 ( im , j , kp )) * dxi + ( u0 ( i , j , kp ) - u0 ( i , j , k )) * dzhi ( kp )) ** 2 & + (( w0 ( i , j , k ) - w0 ( im , j , k )) * dxi + ( u0 ( i , j , k ) - u0 ( i , j , km )) * dzhi ( k )) ** 2 & + (( w0 ( ip , j , k ) - w0 ( i , j , k )) * dxi + ( u0 ( ip , j , k ) - u0 ( ip , j , km )) * dzhi ( k )) ** 2 & + (( w0 ( ip , j , kp ) - w0 ( i , j , kp )) * dxi + ( u0 ( ip , j , kp ) - u0 ( ip , j , k )) * dzhi ( kp )) ** 2 ) tdef2 = tdef2 + 0.25 * ( & (( u0 ( i , jp , k ) - u0 ( i , j , k )) * dyi + ( v0 ( i , jp , k ) - v0 ( im , jp , k )) * dxi ) ** 2 & + (( u0 ( i , j , k ) - u0 ( i , jm , k )) * dyi + ( v0 ( i , j , k ) - v0 ( im , j , k )) * dxi ) ** 2 & + (( u0 ( ip , j , k ) - u0 ( ip , jm , k )) * dyi + ( v0 ( ip , j , k ) - v0 ( i , j , k )) * dxi ) ** 2 & + (( u0 ( ip , jp , k ) - u0 ( ip , j , k )) * dyi + ( v0 ( ip , jp , k ) - v0 ( i , jp , k )) * dxi ) ** 2 ) tdef2 = tdef2 + 0.25 * ( & (( v0 ( i , j , kp ) - v0 ( i , j , k )) * dzhi ( kp ) + ( w0 ( i , j , kp ) - w0 ( i , jm , kp )) * dyi ) ** 2 & + (( v0 ( i , j , k ) - v0 ( i , j , km )) * dzhi ( k ) + ( w0 ( i , j , k ) - w0 ( i , jm , k )) * dyi ) ** 2 & + (( v0 ( i , jp , k ) - v0 ( i , jp , km )) * dzhi ( k ) + ( w0 ( i , jp , k ) - w0 ( i , j , k )) * dyi ) ** 2 & + (( v0 ( i , jp , kp ) - v0 ( i , jp , k )) * dzhi ( kp ) + ( w0 ( i , jp , kp ) - w0 ( i , j , kp )) * dyi ) ** 2 ) !    sbshr(i,j,k)  = ekm(i,j,k)*tdef2/ ( 2*e120(i,j,k)) !    sbbuo(i,j,k)  = -ekh(i,j,k)*grav/thvs*dthvdz(i,j,k)/ ( 2*e120(i,j,k)) !    sbdiss(i,j,k) = - (ce1 + ce2*zlt(i,j,k)/delta(i,k)) * e120(i,j,k)**2 /(2.*zlt(i,j,k)) sbshr ( i , j , k ) = ( ekm ( i , j , k ) - numol ) * tdef2 / ( 2 * e120 ( i , j , k )) ! subtract molecular viscosity !    sbbuo(i,j,k)  = -(ekh(i,j,k)-numol*prandtlmoli)*grav/thvs*dthvdz(i,j,k)/ ( 2*e120(i,j,k))     ! subtract molecular diffusivity sbbuo ( i , j , k ) = - ( ekh ( i , j , k ) - numol * prandtlmoli ) * grav / thvs * dthvdz ( i , j , k ) / ( 2 * e120 ( i , j , k )) ! subtract molecular diffusivity and use thls instead of thvs (not defined) !    sbdiss(i,j,k) = - (ce1 + ce2*zlt(i,j,k)/delta(i,k)) * e120(i,j,k)**2 /(2.*damp*zlt(i,j,k))   ! add near-wall damping function ! added factor 2. for shear-driven flow sbdiss ( i , j , k ) = - 2. * ( ce1 + ce2 * zlt ( i , j , k ) / delta ( i , k )) * e120 ( i , j , k ) ** 2 / ( 2. * damp ( i , j , k ) * zlt ( i , j , k )) ! add near-wall damping function !! added f end do end do end do !     ----------------------------------------------end i,j,k-loop !    special treatment for lowest level ! Don't do this - wall function at bottom ! do j=jb,je !    do i=ib,ie !       jp=j+1 !       jm=j-1 !       ip=i+1 !       im=i-1 ! !       tdef2 = 2. * ( & !               ((u0(ip,j,kb) - u0(i,j,kb))*dxi)**2 & !             + ((v0(i,jp,kb) - v0(i,j,kb))*dyi)**2 & !             + ((w0(i,j,kb+1) -w0(i,j,kb))*dzfi(kb))**2 & !               ) ! !       tdef2 = tdef2 + ( 0.25*(w0(i+1,j,kb+1)-w0(i-1,j,kb+1))*dxfi(i) + dudz(i,j))**2 ! !       tdef2 = tdef2 + 0.25 * ( & !               ((u0(i ,jp,kb) - u0(i ,j ,kb)) * dyi + (v0(i ,jp,kb) - v0(im,jp,kb)) * dxi)**2 & !             + ((u0(i ,j ,kb) - u0(i ,jm,kb)) * dyi + (v0(i ,j ,kb) - v0(im,j ,kb)) * dxi)**2 & !             + ((u0(ip,j ,kb) - u0(ip,jm,kb)) * dyi + (v0(ip,j ,kb) - v0(i ,j ,kb)) * dxi)**2 & !             + ((u0(ip,jp,kb) - u0(ip,j ,kb)) * dyi + (v0(ip,jp,kb) - v0(i ,jp,kb)) * dxi)**2 & !             ) ! !       tdef2 = tdef2 + ( 0.25 * (w0(i,jp,kb+1) - w0(i,jm,kb+1)) * dyi + dvdz(i,j))**2 ! !       ! **  Include shear and buoyancy production terms and dissipation ** ! !       sbshr(i,j,kb)  = ekm(i,j,kb)*tdef2/ ( 2*e120(i,j,kb)) !       sbbuo(i,j,kb)  = -ekh(i,j,kb)*grav/thvf(kb)*dthvdz(i,j,kb)/ ( 2*e120(i,j,kb)) !       sbdiss(i,j,kb) = - (ce1 + ce2*zlt(i,j,kb)/delta(i,kb)) * e120(i,j,kb)**2 /(2.*zlt(i,j,kb)) !    end do ! end do !    ------------------------------------------------ e12p ( ib : ie , jb : je , kb : ke ) = e12p ( ib : ie , jb : je , kb : ke ) + & sbshr ( ib : ie , jb : je , kb : ke ) + sbbuo ( ib : ie , jb : je , kb : ke ) + sbdiss ( ib : ie , jb : je , kb : ke ) return end subroutine sources subroutine diffc ( hi , hj , hk , putin , putout ) use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , dx2i , dzf , dzfi , dyi , dy2i ,& dzhi , dzh2i , jmax , numol , prandtlmoli , lles use modmpi , only : myid implicit none integer , intent ( in ) :: hi !<size of halo in i integer , intent ( in ) :: hj !<size of halo in j integer , intent ( in ) :: hk !<size of halo in k real , intent ( in ) :: putin ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) real , intent ( inout ) :: putout ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ) real cekh integer i , j , k , im , ip , jm , jp , km , kp if ( lles ) then do k = kb , ke kp = k + 1 km = k - 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie ip = i + 1 im = i - 1 putout ( i , j , k ) = putout ( i , j , k ) & + 0.5 * ( & ( & ( ekh ( ip , j , k ) + ekh ( i , j , k )) * ( putin ( ip , j , k ) - putin ( i , j , k )) & - ( ekh ( i , j , k ) + ekh ( im , j , k )) * ( putin ( i , j , k ) - putin ( im , j , k )) & ) * dx2i & + ( & ( ekh ( i , jp , k ) + ekh ( i , j , k )) * ( putin ( i , jp , k ) - putin ( i , j , k )) & - ( ekh ( i , j , k ) + ekh ( i , jm , k )) * ( putin ( i , j , k ) - putin ( i , jm , k )) & ) * dy2i & + ( & ( dzf ( kp ) * ekh ( i , j , k ) + dzf ( k ) * ekh ( i , j , kp )) * ( putin ( i , j , kp ) - putin ( i , j , k )) * dzh2i ( kp ) & - ( dzf ( km ) * ekh ( i , j , k ) + dzf ( k ) * ekh ( i , j , km )) * ( putin ( i , j , k ) - putin ( i , j , km )) * dzh2i ( k ) & ) * dzfi ( k ) & ) end do end do end do else ! DNS cekh = numol * prandtlmoli do k = kb , ke kp = k + 1 km = k - 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie ip = i + 1 im = i - 1 putout ( i , j , k ) = putout ( i , j , k ) & + ( & ( & cekh * ( putin ( ip , j , k ) - putin ( i , j , k )) & - cekh * ( putin ( i , j , k ) - putin ( im , j , k )) & ) * dx2i & + ( & cekh * ( putin ( i , jp , k ) - putin ( i , j , k )) & - cekh * ( putin ( i , j , k ) - putin ( i , jm , k )) & ) * dy2i & + ( & cekh * ( putin ( i , j , kp ) - putin ( i , j , k )) * dzhi ( kp ) & - cekh * ( putin ( i , j , k ) - putin ( i , j , km )) * dzhi ( k ) & ) * dzfi ( k ) & ) end do end do end do end if ! lles=.true. end subroutine diffc subroutine diffe ( putout ) use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , dx2i , dzf , dzfi ,& dy2i , dzhi , dzh2i , jmax use modfields , only : e120 use modmpi , only : myid implicit none real , intent ( inout ) :: putout ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ) integer :: i , j , k , im , ip , jm , jp , km , kp do k = kb , ke kp = k + 1 km = k - 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie ip = i + 1 im = i - 1 putout ( i , j , k ) = putout ( i , j , k ) & + 1.0 * ( & ( & ( ekm ( ip , j , k ) + ekm ( i , j , k )) * ( e120 ( ip , j , k ) - e120 ( i , j , k )) & - ( ekm ( i , j , k ) + ekm ( im , j , k )) * ( e120 ( i , j , k ) - e120 ( im , j , k )) & ) * dx2i & + ( & ( ekm ( i , jp , k ) + ekm ( i , j , k )) * ( e120 ( i , jp , k ) - e120 ( i , j , k )) & - ( ekm ( i , j , k ) + ekm ( i , jm , k )) * ( e120 ( i , j , k ) - e120 ( i , jm , k )) & ) * dy2i & + ( & ( dzf ( kp ) * ekm ( i , j , k ) + dzf ( k ) * ekm ( i , j , kp )) * ( e120 ( i , j , kp ) - e120 ( i , j , k )) * dzh2i ( kp ) & - ( dzf ( km ) * ekm ( i , j , k ) + dzf ( k ) * ekm ( i , j , km )) * ( e120 ( i , j , k ) - e120 ( i , j , km )) * dzh2i ( k ) & ) * dzfi ( k ) & ) end do end do end do end subroutine diffe subroutine diffu ( putout ) use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , kmax , dx2i , dxi , lles ,& dzf , dzfi , dy , dyi , dy2i , dzhi , dzhiq , jmax , numol use modfields , only : u0 , v0 , w0 use modsurfdata , only : ustar use modmpi , only : myid implicit none real , intent ( inout ) :: putout ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ) real :: emmo , emom , emop , empo real :: fu , dummy real :: ucu , upcu integer :: i , j , k , jm , jp , km , kp if ( lles ) then do k = kb , ke kp = k + 1 km = k - 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie emom = ( dzf ( km ) * ( ekm ( i , j , k ) + ekm ( i - 1 , j , k ) ) + & dzf ( k ) * ( ekm ( i , j , km ) + ekm ( i - 1 , j , km ))) * dzhiq ( k ) emop = ( dzf ( kp ) * ( ekm ( i , j , k ) + ekm ( i - 1 , j , k )) + & dzf ( k ) * ( ekm ( i , j , kp ) + ekm ( i - 1 , j , kp ))) * dzhiq ( kp ) empo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , jp , k )) + ( ekm ( i - 1 , j , k ) + ekm ( i - 1 , jp , k ))) emmo = 0.25 * (( ekm ( i , j , k ) + ekm ( i , jm , k )) + ( ekm ( i - 1 , jm , k ) + ekm ( i - 1 , j , k ))) ! Discretized diffusion term putout ( i , j , k ) = putout ( i , j , k ) & + ( & ekm ( i , j , k ) * ( u0 ( i + 1 , j , k ) - u0 ( i , j , k )) & - ekm ( i - 1 , j , k ) * ( u0 ( i , j , k ) - u0 ( i - 1 , j , k )) & ) * 2. * dx2i & + ( & empo * ( & ( u0 ( i , jp , k ) - u0 ( i , j , k )) * dyi & + ( v0 ( i , jp , k ) - v0 ( i - 1 , jp , k )) * dxi & ) & - emmo * ( & ( u0 ( i , j , k ) - u0 ( i , jm , k )) * dyi & + ( v0 ( i , j , k ) - v0 ( i - 1 , j , k )) * dxi & ) & ) * dyi & + ( & emop * ( & ( u0 ( i , j , kp ) - u0 ( i , j , k )) * dzhi ( kp ) & + ( w0 ( i , j , kp ) - w0 ( i - 1 , j , kp )) * dxi ) & - emom * ( & ( u0 ( i , j , k ) - u0 ( i , j , km )) * dzhi ( k ) & + ( w0 ( i , j , k ) - w0 ( i - 1 , j , k )) * dxi ) & ) * dzfi ( k ) end do end do end do else ! DNS do k = kb , ke kp = k + 1 km = k - 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie ! Discretized diffusion term putout ( i , j , k ) = putout ( i , j , k ) & + ( & numol * ( u0 ( i + 1 , j , k ) - u0 ( i , j , k )) * dxi & - numol * ( u0 ( i , j , k ) - u0 ( i - 1 , j , k )) * dxi & ) * 2. * dxi & + ( & numol * ( & ( u0 ( i , jp , k ) - u0 ( i , j , k )) * dyi & + ( v0 ( i , jp , k ) - v0 ( i - 1 , jp , k )) * dxi & ) & - numol * ( & ( u0 ( i , j , k ) - u0 ( i , jm , k )) * dyi & + ( v0 ( i , j , k ) - v0 ( i - 1 , j , k )) * dxi & ) & ) * dyi & + ( & numol * ( & ( u0 ( i , j , kp ) - u0 ( i , j , k )) * dzhi ( kp ) & + ( w0 ( i , j , kp ) - w0 ( i - 1 , j , kp )) * dxi ) & - numol * ( & ( u0 ( i , j , k ) - u0 ( i , j , km )) * dzhi ( k ) & + ( w0 ( i , j , k ) - w0 ( i - 1 , j , k )) * dxi & ) & ) * dzfi ( k ) end do end do end do end if ! lles end subroutine diffu subroutine diffv ( putout ) use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , dxi , dzf , dzfi , dyi ,& dy2i , dzhi , dzhiq , jmax , numol , lles use modfields , only : u0 , v0 , w0 use modsurfdata , only : ustar use modmpi , only : myid implicit none real , intent ( inout ) :: putout ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ) real :: emmo , eomm , eomp , epmo real :: fv , vcv , vpcv integer :: i , j , k , jm , jp , km , kp if ( lles ) then do k = kb , ke kp = k + 1 km = k - 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie eomm = ( dzf ( km ) * ( ekm ( i , j , k ) + ekm ( i , jm , k ) ) + & dzf ( k ) * ( ekm ( i , j , km ) + ekm ( i , jm , km ) ) ) * dzhiq ( k ) eomp = ( dzf ( kp ) * ( ekm ( i , j , k ) + ekm ( i , jm , k ) ) + & dzf ( k ) * ( ekm ( i , j , kp ) + ekm ( i , jm , kp ) ) ) * dzhiq ( kp ) emmo = 0.25 * ( ekm ( i , j , k ) + ekm ( i , jm , k ) + ekm ( i - 1 , jm , k ) + ekm ( i - 1 , j , k ) ) epmo = 0.25 * ( ekm ( i , j , k ) + ekm ( i , jm , k ) + ekm ( i + 1 , jm , k ) + ekm ( i + 1 , j , k ) ) ! discretized diffusion term putout ( i , j , k ) = putout ( i , j , k ) & + ( & epmo * ( & ( v0 ( i + 1 , j , k ) - v0 ( i , j , k )) * dxi & + ( u0 ( i + 1 , j , k ) - u0 ( i + 1 , jm , k )) * dyi & ) & - emmo * ( & ( v0 ( i , j , k ) - v0 ( i - 1 , j , k )) * dxi & + ( u0 ( i , j , k ) - u0 ( i , jm , k )) * dyi & ) & ) * dxi & ! = d/dx( Km*(dv/dx + du/dy) ) + ( & ekm ( i , j , k ) * ( v0 ( i , jp , k ) - v0 ( i , j , k )) & - ekm ( i , jm , k ) * ( v0 ( i , j , k ) - v0 ( i , jm , k )) & ) * 2. * dy2i & ! = d/dy( 2*Km*(dv/dy) ) + ( & eomp * ( & ( v0 ( i , j , kp ) - v0 ( i , j , k )) * dzhi ( kp ) & + ( w0 ( i , j , kp ) - w0 ( i , jm , kp )) * dyi & ) & - eomm * ( & ( v0 ( i , j , k ) - v0 ( i , j , km )) * dzhi ( k ) & + ( w0 ( i , j , k ) - w0 ( i , jm , k )) * dyi & ) & ) * dzfi ( k ) ! = d/dz( Km*(dv/dz + dw/dy) ) end do end do end do else ! DNS do k = kb , ke kp = k + 1 km = k - 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie putout ( i , j , k ) = putout ( i , j , k ) & + ( & numol * ( & ( v0 ( i + 1 , j , k ) - v0 ( i , j , k )) * dxi & + ( u0 ( i + 1 , j , k ) - u0 ( i + 1 , jm , k )) * dyi & ) & - numol * ( & ( v0 ( i , j , k ) - v0 ( i - 1 , j , k )) * dxi & + ( u0 ( i , j , k ) - u0 ( i , jm , k )) * dyi & ) & ) * dxi & ! = d/dx( Km*(dv/dx + du/dy) ) + ( & numol * ( v0 ( i , jp , k ) - v0 ( i , j , k )) & - numol * ( v0 ( i , j , k ) - v0 ( i , jm , k )) & ) * 2. * dy2i & ! = d/dy( 2*Km*(dv/dy) ) + ( & numol * ( & ( v0 ( i , j , kp ) - v0 ( i , j , k )) * dzhi ( kp ) & + ( w0 ( i , j , kp ) - w0 ( i , jm , kp )) * dyi ) & - numol * ( & ( v0 ( i , j , k ) - v0 ( i , j , km )) * dzhi ( k ) & + ( w0 ( i , j , k ) - w0 ( i , jm , k )) * dyi & ) & ) * dzfi ( k ) ! = d/dz( Km*(dv/dz + dw/dy) ) end do end do end do end if end subroutine diffv subroutine diffw ( putout ) use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , kmax , dxi , dy ,& dyi , dy2i , dzf , dzfi , dzhi , dzhiq , jmax , numol , lles use modfields , only : u0 , v0 , w0 use modmpi , only : myid implicit none !***************************************************************** real , intent ( inout ) :: putout ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ) real :: emom , eomm , eopm , epom integer :: i , j , k , jm , jp , km , kp if ( lles ) then do k = kb + 1 , ke kp = k + 1 km = k - 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie emom = ( dzf ( km ) * ( ekm ( i , j , k ) + ekm ( i - 1 , j , k ) ) + & dzf ( k ) * ( ekm ( i , j , km ) + ekm ( i - 1 , j , km ) ) ) * dzhiq ( k ) eomm = ( dzf ( km ) * ( ekm ( i , j , k ) + ekm ( i , jm , k ) ) + & dzf ( k ) * ( ekm ( i , j , km ) + ekm ( i , jm , km ) ) ) * dzhiq ( k ) eopm = ( dzf ( km ) * ( ekm ( i , j , k ) + ekm ( i , jp , k ) ) + & dzf ( k ) * ( ekm ( i , j , km ) + ekm ( i , jp , km ) ) ) * dzhiq ( k ) epom = ( dzf ( km ) * ( ekm ( i , j , k ) + ekm ( i + 1 , j , k ) ) + & dzf ( k ) * ( ekm ( i , j , km ) + ekm ( i + 1 , j , km ) ) ) * dzhiq ( k ) ! discretized diffusion term putout ( i , j , k ) = putout ( i , j , k ) & + ( & epom * ( & ( w0 ( i + 1 , j , k ) - w0 ( i , j , k )) * dxi & + ( u0 ( i + 1 , j , k ) - u0 ( i + 1 , j , km )) * dzhi ( k ) & ) & - emom * ( & ( w0 ( i , j , k ) - w0 ( i - 1 , j , k )) * dxi & + ( u0 ( i , j , k ) - u0 ( i , j , km )) * dzhi ( k ) & ) & ) * dxi & + ( & eopm * ( & ( w0 ( i , jp , k ) - w0 ( i , j , k )) * dyi & + ( v0 ( i , jp , k ) - v0 ( i , jp , km )) * dzhi ( k ) & ) & - eomm * ( & ( w0 ( i , j , k ) - w0 ( i , jm , k )) * dyi & + ( v0 ( i , j , k ) - v0 ( i , j , km )) * dzhi ( k ) & ) & ) * dyi & + ( & ekm ( i , j , k ) * ( w0 ( i , j , kp ) - w0 ( i , j , k )) * dzfi ( k ) & - ekm ( i , j , km ) * ( w0 ( i , j , k ) - w0 ( i , j , km )) * dzfi ( km ) & ) * 2. * dzhi ( k ) end do end do end do else ! DNS do k = kb + 1 , ke kp = k + 1 km = k - 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie ! discretized diffusion term putout ( i , j , k ) = putout ( i , j , k ) & + ( & numol * ( & ( w0 ( i + 1 , j , k ) - w0 ( i , j , k )) * dxi & + ( u0 ( i + 1 , j , k ) - u0 ( i + 1 , j , km )) * dzhi ( k ) & ) & - numol * ( & ( w0 ( i , j , k ) - w0 ( i - 1 , j , k )) * dxi & + ( u0 ( i , j , k ) - u0 ( i , j , km )) * dzhi ( k ) & ) & ) * dxi & + ( & numol * ( & ( w0 ( i , jp , k ) - w0 ( i , j , k )) * dyi & + ( v0 ( i , jp , k ) - v0 ( i , jp , km )) * dzhi ( k ) ) & - numol * ( & ( w0 ( i , j , k ) - w0 ( i , jm , k )) * dyi & + ( v0 ( i , j , k ) - v0 ( i , j , km )) * dzhi ( k ) & ) & ) * dyi & + ( & numol * ( w0 ( i , j , kp ) - w0 ( i , j , k )) * dzfi ( k ) & - numol * ( w0 ( i , j , k ) - w0 ( i , j , km )) * dzfi ( km ) & ) * 2. * dzhi ( k ) end do end do end do end if end subroutine diffw end module modsubgrid","tags":"","url":"sourcefile/modsubgrid.f90.html"},{"title":"initfac.f90 – uDALES","text":"This file depends on sourcefile~~initfac.f90~~EfferentGraph sourcefile~initfac.f90 initfac.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~initfac.f90->sourcefile~modglobal.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~initfac.f90->sourcefile~modmpi.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~initfac.f90~~AfferentGraph sourcefile~initfac.f90 initfac.f90 sourcefile~advec_2nd.f90 advec_2nd.f90 sourcefile~advec_2nd.f90->sourcefile~initfac.f90 sourcefile~modibm.f90 modibm.f90 sourcefile~advec_2nd.f90->sourcefile~modibm.f90 sourcefile~modeb.f90 modEB.f90 sourcefile~modeb.f90->sourcefile~initfac.f90 sourcefile~modibm.f90->sourcefile~initfac.f90 sourcefile~modboundary.f90 modboundary.f90 sourcefile~modibm.f90->sourcefile~modboundary.f90 sourcefile~modsave.f90 modsave.f90 sourcefile~modsave.f90->sourcefile~initfac.f90 sourcefile~modtimedep.f90 modtimedep.f90 sourcefile~modtimedep.f90->sourcefile~initfac.f90 sourcefile~program.f90 program.f90 sourcefile~program.f90->sourcefile~initfac.f90 sourcefile~program.f90->sourcefile~modeb.f90 sourcefile~program.f90->sourcefile~modibm.f90 sourcefile~program.f90->sourcefile~modsave.f90 sourcefile~program.f90->sourcefile~modtimedep.f90 sourcefile~moddriver.f90 moddriver.f90 sourcefile~program.f90->sourcefile~moddriver.f90 sourcefile~modfielddump.f90 modfielddump.f90 sourcefile~program.f90->sourcefile~modfielddump.f90 sourcefile~modstartup.f90 modstartup.f90 sourcefile~program.f90->sourcefile~modstartup.f90 sourcefile~program.f90->sourcefile~modboundary.f90 sourcefile~modsubgrid.f90 modsubgrid.f90 sourcefile~program.f90->sourcefile~modsubgrid.f90 sourcefile~modstatsdump.f90 modstatsdump.f90 sourcefile~program.f90->sourcefile~modstatsdump.f90 sourcefile~wf_gr.f90 wf_gr.f90 sourcefile~wf_gr.f90->sourcefile~initfac.f90 sourcefile~wf_uno.f90 wf_uno.f90 sourcefile~wf_uno.f90->sourcefile~initfac.f90 sourcefile~wfmneutral.f90 wfmneutral.f90 sourcefile~wfmneutral.f90->sourcefile~initfac.f90 sourcefile~moddriver.f90->sourcefile~modsave.f90 sourcefile~modfielddump.f90->sourcefile~modibm.f90 sourcefile~modinlet.f90 modinlet.f90 sourcefile~modinlet.f90->sourcefile~modsave.f90 sourcefile~modstartup.f90->sourcefile~modibm.f90 sourcefile~modstartup.f90->sourcefile~modtimedep.f90 sourcefile~modstartup.f90->sourcefile~moddriver.f90 sourcefile~modstartup.f90->sourcefile~modinlet.f90 sourcefile~modstartup.f90->sourcefile~modboundary.f90 sourcefile~modstartup.f90->sourcefile~modsubgrid.f90 sourcefile~modboundary.f90->sourcefile~moddriver.f90 sourcefile~modsubgrid.f90->sourcefile~modboundary.f90 sourcefile~modstatsdump.f90->sourcefile~modsubgrid.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !!> \\file b2f.f90 !!  \\author Ivo Suter ! !   reads the necessary input files to deal with facets ! !   WARNING: if walls with more than 3 layers (4 points) are to be considered, this file needs to be changed !            e.g. factypes needs to read 7+4*nlayers columns, offsets in reading facet properties also change accordingly ! !  This file is part of uDALES. ! ! This program is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! This program is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !  Copyright 2006-2021 the uDALES Team. ! !> Advection redirection function module initfac use mpi use modglobal , only : ifinput , nfcts , cexpnr , libm , bldT , flrT , rsmin , wsoil , wfc , & nfaclyrs , block , lEB , lvfsparse , nnz , lfacTlyrs , lwritefac use modmpi , only : myid , comm3d , mpierr , MY_REAL , nprocs , cmyid use netcdf implicit none public :: readfacetfiles , qsat , dqsatdT , netsw save !integer, allocatable :: block(:, :) !block coordinates and facet Nr corresponding to block faces !facet properties logical , allocatable :: faclGR (:) !logic array, is it a green (vegetated) facet? real , allocatable :: facz0 (:) !roughness for momentum on facets real , allocatable :: facz0h (:) !roughness for heat and moisture on facets real , allocatable :: facalb (:) !facet shortwave albedo real , allocatable :: facem (:) !facet longwave emissivity of all 5 faces of the blocks real , allocatable :: facd (:,:) !facet thickness real , allocatable :: faccp (:, :) !facet specific heat capacity real , allocatable :: faclam (:, :) !inverse facet heat conductivity real , allocatable :: fackappa (:, :) !facet heat diffusivity (lambda/(rho cp)) real , allocatable :: faca (:) !facet area !integer, allocatable :: facain(:) !facet area as sum of indeces integer , allocatable :: facets (:) !facet orientation, walltype, block and building Nr real , allocatable :: facnorm (:,:) real , allocatable :: factypes (:, :) !the defined wall and rooftypes with properties !radiation real , allocatable :: vf (:, :) !viewfactors between facets real , allocatable :: svf (:) !sky-viewfactor of facets real , allocatable :: netsw (:) !net shortwave radiation on facets real , allocatable :: facLWin (:) !incoming longwave on facets [W/m2] real , allocatable :: vfsparse (:) real , allocatable :: ivfsparse (:) real , allocatable :: jvfsparse (:) !temperature real , allocatable :: Tfacinit (:) !initial facet temperatures real , allocatable :: Tfacinit_layers (:,:) !initial facet temperatures real , allocatable :: facT (:, :) !wall temperatures on surfaces and between layers (1=outdoors,end=indoors) real , allocatable :: facTdash (:, :) !temperature gradient dT/dz !fluxes real , allocatable :: facef (:) !evaporative flux on facets [W/m2] (single processor) real , allocatable :: facefi (:) !time integrated latent heat flux [J/m2] (used in modEB) real , allocatable :: facefsum (:) !evaporative flux on facets [W/m2] (sum over all processors) real , allocatable :: fachf (:) !heat flux on facets [Km/s] (single processor) real , allocatable :: fachfi (:) !time integrated heat flux [Km] real , allocatable :: fachfsum (:) !heat flux on facets [Km/s] (sum over all processors) !GR real , allocatable :: facf (:, :) !dependence of stomatal resistance/soil resistance real , allocatable :: fachurel (:) !relative humidity at ground surface real , allocatable :: facwsoil (:) !soil moisture of facets real , allocatable :: faccth (:) !sum of all transfer coefficients of the facet, used in Penman Moneith, unused real , allocatable :: facqsat (:) !saturation absoulute humidity at facet temperature !misc integer , allocatable :: typeloc (:) !array to match the walltype to sequential integers for indexing integer :: nfactypes = 0 !number of different factypes, will be determined automatically character ( 80 ) :: chmess !dummy character string integer :: nfacprops contains subroutine readfacetfiles use modglobal , only : block , cexpnr , iwallmom , iwalltemp , iwallmoist implicit none !use modglobal, only:block !read initial&unchangeable facet values from files !read blocks and facet Nr corresponding to block faces (Order: Top, West, East, North, South) !define facets with properties and initial temperature !read facets.inp.xxx facetarea.inp.xxx vf.inp.xxx factypes.inp.xxx !read netsw.inp.xxx (if sun is not constant, K needs to be calculated at every EB-timestep) !read tfacinit.inp.xxx !use modglobal, only : nblocks, nfcts, cexpnr, ifinput character ( len = 13 ) :: FILE_VF = 'vf.nc.inp.xxx' integer :: ncid , varid integer :: n = 0 , m = 0 , i = 0 , j = 0 , k = 0 , io = 0 integer :: iret if (. not .( nfcts > 0 )) return nfacprops = 6 + 4 * nfaclyrs + 1 ! used by LES solver - needed on every rank allocate ( facets ( nfcts )); facets = 0 allocate ( facnorm ( nfcts , 3 )); facnorm = 0. allocate ( facz0 ( 0 : nfcts )); facz0 = 0. allocate ( facz0h ( 0 : nfcts )); facz0h = 0. allocate ( faca ( 0 : nfcts )); faca = 0. allocate ( faclGR ( 0 : nfcts )); faclGR = . false . ! only used by SEB if ( myid == 0 ) then !allocate (facalb(0:nfcts)); facalb = 0. allocate ( facem ( 0 : nfcts )); facem = 0. allocate ( facd ( 0 : nfcts , nfaclyrs )); facd = 0. allocate ( faccp ( 0 : nfcts , nfaclyrs )); faccp = 0. allocate ( faclam ( 0 : nfcts , nfaclyrs + 1 )); faclam = 0. !allocate (fackappa(0:nfcts, nfaclyrs+1)); fackappa = 0. end if ! quantities needed when temperature/humidity of facets is specified if ( lEB . or . iwallmom == 2 . or . iwalltemp == 2 . or . iwallmoist == 2 ) then allocate ( facT ( 0 : nfcts , nfaclyrs + 1 )); facT = 0. allocate ( fachurel ( 0 : nfcts )); fachurel = 0 ; allocate ( facqsat ( 0 : nfcts )); facqsat = 0 ; allocate ( facf ( 0 : nfcts , 5 )); facf = 0. ; facf (:, 4 ) = 20 0. ; facf (:, 5 ) = 5 0. ! standard plant & soil resistance for grass (Manickathan2018) in s/m if ( myid == 0 ) then allocate ( Tfacinit ( 1 : nfcts )); Tfacinit = 0. allocate ( Tfacinit_layers ( 1 : nfcts , nfaclyrs )) end if end if ! quantities associated with surface energy balance if ( lEB ) then allocate ( fachf ( 0 : nfcts )); fachf = 0. allocate ( facef ( 1 : nfcts )); facef = 0. allocate ( fachfsum ( 1 : nfcts )); fachfsum = 0. allocate ( facefsum ( 1 : nfcts )); facefsum = 0. if ( myid == 0 ) then allocate ( facTdash ( 1 : nfcts , nfaclyrs + 1 )); facTdash = 0. allocate ( fachfi ( 0 : nfcts )); fachfi = 0. allocate ( facefi ( 1 : nfcts )); facefi = 0. allocate ( facwsoil ( 0 : nfcts )); facwsoil = 0 ; allocate ( svf ( 1 : nfcts )); svf = 0. allocate ( netsw ( 1 : nfcts )); netsw = 0. allocate ( facLWin ( 1 : nfcts )); facLWin = 0. if ( lvfsparse ) then allocate ( ivfsparse ( 1 : nnz )); ivfsparse = 0 allocate ( jvfsparse ( 1 : nnz )); jvfsparse = 0 allocate ( vfsparse ( 1 : nnz )); vfsparse = 0. else allocate ( vf ( 1 : nfcts , 1 : nfcts )); vf = 0. end if end if end if ! Read files if ( myid == 0 . and . libm ) then nfactypes = - 3 !3 lines as headers open ( ifinput , file = 'factypes.inp.' // cexpnr ) do read ( ifinput , * , iostat = io ) if ( io /= 0 ) exit nfactypes = nfactypes + 1 end do close ( ifinput ) end if call MPI_BCAST ( nfactypes , 1 , MPI_Integer , 0 , comm3d , mpierr ) allocate ( factypes ( 1 : nfactypes , nfacprops )) if ( myid == 0 . and . libm ) then open ( ifinput , file = 'factypes.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess read ( ifinput , '(a80)' ) chmess read ( ifinput , '(a80)' ) chmess do n = 1 , nfactypes read ( ifinput , * ) ( factypes ( n , m ), m = 1 , nfacprops ) end do close ( ifinput ) end if call MPI_BCAST ( factypes , nfacprops * nfactypes , MY_REAL , 0 , comm3d , mpierr ) !create an array mapping factypes to sequential integers for indexing !e.g. lets assume walltype -3,-1,1,2,3 and 5 are defined. !index: [-3,-2,-1,0,1,2,3,4,5]  -> [-3,-2,-1,0,1,2,3,4,5] !value: [ 0, 0, 0,0,0,0,0,0,0]  -> [ 1, 0, 2,0,3,4,5,0,6] allocate ( typeloc ( int ( minval ( factypes (:, 1 ))): int ( maxval ( factypes (:, 1 ))))) if ( myid . eq . 0 . and . libm ) then typeloc = 0 do n = 1 , nfactypes typeloc ( int ( factypes ( n , 1 ))) = n end do open ( ifinput , file = 'facets.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess do n = 1 , nfcts read ( ifinput , * ) facets ( n ), facnorm ( n , 1 ), facnorm ( n , 2 ), facnorm ( n , 3 ) end do close ( ifinput ) do n = 1 , nfcts i = typeloc ( facets ( n )) faclGR ( n ) = ( abs ( factypes ( i , 2 ) - 1.00 ) < 1.0D-5 ) !logic for green surface, conversion from real to logical facz0 ( n ) = factypes ( i , 3 ) !surface momentum roughness facz0h ( n ) = factypes ( i , 4 ) !surface heat & moisture roughness !facalb(n) = factypes(i, 5) !surface shortwave albedo facem ( n ) = factypes ( i , 6 ) !surface longwave emissivity if ( facets ( n ) < - 100 ) then !it's a bounding wall, or more generally a facet for which we don't want to model SEB do j = 1 , nfaclyrs facd ( n , j ) = 0. faclam ( n , j ) = 0. faccp ( n , j ) = 0. end do else do j = 1 , nfaclyrs !for all layers facd ( n , j ) = factypes ( i , 6 + j ) !facet thickness of layer j faccp ( n , j ) = factypes ( i , 6 + nfaclyrs + j ) !specific heat capacity of layer j !faclam(n, j) = factypes(i, 6 + 2 * nfaclyrs + j) !heat conductivity of layer j end do faclam ( n , 1 ) = factypes ( i , 6 + 2 * nfaclyrs + 1 ) do j = 2 , nfaclyrs faclam ( n , j ) = ( factypes ( i , 6 + 2 * nfaclyrs + j - 1 ) + factypes ( i , 6 + 2 * nfaclyrs + j )) / 2. !inverse of heat conductivity of layer j end do end if faclam ( n , nfaclyrs + 1 ) = faclam ( n , nfaclyrs ) ! do j= 1,nfaclyrs+1 !   fackappa(n, j) = factypes(i, 6 + 3 * nfaclyrs + j) !heat diffusivity of layer 1 ! end do end do if ( lEB . or . lwritefac ) then ! read facet areas open ( ifinput , file = 'facetarea.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess do n = 1 , nfcts read ( ifinput , * ) & faca ( n ) end do close ( ifinput ) end if if ( lEB ) then if ( lvfsparse ) then open ( ifinput , file = 'vfsparse.inp.' // cexpnr ) do n = 1 , nnz read ( ifinput , * ) ivfsparse ( n ), jvfsparse ( n ), vfsparse ( n ) end do close ( ifinput ) else FILE_VF = 'vf.nc.inp.' // cexpnr iret = nf90_open ( FILE_VF , NF90_NOWRITE , ncid ) ! Get the varid of the data variable, based on its name. iret = nf90_inq_varid ( ncid , \"view factor\" , varid ) ! Read the data. iret = nf90_get_var ( ncid , varid , vf ) end if ! read skyviewfactors open ( ifinput , file = 'svf.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess do n = 1 , nfcts read ( ifinput , * ) & svf ( n ) end do close ( ifinput ) ! read net shortwave radiation open ( ifinput , file = 'netsw.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess do n = 1 , nfcts read ( ifinput , * ) & netsw ( n ) end do close ( ifinput ) do n = 1 , nfcts if ( faclGR ( n )) then facwsoil ( n ) = wsoil end if end do end if !lEB if (( lEB ) . or . ( iwalltemp == 2 ) . or . ( iwallmom == 2 ) . or . ( iwallmoist == 2 )) then ! initial facet temperatures if ( lfacTlyrs ) then open ( ifinput , file = 'Tfacinit_layers.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess do n = 1 , nfcts read ( ifinput , * ) ( Tfacinit_layers ( n , j ), j = 1 , nfaclyrs ) end do close ( ifinput ) do n = 1 , nfcts do j = 1 , nfaclyrs facT ( n , j ) = Tfacinit_layers ( n , j ) end do if ( facets ( n ) > 0 ) then ! Not a floor facT ( n , nfaclyrs + 1 ) = bldT else !floor facT ( n , nfaclyrs + 1 ) = flrT end if end do else open ( ifinput , file = 'Tfacinit.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess do n = 1 , nfcts read ( ifinput , * ) & Tfacinit ( n ) end do close ( ifinput ) do n = 1 , nfcts facT ( n , 1 ) = Tfacinit ( n ) !building surfaces is given an initial temperature if ( facets ( n ) > 0 ) then ! Not a floor facT ( n , nfaclyrs + 1 ) = bldT !inner most layer has the same temperature as the building interior do j = 2 , nfaclyrs facT ( n , j ) = Tfacinit ( n ) - ( Tfacinit ( n ) - bldT ) / nfaclyrs * ( j - 1 ) !scale linearly inside the wall end do else !floor facT ( n , nfaclyrs + 1 ) = flrT !inner most layer has the same temperature as the ground do j = 2 , nfaclyrs facT ( n , j ) = Tfacinit ( n ) - ( Tfacinit ( n ) - flrT ) / nfaclyrs * ( j - 1 ) !scale linearly inside the wall end do end if end do end if ! lfacTlyrs do n = 1 , nfaclyrs facT ( 0 , n ) = 28 8. end do facT ( 0 , nfaclyrs + 1 ) = 29 9. ! assign initial soil moisture for outermost layer do n = 1 , nfcts facqsat ( n ) = qsat ( facT ( n , 1 )) if ( faclGR ( n )) then fachurel ( n ) = 0.5 * ( 1. - cos ( 3.14159 * wsoil / wfc )) end if end do end if !((lEB) .or. (iwalltemp == 2) .or. (iwallmoist==2)) end if !(myid .eq. 0) call MPI_BCAST ( facz0 ( 0 : nfcts ), nfcts + 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( facz0h ( 0 : nfcts ), nfcts + 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( faca ( 0 : nfcts ), nfcts + 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( facets , nfcts , MPI_Integer , 0 , comm3d , mpierr ) call MPI_BCAST ( facnorm , nfcts * 3 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( faclGR ( 0 : nfcts ), nfcts + 1 , mpi_logical , 0 , comm3d , mpierr ) !call MPI_BCAST(facalb(0:nfcts), nfcts + 1, MY_REAL, 0, comm3d, mpierr) !call MPI_BCAST(facem(0:nfcts), nfcts + 1, MY_REAL, 0, comm3d, mpierr) !call MPI_BCAST(facd(0:nfcts,1:nfaclyrs),(nfcts+1)*nfaclyrs, MY_REAL, 0, comm3d, mpierr) !call MPI_BCAST(faccp(0:nfcts, 1:nfaclyrs), (nfcts + 1)*nfaclyrs, MY_REAL, 0, comm3d, mpierr) !call MPI_BCAST(faclam(0:nfcts, 1:nfaclyrs), (nfcts + 1)*nfaclyrs, MY_REAL, 0, comm3d, mpierr) !call MPI_BCAST(fackappa(0:nfcts, 1:nfaclyrs+1), (nfcts + 1)*(nfaclyrs+1), MY_REAL, 0, comm3d, mpierr) if ( lEB ) then ! no need to broadcast - only used by rank 0 !call MPI_BCAST(svf(1:nfcts), nfcts, MY_REAL, 0, comm3d, mpierr) !call MPI_BCAST(netsw(1:nfcts), nfcts, MY_REAL, 0, comm3d, mpierr) ! no need to broadcast - not dependent on input files !call MPI_BCAST(facTdash(1:nfcts, 1:nfaclyrs+1), (nfcts)*(nfaclyrs+1), MY_REAL, 0, comm3d, mpierr) !call MPI_BCAST(facef(1:nfcts), nfcts, MY_REAL, 0, comm3d, mpierr) !call MPI_BCAST(facefi(1:nfcts), nfcts, MY_REAL, 0, comm3d, mpierr) !call MPI_BCAST(facefsum(1:nfcts), nfcts, MY_REAL, 0, comm3d, mpierr) !call MPI_BCAST(fachf(0:nfcts), nfcts + 1, MY_REAL, 0, comm3d, mpierr) !call MPI_BCAST(fachfi(0:nfcts), nfcts + 1, MY_REAL, 0, comm3d, mpierr) !call MPI_BCAST(fachfsum(1:nfcts), nfcts, MY_REAL, 0, comm3d, mpierr) !call MPI_BCAST(facwsoil(0:nfcts), nfcts + 1, MY_REAL, 0, comm3d, mpierr) !call MPI_BCAST(facf(0:nfcts, 1:5), (nfcts + 1)*5, MY_REAL, 0, comm3d, mpierr) end if if (( lEB ) . or . ( iwalltemp == 2 ) . or . ( iwallmom == 2 )) then call MPI_BCAST ( facT ( 0 : nfcts , 1 : nfaclyrs + 1 ), ( nfcts + 1 ) * ( nfaclyrs + 1 ), MY_REAL , 0 , comm3d , mpierr ) !call MPI_BCAST(Tfacinit(1:nfcts), nfcts, MY_REAL, 0, comm3d, mpierr) call MPI_BCAST ( fachurel ( 0 : nfcts ), nfcts + 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( facqsat ( 0 : nfcts ), nfcts + 1 , MY_REAL , 0 , comm3d , mpierr ) if ( myid == 0 ) then deallocate ( Tfacinit ) deallocate ( Tfacinit_layers ) end if end if end subroutine readfacetfiles real function qsat ( T ) implicit none real , intent ( in ) :: T real :: gres gres = 61 1.00 * exp ( 1 7.27 * ( T - 27 3.15 ) / ( T - 3 5.85 )) ![Pa] Bolton 1980 qsat = 0.62198 * 0.01 * gres / ( 1000 - 0.01 * gres ) ![kg/kg] Murphy & Koop 2005 !1000 can be replaced with actual air pressure if desired end function qsat real function dqsatdT ( T ) implicit none real , intent ( in ) :: T dqsatdT = 0.1384832710e-2 + 0.7708409674e-4 * ( T - 300 ) + 0.2022064593e-5 * ( T - 300 ) ** 2 + 0.000000036561 * ( T - 300 ) ** 3 !expansion of qsat(T) end function dqsatdt end module initfac","tags":"","url":"sourcefile/initfac.f90.html"},{"title":"modinletdata.f90 – uDALES","text":"Files dependent on this one sourcefile~~modinletdata.f90~~AfferentGraph sourcefile~modinletdata.f90 modinletdata.f90 sourcefile~modboundary.f90 modboundary.f90 sourcefile~modboundary.f90->sourcefile~modinletdata.f90 sourcefile~moddriver.f90 moddriver.f90 sourcefile~modboundary.f90->sourcefile~moddriver.f90 sourcefile~moddriver.f90->sourcefile~modinletdata.f90 sourcefile~modsave.f90 modsave.f90 sourcefile~moddriver.f90->sourcefile~modsave.f90 sourcefile~modinlet.f90 modinlet.f90 sourcefile~modinlet.f90->sourcefile~modinletdata.f90 sourcefile~modinlet.f90->sourcefile~modsave.f90 sourcefile~modsave.f90->sourcefile~modinletdata.f90 sourcefile~modstartup.f90 modstartup.f90 sourcefile~modstartup.f90->sourcefile~modinletdata.f90 sourcefile~modstartup.f90->sourcefile~modboundary.f90 sourcefile~modstartup.f90->sourcefile~moddriver.f90 sourcefile~modstartup.f90->sourcefile~modinlet.f90 sourcefile~modsubgrid.f90 modsubgrid.f90 sourcefile~modstartup.f90->sourcefile~modsubgrid.f90 sourcefile~modibm.f90 modibm.f90 sourcefile~modstartup.f90->sourcefile~modibm.f90 sourcefile~modsubgrid.f90->sourcefile~modinletdata.f90 sourcefile~modsubgrid.f90->sourcefile~modboundary.f90 sourcefile~tstep.f90 tstep.f90 sourcefile~tstep.f90->sourcefile~modinletdata.f90 sourcefile~modibm.f90->sourcefile~modboundary.f90 sourcefile~modstatsdump.f90 modstatsdump.f90 sourcefile~modstatsdump.f90->sourcefile~modsubgrid.f90 sourcefile~program.f90 program.f90 sourcefile~program.f90->sourcefile~modboundary.f90 sourcefile~program.f90->sourcefile~moddriver.f90 sourcefile~program.f90->sourcefile~modsave.f90 sourcefile~program.f90->sourcefile~modstartup.f90 sourcefile~program.f90->sourcefile~modsubgrid.f90 sourcefile~program.f90->sourcefile~modibm.f90 sourcefile~program.f90->sourcefile~modstatsdump.f90 sourcefile~modfielddump.f90 modfielddump.f90 sourcefile~program.f90->sourcefile~modfielddump.f90 sourcefile~advec_2nd.f90 advec_2nd.f90 sourcefile~advec_2nd.f90->sourcefile~modibm.f90 sourcefile~modfielddump.f90->sourcefile~modibm.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! !!  \\author Jasper Tomas,TU Delft, 31 March 2014 !!  \\par Revision list !!  \\todo Documentation ! !  This file is part of DALES. ! ! DALES is free software; you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation; either version 3 of the License, or ! (at your option) any later version. ! ! DALES is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !  Copyright 1993-2009 Delft University of Technology, Wageningen University, Utrecht University, KNMI ! module modinletdata implicit none save real , allocatable :: storeu0inletbc (:,:,:) real , allocatable :: storev0inletbc (:,:,:) real , allocatable :: storew0inletbc (:,:,:) real , allocatable :: storet0inletbc (:,:,:) real , allocatable :: u0rot (:,:,:) ! dummy variable to eventually rotate u0 in horizontal plane real , allocatable :: v0rot (:,:,:) ! dummy variable to eventually rotate v0 in horizontal plane real , allocatable :: Utav (:,:) !< j-averaged and time averaged mean velocity real , allocatable :: QLtav (:,:) !< j-averaged and time averaged mean velocity real , allocatable :: QTtav (:,:) !< j-averaged and time averaged mean velocity real , allocatable :: Ttav (:,:) !< j-averaged and time averaged mean temperature real , allocatable :: uaver (:,:) !< j-averaged  mean velocity real , allocatable :: taver (:,:) !< j-averaged  mean temperature real , allocatable :: u0inletbc (:,:) !< final computed inlet bc for u real , allocatable :: v0inletbc (:,:) !< final computed inlet bc for v real , allocatable :: w0inletbc (:,:) !< final computed inlet bc for t real , allocatable :: t0inletbc (:,:) !< final computed inlet bc for w real , allocatable :: u0inletbcold (:,:) !< old final computed inlet bc for u real , allocatable :: v0inletbcold (:,:) !< old final computed inlet bc for v real , allocatable :: w0inletbcold (:,:) !< old final computed inlet bc for w real , allocatable :: t0inletbcold (:,:) !< old final computed inlet bc for t real , allocatable :: uminletbc (:,:) !< final computed inlet bc for u real , allocatable :: vminletbc (:,:) !< final computed inlet bc for v real , allocatable :: wminletbc (:,:) !< final computed inlet bc for w real , allocatable :: tminletbc (:,:) !< final computed inlet bc for t real , allocatable :: Uinl (:) !< mean inlet u-velocity (time-averaged and y-averaged) real , allocatable :: QLinl (:) !< mean inlet u-velocity (time-averaged and y-averaged) real , allocatable :: QTinl (:) !< mean inlet u-velocity (time-averaged and y-averaged) real , allocatable :: Winl (:) !< mean inlet w-velocity  (time-averaged and y-averaged) real , allocatable :: Tinl (:) !< mean inlet temperature  (time-averaged and y-averaged) real , allocatable :: Urec (:) !< mean recycle u-velocity (time-averaged and y-averaged) real , allocatable :: QLrec (:) !< mean recycle u-velocity (time-averaged and y-averaged) real , allocatable :: QTrec (:) !< mean recycle u-velocity (time-averaged and y-averaged) real , allocatable :: Wrec (:) !< mean recycle w-velocity  (time-averaged and y-averaged) real , allocatable :: Trec (:) !< mean recycle temperature  (time-averaged and y-averaged) real , allocatable :: zirf (:) !< zf-coordinate at recycle station (inner scaling) real , allocatable :: ziif (:) !< zf-coordinate at inlet station (inner scaling) real , allocatable :: zirh (:) !< zh-coordinate at recycle station (inner scaling) real , allocatable :: ziih (:) !< zh-coordinate at inlet station (inner scaling) real , allocatable :: zorf (:) !< zf-coordinate at recycle station (outer scaling) real , allocatable :: zoif (:) !< zf-coordinate at inlet station (outer scaling) real , allocatable :: zorh (:) !< zh-coordinate at recycle station (outer scaling) real , allocatable :: zoih (:) !< zh-coordinate at inlet station (outer scaling) real , allocatable :: zotr (:) !< zf-coordinate at recycle station (temperature outer scaling) real , allocatable :: zoti (:) !< zf-coordinate at inlet station (temperature outer scaling) real , allocatable :: displ (:) !< displacement thickness real , allocatable :: displold (:) !< old displacement thickness real , allocatable :: upupavinl (:) !< j-averaged time-averaged u'u' at the inlet real , allocatable :: vpvpavinl (:) !< j-averaged time-averaged v'v' at the inlet real , allocatable :: wpwpavinl (:) !< j-averaged time-averaged w'w' at the inlet real , allocatable :: upwpavinl (:) !< j-averaged time-averaged u'w' at the inlet real , allocatable :: thlpthlpavinl (:) !< j-averaged time-averaged thl'thl' at the inlet real , allocatable :: thlpupavinl (:) !< j-averaged time-averaged thl'u' at the inlet real , allocatable :: thlpwpavinl (:) !< j-averaged time-averaged thl'w' at the inlet real , allocatable :: qlpqlpavinl (:) !< j-averaged time-averaged thl'thl' at the inlet real , allocatable :: qlpupavinl (:) !< j-averaged time-averaged thl'u' at the inlet real , allocatable :: qlpwpavinl (:) !< j-averaged time-averaged thl'w' at the inlet real , allocatable :: qtpqtpavinl (:) !< j-averaged time-averaged thl'thl' at the inlet real , allocatable :: qtpupavinl (:) !< j-averaged time-averaged thl'u' at the inlet real , allocatable :: qtpwpavinl (:) !< j-averaged time-averaged thl'w' at the inlet real , allocatable :: zfin (:) ! zf from inlet simulation real , allocatable :: zhin (:) ! zh from inlet simulation real , allocatable :: dzfin (:) ! dzf from inlet simulation real , allocatable :: dzhin (:) ! dzh from inlet simulation real , allocatable :: heavif (:) !< Heaviside function for u,v real , allocatable :: heavih (:) !< Heaviside function for w real , allocatable :: heavit (:) !< Heaviside function for t integer , allocatable :: loclowif (:) !< index of lower zir at full level integer , allocatable :: locupif (:) !< index of upper zir at full level integer , allocatable :: loclowih (:) !< index of lower zir at half level integer , allocatable :: locupih (:) !< index of upper zir at half level integer , allocatable :: loclowof (:) !< index of lower zor at full level integer , allocatable :: locupof (:) !< index of upper zor at full level integer , allocatable :: loclowoh (:) !< index of lower zor at half level integer , allocatable :: locupoh (:) !< index of upper zor at half level integer , allocatable :: loclowot (:) !< index of lower zot at full level integer , allocatable :: locupot (:) !< index of upper zot at full level integer , allocatable :: linlf (:) !< index of lower zfin integer , allocatable :: linuf (:) !< index of upper zfin integer , allocatable :: linlh (:) !< index of lower zhin integer , allocatable :: linuh (:) !< index of upper zhin real :: di = 0.09 !< delta at inlet  (should be prescribed in namoptions!)  corresponds to critertion 0.99 !    real :: di=0.12        !< delta at inlet  (should be prescribed in namoptions!)  corresponds to critertion 1.0 !    real :: di=0.0645        !< delta at inlet  (should be prescribed in namoptions!) corresponds to criterion 0.95 !    real :: di=0.100       !< delta at inlet  (should be prescribed in namoptions!) real :: di_test !< measured delta at the inlet real :: dti_test !< measured deltat at the inlet real :: dr !< delta at recycle station real :: dti !< delta_t at inlet real :: dtr !< delta_t at recycle real :: thetai !< momentum thickness at inlet real :: thetar !< momentum thickness at recycle real :: thetati !< enthalpy thickness at inlet real :: thetatr !< enthalpy thickness at recycle real :: utaui !< u_tau at inlet real :: utaur !< u_tau at recycle real :: ttaui !< t_tau at inlet real :: ttaur !< t_tau at recycle real :: lmoi !< Obukhov length at inlet real :: lmor !< Obukhov length at recycle real :: q0 !< wall heat flux at recycle real :: deltat = 0. !< full time step (set to zero at start of sim) real :: ubulk = 0. !< Bulk velocity (to be determined at first time step) real :: vbulk = 0. !< Bulk velocity (to be determined at first time step) real :: totalu = 0. !< Bulk velocity inlet real :: totaluold = 0. !< old bulk velocity inlet real :: ddispdx = 0. !< spatial variation of displacement thickness (d/dx(delta*)) real :: ddispdxold = 0. !< old ddispdx real :: wtop = 0. !< mean vertical velocity at top read from zgrid.inf real :: xfm !< mean (xf) real :: xf2m !< mean (xf&#94;2) !    real :: dtin=0.0055  !< time step used in inletgenerator real :: dtin !< time step used in inletgenerator real :: elapstep = 0. !< elapsed time in this time step. (used in time interpolation whe reading inletfiles) real :: totalreadu !< bulk velocity of inlet data (computed once at first time step) real :: iangle !< inflow angle in radians (change with respect to inlet velocity that is read in) real :: iangledeg = 0. !< inflow angle in degrees (change with respect to inlet velocity that is read in) ! Needed for interpolation in y-direction integer :: jgbin integer :: jgein integer :: jgtotinl !< total number of cells in y-direction of inlet files (all procs together) integer :: jbin integer :: jein integer :: jtotin integer :: jbdum integer :: jedum integer :: jtotdum integer :: filenumstart integer :: filenumend integer :: filestoread integer :: procinlo integer :: procinup integer :: jend integer :: jgend integer :: jbeg integer :: jgbeg real , allocatable :: yh (:) real , allocatable :: yf (:) real , allocatable :: yhin (:) real , allocatable :: yfin (:) real , allocatable :: yhdum (:) real , allocatable :: yfdum (:) integer , allocatable :: ylocupf (:) integer , allocatable :: yloclowf (:) integer , allocatable :: ylocuph (:) integer , allocatable :: yloclowh (:) real :: dyin integer :: irecy !< ib + irecy is the i-index of recycle station integer :: nfile = 0 !< file number to be read or written integer :: nstepread = 1 !< time step number in file containing inlet plane integer :: rk3stepin = 1 !< rk3step in inlet plane data integer :: kbin integer :: kein integer :: nprocsinl !< number of procs at used in inletdata files (only used for inletgen==2) integer :: inlfactor !< ratio of number of processors in this sim and in inlet data files (only used for inletgen==2) logical :: lzinzsim = . true . ! lzinzsim is .true. when inlet zgrid equals sim zgrid ! Inlet driver simulation variables - idriver - ae1212 real , allocatable :: storeu0driver (:,:,:) real , allocatable :: storev0driver (:,:,:) real , allocatable :: storew0driver (:,:,:) real , allocatable :: storethl0driver (:,:,:) real , allocatable :: storee120driver (:,:,:) real , allocatable :: storeqt0driver (:,:,:) real , allocatable :: storesv0driver (:,:,:,:) real , allocatable :: storetdriver (:) real , allocatable :: u0driver (:,:) real , allocatable :: v0driver (:,:) real , allocatable :: u0driverrot (:,:) real , allocatable :: v0driverrot (:,:) real , allocatable :: w0driver (:,:) real , allocatable :: e120driver (:,:) real , allocatable :: tdriver (:) real , allocatable :: thl0driver (:,:) real , allocatable :: qt0driver (:,:) real , allocatable :: sv0driver (:,:,:) real , allocatable :: storeumdriver (:,:,:) real , allocatable :: umdriver (:,:) real , allocatable :: storevmdriver (:,:,:) real , allocatable :: vmdriver (:,:) real , allocatable :: storewmdriver (:,:,:) real , allocatable :: wmdriver (:,:) real , allocatable :: storee12mdriver (:,:,:) real , allocatable :: e12mdriver (:,:) real , allocatable :: storethlmdriver (:,:,:) real , allocatable :: thlmdriver (:,:) real , allocatable :: storeqtmdriver (:,:,:) real , allocatable :: qtmdriver (:,:) real , allocatable :: storesvmdriver (:,:,:,:) real , allocatable :: svmdriver (:,:,:) integer :: irecydriver integer :: nstepreaddriver = 0 integer :: chunkreadctr = 1 ! chunk reading counter integer :: chunkread_s = 0 ! chunk reading loop start integer :: chunkread_e = 0 ! chunk reading loop end end module","tags":"","url":"sourcefile/modinletdata.f90.html"},{"title":"advec_upw.f90 – uDALES","text":"This file depends on sourcefile~~advec_upw.f90~~EfferentGraph sourcefile~advec_upw.f90 advec_upw.f90 sourcefile~modfields.f90 modfields.f90 sourcefile~advec_upw.f90->sourcefile~modfields.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~advec_upw.f90->sourcefile~modglobal.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> \\file advec_upw.f90 !!  Does advection with a 1st order upwind scheme. !! \\par Revision list !! \\par Authors !  This file is part of DALES. ! ! DALES is free software; you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation; either version 3 of the License, or ! (at your option) any later version. ! ! DALES is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !  Copyright 1993-2009 Delft University of Technology, Wageningen University, Utrecht University, KNMI ! !> Advection at cell center subroutine advecc_upw ( hi , hj , hk , putin , putout ) use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , dyi , dxfci , dzfci use modfields , only : u0 , v0 , w0 implicit none integer , intent ( in ) :: hi !< size of halo in i integer , intent ( in ) :: hj !< size of halo in j integer , intent ( in ) :: hk !< size of halo in k real , dimension ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ), intent ( in ) :: putin !< Input: the cell centered field real , dimension ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ), intent ( inout ) :: putout !< Output: the tendency real , allocatable , dimension (:, :, :) :: put integer :: i , j , k allocate ( put ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk )) do k = kb , ke do j = jb , je do i = ib , ie + 1 if ( u0 ( i , j , k ) > 0 ) then put ( i , j , k ) = putin ( i - 1 , j , k ) else put ( i , j , k ) = putin ( i , j , k ) endif enddo enddo enddo do k = kb , ke do j = jb , je do i = ib , ie putout ( i , j , k ) = putout ( i , j , k ) - & ( u0 ( i + 1 , j , k ) * put ( i + 1 , j , k ) - u0 ( i , j , k ) * put ( i , j , k )) * dxfci ( i ) enddo enddo enddo do k = kb , ke do j = jb , je + 1 do i = ib , ie if ( v0 ( i , j , k ) > 0 ) then put ( i , j , k ) = putin ( i , j - 1 , k ) else put ( i , j , k ) = putin ( i , j , k ) endif enddo enddo enddo do k = kb , ke do j = jb , je do i = ib , ie putout ( i , j , k ) = putout ( i , j , k ) - & ( v0 ( i , j + 1 , k ) * put ( i , j + 1 , k ) - v0 ( i , j , k ) * put ( i , j , k )) * dyi enddo enddo enddo do k = kb , ke + 1 do j = jb , je do i = ib , ie if ( w0 ( i , j , k ) > 0 ) then put ( i , j , k ) = putin ( i , j , k - 1 ) else put ( i , j , k ) = putin ( i , j , k ) endif enddo enddo enddo do k = kb , ke do j = jb , je do i = ib , ie putout ( i , j , k ) = putout ( i , j , k ) - & ( w0 ( i , j , k + 1 ) * put ( i , j , k + 1 ) - w0 ( i , j , k ) * put ( i , j , k )) * dzfci ( k ) enddo enddo enddo deallocate ( put ) end subroutine advecc_upw","tags":"","url":"sourcefile/advec_upw.f90.html"},{"title":"moddriver.f90 – uDALES","text":"This file depends on sourcefile~~moddriver.f90~~EfferentGraph sourcefile~moddriver.f90 moddriver.f90 sourcefile~modfields.f90 modfields.f90 sourcefile~moddriver.f90->sourcefile~modfields.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~moddriver.f90->sourcefile~modglobal.f90 sourcefile~modinletdata.f90 modinletdata.f90 sourcefile~moddriver.f90->sourcefile~modinletdata.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~moddriver.f90->sourcefile~modmpi.f90 sourcefile~modsave.f90 modsave.f90 sourcefile~moddriver.f90->sourcefile~modsave.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 sourcefile~modsave.f90->sourcefile~modfields.f90 sourcefile~modsave.f90->sourcefile~modglobal.f90 sourcefile~modsave.f90->sourcefile~modinletdata.f90 sourcefile~modsave.f90->sourcefile~modmpi.f90 sourcefile~initfac.f90 initfac.f90 sourcefile~modsave.f90->sourcefile~initfac.f90 sourcefile~modibmdata.f90 modibmdata.f90 sourcefile~modsave.f90->sourcefile~modibmdata.f90 sourcefile~modsubgriddata.f90 modsubgriddata.f90 sourcefile~modsave.f90->sourcefile~modsubgriddata.f90 sourcefile~modsurfdata.f90 modsurfdata.f90 sourcefile~modsave.f90->sourcefile~modsurfdata.f90 sourcefile~initfac.f90->sourcefile~modglobal.f90 sourcefile~initfac.f90->sourcefile~modmpi.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~moddriver.f90~~AfferentGraph sourcefile~moddriver.f90 moddriver.f90 sourcefile~modboundary.f90 modboundary.f90 sourcefile~modboundary.f90->sourcefile~moddriver.f90 sourcefile~modstartup.f90 modstartup.f90 sourcefile~modstartup.f90->sourcefile~moddriver.f90 sourcefile~modstartup.f90->sourcefile~modboundary.f90 sourcefile~modibm.f90 modibm.f90 sourcefile~modstartup.f90->sourcefile~modibm.f90 sourcefile~modsubgrid.f90 modsubgrid.f90 sourcefile~modstartup.f90->sourcefile~modsubgrid.f90 sourcefile~program.f90 program.f90 sourcefile~program.f90->sourcefile~moddriver.f90 sourcefile~program.f90->sourcefile~modboundary.f90 sourcefile~program.f90->sourcefile~modstartup.f90 sourcefile~program.f90->sourcefile~modibm.f90 sourcefile~program.f90->sourcefile~modsubgrid.f90 sourcefile~modfielddump.f90 modfielddump.f90 sourcefile~program.f90->sourcefile~modfielddump.f90 sourcefile~modstatsdump.f90 modstatsdump.f90 sourcefile~program.f90->sourcefile~modstatsdump.f90 sourcefile~modibm.f90->sourcefile~modboundary.f90 sourcefile~modsubgrid.f90->sourcefile~modboundary.f90 sourcefile~advec_2nd.f90 advec_2nd.f90 sourcefile~advec_2nd.f90->sourcefile~modibm.f90 sourcefile~modfielddump.f90->sourcefile~modibm.f90 sourcefile~modstatsdump.f90->sourcefile~modsubgrid.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! moddriverinlet.f90 contains the set up for creating a driver simulation to use an inlet conditions for a following simulation/ !! This creates a realistic turbulent inlet profiles as necessary. !! The fields are extracted from a specified plane and stored in !! respective files. These files are then used to create inlet !! conditions for a following simualtion. Fields are linearly !! interpolated in time where necessary. !! Code set up is adapted from modinlet.f90 since similar processes are involved !! \\author Anton Esmail-Yakas, Imperial College London, August 5th 2017. !! Edited by tg3315, ICL, May 2019. !! \\todo Documentation !!       Remove unecessary \"use\" variables !!       Remove unecessary commented lines ! !  This file is part of uDALES. ! ! This program is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! This program is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !  Copyright 2006-2021 the uDALES Team. ! module moddriver use modinletdata implicit none save public :: initdriver , exitdriver , readdriverfile , drivergen , readdriverfile_chunk , driverchunkread contains subroutine initdriver use modglobal , only : ih , ib , ie , jh , jb , je , kb , ke , kh , jhc , khc , idriver , lchunkread , chunkread_size , iplane , xf , lstoreplane , nstore , Uinf , ltempeq , lmoist , pi , zf , zh , driverstore , tdriverstart , tdriverdump , timeleft , dtdriver , nsv , timee , lhdriver , lqdriver , lsdriver , ibrank , iplanerank , driverid , cdriverid use modfields , only : um use modmpi , only : myid , nprocs , myidy , nprocy use decomp_2d , only : zstart , zend implicit none real :: pfi , epsi integer :: k if ( idriver == 1 ) then ! if (tdriverstart < timee) then !   write(0, *) 'ERROR: tdriverstart must be greater than the elapsed time at the start of the simulation' !   stop 1 ! end if tdriverdump = tdriverstart if (( iplane >= zstart ( 1 )) . and . ( iplane <= zend ( 1 ))) then iplanerank = . true . irecydriver = iplane - zstart ( 1 ) + 1 end if endif driverid = mod ( myidy , nprocy ) write ( cdriverid , '(i3.3)' ) driverid if ( idriver == 1 . and . iplanerank ) then allocate ( storetdriver ( 1 : driverstore )) allocate ( storeu0driver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storeumdriver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storev0driver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storevmdriver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storew0driver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storewmdriver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) !allocate(storee120driver(jb-jh:je+jh,kb-kh:ke+kh,1:driverstore)) !allocate(storee12mdriver(jb-jh:je+jh,kb-kh:ke+kh,1:driverstore)) if ( ltempeq ) then allocate ( storethl0driver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storethlmdriver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) end if if ( lmoist ) then allocate ( storeqt0driver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storeqtmdriver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) end if if ( nsv > 0 ) then allocate ( storesv0driver ( jb - jhc : je + jhc , kb - khc : ke + khc , 1 : nsv , 1 : driverstore )) allocate ( storesvmdriver ( jb - jhc : je + jhc , kb - khc : ke + khc , 1 : nsv , 1 : driverstore )) end if else if ( idriver == 2 . and . ibrank ) then allocate ( storetdriver ( 1 : driverstore )) if (. not .( lchunkread )) then allocate ( storeu0driver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storeumdriver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storev0driver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storevmdriver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storew0driver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storewmdriver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) !allocate(storee120driver(jb-jh:je+jh,kb-kh:ke+kh,1:driverstore)) !allocate(storee12mdriver(jb-jh:je+jh,kb-kh:ke+kh,1:driverstore)) allocate ( u0driver ( jb - jh : je + jh , kb - kh : ke + kh )) allocate ( v0driver ( jb - jh : je + jh , kb - kh : ke + kh )) allocate ( u0driverrot ( jb - jh : je + jh , kb - kh : ke + kh )) allocate ( v0driverrot ( jb - jh : je + jh , kb - kh : ke + kh )) allocate ( w0driver ( jb - jh : je + jh , kb - kh : ke + kh )) !allocate(e120driver(jb-jh:je+jh,kb-kh:ke+kh)) allocate ( umdriver ( jb - jh : je + jh , kb - kh : ke + kh )) allocate ( vmdriver ( jb - jh : je + jh , kb - kh : ke + kh )) allocate ( wmdriver ( jb - jh : je + jh , kb - kh : ke + kh )) !allocate(e12mdriver(jb-jh:je+jh,kb-kh:ke+kh)) if ( ltempeq . and . lhdriver ) then allocate ( storethl0driver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storethlmdriver ( jb - jh : je + kh , kb - kh : ke + kh , 1 : driverstore )) allocate ( thl0driver ( jb - jh : je + jh , kb - kh : ke + kh )) allocate ( thlmdriver ( jb - jh : je + jh , kb - kh : ke + kh )) end if if ( lmoist . and . lqdriver ) then allocate ( storeqt0driver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( storeqtmdriver ( jb - jh : je + jh , kb - kh : ke + kh , 1 : driverstore )) allocate ( qt0driver ( jb - jh : je + jh , kb - kh : ke + kh )) allocate ( qtmdriver ( jb - jh : je + jh , kb - kh : ke + kh )) end if if ( nsv > 0 . and . lsdriver ) then allocate ( storesv0driver ( jb - jhc : je + jhc , kb - khc : ke + khc , 1 : nsv , 1 : driverstore )) allocate ( storesvmdriver ( jb - jhc : je + jhc , kb - khc : ke + khc , 1 : nsv , 1 : driverstore )) allocate ( sv0driver ( jb - jhc : je + jhc , kb - khc : ke + khc , 1 : nsv )) allocate ( svmdriver ( jb - jhc : je + jhc , kb - khc : ke + khc , 1 : nsv )) end if else ! if(lchunkread) allocate ( storeu0driver ( jb - jh : je + jh , kb - kh : ke + kh , 0 : chunkread_size )) allocate ( storeumdriver ( jb - jh : je + jh , kb - kh : ke + kh , 0 : chunkread_size )) allocate ( storev0driver ( jb - jh : je + jh , kb - kh : ke + kh , 0 : chunkread_size )) allocate ( storevmdriver ( jb - jh : je + jh , kb - kh : ke + kh , 0 : chunkread_size )) allocate ( storew0driver ( jb - jh : je + jh , kb - kh : ke + kh , 0 : chunkread_size )) allocate ( storewmdriver ( jb - jh : je + jh , kb - kh : ke + kh , 0 : chunkread_size )) !allocate(storee120driver(jb-jh:je+jh,kb-kh:ke+kh,0:chunkread_size)) !allocate(storee12mdriver(jb-jh:je+jh,kb-kh:ke+kh,0:chunkread_size)) allocate ( u0driver ( jb - jh : je + jh , kb - kh : ke + kh )) allocate ( v0driver ( jb - jh : je + jh , kb - kh : ke + kh )) allocate ( u0driverrot ( jb - jh : je + jh , kb - kh : ke + kh )) allocate ( v0driverrot ( jb - jh : je + jh , kb - kh : ke + kh )) allocate ( w0driver ( jb - jh : je + jh , kb - kh : ke + kh )) !allocate(e120driver(jb-jh:je+jh,kb-kh:ke+kh)) allocate ( umdriver ( jb - jh : je + jh , kb - kh : ke + kh )) allocate ( vmdriver ( jb - jh : je + jh , kb - kh : ke + kh )) allocate ( wmdriver ( jb - jh : je + jh , kb - kh : ke + kh )) !allocate(e12mdriver(jb-jh:je+jh,kb-kh:ke+kh)) if ( ltempeq . and . lhdriver ) then allocate ( storethl0driver ( jb - jh : je + jh , kb - kh : ke + kh , 0 : chunkread_size )) allocate ( storethlmdriver ( jb - jh : je + kh , kb - kh : ke + kh , 0 : chunkread_size )) allocate ( thl0driver ( jb - jh : je + jh , kb - kh : ke + kh )) allocate ( thlmdriver ( jb - jh : je + jh , kb - kh : ke + kh )) end if if ( lmoist . and . lqdriver ) then allocate ( storeqt0driver ( jb - jh : je + jh , kb - kh : ke + kh , 0 : chunkread_size )) allocate ( storeqtmdriver ( jb - jh : je + jh , kb - kh : ke + kh , 0 : chunkread_size )) allocate ( qt0driver ( jb - jh : je + jh , kb - kh : ke + kh )) allocate ( qtmdriver ( jb - jh : je + jh , kb - kh : ke + kh )) end if if ( nsv > 0 . and . lsdriver ) then allocate ( storesv0driver ( jb - jhc : je + jhc , kb - khc : ke + khc , 1 : nsv , 0 : chunkread_size )) allocate ( storesvmdriver ( jb - jhc : je + jhc , kb - khc : ke + khc , 1 : nsv , 0 : chunkread_size )) allocate ( sv0driver ( jb - jhc : je + jhc , kb - khc : ke + khc , 1 : nsv )) allocate ( svmdriver ( jb - jhc : je + jhc , kb - khc : ke + khc , 1 : nsv )) end if end if else return end if end subroutine initdriver subroutine drivergen use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , zf , zh , dzf , dzhi , timee , btime , totavtime , rk3step ,& dt , numol , iplane , lles , idriver , inletav , runavtime , Uinf , lwallfunc , linletRA ,& totinletav , lstoreplane , nstore , driverstore , prandtlmoli , numol , grav , lbuoyancy ,& lfixinlet , lfixutauin , tdriverstart , dtdriver , tdriverdump , lchunkread , chunkread_size , ltempeq , lmoist , nsv , lhdriver , lqdriver , lsdriver ,& ibrank , iplanerank , driverid , cdriverid , runtime , lwarmstart , cdriverjobnr use modfields , only : u0 , v0 , w0 , e120 , thl0 , qt0 , wm , uprof , vprof use modsave , only : writerestartfiles use modmpi , only : slabsum , myid implicit none real :: inlrec ! time of last inlet record real :: elapsrec ! time elapsed in this inlet record real :: dtint ! dt for linear interpolation real , PARAMETER :: eps = 1 d - 4 integer i , j , k , kk , kdamp , x , xc if ( idriver == 1 . and . iplanerank ) then ! if (.not. (rk3step==3)) return if (. not . ( timee >= tdriverstart )) return if (. not . ( timee >= tdriverdump )) return if ( nstepreaddriver >= driverstore ) return if ( nstepreaddriver == 0 ) then ! tdriverdump = timee tdriverdump = tdriverstart ! tdriverstart = timee   !Update tdriverstart to the actual recorded value if (( driverid == 0 ) . and . ( rk3step == 3 )) then write ( 6 , * ) '==================================================================' write ( 6 , * ) '*** Starting to write data for driver simulation ***' write ( 6 , * ) 'Driver recording variables:' write ( 6 , '(A,F15.5,A,I8,A,F12.9)' ) ' Starting time: ' , tdriverdump , ' Stored time steps: ' , driverstore , '     Inlet record intervals: ' , dtdriver write ( 6 , * ) '==================================================================' end if end if if ( rk3step == 3 ) then nstepreaddriver = nstepreaddriver + 1 tdriverdump = tdriverdump + dtdriver ! storetinlet(nstepreaddriver) = timee - tdriverstart call writedriverfile end if elseif ( idriver == 2 ) then ! this gets called in modboundary when ibrank=.true., so no need for switch if ( timee > ( runtime + btime )) return if ( driverid == 0 ) then if (. not .( lwarmstart )) then if ( runtime > maxval ( storetdriver )) then write ( * , '(A,F15.5,A,F15.5,A)' ) \"Simulation will stop before runtime = \" , runtime , \", since last & &read driver time (\" , maxval ( storetdriver ), \") is less than runtime.\" end if else ! if lwarmstart if ( runtime + btime > maxval ( storetdriver )) then write ( * , '(A,F15.5,A,F15.5,A)' ) \"Simulation will stop before runtime+btime = \" , runtime + btime , \", since last & &read driver time (\" , maxval ( storetdriver ), \") is less than runtime+btime.\" end if end if end if ! if (.not. rk3step==1) return if ( timee > maxval ( storetdriver )) then if ( driverid == 0 ) then write ( 0 , '(A,F15.5,A,F15.5)' ) 'timee: ' , timee , '     Final inlet driver time:' , maxval ( storetdriver ) write ( 0 , '(A,I8,A,I8)' ) 'Inlet driver step: ' , nstepreaddriver , '     Total inlet driver steps:' , driverstore end if stop 'Time in simulation has exceeded the inlet information - no more inlet data available!' end if if (. not .( lchunkread )) then x = minloc ( abs ( storetdriver - timee ), 1 ) elapsrec = storetdriver ( x ) - timee if ( myid == 0 ) then ! if(rk3step==1) then ! write(6,*) '============ Inlet interpolating =============' ! write(6,*) 'Inlet interpolation time = ', elapsrec ! write(6,'(A,F9.4)') 'Inlet driver time stamp (x)  = ', storetdriver(x) ! write(6,'(A,F9.4)') 'Inlet driver time stamp (x+1) = ', storetdriver(x+1) ! write(6,'(A,F9.4)') 'Inlet driver time stamp (x-1) = ', storetdriver(x-1) ! write(6,'(A,E20.12)') 'Reading driver velocity: storeu0driver(je,ke,x) = ', storeu0driver(je,ke,x) ! write(6,*) 'Inlet step = ',nstepreaddriver ! end if end if if ( abs ( elapsrec ) < eps ) then if (( driverid == 0 ) . and . (( rk3step == 0 ) . or . ( rk3step == 3 ))) then write ( * , '(A,I8,A,F15.5,A)' ) '======= Inputs loaded from driver tstep ' , x , ' (at ' , storetdriver ( x ), 's) =======' end if u0driver (:,:) = storeu0driver (:,:, x ) v0driver (:,:) = storev0driver (:,:, x ) w0driver (:,:) = storew0driver (:,:, x ) !e120driver(:,:) = storee120driver(:,:,x) if ( ltempeq . and . lhdriver ) then thl0driver (:,:) = storethl0driver (:,:, x ) end if if ( lmoist . and . lqdriver ) then qt0driver (:,:) = storeqt0driver (:,:, x ) end if if ( nsv > 0 . and . lsdriver ) then sv0driver (:,:,:) = storesv0driver (:,:,:, x ) end if nstepreaddriver = x elseif (( elapsrec > 0. ) . and . ( x == 1 )) then if (( driverid == 0 ) . and . (( rk3step == 0 ) . or . ( rk3step == 3 ))) then write ( * , '(A,F15.5,A)' ) '======= Inputs loaded from the proceeding driver tstep 1 (at ' , storetdriver ( x ), 's) =======' end if u0driver (:,:) = storeu0driver (:,:, x ) v0driver (:,:) = storev0driver (:,:, x ) w0driver (:,:) = storew0driver (:,:, x ) ! e120driver(:,:) = storee120driver(:,:,x) if ( ltempeq . and . lhdriver ) then thl0driver (:,:) = storethl0driver (:,:, x ) end if if ( lmoist . and . lqdriver ) then qt0driver (:,:) = storeqt0driver (:,:, x ) end if if ( nsv > 0 . and . lsdriver ) then sv0driver (:,:,:) = storesv0driver (:,:,:, x ) end if nstepreaddriver = x elseif ( elapsrec < 0. ) then if (( driverid == 0 ) . and . (( rk3step == 0 ) . or . ( rk3step == 3 ))) then write ( * , '(A,I8,A,F15.5,A,I8,A,F15.5,A)' ) '======= Inputs interpolated from driver tsteps ' , x , ' (' , storetdriver ( x ), ' s) and ' , x + 1 , ' (' , storetdriver ( x + 1 ), ' s) =======' end if dtint = ( timee - storetdriver ( x )) / ( storetdriver ( x + 1 ) - storetdriver ( x )) ! if(myid==0) then ! write(6,'(A,I4)') 'x: ', x ! write(6,'(A,F9.4)') 'dtint: ', dtint ! write(6,'(A,E20.12)') 'storeu0driver(1,32,x): ', storeu0driver(1,32,x) ! write(6,'(A,E20.12)') 'storeu0driver(1,32,x+1): ', storeu0driver(1,32,x+1) ! write(6,'(A,E20.12)') 'u0driver(1,32): ',  storeu0driver(1,32,x) + (storeu0driver(1,32,x+1)-storeu0driver(1,32,x))*dtint ! end if u0driver (:,:) = storeu0driver (:,:, x ) + ( storeu0driver (:,:, x + 1 ) - storeu0driver (:,:, x )) * dtint v0driver (:,:) = storev0driver (:,:, x ) + ( storev0driver (:,:, x + 1 ) - storev0driver (:,:, x )) * dtint w0driver (:,:) = storew0driver (:,:, x ) + ( storew0driver (:,:, x + 1 ) - storew0driver (:,:, x )) * dtint ! e120driver(:,:) = storee120driver(:,:,x) + (storee120driver(:,:,x+1)-storee120driver(:,:,x))*dtint if ( ltempeq . and . lhdriver ) then thl0driver (:,:) = storethl0driver (:,:, x ) + ( storethl0driver (:,:, x + 1 ) - storethl0driver (:,:, x )) * dtint end if if ( lmoist . and . lqdriver ) then qt0driver (:,:) = storeqt0driver (:,:, x ) + ( storeqt0driver (:,:, x + 1 ) - storeqt0driver (:,:, x )) * dtint end if if ( nsv > 0 . and . lsdriver ) then sv0driver (:,:,:) = storesv0driver (:,:,:, x ) + ( storesv0driver (:,:,:, x + 1 ) - storesv0driver (:,:,:, x )) * dtint end if nstepreaddriver = x elseif ( elapsrec > 0. ) then if (( driverid == 0 ) . and . (( rk3step == 0 ) . or . ( rk3step == 3 ))) then write ( * , '(A,I8,A,F15.5,A,I8,A,F15.5,A)' ) '======= Inputs interpolated from driver tsteps ' , x , ' (' , storetdriver ( x ), ' s) and ' , x - 1 , ' (' , storetdriver ( x - 1 ), ' s) =======' end if dtint = ( timee - storetdriver ( x - 1 )) / ( storetdriver ( x ) - storetdriver ( x - 1 )) u0driver (:,:) = storeu0driver (:,:, x - 1 ) + ( storeu0driver (:,:, x ) - storeu0driver (:,:, x - 1 )) * dtint v0driver (:,:) = storev0driver (:,:, x - 1 ) + ( storev0driver (:,:, x ) - storev0driver (:,:, x - 1 )) * dtint w0driver (:,:) = storew0driver (:,:, x - 1 ) + ( storew0driver (:,:, x ) - storew0driver (:,:, x - 1 )) * dtint ! e120driver(:,:) = storee120driver(:,:,x-1) + (storee120driver(:,:,x)-storee120driver(:,:,x-1))*dtint if ( ltempeq . and . lhdriver ) then thl0driver (:,:) = storethl0driver (:,:, x - 1 ) + ( storethl0driver (:,:, x ) - storethl0driver (:,:, x - 1 )) * dtint end if if ( lmoist . and . lqdriver ) then qt0driver (:,:) = storeqt0driver (:,:, x - 1 ) + ( storeqt0driver (:,:, x ) - storeqt0driver (:,:, x - 1 )) * dtint end if if ( nsv > 0 . and . lsdriver ) then sv0driver (:,:,:) = storesv0driver (:,:,:, x - 1 ) + ( storesv0driver (:,:,:, x ) - storesv0driver (:,:,:, x - 1 )) * dtint end if nstepreaddriver = x end if else ! if (lchunkread) x = minloc ( abs ( storetdriver - timee ), 1 ) xc = mod ( x , chunkread_size ) if ( xc == 0 ) xc = x - ( chunkreadctr - 2 ) * chunkread_size elapsrec = storetdriver ( x ) - timee if ( myid == 0 ) then ! if(rk3step==1) then ! write(6,*) '============ Inlet interpolating =============' ! write(6,*) 'Inlet interpolation time = ', elapsrec ! write(6,'(A,F9.4)') 'Inlet driver time stamp (x)  = ', storetdriver(x) ! write(6,'(A,F9.4)') 'Inlet driver time stamp (x+1) = ', storetdriver(x+1) ! write(6,'(A,F9.4)') 'Inlet driver time stamp (x-1) = ', storetdriver(x-1) ! write(6,'(A,E20.12)') 'Reading driver velocity: storeu0driver(je,ke,x) = ', storeu0driver(je,ke,x) ! write(6,*) 'Inlet step = ',nstepreaddriver ! end if end if if ( abs ( elapsrec ) < eps ) then if (( driverid == 0 ) . and . (( rk3step == 0 ) . or . ( rk3step == 3 ))) then write ( * , '(A,I8,A,I8,A,F15.5,A)' ) '======= Inputs loaded from driver tstep ' , x , '(' , xc , ') (at ' , storetdriver ( x ), 's) =======' end if u0driver (:,:) = storeu0driver (:,:, xc ) v0driver (:,:) = storev0driver (:,:, xc ) w0driver (:,:) = storew0driver (:,:, xc ) !e120driver(:,:) = storee120driver(:,:,xc) if ( ltempeq . and . lhdriver ) then thl0driver (:,:) = storethl0driver (:,:, xc ) end if if ( lmoist . and . lqdriver ) then qt0driver (:,:) = storeqt0driver (:,:, xc ) end if if ( nsv > 0 . and . lsdriver ) then sv0driver (:,:,:) = storesv0driver (:,:,:, xc ) end if elseif (( elapsrec > 0. ) . and . ( x == 1 )) then if (( driverid == 0 ) . and . (( rk3step == 0 ) . or . ( rk3step == 3 ))) then write ( * , '(A,F15.5,A,I8,A,I8)' ) '======= Inputs loaded from the proceeding driver tstep 1 (at ' , storetdriver ( x ), 's) =======' , x , '  ' , xc end if u0driver (:,:) = storeu0driver (:,:, xc ) v0driver (:,:) = storev0driver (:,:, xc ) w0driver (:,:) = storew0driver (:,:, xc ) ! e120driver(:,:) = storee120driver(:,:,xc) if ( ltempeq . and . lhdriver ) then thl0driver (:,:) = storethl0driver (:,:, xc ) end if if ( lmoist . and . lqdriver ) then qt0driver (:,:) = storeqt0driver (:,:, xc ) end if if ( nsv > 0 . and . lsdriver ) then sv0driver (:,:,:) = storesv0driver (:,:,:, xc ) end if elseif ( elapsrec < 0. ) then if (( driverid == 0 ) . and . (( rk3step == 0 ) . or . ( rk3step == 3 ))) then write ( * , '(A,I8,A,I8,A,F15.5,A,I8,A,I8,A,F15.5,A)' ) '======= Inputs interpolated from driver tsteps ' , x , '(' , xc , ') (' , storetdriver ( x ), ' s) and ' , x + 1 , '(' , xc + 1 , ') (' , storetdriver ( x + 1 ), ' s) =======' end if dtint = ( timee - storetdriver ( x )) / ( storetdriver ( x + 1 ) - storetdriver ( x )) ! if(myid==0) then ! write(6,'(A,I4)') 'x: ', x ! write(6,'(A,F9.4)') 'dtint: ', dtint ! write(6,'(A,E20.12)') 'storeu0driver(1,32,x): ', storeu0driver(1,32,x) ! write(6,'(A,E20.12)') 'storeu0driver(1,32,x+1): ', storeu0driver(1,32,x+1) ! write(6,'(A,E20.12)') 'u0driver(1,32): ',  storeu0driver(1,32,x) + (storeu0driver(1,32,x+1)-storeu0driver(1,32,x))*dtint ! end if u0driver (:,:) = storeu0driver (:,:, xc ) + ( storeu0driver (:,:, xc + 1 ) - storeu0driver (:,:, xc )) * dtint v0driver (:,:) = storev0driver (:,:, xc ) + ( storev0driver (:,:, xc + 1 ) - storev0driver (:,:, xc )) * dtint w0driver (:,:) = storew0driver (:,:, xc ) + ( storew0driver (:,:, xc + 1 ) - storew0driver (:,:, xc )) * dtint ! e120driver(:,:) = storee120driver(:,:,xc) + (storee120driver(:,:,xc+1)-storee120driver(:,:,xc))*dtint if ( ltempeq . and . lhdriver ) then thl0driver (:,:) = storethl0driver (:,:, xc ) + ( storethl0driver (:,:, xc + 1 ) - storethl0driver (:,:, xc )) * dtint end if if ( lmoist . and . lqdriver ) then qt0driver (:,:) = storeqt0driver (:,:, xc ) + ( storeqt0driver (:,:, xc + 1 ) - storeqt0driver (:,:, xc )) * dtint end if if ( nsv > 0 . and . lsdriver ) then sv0driver (:,:,:) = storesv0driver (:,:,:, xc ) + ( storesv0driver (:,:,:, xc + 1 ) - storesv0driver (:,:,:, xc )) * dtint end if elseif ( elapsrec > 0. ) then if (( driverid == 0 ) . and . (( rk3step == 0 ) . or . ( rk3step == 3 ))) then write ( * , '(A,I8,A,I8,A,F15.5,A,I8,A,I8,A,F15.5,A)' ) '======= Inputs interpolated from driver tsteps ' , x , '(' , xc , ') (' , storetdriver ( x ), ' s) and ' , x - 1 , '(' , xc - 1 , ') (' , storetdriver ( x - 1 ), ' s) =======' end if dtint = ( timee - storetdriver ( x - 1 )) / ( storetdriver ( x ) - storetdriver ( x - 1 )) u0driver (:,:) = storeu0driver (:,:, xc - 1 ) + ( storeu0driver (:,:, xc ) - storeu0driver (:,:, xc - 1 )) * dtint v0driver (:,:) = storev0driver (:,:, xc - 1 ) + ( storev0driver (:,:, xc ) - storev0driver (:,:, xc - 1 )) * dtint w0driver (:,:) = storew0driver (:,:, xc - 1 ) + ( storew0driver (:,:, xc ) - storew0driver (:,:, xc - 1 )) * dtint ! e120driver(:,:) = storee120driver(:,:,xc-1) + (storee120driver(:,:,xc)-storee120driver(:,:,xc-1))*dtint if ( ltempeq . and . lhdriver ) then thl0driver (:,:) = storethl0driver (:,:, xc - 1 ) + ( storethl0driver (:,:, xc ) - storethl0driver (:,:, xc - 1 )) * dtint end if if ( lmoist . and . lqdriver ) then qt0driver (:,:) = storeqt0driver (:,:, xc - 1 ) + ( storeqt0driver (:,:, xc ) - storeqt0driver (:,:, xc - 1 )) * dtint end if if ( nsv > 0 . and . lsdriver ) then sv0driver (:,:,:) = storesv0driver (:,:,:, xc - 1 ) + ( storesv0driver (:,:,:, xc ) - storesv0driver (:,:,:, xc - 1 )) * dtint end if end if nstepreaddriver = x !! Not sure.. may need modification end if ! rotate u0driverrot = u0driver * cos ( iangle ) - v0driver * sin ( iangle ) v0driverrot = v0driver * cos ( iangle ) + u0driver * sin ( iangle ) u0driver = u0driverrot v0driver = v0driverrot ! if(myid==0) then ! write(6,'(A,F9.4)') 'Simulation time: ', timee ! write(6,'(A,F9.4)') 'dtint: ', dtint ! write(6,*) 'Velocities interpolated:' ! write(6,'(A,e20.12)') 'storeu0driver(je,ke,x-1): ', storeu0driver(je,ke,x-1) ! write(6,'(A,e20.12)') 'storeu0driver(je,ke,x): ', storeu0driver(je,ke,x) ! write(6,'(A,e20.12)') 'storeu0driver(je,ke,x+1): ', storeu0driver(je,ke,x+1) ! write(6,'(A,e20.12)') 'Interpolated inlet velocity (jb,20): ', u0driver(jb,20) ! write(6,*) 'Temperatures interpolated:' ! write(6,'(A,e20.12)') 'storethl0driver(je,20,x-1): ', storethl0driver(jb,20,x-1) ! write(6,'(A,e20.12)') 'storethl0driver(je,20,x): ', storethl0driver(jb,20,x) ! write(6,'(A,e20.12)') 'storethl0driver(je,20,x+1): ', storethl0driver(jb,20,x+1) ! write(6,'(A,e20.12)') 'Interpolated inlet temperature (jb,20): ', thl0driver(jb,20) ! end if ! umdriver = u0driver   ! MAYBE ITS BETTER TO WRITE THE M VARIABLES TO FILE TOO AND JUST READ THEM - THOUGH CURRENTLY THIS IS NOT DONE FOR RESTART FILES?? ae1212 ! vmdriver = v0driver   ! EDIT READ AND WRITE INLET FILES (AND CHECK MODBOUNDARY & MODSURFACE) TO INCLUDE M VARIABLES ! wmdriver = w0driver ! thlmdriver = thl0driver ! qtmdriver = qt0driver if ( rk3step == 0 . or . rk3step == 3 ) then umdriver = u0driver vmdriver = v0driver wmdriver = w0driver !e12mdriver = e120driver if ( ltempeq . and . lhdriver ) then thlmdriver = thl0driver end if if ( lmoist . and . lqdriver ) then qtmdriver = qt0driver end if if ( nsv > 0 . and . lsdriver ) then svmdriver = sv0driver end if end if else return end if ! idrivergen end subroutine drivergen subroutine writedriverfile use modglobal , only : runtime , timee , tdriverstart , tdriverstart_cold , ib , ie , ih , jb , je , jh , kb , ke , kh , cexpnr , ifoutput , nstore , ltempeq , lmoist , driverstore , dtdriver , nsv , lhdriver , lqdriver , lsdriver , ibrank , iplanerank , driverid , cdriverid , btime , lwarmstart use modfields , only : u0 , v0 , w0 , e120 , thl0 , qt0 , um , sv0 use modmpi , only : cmyid , myid use modinletdata , only : storetdriver , storeu0driver , storev0driver , storew0driver , storethl0driver , storeqt0driver ,& storesv0driver , nfile , nstepreaddriver implicit none integer :: fileid , IOS integer :: i , j , k , n integer :: filesizet , filesizev , filesizetest1 , filesizetest2 , filesizes character ( 15 ) :: name logical :: lexist real , allocatable :: arraysizetest (:,:) allocate ( arraysizetest ( jb - jh : je + jh , kb - kh : ke + kh )) inquire ( iolength = filesizet )( timee - tdriverstart ) ! inquire(iolength=filesizetest1)(timee) ! inquire(iolength=filesizetest2)u0(1,1,1) inquire ( iolength = filesizev ) u0 ( irecydriver ,:,:) inquire ( iolength = filesizes ) sv0 ( irecydriver ,:,:,:) !! ! if((myid==0) .and. (nstepreaddriver==1)) then ! write(6,*) 'inquire iolength ', filesizet ! write(6,*) 'inquire iolength test', filesizetest1 ! write(6,*) 'inquire iolength test u', filesizetest2 ! end if ! inquire(iolength=filesizetest1)arraysizetest(:,:) ! filesizetest2 = (je-jb+2*jh)*(ke-kb+2*kh) ! if((myid==0) .and. (nstepreaddriver==1)) then ! write(6,*) 'je,jb,jh,ke,kb,kh', je,jb,jh,ke,kb,kh ! write(6,*) 'inquire iolength test 1 ', filesizetest1 ! write(6,*) 'inquire iolength test 2', filesizetest2 ! write(6,*) 'inquire iolength', filesizev ! end if if ( driverid == 0 ) then write ( 6 , * ) '============ Writing driver files ============' write ( * , * ) 'Driver timestep: ' , nstepreaddriver end if if ( driverid == 0 ) then name = 'tdriver_   .' name ( 9 : 11 ) = cdriverid name ( 13 : 15 ) = cexpnr ! name(15:18)= '.txt' inquire ( file = name , exist = lexist ) if ( lexist ) then ! write(6,*) 'Writing Time stamp to file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , access = 'direct' , recl = filesizet , action = 'write' ) else ! write(6,*) 'Creating Time stamp driver file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'replace' , access = 'direct' , recl = filesizet , action = 'write' , IOSTAT = IOS ) ! if (IOS > 0) then ! write(6,*) 'IOS = ',IOS ! endif end if ! write(*,*) 'filesizet', filesizet ! write(ifoutput)  ( storetdriver (n),  n=1,nstore) ! write(6,'(A,F9.2)') 'Writing time stamp to file: ', timee-tdriverstart if (. not .( lwarmstart )) then write ( 11 , rec = nstepreaddriver ) ( timee - tdriverstart ) write ( * , * ) 'Driver time:' , timee - tdriverstart else ! if lwarmstart if ( btime < tdriverstart ) then write ( 11 , rec = nstepreaddriver ) ( timee - tdriverstart ) write ( * , * ) 'Driver time:' , timee - tdriverstart else write ( 11 , rec = nstepreaddriver ) ( timee - tdriverstart_cold ) write ( * , * ) 'Driver time:' , timee - tdriverstart_cold end if end if close ( unit = 11 ) end if name = 'udriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cdriverid name ( 13 : 15 ) = cexpnr ! name(15:18)= '.txt' inquire ( file = name , exist = lexist ) if ( lexist ) then ! write(6,*) 'Writing Inlet u-velocity to file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , access = 'direct' , recl = filesizev , action = 'write' ) else ! write(6,*) 'Creating Inlet u-velocity inlet file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'replace' , access = 'direct' , recl = filesizev , action = 'write' ) end if ! write(ifoutput)  (((storeu0driver (j,k,n),j=jb,je),k=kb,ke),  n=1,nstore) ! Nested implied do-loop !if(myid==0) then !write(6,'(A,e20.12)') 'Writing u0 to file. u0(irecydriver,je,ke)', u0(irecydriver,je,ke) !write(6,'(A,e20.12)') 'u0(irecydriver,jb,kb)', u0(irecydriver,jb,kb) !write(6,'(A,e20.12)') 'Writing thl0 to file. thl0(irecydriver-1,je,ke)', thl0(irecydriver-1,je,ke) !write(6,'(A,e20.12)') 'thl0(irecydriver-1,jb,kb)', thl0(irecydriver-1,jb,kb) ! write(6,*) 'irecydriver, je, ke, ib, jb, kb', irecydriver, je, ke, ib, jb, kb !end if write ( 11 , rec = nstepreaddriver ) ( u0 ( irecydriver ,:,:)) close ( unit = 11 ) name = 'vdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cdriverid name ( 13 : 15 ) = cexpnr ! name(15:18)= '.txt' inquire ( file = name , exist = lexist ) if ( lexist ) then ! write(6,*) 'Writing Inlet v-velocity to file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'write' , access = 'direct' , recl = filesizev ) else ! write(6,*) 'Creating v-velocity inlet file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'replace' , access = 'direct' , recl = filesizev , action = 'write' ) end if ! write(ifoutput)  (((storev0driver (j,k,n),j=jb,je),k=kb,ke),  n=1,nstore) ! '(F8.4)' write ( 11 , rec = nstepreaddriver ) ( v0 ( irecydriver - 1 ,:,:)) !tg3315 removed irecydriver-1 close ( unit = 11 ) name = 'wdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cdriverid name ( 13 : 15 ) = cexpnr ! name(15:18)= '.txt' inquire ( file = name , exist = lexist ) if ( lexist ) then ! write(6,*) 'Writing Inlet w-velocity to file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'write' , access = 'direct' , recl = filesizev ) else ! write(6,*) 'Creating w-velocity inlet file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'replace' , access = 'direct' , recl = filesizev , action = 'write' ) end if ! write(ifoutput)  (((storew0driver (j,k,n),j=jb,je),k=kb,ke+1),n=1,nstore) write ( 11 , rec = nstepreaddriver ) ( w0 ( irecydriver - 1 ,:,:)) !tg3315 removed irecydriver-1 close ( unit = 11 ) ! name = 'edriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile ! name(9:11)= cmyid ! name(13:15)= cexpnr ! name(15:18)= '.txt' ! inquire(file=name,exist=lexist) ! if (lexist) then ! write(6,*) 'Writing Inlet w-velocity to file: ', name ! open(unit=11,file=name,form='unformatted',status='old',action='write',access='direct',recl=filesizev) ! else ! write(6,*) 'Creating w-velocity inlet file: ', name ! open(unit=11,file=name,form='unformatted',status='replace',access='direct',recl=filesizev,action='write') ! end if ! write(ifoutput)  (((storew0driver (j,k,n),j=jb,je),k=kb,ke+1),n=1,nstore) ! write(11,rec=nstepreaddriver)  (e120(irecydriver,:,:)) !tg3315 removed irecydriver-1 ! close (unit=11) if ( ltempeq ) then name = 'hdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cdriverid name ( 13 : 15 ) = cexpnr ! name(15:18)= '.txt' inquire ( file = name , exist = lexist ) if ( lexist ) then ! write(6,*) 'Writing Inlet temperature to file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'write' , access = 'direct' , recl = filesizev ) else ! write(6,*) 'Creating temperature inlet file: ', name ! write(6,*) 'Creating w-velocity inlet file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'replace' , access = 'direct' , recl = filesizev , action = 'write' ) end if ! write(ifoutput)  (((storew0driver (j,k,n),j=jb,je),k=kb,ke+1),n=1,nstore) write ( 11 , rec = nstepreaddriver ) ( thl0 ( irecydriver - 1 ,:,:)) !tg3315 removed irecydriver-1 close ( unit = 11 ) end if if ( lmoist ) then name = 'qdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cdriverid name ( 13 : 15 ) = cexpnr ! name(15:18)= '.txt' inquire ( file = name , exist = lexist ) if ( lexist ) then ! write(6,*) 'Writing Inlet temperature to file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'write' , access = 'direct' , recl = filesizev ) else ! write(6,*) 'Creating temperature inlet file: ', name ! write(6,*) 'Creating w-velocity inlet file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'replace' , access = 'direct' , recl = filesizev , action = 'write' ) end if ! write(ifoutput)  (((storew0driver (j,k,n),j=jb,je),k=kb,ke+1),n=1,nstore) write ( 11 , rec = nstepreaddriver ) ( qt0 ( irecydriver - 1 ,:,:)) !tg3315 removed irecydriver-1 close ( unit = 11 ) end if if ( nsv > 0 ) then name = 'sdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cdriverid name ( 13 : 15 ) = cexpnr ! name(15:18)= '.txt' inquire ( file = name , exist = lexist ) if ( lexist ) then ! write(6,*) 'Writing Inlet temperature to file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'write' , access = 'direct' , recl = filesizes ) else ! write(6,*) 'Creating temperature inlet file: ', name ! write(6,*) 'Creating w-velocity inlet file: ', name open ( unit = 11 , file = name , form = 'unformatted' , status = 'replace' , access = 'direct' , recl = filesizes , action = 'write' ) end if ! write(ifoutput)  (((storew0driver (j,k,n),j=jb,je),k=kb,ke+1),n=1,nstore) write ( 11 , rec = nstepreaddriver ) ( sv0 ( irecydriver - 1 ,:,:,:)) !tg3315 removed irecydriver-1 close ( unit = 11 ) end if if (. not .( lwarmstart )) then if ( driverid == 0 . and . runtime + 1e-10 < ( tdriverstart + ( driverstore - 1 ) * dtdriver )) then write ( * , * ) 'Warning! Driver files cannot be written upto ' , driverstore , ' steps. & &Consider taking runtime >= (tdriverstart + (driverstore-1)*dtdriver).' end if else ! if lwarmstart if ( btime < tdriverstart ) then if ( driverid == 0 . and . ( btime + runtime ) < ( tdriverstart + ( driverstore - 1 ) * dtdriver ) ) then write ( * , * ) 'Warning! Driver files cannot be written upto ' , driverstore , ' steps. & &Consider taking runtime + ' , btime , ' >= (tdriverstart + (driverstore-1)*dtdriver).' end if else if ( driverid == 0 . and . runtime + 1e-10 < ( driverstore - 1 ) * dtdriver ) then write ( * , * ) 'Warning! Driver files cannot be written upto ' , driverstore , ' steps. & &Consider taking runtime >= (driverstore-1)*dtdriver).' end if end if end if end subroutine writedriverfile subroutine readdriverfile ! this gets called in modstartup (readinitfiles) when ibrank=.true. use modfields , only : u0 , sv0 use modglobal , only : ib , jb , je , jmax , kb , ke , kh , jhc , khc , cexpnr , ifinput , driverstore , ltempeq , lmoist , zh , jh , driverjobnr , cdriverjobnr , nsv , timee , tdriverstart , lhdriver , lqdriver , lsdriver , ibrank , iplanerank , driverid , cdriverid , lwarmstart use modmpi , only : cmyid , myid , nprocs , slabsum , excjs use modinletdata , only : storetdriver , storeu0driver , storev0driver , storew0driver , storethl0driver , storeqt0driver , storesv0driver , nfile implicit none integer :: filen , filee integer :: fileid , IOS , filesize , filesizes integer :: j , k , m , n , js , jf , jfdum , jsdum character ( 24 ) :: name write ( cdriverjobnr , '(i3.3)' ) driverjobnr if ( driverid == 0 ) then write ( * , * ) \"Consider setting 'trestart' as '(driverstore-1)*dtdriver' of driver case \" , cdriverjobnr , & \" or a value such that (((driverstore-1)*dtdriver)/trestart) is an integer. Ignore, if set already.\" if (. not .( lwarmstart )) then write ( * , * ) \"NOTE: ensure ylen,ytot,nprocy == ylen,ytot,nprocy of driver case \" , cdriverjobnr , \", respectively\" write ( * , * ) \"NOTE: ensure ztot == ztot of driver case \" , cdriverjobnr write ( * , * ) \"NOTE: ensure z direction grid (i.e. zsize and other parameters if stretching) == z direction grid of driver case \" , cdriverjobnr write ( * , * ) \"NOTE: ensure driverstore <= last driver entry step count in driver case \" , cdriverjobnr , \", check corresponding simulation log.\" else ! if lwarmstart write ( * , * ) \"NOTE: ensure driverstore <= last driver entry step count in driver case \" , cdriverjobnr , \", check corresponding simulation log.\" end if write ( * , * ) '========================================================================' write ( * , * ) '*** Reading precursor driver simulation ***' end if name = 'tdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = '000' ! write (name(18:20)  ,'(i3.3)') filen write ( name ( 13 : 15 ) , '(i3.3)' ) driverjobnr inquire ( file = name , size = filesize ) ! if(driverid==0) then !   write(6,*) 'Reading time stamps: ', name !   write(6,*) 'driverstore: ', driverstore !   write(6,*) 'File size of time in bytes (/8) = ', filesize ! endif ! driverstore = driverstore/4. ! write(6,*) 'driverstore: ', driverstore inquire ( iolength = filesize )( timee - tdriverstart ) open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'read' , access = 'direct' , recl = filesize , IOSTAT = IOS ) ! if(myid==0) then !   if (IOS > 0) then !     write(6,*) 'IOS = ',IOS !   endif ! endif do n = 1 , driverstore read ( 11 , rec = n , IOSTAT = IOS ) storetdriver ( n ) ! if(myid==0) then !   if(IOS > 0) then !     write(6,*) 'IOS = ',IOS !   elseif (IOS<0) then !     write(6,*) 'n =', n !   end if !   write(6,'(A,e20.12)') ' Reading t:', storetdriver(n) ! end if end do ! storetdriver = storetdriver + timee !tg3315 added in case using a warmstart... close ( unit = 11 ) ! write(*,*) 'storetdriver', storetdriver ! end if name = 'udriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cdriverid ! write (name(18:20)  ,'(i3.3)') filen write ( name ( 13 : 15 ) , '(i3.3)' ) driverjobnr !write(6,*) 'Reading Driver u-velocity: ', name ! inquire(file=name,recl=filesize) inquire ( iolength = filesize ) u0 ( ib ,:,:) !write(6,*) 'record length ',filesize open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'read' , access = 'direct' , recl = filesize ) do n = 1 , driverstore read ( 11 , rec = n ) (( storeu0driver ( j , k , n ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) ! if(myid==0) then ! write(6, '(A,e20.12)') 'Reading u(irecydriver, jb, kb)', storeu0driver(jb,kb,n) ! endif end do ! if(myid==0) then ! do k=ke,kb,-1 !   write(6, '(A,e20.12)') 'Reading u(ib,1,:)', storeu0driver(jb,k,1) ! end do ! end if close ( unit = 11 ) name = 'vdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cdriverid ! write (name(18:20)  ,'(i3.3)') filen write ( name ( 13 : 15 ) , '(i3.3)' ) driverjobnr !write(6,*) 'Reading Driver v-velocity: ', name ! inquire(file=name,recl=filesize) ! inquire(iolength=filesize)u0(ib,:,:) open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'read' , access = 'direct' , recl = filesize ) do n = 1 , driverstore read ( 11 , rec = n ) (( storev0driver ( j , k , n ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) end do close ( unit = 11 ) name = 'wdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cdriverid ! write (name(18:20)  ,'(i3.3)') filen write ( name ( 13 : 15 ) , '(i3.3)' ) driverjobnr !write(6,*) 'Reading Driver w-velocity: ', name ! inquire(file=name,recl=filesize) ! inquire(iolength=filesize)u0(ib,:,:) open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'read' , access = 'direct' , recl = filesize ) do n = 1 , driverstore read ( 11 , rec = n ) (( storew0driver ( j , k , n ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) end do close ( unit = 11 ) !name = 'edriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile ! name(9:11)= cmyid ! write (name(18:20)  ,'(i3.3)') filen ! write (name(13:15)   ,'(i3.3)') driverjobnr ! write(6,*) 'Reading Driver turbulent kinetic energy: ', name ! inquire(file=name,recl=filesize) ! inquire(iolength=filesize)u0(ib,:,:) ! open(unit=11,file=name,form='unformatted',status='old',action='read',access='direct',recl=filesize) ! do n = 1,driverstore ! read(11,rec=n)  ((storee120driver (j,k,n),j=jb-jh,je+jh),k=kb-kh,ke+kh) ! enddo ! close (unit=11) if ( ltempeq . and . lhdriver ) then name = 'hdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cdriverid ! write (name(18:20)  ,'(i3.3)') filen write ( name ( 13 : 15 ) , '(i3.3)' ) driverjobnr !write(6,*) 'Reading Driver temperature: ', name ! inquire(file=name,recl=filesize) open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'read' , access = 'direct' , recl = filesize ) do n = 1 , driverstore read ( 11 , rec = n ) (( storethl0driver ( j , k , n ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) end do !if(myid==0) then !  do k=ke,kb,-1 !    write(6, '(A,e20.12)') 'Reading thl0(ib,1,:)', storethl0driver(jb,k,1) !  end do !end if close ( unit = 11 ) end if if ( lmoist . and . lqdriver ) then name = 'qdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cdriverid ! write (name(18:20)  ,'(i3.3)') filen write ( name ( 13 : 15 ) , '(i3.3)' ) driverjobnr !write(6,*) 'Reading Driver moisture: ', name ! inquire(file=name,recl=filesize) open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'read' , access = 'direct' , recl = filesize ) do n = 1 , driverstore read ( 11 , rec = n ) (( storeqt0driver ( j , k , n ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) end do close ( unit = 11 ) end if if ( nsv > 0 . and . lsdriver ) then name = 'sdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cdriverid ! write (name(18:20)  ,'(i3.3)') filen write ( name ( 13 : 15 ) , '(i3.3)' ) driverjobnr !write(6,*) 'Reading Driver scalar: ', name ! inquire(file=name,recl=filesize) inquire ( iolength = filesizes ) sv0 ( ib ,:,:,:) open ( unit = 12 , file = name , form = 'unformatted' , status = 'old' , action = 'read' , access = 'direct' , recl = filesizes ) do n = 1 , driverstore read ( 12 , rec = n ) ((( storesv0driver ( j , k , m , n ), j = jb - jhc , je + jhc ), k = kb - khc , ke + khc ), m = 1 , nsv ) end do close ( unit = 12 ) end if end subroutine readdriverfile subroutine readdriverfile_chunk use modfields , only : u0 , sv0 use modglobal , only : ib , jb , je , jmax , kb , ke , kh , jhc , khc , cexpnr , ifinput , driverstore , chunkread_size , ltempeq , lmoist , zh , jh , driverjobnr , cdriverjobnr , nsv , timee , tdriverstart , lhdriver , lqdriver , lsdriver , ibrank , iplanerank , driverid , cdriverid , lwarmstart use modmpi , only : cmyid , myid , nprocs , slabsum , excjs use modinletdata , only : storetdriver , storeu0driver , storev0driver , storew0driver , storethl0driver , storeqt0driver , storesv0driver , nfile , & chunkreadctr , chunkread_s , chunkread_e implicit none integer :: filen , filee integer :: fileid , IOS , filesize , filesizes integer :: j , k , m , n , js , jf , jfdum , jsdum character ( 24 ) :: name write ( cdriverjobnr , '(i3.3)' ) driverjobnr chunkread_s = ( chunkreadctr - 1 ) * chunkread_size + 1 chunkread_e = chunkreadctr * chunkread_size if ( chunkread_e > driverstore ) chunkread_e = driverstore if ( driverid == 0 ) then write ( * , * ) '========================================================================' write ( * , * ) '*** Reading precursor driver simulation field data chunk *** ' , chunkreadctr end if if ( chunkreadctr == 1 ) then if ( driverid == 0 ) then if (. not .( lwarmstart )) then write ( * , * ) \"NOTE: ensure ylen,ytot,nprocy == ylen,ytot,nprocy of driver case \" , cdriverjobnr , \", respectively\" write ( * , * ) \"NOTE: ensure ztot == ztot of driver case \" , cdriverjobnr write ( * , * ) \"NOTE: ensure z dircetion grid (i.e. zsize and other parameters if stretching) == z dircetion grid of driver case \" , cdriverjobnr write ( * , * ) \"NOTE: ensure driverstore <= last driver entry step count in driver case \" , cdriverjobnr , \", check corresponding simulation log.\" else ! if lwarmstart write ( * , * ) \"NOTE: ensure driverstore <= last driver entry step count in driver case \" , cdriverjobnr , \", check corresponding simulation log.\" end if end if name = 'tdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = '000' ! write (name(18:20)  ,'(i3.3)') filen write ( name ( 13 : 15 ) , '(i3.3)' ) driverjobnr inquire ( file = name , size = filesize ) ! if(driverid==0) then !   write(6,*) 'Reading time stamps: ', name !   write(6,*) 'driverstore: ', driverstore !   write(6,*) 'File size of time in bytes (/8) = ', filesize ! endif ! driverstore = driverstore/4. ! write(6,*) 'driverstore: ', driverstore inquire ( iolength = filesize )( timee - tdriverstart ) open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'read' , access = 'direct' , recl = filesize , IOSTAT = IOS ) if ( myid == 0 ) then if ( IOS > 0 ) then write ( 6 , * ) 'IOS = ' , IOS endif endif do n = 1 , driverstore read ( 11 , rec = n , IOSTAT = IOS ) storetdriver ( n ) if ( myid == 0 ) then ! if(IOS > 0) then !   write(6,*) 'IOS = ',IOS ! elseif (IOS<0) then !   write(6,*) 'n =', n ! end if ! write(6,'(A,e20.12)') ' Reading t:', storetdriver(n) end if end do close ( unit = 11 ) end if if ( driverid == 0 ) then write ( * , * ) 'Reading from driver step ' , chunkread_s , ' (time instant ' , storetdriver ( chunkread_s ), & ') to driver step ' , chunkread_e , ' (time instant ' , storetdriver ( chunkread_e ), ')' end if do k = kb - kh , ke + kh do j = jb - jh , je + jh storeu0driver ( j , k , 0 ) = storeu0driver ( j , k , chunkread_size ) end do end do name = 'udriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cdriverid ! write (name(18:20)  ,'(i3.3)') filen write ( name ( 13 : 15 ) , '(i3.3)' ) driverjobnr !write(6,*) 'Reading Driver u-velocity: ', name ! inquire(file=name,recl=filesize) inquire ( iolength = filesize ) u0 ( ib ,:,:) !write(6,*) 'record length ',filesize open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'read' , access = 'direct' , recl = filesize ) do n = chunkread_s , chunkread_e !1,driverstore !if(myid==0) write(6,*) 'reading u_driver at step = ',n,'(',n-chunkread_s+1,') time = ',storetdriver(n) read ( 11 , rec = n ) (( storeu0driver ( j , k , n - chunkread_s + 1 ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) ! if(myid==0) then ! write(6, '(A,e20.12)') 'Reading u(irecydriver, jb, kb)', storeu0driver(jb,kb,n) ! endif end do ! if(myid==0) then ! do k=ke,kb,-1 !   write(6, '(A,e20.12)') 'Reading u(ib,1,:)', storeu0driver(jb,k,1) ! end do ! end if close ( unit = 11 ) do k = kb - kh , ke + kh do j = jb - jh , je + jh storev0driver ( j , k , 0 ) = storev0driver ( j , k , chunkread_size ) end do end do name = 'vdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cdriverid ! write (name(18:20)  ,'(i3.3)') filen write ( name ( 13 : 15 ) , '(i3.3)' ) driverjobnr !write(6,*) 'Reading Driver v-velocity: ', name ! inquire(file=name,recl=filesize) ! inquire(iolength=filesize)u0(ib,:,:) open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'read' , access = 'direct' , recl = filesize ) do n = chunkread_s , chunkread_e !1,driverstore read ( 11 , rec = n ) (( storev0driver ( j , k , n - chunkread_s + 1 ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) end do close ( unit = 11 ) do k = kb - kh , ke + kh do j = jb - jh , je + jh storew0driver ( j , k , 0 ) = storew0driver ( j , k , chunkread_size ) end do end do name = 'wdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cdriverid ! write (name(18:20)  ,'(i3.3)') filen write ( name ( 13 : 15 ) , '(i3.3)' ) driverjobnr !write(6,*) 'Reading Driver w-velocity: ', name ! inquire(file=name,recl=filesize) ! inquire(iolength=filesize)u0(ib,:,:) open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'read' , access = 'direct' , recl = filesize ) do n = chunkread_s , chunkread_e !1,driverstore read ( 11 , rec = n ) (( storew0driver ( j , k , n - chunkread_s + 1 ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) end do close ( unit = 11 ) ! do k = kb-kh,ke+kh !   do j = jb-jh,je+jh !     storee120driver(j,k,0) = storee120driver (j,k,chunkread_size) !   end do ! end do ! name = 'edriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile ! name(9:11)= cmyid ! write (name(18:20)  ,'(i3.3)') filen ! write (name(13:15)   ,'(i3.3)') driverjobnr ! write(6,*) 'Reading Driver turbulent kinetic energy: ', name ! inquire(file=name,recl=filesize) ! inquire(iolength=filesize)u0(ib,:,:) ! open(unit=11,file=name,form='unformatted',status='old',action='read',access='direct',recl=filesize) ! do n = chunkread_s,chunkread_e!1,driverstore ! read(11,rec=n)  ((storee120driver (j,k,n-chunkread_s+1),j=jb-jh,je+jh),k=kb-kh,ke+kh) ! enddo ! close (unit=11) if ( ltempeq . and . lhdriver ) then do k = kb - kh , ke + kh do j = jb - jh , je + jh storethl0driver ( j , k , 0 ) = storethl0driver ( j , k , chunkread_size ) end do end do name = 'hdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cdriverid ! write (name(18:20)  ,'(i3.3)') filen write ( name ( 13 : 15 ) , '(i3.3)' ) driverjobnr !write(6,*) 'Reading Driver temperature: ', name ! inquire(file=name,recl=filesize) open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'read' , access = 'direct' , recl = filesize ) do n = chunkread_s , chunkread_e !1,driverstore read ( 11 , rec = n ) (( storethl0driver ( j , k , n - chunkread_s + 1 ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) end do !if(myid==0) then !  do k=ke,kb,-1 !    write(6, '(A,e20.12)') 'Reading thl0(ib,1,:)', storethl0driver(jb,k,1) !  end do !end if close ( unit = 11 ) end if if ( lmoist . and . lqdriver ) then do k = kb - kh , ke + kh do j = jb - jh , je + jh storeqt0driver ( j , k , 0 ) = storeqt0driver ( j , k , chunkread_size ) end do end do name = 'qdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cdriverid ! write (name(18:20)  ,'(i3.3)') filen write ( name ( 13 : 15 ) , '(i3.3)' ) driverjobnr !write(6,*) 'Reading Driver moisture: ', name ! inquire(file=name,recl=filesize) open ( unit = 11 , file = name , form = 'unformatted' , status = 'old' , action = 'read' , access = 'direct' , recl = filesize ) do n = chunkread_s , chunkread_e !1,driverstore read ( 11 , rec = n ) (( storeqt0driver ( j , k , n - chunkread_s + 1 ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) end do close ( unit = 11 ) end if if ( nsv > 0 . and . lsdriver ) then do m = 1 , nsv do k = kb - kh , ke + kh do j = jb - jh , je + jh storesv0driver ( j , k , m , 0 ) = storesv0driver ( j , k , m , chunkread_size ) end do end do end do name = 'sdriver_   .' ! write (name(13:16)  ,'(i4.4)') nfile name ( 9 : 11 ) = cdriverid ! write (name(18:20)  ,'(i3.3)') filen write ( name ( 13 : 15 ) , '(i3.3)' ) driverjobnr !write(6,*) 'Reading Driver scalar: ', name ! inquire(file=name,recl=filesize) inquire ( iolength = filesizes ) sv0 ( ib ,:,:,:) open ( unit = 12 , file = name , form = 'unformatted' , status = 'old' , action = 'read' , access = 'direct' , recl = filesizes ) do n = chunkread_s , chunkread_e !1,driverstore read ( 12 , rec = n ) ((( storesv0driver ( j , k , m , n - chunkread_s + 1 ), j = jb - jhc , je + jhc ), k = kb - khc , ke + khc ), m = 1 , nsv ) end do close ( unit = 12 ) end if chunkreadctr = chunkreadctr + 1 end subroutine readdriverfile_chunk subroutine driverchunkread use modglobal , only : timee , ibrank , idriver , lchunkread use modinletdata , only : storetdriver , chunkread_e use modmpi , only : myid ! if (idriver==2 .and. lchunkread .and. timee > storetdriver(chunkread_e)) then !   if (myid==0) then !     write(6,*) 'Current timee = ', timee, '; last read storetdriver = ', storetdriver(chunkread_e), & !                'at driver step = ',chunkread_e,'. Hence, next driver chunk will be read now.' !   end if !   if (ibrank) call readdriverfile_chunk ! end if do while ( timee > storetdriver ( chunkread_e )) if ( myid == 0 ) then write ( 6 , * ) 'Current timee = ' , timee , '; last read storetdriver = ' , storetdriver ( chunkread_e ), & 'at driver step = ' , chunkread_e , '. Hence, next driver chunk will be read now.' end if if ( ibrank ) call readdriverfile_chunk end do end subroutine driverchunkread subroutine exitdriver use modglobal , only : idriver , lstoreplane , ltempeq , lmoist , nsv , lhdriver , lqdriver , lsdriver , ibrank , iplanerank if ( idriver == 1 . and . iplanerank ) then !if (lstoreplane ) then deallocate ( storetdriver , storeu0driver , storev0driver , storew0driver ) !,storee120driver) if ( ltempeq ) then deallocate ( storethl0driver ) end if if ( lmoist ) then deallocate ( storeqt0driver ) end if if ( nsv > 0 ) then deallocate ( storesv0driver ) end if !end if else if ( idriver == 2 . and . ibrank ) then deallocate ( storetdriver , storeu0driver , storev0driver , storew0driver , u0driver , v0driver , w0driver ) !,e120driver,storee120driver) if ( ltempeq . and . lhdriver ) then deallocate ( storethl0driver , thl0driver ) end if if ( lmoist . and . lqdriver ) then deallocate ( storeqt0driver , qt0driver ) end if if ( nsv > 0 . and . lsdriver ) then deallocate ( storesv0driver , sv0driver ) end if end if end subroutine exitdriver end module","tags":"","url":"sourcefile/moddriver.f90.html"},{"title":"wf_gr.f90 – uDALES","text":"This file depends on sourcefile~~wf_gr.f90~~EfferentGraph sourcefile~wf_gr.f90 wf_gr.f90 sourcefile~initfac.f90 initfac.f90 sourcefile~wf_gr.f90->sourcefile~initfac.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~wf_gr.f90->sourcefile~modglobal.f90 sourcefile~modibmdata.f90 modibmdata.f90 sourcefile~wf_gr.f90->sourcefile~modibmdata.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~wf_gr.f90->sourcefile~modmpi.f90 sourcefile~modsubgriddata.f90 modsubgriddata.f90 sourcefile~wf_gr.f90->sourcefile~modsubgriddata.f90 sourcefile~initfac.f90->sourcefile~modglobal.f90 sourcefile~initfac.f90->sourcefile~modmpi.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !  This file is part of uDALES. ! ! This program is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! This program is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !  Copyright 2006-2021 the uDALES Team. ! SUBROUTINE wfGR ( hi , hj , hk , ioq , ioqflux , icth , obcqfluxA , qcell , qwall , hurel , resc , ress , n , ind , wforient ) !wfGR USE modglobal , ONLY : dzf , dzfi , dzh2i , dzhi , dzhiq , dy , dyi , dy2i , dyi5 , dxf , dxh , dxfi , dxhi , dxh2i , ib , ie , jb , je , kb , ke , fkar , grav , jmax , rk3step USE modsubgriddata , ONLY : ekh USE modmpi , ONLY : myid USE initfac , ONLY : block USE modibmdata INTEGER i , j , k , jl , ju , kl , ku , il , iu , km , im , jm , ip , jp , kp REAL :: bcqflux = 0. !temp storage for temperature flux REAL :: bcmomflux = 0. !temp storage for momentum flux REAL :: dummy = 0. !for debugging REAL :: delta = 0. !distance from wall REAL :: fkar2 !fkar&#94;2, von Karman constant squared REAL :: emmo = 0. , epmo = 0. , epom = 0. , emom = 0. , eopm = 0. , eomm = 0. , empo = 0. REAL :: umin = 0.0001 !m&#94;2/s&#94;2 REAL :: cveg = 0.8 !hardcoded for now, !fraction of GR covered in vegetation, should be made into a proper model parameter (-> modglobal) INTEGER , INTENT ( in ) :: hi !<size of halo in i INTEGER , INTENT ( in ) :: hj !<size of halo in j INTEGER , INTENT ( in ) :: hk !<size of halo in k REAL , INTENT ( out ) :: obcqfluxA ; !temperature flux of entire wall facet (double sum over indeces) [Km/s] REAL , INTENT ( inout ) :: ioq ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ) !updated prognostic temperature REAL , INTENT ( inout ) :: ioqflux ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) !a field to save the momentum flux REAL , INTENT ( in ) :: icth ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) ; !heat transfer coefficient, used to calculate moisture flux REAL , INTENT ( in ) :: qcell ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) !Temperature of fluid cell !       real, intent(in)    :: Troof(ib:ie,jb:je,kb:ke)  !Temperature of horizontal surfaces (also includes roads) REAL , INTENT ( in ) :: qwall REAL , INTENT ( in ) :: hurel REAL , INTENT ( in ) :: resc REAL , INTENT ( in ) :: ress INTEGER , INTENT ( in ) :: n ! number of the block, used to get i,j,k-indeces INTEGER , INTENT ( in ) :: ind ! in case of y-wall (case 3x & 4x) \"ind\" is used for j-index, otherwise this is irrelevant INTEGER , INTENT ( in ) :: wforient !frist digit, orientation of wall, determines iteration idices and if Twall or Troof is used obcqfluxA = 0. fkar2 = fkar ** 2 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!CASES!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!CASES FOR SCALARS!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! SELECT CASE ( wforient ) CASE ( 12 ) !wall in yz -> wf in x (=vertical), lower wall, west wall i = block ( n , 1 ) - 1 !wall property and fluid index ip = i + 1 !index to remove subgrid flux jl = MAX ( block ( n , 3 ) - myid * jmax , 1 ) ! starting j-index ju = MIN ( block ( n , 4 ) - myid * jmax , jmax ) ! ending j-index kl = block ( n , 5 ) ! starting k-index ku = block ( n , 6 ) ! ending k-index delta = dxf ( i ) * 0.5 ! DO k = kl , ku DO j = jl , ju bcqflux = min ( 0. , cveg * ( qcell ( i , j , k ) - qwall ) * 1 / ( 1 / icth ( i , j , k ) + resc ) + ( 1 - cveg ) * ( qcell ( i , j , k ) - qwall * hurel ) * 1 / ( 1 / icth ( i , j , k ) + ress )) obcqfluxA = obcqfluxA + bcqflux ioqflux ( i , j , k ) = ioqflux ( i , j , k ) + bcqflux * dxfi ( i ) ioq ( i , j , k ) = ioq ( i , j , k ) - 0.5 * ( ekh ( ip , j , k ) * dxf ( i ) + ekh ( i , j , k ) * dxf ( ip )) * ( qcell ( ip , j , k ) - qcell ( i , j , k )) * dxh2i ( ip ) * dxfi ( i ) - bcqflux * dxfi ( i ) ! END DO END DO !!! case 22 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! CASE ( 22 ) i = block ( n , 2 ) + 1 ! im = i - 1 ! jl = MAX ( block ( n , 3 ) - myid * jmax , 1 ) ! starting j-index ju = MIN ( block ( n , 4 ) - myid * jmax , jmax ) ! ending j-index kl = block ( n , 5 ) ! starting k-index ku = block ( n , 6 ) ! ending k-index delta = dxh ( i ) * 0.5 DO k = kl , ku DO j = jl , ju !dq * 1/res, where res is in [s/m] bcqflux = min ( 0. , cveg * ( qcell ( i , j , k ) - qwall ) * 1 / ( 1 / icth ( i , j , k ) + resc ) + ( 1 - cveg ) * ( qcell ( i , j , k ) - qwall * hurel ) * 1 / ( 1 / icth ( i , j , k ) + ress )) obcqfluxA = obcqfluxA + bcqflux ioqflux ( i , j , k ) = ioqflux ( i , j , k ) + bcqflux * dxfi ( i ) ioq ( i , j , k ) = ioq ( i , j , k ) + 0.5 * ( ekh ( i , j , k ) * dxf ( im ) + ekh ( im , j , k ) * dxf ( i )) * ( qcell ( i , j , k ) - qcell ( im , j , k )) * dxh2i ( i ) * dxfi ( i ) - bcqflux * dxfi ( i ) END DO END DO !!! case 32 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! CASE ( 32 ) !wall in xz -> wf in y (=vertical) upper, north wall j = ind jm = j - 1 il = block ( n , 1 ) iu = block ( n , 2 ) kl = block ( n , 5 ) ku = block ( n , 6 ) DO k = kl , ku DO i = il , iu bcqflux = min ( 0. , cveg * ( qcell ( i , j , k ) - qwall ) * 1 / ( 1 / icth ( i , j , k ) + resc ) + ( 1 - cveg ) * ( qcell ( i , j , k ) - qwall * hurel ) * 1 / ( 1 / icth ( i , j , k ) + ress )) obcqfluxA = obcqfluxA + bcqflux ioqflux ( i , j , k ) = ioqflux ( i , j , k ) + bcqflux * dyi ioq ( i , j , k ) = ioq ( i , j , k ) + ( & 0.5 * ( ekh ( i , j , k ) + ekh ( i , jm , k )) * ( qcell ( i , j , k ) - qcell ( i , jm , k ))) * dy2i & - bcqflux * dyi END DO END DO !!! case 42 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! CASE ( 42 ) !wall in xz -> wf in y (=vertical) lower, south wall j = ind jp = j + 1 il = block ( n , 1 ) iu = block ( n , 2 ) kl = block ( n , 5 ) ku = block ( n , 6 ) DO k = kl , ku DO i = il , iu bcqflux = min ( 0. , cveg * ( qcell ( i , j , k ) - qwall ) * 1 / ( 1 / icth ( i , j , k ) + resc ) + ( 1 - cveg ) * ( qcell ( i , j , k ) - qwall * hurel ) * 1 / ( 1 / icth ( i , j , k ) + ress )) obcqfluxA = obcqfluxA + bcqflux ioqflux ( i , j , k ) = ioqflux ( i , j , k ) + bcqflux * dyi ioq ( i , j , k ) = ioq ( i , j , k ) - & 0.5 * ( ekh ( i , jp , k ) + ekh ( i , j , k )) * ( qcell ( i , jp , k ) - qcell ( i , j , k )) * dy2i & - bcqflux * dyi END DO END DO !!! case 52 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! CASE ( 52 ) !wall in xy -> wf in z (=horizontal), top wall k = block ( n , 6 ) + 1 !block location km = k - 1 ! il = block ( n , 1 ) iu = block ( n , 2 ) jl = MAX ( block ( n , 3 ) - myid * jmax , 1 ) ju = MIN ( block ( n , 4 ) - myid * jmax , jmax ) delta = dzf ( k ) * 0.5 DO j = jl , ju DO i = il , iu bcqflux = min ( 0. , cveg * ( qcell ( i , j , k ) - qwall ) * 1 / ( 1 / icth ( i , j , k ) + resc ) + ( 1 - cveg ) * ( qcell ( i , j , k ) - qwall * hurel ) * 1 / ( 1 / icth ( i , j , k ) + ress )) obcqfluxA = obcqfluxA + bcqflux ioqflux ( i , j , k ) = ioqflux ( i , j , k ) + bcqflux * dzfi ( k ) ioq ( i , j , k ) = ioq ( i , j , k ) & + 0.5 * ( dzf ( km ) * ekh ( i , j , k ) + dzf ( k ) * ekh ( i , j , km )) * ( qcell ( i , j , k ) - qcell ( i , j , km )) * dzh2i ( k ) * dzfi ( k ) & - bcqflux * dzfi ( k ) END DO END DO END SELECT END SUBROUTINE wfGR","tags":"","url":"sourcefile/wf_gr.f90.html"},{"title":"modsurfdata.f90 – uDALES","text":"Files dependent on this one sourcefile~~modsurfdata.f90~~AfferentGraph sourcefile~modsurfdata.f90 modsurfdata.f90 sourcefile~modboundary.f90 modboundary.f90 sourcefile~modboundary.f90->sourcefile~modsurfdata.f90 sourcefile~moddriver.f90 moddriver.f90 sourcefile~modboundary.f90->sourcefile~moddriver.f90 sourcefile~modfielddump.f90 modfielddump.f90 sourcefile~modfielddump.f90->sourcefile~modsurfdata.f90 sourcefile~modibm.f90 modibm.f90 sourcefile~modfielddump.f90->sourcefile~modibm.f90 sourcefile~modforces.f90 modforces.f90 sourcefile~modforces.f90->sourcefile~modsurfdata.f90 sourcefile~modibm.f90->sourcefile~modsurfdata.f90 sourcefile~modibm.f90->sourcefile~modboundary.f90 sourcefile~modinlet.f90 modinlet.f90 sourcefile~modinlet.f90->sourcefile~modsurfdata.f90 sourcefile~modsave.f90 modsave.f90 sourcefile~modinlet.f90->sourcefile~modsave.f90 sourcefile~modsave.f90->sourcefile~modsurfdata.f90 sourcefile~modstartup.f90 modstartup.f90 sourcefile~modstartup.f90->sourcefile~modsurfdata.f90 sourcefile~modstartup.f90->sourcefile~modboundary.f90 sourcefile~modstartup.f90->sourcefile~modforces.f90 sourcefile~modstartup.f90->sourcefile~modibm.f90 sourcefile~modstartup.f90->sourcefile~modinlet.f90 sourcefile~modsubgrid.f90 modsubgrid.f90 sourcefile~modstartup.f90->sourcefile~modsubgrid.f90 sourcefile~modthermodynamics.f90 modthermodynamics.f90 sourcefile~modstartup.f90->sourcefile~modthermodynamics.f90 sourcefile~modstartup.f90->sourcefile~moddriver.f90 sourcefile~modstatistics.f90 modstatistics.f90 sourcefile~modstatistics.f90->sourcefile~modsurfdata.f90 sourcefile~modstatsdump.f90 modstatsdump.f90 sourcefile~modstatsdump.f90->sourcefile~modsurfdata.f90 sourcefile~modstatsdump.f90->sourcefile~modstatistics.f90 sourcefile~modstatsdump.f90->sourcefile~modsubgrid.f90 sourcefile~modsubgrid.f90->sourcefile~modsurfdata.f90 sourcefile~modsubgrid.f90->sourcefile~modboundary.f90 sourcefile~modthermodynamics.f90->sourcefile~modsurfdata.f90 sourcefile~modtrees.f90 modtrees.f90 sourcefile~modtrees.f90->sourcefile~modsurfdata.f90 sourcefile~advec_2nd.f90 advec_2nd.f90 sourcefile~advec_2nd.f90->sourcefile~modibm.f90 sourcefile~moddriver.f90->sourcefile~modsave.f90 sourcefile~program.f90 program.f90 sourcefile~program.f90->sourcefile~modboundary.f90 sourcefile~program.f90->sourcefile~modfielddump.f90 sourcefile~program.f90->sourcefile~modforces.f90 sourcefile~program.f90->sourcefile~modibm.f90 sourcefile~program.f90->sourcefile~modsave.f90 sourcefile~program.f90->sourcefile~modstartup.f90 sourcefile~program.f90->sourcefile~modstatsdump.f90 sourcefile~program.f90->sourcefile~modsubgrid.f90 sourcefile~program.f90->sourcefile~modthermodynamics.f90 sourcefile~program.f90->sourcefile~modtrees.f90 sourcefile~program.f90->sourcefile~moddriver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> \\file modsurfdata.f90 !! Variable definitions and auxilary routines for the surface model !> !! Variable definitions and auxilary routines for surface model !> !! This routine should have no dependency on any other routine, save perhaps modglobal or modfields. !!  \\author Thijs Heus, MPI-M !!  \\todo Documentation !!  \\par Revision list !  This file is part of DALES. ! ! DALES is free software; you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation; either version 3 of the License, or ! (at your option) any later version. ! ! DALES is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !  Copyright 1993-2009 Delft University of Technology, Wageningen University, Utrecht University, KNMI ! !!whole module should be removed and variables moved module modsurfdata ! implicit none SAVE ! Surface properties real , allocatable :: tskin (:,:) !<  Skin temperature [K] real , allocatable :: qskin (:,:) !<  Skin specific humidity [kg/kg] real :: ps = 10132 5. !<  Surface pressure [Pa] ! Surface energy balance logical :: lmostlocal = . false . !<  Switch to apply MOST locally to get local Obukhov length real , allocatable :: obl (:,:) !<  Obukhov length [m] real :: oblav = 0.001 !<  Spatially averaged obukhov length [m] real , allocatable :: Cm (:,:) !<  Drag coefficient for momentum [-] real , allocatable :: Cs (:,:) !<  Drag coefficient for scalars [-] real , allocatable :: ustar (:,:) !<  Friction velocity [m/s] real , allocatable :: thlflux (:,:) !<  Kinematic temperature flux [K m/s] real , allocatable :: qtflux (:,:) !<  Kinematic specific humidity flux [kg/kg m/s] real , allocatable :: svflux (:,:,:) !<  Kinematic scalar flux [- m/s] ! Surface gradients of prognostic variables real , allocatable :: dudz (:,:) !<  U-wind gradient in surface layer [1/s] real , allocatable :: dvdz (:,:) !<  V-wind gradient in surface layer [1/s] real , allocatable :: dqtdz (:,:) !<  Specific humidity gradient in surface layer [kg/kg/m] real , allocatable :: dthldz (:,:) !<  Liquid water potential temperature gradient in surface layer [K/m] ! Surface properties in case of prescribed conditions (previous isurf 2, 3 and 4) real :: thls = - 1. !<  Surface liquid water potential temperature [K] real :: thl_top = - 1. !<  Surface liquid water potential temperature [K] at top wall real :: qts = - 1. !<  Surface specific humidity [kg/kg] real :: qt_top = - 1. !<  Top value of specific humidity [kg/kg] real :: thvs = - 1. !<  Surface virtual temperature [K] real , allocatable :: svs (:) !<  Surface scalar concentration [-] real , allocatable :: sv_top (:) ! top scalar concentration concentrations real :: z0 = - 1. !<  Surface roughness length [m] real :: z0h = - 1. !<  Surface roughness for heat [m] ! prescribed surface fluxes real :: Cmav !<  Average drag coefficient for momentum [-] real :: Csav !<  Average drag coefficient for scalars [-] real :: horvel !<  Average horizontal velocity at first level real :: wtsurf = - 1. !<  Prescribed kinematic temperature flux [K m/s] real :: wttop = 0. real :: wqtop = 0. real :: wqsurf = - 1. !<  Prescribed kinematic moisture flux [kg/kg m/s] real , allocatable :: wsvsurf (:) !<  Prescribed surface scalar(n) flux [- m/s] real , allocatable :: wsvtop (:) real :: wsvsurfdum ( 1 : 99 ) = 0. !<  Dummy variables as nsv allocated variable real :: wsvtopdum ( 1 : 99 ) = 0. end module modsurfdata","tags":"","url":"sourcefile/modsurfdata.f90.html"},{"title":"modstat_nc.f90 – uDALES","text":"This file depends on sourcefile~~modstat_nc.f90~~EfferentGraph sourcefile~modstat_nc.f90 modstat_nc.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~modstat_nc.f90->sourcefile~modglobal.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~modstat_nc.f90->sourcefile~modmpi.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~modstat_nc.f90~~AfferentGraph sourcefile~modstat_nc.f90 modstat_nc.f90 sourcefile~modeb.f90 modEB.f90 sourcefile~modeb.f90->sourcefile~modstat_nc.f90 sourcefile~modfielddump.f90 modfielddump.f90 sourcefile~modfielddump.f90->sourcefile~modstat_nc.f90 sourcefile~modibm.f90 modibm.f90 sourcefile~modfielddump.f90->sourcefile~modibm.f90 sourcefile~modibm.f90->sourcefile~modstat_nc.f90 sourcefile~modstatistics.f90 modstatistics.f90 sourcefile~modstatistics.f90->sourcefile~modstat_nc.f90 sourcefile~modstatsdump.f90 modstatsdump.f90 sourcefile~modstatsdump.f90->sourcefile~modstat_nc.f90 sourcefile~modstatsdump.f90->sourcefile~modstatistics.f90 sourcefile~program.f90 program.f90 sourcefile~program.f90->sourcefile~modstat_nc.f90 sourcefile~program.f90->sourcefile~modeb.f90 sourcefile~program.f90->sourcefile~modfielddump.f90 sourcefile~program.f90->sourcefile~modibm.f90 sourcefile~program.f90->sourcefile~modstatsdump.f90 sourcefile~modstartup.f90 modstartup.f90 sourcefile~program.f90->sourcefile~modstartup.f90 sourcefile~advec_2nd.f90 advec_2nd.f90 sourcefile~advec_2nd.f90->sourcefile~modibm.f90 sourcefile~modstartup.f90->sourcefile~modibm.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> \\file modstat_nc.f90 !!  Background routines to write NetCDF output !> !!  Background routines to write NetCDF output. !> !! All calls to the netcdf library should be directed through here. !! Inspired on the UCLA-LES routine by Bjorn Stevens. !!  \\author Thijs Heus,MPI-M !!  \\par Revision list !!  \\todo documentation !!   \\todo restartfiles in NetCDF? !  This file is part of DALES. ! ! DALES is free software; you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation; either version 3 of the License, or ! (at your option) any later version. ! ! DALES is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !  Copyright 1993-2009 Delft University of Technology, Wageningen University, Utrecht University, KNMI ! module modstat_nc use netcdf use modmpi , only : myid implicit none integer , save :: timeID = 0 , ztID = 0 , zmID = 0 , xtID = 0 , xmID = 0 , ytID = 0 , ymID = 0 , ztsID = 0 , fctID = 0 , lyrID = 0 real ( kind = 4 ) :: nc_fillvalue = - 99 9. !> The only interface necessary to write data to netcdf, regardless of the dimensions. interface writestat_nc module procedure writestat_time_nc module procedure writestat_1D_nc module procedure writestat_2D_nc module procedure writestat_3D_nc module procedure writestat_3D_short_nc end interface writestat_nc contains subroutine initstat_nc use modglobal , only : kmax , ifnamopt , fname_options , iexpnr use modmpi , only : mpierr , mpi_logical , comm3d , myid implicit none integer :: ierr end subroutine initstat_nc ! ! ---------------------------------------------------------------------- !> Subroutine Open_NC: Opens a NetCDF File and identifies starting record ! subroutine open_nc ( fname , ncid , nrec , n1 , n2 , n3 , ns , nfcts , nlyrs ) use modglobal , only : author , version , timee implicit none integer , intent ( out ) :: ncid , nrec integer , optional , intent ( in ) :: n1 , n2 , n3 , ns , nfcts , nlyrs character ( len = 40 ), intent ( in ) :: fname character ( len = 12 ) :: date = '' , time = '' integer :: iret , varid , ncall , RecordDimID real , allocatable :: xtimes (:) logical :: exans inquire ( file = trim ( fname ), exist = exans ) !write(*,*) 'opennc' ncall = 0 if (. not . exans ) then call date_and_time ( date , time ) !iret = nf90_create(fname,NF90_SHARE,ncid) iret = nf90_create ( fname , IOR ( NF90_NETCDF4 , NF90_SHARE ), ncid ) iret = nf90_put_att ( ncid , NF90_GLOBAL , 'title' , fname ) iret = nf90_put_att ( ncid , NF90_GLOBAL , 'history' , 'Created on ' // trim ( date ) // ' at ' // trim ( time )) iret = nf90_put_att ( ncid , NF90_GLOBAL , 'Source' , trim ( version )) iret = nf90_put_att ( ncid , NF90_GLOBAL , 'Author' , trim ( author )) iret = nf90_def_dim ( ncID , 'time' , NF90_UNLIMITED , timeID ) if ( present ( n1 )) then iret = nf90_def_dim ( ncID , 'xt' , n1 , xtID ) iret = nf90_def_dim ( ncID , 'xm' , n1 , xmID ) iret = nf90_def_var ( ncID , 'xt' , NF90_FLOAT ,( / xtID / ) , VarID ) iret = nf90_put_att ( ncID , VarID , 'longname' , 'West-East displacement of cell centers' ) iret = nf90_put_att ( ncID , VarID , 'units' , 'm' ) iret = nf90_def_var ( ncID , 'xm' , NF90_FLOAT ,( / xmID / ), VarID ) iret = nf90_put_att ( ncID , VarID , 'longname' , 'West-East displacement of cell edges' ) iret = nf90_put_att ( ncID , VarID , 'units' , 'm' ) end if if ( present ( n2 )) then iret = nf90_def_dim ( ncID , 'yt' , n2 , ytID ) iret = nf90_def_dim ( ncID , 'ym' , n2 , ymID ) iret = nf90_def_var ( ncID , 'yt' , NF90_FLOAT , ytID , VarID ) iret = nf90_put_att ( ncID , VarID , 'longname' , 'South-North displacement of cell centers' ) iret = nf90_put_att ( ncID , VarID , 'units' , 'm' ) iret = nf90_def_var ( ncID , 'ym' , NF90_FLOAT , ymID , VarID ) iret = nf90_put_att ( ncID , VarID , 'longname' , 'South-North displacement of cell edges' ) iret = nf90_put_att ( ncID , VarID , 'units' , 'm' ) end if if ( present ( n3 )) then iret = nf90_def_dim ( ncID , 'zt' , n3 , ztID ) iret = nf90_def_dim ( ncID , 'zm' , n3 , zmID ) iret = nf90_def_var ( ncID , 'zt' , NF90_FLOAT ,( / ztID / ) , VarID ) iret = nf90_put_att ( ncID , VarID , 'longname' , 'Vertical displacement of cell centers' ) iret = nf90_put_att ( ncID , VarID , 'units' , 'm' ) iret = nf90_def_var ( ncID , 'zm' , NF90_FLOAT ,( / zmID / ), VarID ) iret = nf90_put_att ( ncID , VarID , 'longname' , 'Vertical displacement of cell edges' ) iret = nf90_put_att ( ncID , VarID , 'units' , 'm' ) end if if ( present ( ns )) then iret = nf90_def_dim ( ncID , 'zts' , ns , ztsID ) iret = nf90_def_var ( ncID , 'zts' , NF90_FLOAT ,( / ztsID / ) , VarID ) iret = nf90_put_att ( ncID , VarID , 'longname' , 'Soil level depth of cell centers' ) iret = nf90_put_att ( ncID , VarID , 'units' , 'm' ) end if if ( present ( nfcts )) then iret = nf90_def_dim ( ncID , 'fct' , nfcts , fctID ) iret = nf90_def_var ( ncID , 'fct' , NF90_INT ,( / fctID / ) , VarID ) iret = nf90_put_att ( ncID , VarID , 'longname' , 'Facet number' ) end if if ( present ( nlyrs )) then iret = nf90_def_dim ( ncID , 'lyr' , nlyrs , lyrID ) iret = nf90_def_var ( ncID , 'lyr' , NF90_INT ,( / lyrID / ) , VarID ) iret = nf90_put_att ( ncID , VarID , 'longname' , 'Number of wall layers' ) end if else nrec = 0 ncall = 0 iret = nf90_open ( trim ( fname ), NF90_WRITE , ncid ) iret = nf90_inquire ( ncid , unlimitedDimId = RecordDimID ) iret = nf90_inquire_dimension ( ncid , RecordDimID , len = nrec ) if ( nrec > 0 ) then iret = nf90_inq_varid ( ncid , 'time' , timeID ) allocate ( xtimes ( nrec )) iret = nf90_get_var ( ncid , timeId , xtimes ( 1 : nrec )) do while ( xtimes ( ncall + 1 ) < timee - spacing ( 1. )) ncall = ncall + 1 if ( ncall >= nrec ) exit end do deallocate ( xtimes ) end if if ( present ( n1 )) then iret = nf90_inq_dimid ( ncid , 'xt' , xtId ) iret = nf90_inq_dimid ( ncid , 'xm' , xmId ) end if if ( present ( n2 )) then iret = nf90_inq_dimid ( ncid , 'yt' , ytId ) iret = nf90_inq_dimid ( ncid , 'ym' , ymId ) end if if ( present ( n3 )) then iret = nf90_inq_dimid ( ncid , 'zt' , ztId ) iret = nf90_inq_dimid ( ncid , 'zm' , zmId ) end if if ( present ( ns )) then iret = nf90_inq_dimid ( ncid , 'zts' , ztsId ) end if if ( present ( nfcts )) then iret = nf90_inq_dimid ( ncid , 'fct' , fctId ) end if end if nrec = ncall iret = nf90_sync ( ncid ) iret = nf90_enddef ( ncID ) end subroutine open_nc ! ! ---------------------------------------------------------------------- !> Subroutine Define_NC: Defines the structure of the nc file (if not !! already open) ! subroutine define_nc ( ncID , nVar , sx ) implicit none integer , intent ( in ) :: nVar , ncID character ( * ), intent ( in ) :: sx ( nVar , 4 ) integer , save :: dim_mttt ( 4 ) = 0 , dim_tmtt ( 4 ) = 0 , dim_ttmt ( 4 ) = 0 , dim_tttt ( 4 ) = 0 , & dim_tt ( 2 ) = 0 , dim_mt ( 2 ) = 0 , dim_t0tt ( 3 ) = 0 , dim_m0tt ( 3 ) = 0 , dim_t0mt ( 3 ) = 0 ,& dim_m0mt ( 3 ) = 0 , dim_tt0t ( 3 ) = 0 , & dim_mt0t ( 3 ) = 0 , dim_tm0t ( 3 ) = 0 , dim_0ttt ( 3 ) = 0 , dim_0mtt ( 3 ) = 0 , dim_0tmt ( 3 ) = 0 ,& dim_tts ( 2 ) = 0 , dim_t0tts ( 3 ) = 0 , dim_0ttts ( 3 ) = 0 , dim_tttts ( 4 ) = 0 , dim_ttt0 ( 3 ) = 0 ,& !tg3315 added last one dim_mtmt ( 4 ), dim_tmmt ( 4 ), dim_mmtt ( 4 ),& !bss116 dim_ft ( 2 ), dim_flt ( 3 ) !SO integer :: iret , n , VarID !write(*,*) 'definenc' iret = nf90_inq_dimid ( ncid , 'time' , timeId ) iret = nf90_inq_dimid ( ncid , 'xt' , xtId ) iret = nf90_inq_dimid ( ncid , 'xm' , xmId ) iret = nf90_inq_dimid ( ncid , 'yt' , ytId ) iret = nf90_inq_dimid ( ncid , 'ym' , ymId ) iret = nf90_inq_dimid ( ncid , 'zt' , ztId ) iret = nf90_inq_dimid ( ncid , 'zm' , zmId ) iret = nf90_inq_dimid ( ncid , 'zts' , ztsId ) iret = nf90_inq_dimid ( ncid , 'fct' , fctId ) ! so4718 for energy balance output iret = nf90_inq_dimid ( ncid , 'lyr' , lyrId ) ! so4718 for energy balance output iret = nf90_redef ( ncid ) dim_tt = ( / ztId , timeId / ) dim_mt = ( / zmId , timeId / ) dim_t0tt = ( / xtID , ztID , timeId / ) ! thermo point dim_t0mt = ( / xtID , zmID , timeId / ) ! zpoint dim_m0tt = ( / xmID , ztID , timeId / ) ! upoint dim_m0mt = ( / xmID , ztID , timeId / ) ! uw stats point dim_tt0t = ( / xtID , ytID , timeId / ) ! thermo point dim_tm0t = ( / xtID , ymID , timeId / ) ! vpoint dim_mt0t = ( / xmID , ytID , timeId / ) ! upoint dim_0ttt = ( / ytID , ztID , timeId / ) ! thermo point dim_0tmt = ( / ytID , zmID , timeId / ) ! wpoint dim_0mtt = ( / ymID , ztID , timeId / ) ! vpoint dim_tttt = ( / xtID , ytID , ztID , timeId / ) ! thermo point dim_ttmt = ( / xtID , ytID , zmID , timeId / ) ! zpoint dim_mttt = ( / xmID , ytID , ztID , timeId / ) ! upoint dim_tmtt = ( / xtID , ymID , ztId , timeId / ) ! ypoint dim_mtmt = ( / xmID , ytID , zmId , timeId / ) ! uw stats point bss116 dim_tmmt = ( / xtID , ymID , zmId , timeId / ) ! vw stats point bss116 dim_mmtt = ( / xmID , ymID , ztId , timeId / ) ! uv stats point bss116 dim_ttt0 = ( / xtID , ytID , ztID / ) ! stats point tg3315 dim_tts = ( / ztsId , timeId / ) dim_t0tts = ( / xtID , ztsID , timeId / ) ! thermo soil point dim_0ttts = ( / ytID , ztsID , timeId / ) ! thermo point dim_tttts = ( / xtID , ytID , ztsID , timeId / ) ! thermo point dim_ft = ( / fctID , timeId / ) dim_flt = ( / fctID , lyrID , timeId / ) do n = 1 , nVar !      write(*,*) 'n', n !      write(*,*) \"dummyline1\" !      write(*,*) 'sx1', sx(1,:) !      write(*,*) 'sx2', sx(2,:) !      write(*,*) \"dummyline2\" !      write(*,*) 'trim(sx(n,1))', trim(sx(n,1)) !      write(*,*) 'trim(sx(n,2))', trim(sx(n,2)) !      write(*,*) 'trim(sx(n,3))', trim(sx(n,3)) !      write(*,*) 'trim(sx(n,4))', trim(sx(n,4)) !      write (*,*) 'ncID', ncID iret = nf90_inq_varid ( ncid , trim ( sx ( n , 1 )), VarID ) if ( iret == 0 ) cycle select case ( trim ( sx ( n , 4 ))) case ( 'time' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT ,( / timeID / ) , VarID ) case ( 'tt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_tt , VarID ) case ( 'mt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_mt , VarID ) !2D Fields case ( 't0tt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_t0tt , VarID ) case ( 't0mt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_t0mt , VarID ) case ( 'm0tt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_m0tt , VarID ) case ( 'm0mt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_m0mt , VarID ) case ( 'tt0t' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_tt0t , VarID ) case ( 'tm0t' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_tm0t , VarID ) case ( 'mt0t' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_mt0t , VarID ) case ( '0ttt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_0ttt , VarID ) case ( '0tmt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_0tmt , VarID ) case ( '0mtt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_0mtt , VarID ) case ( 'ttt0' ) !tg3315 for uav,vav,wav etc. iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_ttt0 , VarID ) !3D Fields case ( 'tttt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_tttt , VarID ) case ( 'mttt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_mttt , VarID ) case ( 'tmtt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_tmtt , VarID ) case ( 'ttmt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_ttmt , VarID ) case ( 'mtmt' ) ! bss116 iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_mtmt , VarID ) case ( 'tmmt' ) ! bss116 iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_tmmt , VarID ) case ( 'mmtt' ) ! bss116 iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_mmtt , VarID ) !Soil fields case ( 'tts' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_tts , VarID ) case ( 't0tts' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_t0tts , VarID ) case ( '0ttts' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_0ttts , VarID ) case ( 'tttts' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_tttts , VarID ) !Facet information case ( 'ft' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_ft , VarID ) case ( 'flt' ) iret = nf90_def_var ( ncID , sx ( n , 1 ), NF90_FLOAT , dim_flt , VarID ) case default write ( 0 , * ) 'nvar' , nvar , sx ( n ,:) write ( 0 , * ) 'ERROR: Bad dimensional information ' , sx ( n ,:) stop 1 ! call appl_abort(0) end select if ( iret /= 0 ) then !        write (*,*) 'nvar', nvar, sx(n,:) !        write (*,*) 'ncID', ncID call nchandle_error ( iret ) end if iret = nf90_put_att ( ncID , VarID , 'longname' , sx ( n , 2 )) iret = nf90_put_att ( ncID , VarID , 'units' , sx ( n , 3 )) iret = nf90_put_att ( ncid , VarID , '_FillValue' , nc_fillvalue ) end do iret = nf90_enddef ( ncID ) end subroutine define_nc subroutine redefine_nc ( ncid ) implicit none integer , intent ( in ) :: ncid integer :: iret iret = nf90_redef ( ncid ) end subroutine redefine_nc subroutine exitstat_nc ( ncid ) implicit none integer , intent ( in ) :: ncid integer status status = nf90_close ( ncid ) if ( status /= nf90_noerr ) call nchandle_error ( status ) end subroutine exitstat_nc subroutine writestat_dims_nc ( ncid ) use modglobal , only : xf , xh , yf , yh , dy , zf , zh , jmax , imax , kb , dxh use modmpi , only : myidx , myidy implicit none integer , intent ( in ) :: ncid integer :: i = 0 , iret , length , varid integer :: dx dx = dxh ( 1 ) ! Assume equidistant grid !write(*,*) 'writestat_dims_nc' iret = nf90_inq_varid ( ncid , 'xt' , VarID ) if ( iret == 0 ) iret = nf90_inquire_dimension ( ncid , xtID , len = length ) !if (iret==0) iret = nf90_put_var(ncid, varID, xf(1:length),(/1/)) if ( iret == 0 ) iret = nf90_put_var ( ncid , varID , ( / ( xf ( i + imax * myidx ), i = 1 , length ) / ),( / 1 / )) !if (iret==0) iret = nf90_put_var(ncid, varID, (/(dx*(0.5+i)+myidx*imax*dx,i=0,length-1)/),(/1/)) iret = nf90_inq_varid ( ncid , 'xm' , VarID ) if ( iret == 0 ) iret = nf90_inquire_dimension ( ncid , xmID , len = length ) !if (iret==0) iret = nf90_put_var(ncid, varID, xh(1:length),(/1/)) if ( iret == 0 ) iret = nf90_put_var ( ncid , varID , ( / ( xh ( i + imax * myidx ), i = 1 , length ) / ),( / 1 / )) !if (iret==0) iret = nf90_put_var(ncid, varID, (/(dx*i+myidx*imax*dx,i=0,length-1)/),(/1/)) iret = nf90_inq_varid ( ncid , 'yt' , VarID ) if ( iret == 0 ) iret = nf90_inquire_dimension ( ncid , ytID , len = length ) !if (iret==0) iret = nf90_put_var(ncid, varID, (/(dy*(0.5+i)+myidy*jmax*dy,i=0,length-1)/),(/1/)) if ( iret == 0 ) iret = nf90_put_var ( ncid , varID , ( / ( yf ( i + jmax * myidy ), i = 1 , length ) / ),( / 1 / )) iret = nf90_inq_varid ( ncid , 'ym' , VarID ) if ( iret == 0 ) iret = nf90_inquire_dimension ( ncid , ymID , len = length ) !if (iret==0) iret = nf90_put_var(ncid, varID, (/(dy*i+myidy*jmax*dy,i=0,length-1)/),(/1/)) if ( iret == 0 ) iret = nf90_put_var ( ncid , varID , ( / ( yh ( i + jmax * myidy ), i = 1 , length ) / ),( / 1 / )) iret = nf90_inq_varid ( ncid , 'zt' , VarID ) if ( iret == 0 ) iret = nf90_inquire_dimension ( ncid , ztID , len = length ) if ( iret == 0 ) iret = nf90_put_var ( ncid , varID , zf ( 1 : length ),( / 1 / )) !ils13, 29.06.2017 zf starts at 0, not at 1 iret = nf90_inq_varid ( ncid , 'zm' , VarID ) if ( iret == 0 ) iret = nf90_inquire_dimension ( ncid , zmID , len = length ) if ( iret == 0 ) iret = nf90_put_var ( ncid , varID , zh ( 1 : length ),( / 1 / )) !same for zh !if (isurf==1) then !iret = nf90_inq_varid(ncid, 'zts', VarID) !if (iret==0) iret = nf90_inquire_dimension(ncid, ztsID, len=length) !if (iret==0) iret = nf90_put_var(ncid, varID, zsoilc(1:length),(/1/)) !end if end subroutine writestat_dims_nc subroutine writestat_time_nc ( ncid , nvar , ncname , vars , nrec , lraise ) implicit none integer , intent ( in ) :: ncid , nvar integer , intent ( inout ) :: nrec real , dimension ( nvar ), intent ( in ) :: vars character ( * ), dimension (:,:), intent ( in ) :: ncname logical , intent ( in ) :: lraise integer :: iret , n , varid !write(*,*) 'time-nc' if ( lraise ) then nrec = nrec + 1 end if do n = 1 , nvar iret = nf90_inq_varid ( ncid , ncname ( n , 1 ), VarID ) iret = nf90_put_var ( ncid , VarID , vars ( n ), start = ( / nrec / )) end do iret = nf90_sync ( ncid ) end subroutine writestat_time_nc subroutine writestat_1D_nc ( ncid , nvar , ncname , vars , nrec , dim1 ) implicit none integer , intent ( in ) :: ncid , nvar , dim1 integer , intent ( in ) :: nrec real , dimension ( dim1 , nvar ), intent ( in ) :: vars character ( * ), dimension (:,:), intent ( in ) :: ncname integer :: iret , n , varid do n = 1 , nvar iret = nf90_inq_varid ( ncid , ncname ( n , 1 ), VarID ) iret = nf90_put_var ( ncid , VarID , vars ( 1 : dim1 , n ),( / 1 , nrec / ),( / dim1 , 1 / )) end do iret = nf90_sync ( ncid ) end subroutine writestat_1D_nc subroutine writestat_2D_nc ( ncid , nvar , ncname , vars , nrec , dim1 , dim2 ) implicit none integer , intent ( in ) :: ncid , nvar , dim1 , dim2 integer , intent ( in ) :: nrec real , dimension (:,:,:), intent ( in ) :: vars character ( * ), dimension (:,:), intent ( in ) :: ncname integer :: iret , n , varid do n = 1 , nvar iret = nf90_inq_varid ( ncid , ncname ( n , 1 ), VarID ) iret = nf90_put_var ( ncid , VarID , vars ( 1 : dim1 , 1 : dim2 , n ),( / 1 , 1 , nrec / ),( / dim1 , dim2 , 1 / )) end do iret = nf90_sync ( ncid ) end subroutine writestat_2D_nc subroutine writestat_3D_nc ( ncid , nvar , ncname , vars , nrec , dim1 , dim2 , dim3 ) implicit none integer , intent ( in ) :: ncid , nvar , dim1 , dim2 , dim3 integer , intent ( in ) :: nrec !real,dimension(dim1,dim2,dim3,nvar),intent(in)       :: vars real , intent ( in ) :: vars ( 0 : dim1 - 1 , 0 : dim2 - 1 , 0 : dim3 - 1 , nvar ) character ( * ), dimension (:,:), intent ( in ) :: ncname integer :: iret , n , varid !write(*,*) 'write 3Dnc' do n = 1 , nvar iret = nf90_inq_varid ( ncid , ncname ( n , 1 ), VarID ) !write(*,*) 'MYID,.', myid !write(*,*) \"nth netcdf variable\",n !write(*,*) 'ncid',ncid !write(*,*) \"n\",n !write(*,*) 'ncname(n,1)',ncname(n,1) !write(*,*) 'VarID',VarID !write(*,*) 'nrec',nrec !write(*,*) 'imax',dim1 !write(*,*) 'jmax',dim2 !write(*,*) 'kmax',dim3 !write(*,*) 'shape(vars)',shape(vars) !iret = nf90_put_var(ncid, VarID, vars(1:dim1,1:dim2,1:dim3,n),(/1,1,1,nrec/),(/dim1,dim2,dim3,1/)) iret = nf90_put_var ( ncid , VarID , vars (:,:,:, n ),( / 1 , 1 , 1 , nrec / ),( / dim1 , dim2 , dim3 , 1 / )) end do iret = nf90_sync ( ncid ) end subroutine writestat_3D_nc subroutine writestat_3D_short_nc ( ncid , nvar , ncname , vars , nrec , dim1 , dim2 , dim3 ) implicit none integer , intent ( in ) :: ncid , nvar , dim1 , dim2 , dim3 integer , intent ( in ) :: nrec integer ( KIND = selected_int_kind ( 4 )), dimension ( dim1 , dim2 , dim3 , nvar ), intent ( in ) :: vars character ( * ), dimension (:,:), intent ( in ) :: ncname integer :: iret , n , varid !write(*,*) '3Dnc short' do n = 1 , nvar iret = nf90_inq_varid ( ncid , ncname ( n , 1 ), VarID ) iret = nf90_put_var ( ncid , VarID , vars ( 1 : dim1 , 1 : dim2 , 1 : dim3 , n ),( / 1 , 1 , 1 , nrec / ),( / dim1 , dim2 , dim3 , 1 / )) end do iret = nf90_sync ( ncid ) end subroutine writestat_3D_short_nc subroutine ncinfo ( out , in1 , in2 , in3 , in4 ) implicit none character ( * ), dimension ( 4 ), intent ( out ) :: out character ( * ), intent ( in ) :: in1 , in2 , in3 , in4 out ( 1 ) = in1 out ( 2 ) = in2 out ( 3 ) = in3 out ( 4 ) = in4 end subroutine ncinfo subroutine nchandle_error ( status ) use netcdf implicit none integer , intent ( in ) :: status if ( status /= nf90_noerr ) then write ( 0 , * ) trim ( nf90_strerror ( status )) write ( 0 , * ) 'ERROR: status' , status stop 1 end if end subroutine nchandle_error end module modstat_nc","tags":"","url":"sourcefile/modstat_nc.f90.html"},{"title":"modchem.f90 – uDALES","text":"This file depends on sourcefile~~modchem.f90~~EfferentGraph sourcefile~modchem.f90 modchem.f90 sourcefile~modfields.f90 modfields.f90 sourcefile~modchem.f90->sourcefile~modfields.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~modchem.f90->sourcefile~modglobal.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~modchem.f90~~AfferentGraph sourcefile~modchem.f90 modchem.f90 sourcefile~tstep.f90 tstep.f90 sourcefile~tstep.f90->sourcefile~modchem.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> \\file modchem.f90 !!tg3315, 2 Nov 2017 !> Input chemistry of the null cycle into DALES following Zhong, Cai 2015. !> Assumes scalar fields are in order 1: NO, 2: NO2 and 3: O3. ! !  This file is part of uDALES. ! ! This program is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! This program is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !  Copyright 2006-2021 the uDALES Team. ! module modchem implicit none save contains subroutine chem use modglobal , only : lchem , k1 , JNO2 , dt , rk3step , ib , ie , ihc , ih , jb , je , jhc , jh , kb , ke , khc , kh use modfields , only : svp , svm , sv0 , IIc implicit none real , dimension ( ib - ihc : ie + ihc , jb - jhc : je + jhc , kb : ke + khc ) :: dummyNO , dummyNO2 , dummyO3 if ( lchem . eqv . . false .) return ! forward Euler ! [NO] !    svp(:,:,:,1) = svp(:,:,:,1) + 30.006 * ( JNO2 * (svm(:,:,:,2)/46.005) - k1 * (svm(:,:,:,1) / 30.006) * (svm(:,:,:,3)/47.997) ) ! [NO2] !    svp(:,:,:,2) = svp(:,:,:,2) + 46.005 * (-JNO2 * (svm(:,:,:,2)/46.005) + k1 * (svm(:,:,:,1) / 30.006) * (svm(:,:,:,3)/47.997) ) ! [O3] !    svp(:,:,:,3) = svp(:,:,:,3) + 47.997 * ( JNO2 * (svm(:,:,:,2)/46.005) - k1 * (svm(:,:,:,1) / 30.006) * (svm(:,:,:,3)/47.997) ) if (. not . rk3step == 3 ) return ! convert into mol/m&#94;3 dummyNO = IIc * sv0 (:,:, kb : ke + khc , 1 ) / 3 0.006 dummyNO2 = IIc * sv0 (:,:, kb : ke + khc , 2 ) / 4 6.005 dummyO3 = IIc * sv0 (:,:, kb : ke + khc , 3 ) / 4 7.997 !backward Euler, semi-implicit !    sv0(:,:,kb:ke+khc,1) = 30.006 * ( ( (sv0(:,:,kb:ke+khc,1)/30.006) + JNO2 * dummyNO2 * dt) / (1. + k1 * dummyO3 * dt) ) !    sv0(:,:,kb:ke+khc,2) = 46.005 * ( ( (sv0(:,:,kb:ke+khc,2)/46.005) + k1 * dummyNO * dummyO3 * dt )  / (1. + JNO2 * dt) ) !    sv0(:,:,kb:ke+khc,3) = 47.997 * ( ( (sv0(:,:,kb:ke+khc,3)/47.997) + JNO2 * dummyNO2 * dt) / (1. + k1 * dummyNO * dt) ) !backward Euler, fully implicit. Derivation at (/projects/Chemistry/FullyImplicit.mw) sv0 (:,:, kb : ke + khc , 1 ) = 3 0.006 * ( ( sv0 (:,:, kb : ke + khc , 1 ) / 3 0.006 ) + ( dt * ( - k1 * dummyNO * dummyO3 + JNO2 * dummyNO2 ) ) / & ( 1. + ( ( dummyNO + dummyO3 ) * k1 + JNO2 ) * dt ) ) sv0 (:,:, kb : ke + khc , 2 ) = 4 6.005 * ( ( sv0 (:,:, kb : ke + khc , 2 ) / 4 6.005 ) - ( dt * ( - k1 * dummyNO * dummyO3 + JNO2 * dummyNO2 ) ) / & ( 1. + ( ( dummyNO + dummyO3 ) * k1 + JNO2 ) * dt ) ) sv0 (:,:, kb : ke + khc , 3 ) = 4 7.997 * ( ( sv0 (:,:, kb : ke + khc , 3 ) / 4 7.997 ) + ( dt * ( - k1 * dummyNO * dummyO3 + JNO2 * dummyNO2 ) ) / & ( 1. + ( ( dummyNO + dummyO3 ) * k1 + JNO2 ) * dt ) ) ! alternative method in Zhong 2017 eqn. 7, analytical solution! end subroutine chem end module modchem","tags":"","url":"sourcefile/modchem.f90.html"},{"title":"wf_uno.f90 – uDALES","text":"This file depends on sourcefile~~wf_uno.f90~~EfferentGraph sourcefile~wf_uno.f90 wf_uno.f90 sourcefile~initfac.f90 initfac.f90 sourcefile~wf_uno.f90->sourcefile~initfac.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~wf_uno.f90->sourcefile~modglobal.f90 sourcefile~modibmdata.f90 modibmdata.f90 sourcefile~wf_uno.f90->sourcefile~modibmdata.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~wf_uno.f90->sourcefile~modmpi.f90 sourcefile~modsubgriddata.f90 modsubgriddata.f90 sourcefile~wf_uno.f90->sourcefile~modsubgriddata.f90 sourcefile~initfac.f90->sourcefile~modglobal.f90 sourcefile~initfac.f90->sourcefile~modmpi.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !  This file is part of uDALES. ! ! This program is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! This program is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !  Copyright 2006-2021 the uDALES Team. ! SUBROUTINE wfuno ( hi , hj , hk , iout1 , iout2 , iot , iomomflux , iotflux , iocth , obcTfluxA , utang1 , utang2 , Tcell , Twall , z0 , z0h , n , ind , wforient ) !wfuno !calculating wall function for momentum and scalars following Cai2012&Uno1995, extension of Louis 1979 method to rough walls !fluxes in m2/s2 and Km/s USE modglobal , ONLY : dzf , dzfi , dzh2i , dzhi , dzhiq , dy , dyi , dy2i , dyi5 , dxf , dxh , dxfi , dxhi , dxh2i , ib , ie , jb , je , kb , ke , fkar , grav , jmax , rk3step , kmax , jge , jgb USE modsubgriddata , ONLY : ekh , ekm USE modmpi , ONLY : myid USE initfac , ONLY : block USE modibmdata REAL , EXTERNAL :: unom INTEGER i , j , k , jl , ju , kl , ku , il , iu , km , im , jm , ip , jp , kp REAL :: Ribl0 = 0. !initial guess of Ribl based on Ts REAL :: bcTflux = 0. !temp storage for temperature flux REAL :: bcmomflux = 0. !temp storage for momentum flux REAL :: ctm = 0. !momentum transfer coefficient REAL :: cth = 0. !heat transfer coefficient REAL :: dummy = 0. !for debugging REAL :: delta = 0. !distance from wall REAL :: logdz = 0. !log(delta/z0) REAL :: logdzh = 0. !log(delta/z0h) REAL :: logzh = 0. !log(z0/z0h) REAL :: sqdz = 0. !sqrt(delta/z0) REAL :: utang1Int !Interpolated 1st tangential velocity component needed for stability calculation (to T location) REAL :: utang2Int !Interpolated 2nd tangential velocity component needed for stability calculation (to T location) REAL :: utangInt !Interpolated absolute tangential velocity REAL :: dT !Temperature difference between wall and cell REAL :: fkar2 !fkar&#94;2, von Karman constant squared REAL :: emmo = 0. , epmo = 0. , epom = 0. , emom = 0. , eopm = 0. , eomm = 0. , empo = 0. REAL :: umin = 0.0001 !m&#94;2/s&#94;2 INTEGER , INTENT ( in ) :: hi !<size of halo in i INTEGER , INTENT ( in ) :: hj !<size of halo in j INTEGER , INTENT ( in ) :: hk !<size of halo in k REAL , INTENT ( out ) :: obcTfluxA !temperature flux of entire wall facet (double sum over indeces) [Km/s] REAL , INTENT ( inout ) :: iout1 ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ) !updated prognostic tangential velocity (component1) REAL , INTENT ( inout ) :: iout2 ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ) !updated prognostic tangential velocity (component2) REAL , INTENT ( inout ) :: iot ( ib - hi : ie + hi , jb - hj : je + hj , kb : ke + hk ) !updated prognostic temperature REAL , INTENT ( inout ) :: iomomflux ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) !a field to save the momentum flux REAL , INTENT ( inout ) :: iotflux ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) !a field to save the heat flux REAL , INTENT ( inout ) :: iocth ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) !heat transfer coefficient, used to calculate moisture flux REAL , INTENT ( in ) :: Tcell ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) !Temperature of fluid cell REAL , INTENT ( in ) :: Twall !Temperature of surfaces !SINCE EVERY WALL HAS PRECISELY ONE TEMPERATURE (at the outside). CAREFUL IF THIS EVER CHANGES (i.e. multiple EB facets per wall) REAL , INTENT ( in ) :: z0 REAL , INTENT ( in ) :: z0h REAL , INTENT ( in ) :: utang1 ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) !tangential velocity field REAL , INTENT ( in ) :: utang2 ( ib - hi : ie + hi , jb - hj : je + hj , kb - hk : ke + hk ) !second tangential velocity field INTEGER , INTENT ( in ) :: n ! number of the block, used to get i,j,k-indeces INTEGER , INTENT ( in ) :: ind ! in case of y-wall (case 3x & 4x) \"ind\" is used for j-index, otherwise this is irrelevant INTEGER , INTENT ( in ) :: wforient !orientation of the facet see below: !frist digit, orientation of wall, determines iteration indices !second digit, if for momentum or for scalar (necessary because of staggered grid -> which variable to interpolate) !xlow=1,xup=2,yup=3,ylow=4,z=5 !momentum=1,scalar=2 fkar2 = fkar ** 2 obcTfluxA = 0. !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!CASES!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!CASES FOR SCALARS!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! SELECT CASE ( wforient ) !!!!!!!!!!!!!!!SPECIAL CASES FOR THE SURFACE!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !can actually be made redundant and just be replaced by standard horizontal case (doesn't really matter though) ! SO: This code is essentially unchanged from uDALES v1, and should probably be moved out of this file in a later release. CASE ( 91 ) !surface momentum flux k = kb ! km = k - 1 ! il = ib iu = ie jl = jb ju = je delta = 0.5 * dzf ( k ) !might need attention on streched grids! as well as the dzfi when updating up logdz = LOG ( delta / z0 ) logdzh = LOG ( delta / z0h ) logzh = LOG ( z0 / z0h ) sqdz = SQRT ( delta / z0 ) DO j = jl , ju !u component DO i = il , iu utang1Int = utang1 ( i , j , k ) utang2Int = ( utang2 ( i , j , k ) + utang2 ( i - 1 , j , k ) + utang2 ( i , j + 1 , k ) + utang2 ( i - 1 , j + 1 , k )) * 0.25 utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = (( Tcell ( i , j , k ) + Tcell ( i - 1 , j , k )) - ( Twall + Twall )) * 0.5 Ribl0 = grav * delta * dT * 2 / (( Twall + Twall ) * utangInt ) !Eq. 6, guess initial Ri ctm = unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field !dummy = (utang1Int**2)*ctm dummy = abs ( utang1Int ) * sqrt ( utangInt ) * ctm bcmomflux = SIGN ( dummy , utang1Int ) !bcmomflux=u_star&#94;2 iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dzfi ( k ) emom = ( dzf ( km ) * ( ekm ( i , j , k ) * dxf ( i - 1 ) + ekm ( i - 1 , j , k ) * dxf ( i )) + & ! dx is non-equidistant dzf ( k ) * ( ekm ( i , j , km ) * dxf ( i - 1 ) + ekm ( i - 1 , j , km ) * dxf ( i ))) * dxhi ( i ) * dzhiq ( k ) iout1 ( i , j , k ) = iout1 ( i , j , k ) + ( utang1 ( i , j , k ) - utang1 ( i , j , km )) * emom * dzhi ( k ) * dzfi ( k ) - bcmomflux * dzfi ( k ) ! END DO END DO DO j = jl , ju DO i = il , iu utang1Int = ( utang1 ( i , j , k ) + utang1 ( i , j - 1 , k ) + utang1 ( i + 1 , j - 1 , k ) + utang1 ( i + 1 , j , k )) * 0.25 utang2Int = utang2 ( i , j , k ) utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = (( Tcell ( i , j , k ) + Tcell ( i , j - 1 , k )) - ( Twall + Twall )) * 0.5 Ribl0 = grav * delta * dT * 2 / (( Twall + Twall ) * utangInt ) !Eq. 6, guess initial Ri ctm = unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !save result and update field !dummy = (utang2Int**2)*ctm !save result and update field dummy = abs ( utang2Int ) * sqrt ( utangInt ) * ctm bcmomflux = SIGN ( dummy , utang2Int ) iomomflux ( i , j , k ) = iomomflux ( i , j , k ) + bcmomflux * dzfi ( k ) eomm = ( dzf ( km ) * ( ekm ( i , j , k ) + ekm ( i , j - 1 , k )) + dzf ( k ) * ( ekm ( i , j , km ) + ekm ( i , j - 1 , km ))) * dzhiq ( k ) iout2 ( i , j , k ) = iout2 ( i , j , k ) + ( utang2 ( i , j , k ) - utang2 ( i , j , km )) * eomm * dzhi ( k ) * dzfi ( k ) - bcmomflux * dzfi ( k ) ! END DO END DO !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! CASE ( 92 ) !surface temperature flux k = kb !block location ku = k !shear velocity location il = ib iu = ie jl = jb ju = je delta = dzf ( k ) * 0.5 logdz = LOG ( delta / z0 ) logdzh = LOG ( delta / z0h ) logzh = LOG ( z0 / z0h ) sqdz = SQRT ( delta / z0 ) DO j = jl , ju DO i = il , iu utang1Int = ( utang1 ( i , j , ku ) + utang1 ( i + 1 , j , ku )) * 0.5 utang2Int = ( utang2 ( i , j , ku ) + utang2 ( i , j + 1 , ku )) * 0.5 utangInt = max ( umin , ( utang1Int ** 2 + utang2Int ** 2 )) dT = ( Tcell ( i , j , ku ) - Twall ) Ribl0 = grav * delta * dT / ( Twall * utangInt ) ! call unoh ( bcTflux , cth , logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) obcTfluxA = obcTfluxA + bcTflux iotflux ( i , j , k ) = iotflux ( i , j , k ) + bcTflux * dzfi ( k ) iot ( i , j , ku ) = iot ( i , j , ku ) + & 0.5 * ( dzf ( k - 1 ) * ekh ( i , j , k ) + dzf ( k ) * ekh ( i , j , k - 1 )) * & ! zero flux ( Tcell ( i , j , k ) - Tcell ( i , j , k - 1 )) * dzh2i ( ku ) * dzfi ( ku ) & - bcTflux * dzfi ( k ) END DO END DO END SELECT END SUBROUTINE wfuno !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!FUNCTIONS!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !for scalar !FUNCTION unoh(logdz, logdzh, logzh, sqdz, utangInt, dT, Ribl0, fkar2) !for heat, the bit that does not change no matter what wall SUBROUTINE unoh ( otf , octh , logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !for heat, the bit that does not change no matter what wall use modglobal , only : prandtlturb !flux in Km/s IMPLICIT NONE REAL , INTENT ( in ) :: logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 REAL , INTENT ( out ) :: octh , otf REAL :: Ribl1 , Fm , Fh , cm , ch , M , dTrough , cth REAL , PARAMETER :: b1 = 9.4 !parameters from Uno1995 REAL , PARAMETER :: b2 = 4.7 REAL , PARAMETER :: dm = 7.4 REAL , PARAMETER :: dh = 5.3 octh = 0. otf = 0. IF ( Ribl0 > 0. ) THEN !0.25 approx critical for bulk Richardson number  => stable Fm = 1. / ( 1. + b2 * Ribl0 ) ** 2 !Eq. 4 Fh = Fm !Eq. 4 ELSE ! => unstable cm = ( dm * fkar2 ) / ( logdz ** 2 ) * b1 * sqdz !Eq. 5 ch = ( dh * fkar2 ) / ( logdz ** 2 ) * b1 * sqdz !Eq. 5 Fm = 1. - ( b1 * Ribl0 ) / ( 1. + cm * SQRT ( ABS ( Ribl0 ))) !Eq. 3 Fh = 1. - ( b1 * Ribl0 ) / ( 1. + ch * SQRT ( ABS ( Ribl0 ))) !Eq. 3 END IF M = prandtlturb * logdz * SQRT ( Fm ) / Fh !Eq. 14 Ribl1 = Ribl0 - Ribl0 * prandtlturb * logzh / ( prandtlturb * logzh + M ) !Eq. 17 !interate to get new Richardson number IF ( Ribl1 > 0. ) THEN !0.25 approx critical for bulk Richardson number  => stable Fm = 1. / ( 1. + b2 * Ribl1 ) ** 2 !Eq. 4 Fh = Fm !Eq. 4 ELSE ! => unstable cm = ( dm * fkar2 ) / ( logdz ** 2 ) * b1 * sqdz !Eq. 5 ch = ( dh * fkar2 ) / ( logdz ** 2 ) * b1 * sqdz !Eq. 5 Fm = 1. - ( b1 * Ribl1 ) / ( 1. + cm * SQRT ( ABS ( Ribl1 ))) !Eq. 3 Fh = 1. - ( b1 * Ribl1 ) / ( 1. + ch * SQRT ( ABS ( Ribl1 ))) !Eq. 3 END IF ! Uno (2) M = prandtlturb * logdz * SQRT ( Fm ) / Fh !Eq. 14 dTrough = dT * 1. / ( prandtlturb * logzh / M + 1. ) !Eq. 13a octh = SQRT ( utangInt ) * fkar2 / ( logdz * logdz ) * Fh / prandtlturb !Eq. 8 otf = octh * dTrough !Eq. 2, Eq. 8 ! ! Uno (8) ! octh = SQRT(utangInt)*fkar2/(logdz*logdzh)*Fh/prandtlturb !Eq. 8 ! otf = octh*dT !Eq. 2, Eq. 8 END SUBROUTINE unoh !!!!!!!!!!!!! !for momentum REAL FUNCTION unom ( logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 ) !for momentum, this bit is not depended on orientation etc use modglobal , only : prandtlturb !momentum flux in m2/s2 !dT,utang and logdzh are unused and could be removed IMPLICIT NONE REAL , INTENT ( in ) :: logdz , logdzh , logzh , sqdz , utangInt , dT , Ribl0 , fkar2 REAL :: Ribl1 , Fm , Fh , cm , ch , Ctm , M REAL , PARAMETER :: b1 = 9.4 !parameters from Uno1995 REAL , PARAMETER :: b2 = 4.7 REAL , PARAMETER :: dm = 7.4 REAL , PARAMETER :: dh = 5.3 !REAL, PARAMETER :: prandtlmol = 0.71 IF ( Ribl0 > 0. ) THEN !0.25 approx critical for bulk Richardson number  => stable Fm = 1. / ( 1. + b2 * Ribl0 ) ** 2 !Eq. 4 Fh = Fm !Eq. 4 ELSE ! => unstable cm = ( dm * fkar2 ) / ( logdz ** 2 ) * b1 * sqdz !Eq. 5 ch = ( dh * fkar2 ) / ( logdz ** 2 ) * b1 * sqdz !Eq. 5 Fm = 1. - ( b1 * Ribl0 ) / ( 1. + cm * SQRT ( ABS ( Ribl0 ))) !Eq. 3 Fh = 1. - ( b1 * Ribl0 ) / ( 1. + ch * SQRT ( ABS ( Ribl0 ))) !Eq. 3 END IF M = prandtlturb * logdz * SQRT ( Fm ) / Fh !Eq. 14 Ribl1 = Ribl0 - Ribl0 * prandtlturb * logzh / ( prandtlturb * logzh + M ) !Eq. 17 !interate to get new Richardson number IF ( Ribl1 > 0. ) THEN !0.25 approx critical for bulk Richardson number  => stable Fm = 1. / ( 1. + b2 * Ribl1 ) ** 2 !Eq. 4 ELSE ! => unstable cm = ( dm * fkar2 ) / ( logdz ** 2 ) * b1 * sqdz !Eq. 5 Fm = 1. - ( b1 * Ribl1 ) / ( 1. + cm * SQRT ( ABS ( Ribl1 ))) !Eq. 3 END IF Ctm = fkar2 / ( logdz ** 2 ) * Fm !Eq. 7 unom = Ctm !Eq. 2, Eq. 8 END FUNCTION unom","tags":"","url":"sourcefile/wf_uno.f90.html"},{"title":"modibmdata.f90 – uDALES","text":"Files dependent on this one sourcefile~~modibmdata.f90~~AfferentGraph sourcefile~modibmdata.f90 modibmdata.f90 sourcefile~advec_kappa.f90 advec_kappa.f90 sourcefile~advec_kappa.f90->sourcefile~modibmdata.f90 sourcefile~modforces.f90 modforces.f90 sourcefile~modforces.f90->sourcefile~modibmdata.f90 sourcefile~modibm.f90 modibm.f90 sourcefile~modibm.f90->sourcefile~modibmdata.f90 sourcefile~modboundary.f90 modboundary.f90 sourcefile~modibm.f90->sourcefile~modboundary.f90 sourcefile~modsave.f90 modsave.f90 sourcefile~modsave.f90->sourcefile~modibmdata.f90 sourcefile~modstartup.f90 modstartup.f90 sourcefile~modstartup.f90->sourcefile~modibmdata.f90 sourcefile~modstartup.f90->sourcefile~modforces.f90 sourcefile~modstartup.f90->sourcefile~modibm.f90 sourcefile~modtimedep.f90 modtimedep.f90 sourcefile~modstartup.f90->sourcefile~modtimedep.f90 sourcefile~moddriver.f90 moddriver.f90 sourcefile~modstartup.f90->sourcefile~moddriver.f90 sourcefile~modinlet.f90 modinlet.f90 sourcefile~modstartup.f90->sourcefile~modinlet.f90 sourcefile~modstartup.f90->sourcefile~modboundary.f90 sourcefile~modsubgrid.f90 modsubgrid.f90 sourcefile~modstartup.f90->sourcefile~modsubgrid.f90 sourcefile~modtimedep.f90->sourcefile~modibmdata.f90 sourcefile~modtrees.f90 modtrees.f90 sourcefile~modtrees.f90->sourcefile~modibmdata.f90 sourcefile~wf_gr.f90 wf_gr.f90 sourcefile~wf_gr.f90->sourcefile~modibmdata.f90 sourcefile~wf_uno.f90 wf_uno.f90 sourcefile~wf_uno.f90->sourcefile~modibmdata.f90 sourcefile~wfmneutral.f90 wfmneutral.f90 sourcefile~wfmneutral.f90->sourcefile~modibmdata.f90 sourcefile~advec_2nd.f90 advec_2nd.f90 sourcefile~advec_2nd.f90->sourcefile~modibm.f90 sourcefile~moddriver.f90->sourcefile~modsave.f90 sourcefile~modfielddump.f90 modfielddump.f90 sourcefile~modfielddump.f90->sourcefile~modibm.f90 sourcefile~modinlet.f90->sourcefile~modsave.f90 sourcefile~program.f90 program.f90 sourcefile~program.f90->sourcefile~modforces.f90 sourcefile~program.f90->sourcefile~modibm.f90 sourcefile~program.f90->sourcefile~modsave.f90 sourcefile~program.f90->sourcefile~modstartup.f90 sourcefile~program.f90->sourcefile~modtimedep.f90 sourcefile~program.f90->sourcefile~modtrees.f90 sourcefile~program.f90->sourcefile~moddriver.f90 sourcefile~program.f90->sourcefile~modfielddump.f90 sourcefile~program.f90->sourcefile~modboundary.f90 sourcefile~program.f90->sourcefile~modsubgrid.f90 sourcefile~modstatsdump.f90 modstatsdump.f90 sourcefile~program.f90->sourcefile~modstatsdump.f90 sourcefile~modboundary.f90->sourcefile~moddriver.f90 sourcefile~modsubgrid.f90->sourcefile~modboundary.f90 sourcefile~modstatsdump.f90->sourcefile~modsubgrid.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! !!  \\author Jasper Tomas,TU Delft, 31 March 2014 !!  \\par Revision list !!  \\todo Documentation ! !  This file is part of DALES. ! ! DALES is free software; you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation; either version 3 of the License, or ! (at your option) any later version. ! ! DALES is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !  Copyright 1993-2009 Delft University of Technology, Wageningen University, Utrecht University, KNMI ! module modibmdata implicit none save integer , allocatable :: xwallsglobal (:,:) integer , allocatable :: ywallsglobal (:,:) integer , allocatable :: zwallsglobal (:,:) !    integer, allocatable :: block(:,:) integer , allocatable :: xwallsshear (:,:) integer , allocatable :: ywallsp (:,:) integer , allocatable :: ywallsm (:,:) integer , allocatable :: zwallsshear (:,:) integer , allocatable :: xwallsnorm (:,:) integer , allocatable :: ywallsnorm (:,:) integer , allocatable :: zwallsnorm (:,:) integer :: nxwall !number of local xwalls integer , allocatable :: ixwall (:) !index of block that is on local processor, used to determine local xwalls, ils13, 16.02.2017 integer :: nywall !number of local xwalls integer , allocatable :: iyminwall (:,:) !index of block that is on local processor, used to determine local xwalls, ils13, 16.02.2017 integer :: nyminwall !number of local xwalls integer , allocatable :: iywall (:) !index of block that is on local processor, used to determine local xwalls, ils13, 16.02.2017 integer :: nypluswall !number of local xwalls integer , allocatable :: iypluswall (:,:) !index of block that is on local processor, used to determine local xwalls, ils13, 16.02.2017 real , allocatable :: ibmxforce (:,:) ! spanwise- and time-averaged force by ibm method. real , allocatable :: ibmxforcevol (:,:) ! spanwise- and time-averaged force by ibm method (complete volume) real , allocatable :: ibmxforcevolp (:,:) ! spanwise- and time-averaged force by ibm method (complete volume minus dp/dx) ! real :: sumctm = 0. real :: bcTfluxA = 0. real :: bcqfluxA = 0. !fluxes for temperature and humidity at immersed boundaries real :: bctfxm = 0. real :: bctfxp = 0. real :: bctfym = 0. real :: bctfyp = 0. real :: bctfz = 0. real :: bcqfxm = 0. real :: bcqfxp = 0. real :: bcqfym = 0. real :: bcqfyp = 0. real :: bcqfz = 0. integer :: nxwallsnorm integer :: nywallsnorm integer :: nzwallsnorm integer :: nxwallsshear integer :: nywallsp integer :: nywallsm integer :: nzwallsshear integer :: offset = 1 !why do we need offset in modglobal? just use same value here to get some indeces right, ils13 20/03/2017 end module","tags":"","url":"sourcefile/modibmdata.f90.html"},{"title":"modpurifiers.f90 – uDALES","text":"This file depends on sourcefile~~modpurifiers.f90~~EfferentGraph sourcefile~modpurifiers.f90 modpurifiers.f90 sourcefile~modfields.f90 modfields.f90 sourcefile~modpurifiers.f90->sourcefile~modfields.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~modpurifiers.f90->sourcefile~modglobal.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~modpurifiers.f90->sourcefile~modmpi.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~modpurifiers.f90~~AfferentGraph sourcefile~modpurifiers.f90 modpurifiers.f90 sourcefile~program.f90 program.f90 sourcefile~program.f90->sourcefile~modpurifiers.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> \\file modpurifs.f90 !!tg3315, 3 Jul 2017 !> Input air purifiers into DALES model. module modpurifiers use mpi implicit none save contains subroutine createpurifiers use modglobal , only : lpurif , npurif , purif , cexpnr , ifinput use modmpi , only : myid , comm3d , mpierr implicit none integer :: n character ( 80 ) chmess if ( lpurif . eqv . . false .) return allocate ( purif ( npurif , 7 )) ! read global purifiers if ( myid == 0 ) then ! write(*,*) '1, myid, npurif, lpurif, cexpnr', myid, npurif, lpurif, cexpnr if ( npurif > 0 ) then open ( ifinput , file = 'purifs.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess read ( ifinput , '(a80)' ) chmess do n = 1 , npurif read ( ifinput , * ) & purif ( n , 1 ), & purif ( n , 2 ), & purif ( n , 3 ), & purif ( n , 4 ), & purif ( n , 5 ), & purif ( n , 6 ), & purif ( n , 7 ) end do ! write (6,*) 'Purifier number,  il, iu, jl, ju, kl, ku, ipu ' ! do n=1,npurif !   write (6,*) & !         n , & !         purif(n,1), & !         purif(n,2), & !         purif(n,3), & !         purif(n,4), & !         purif(n,5), & !         purif(n,6), & !         purif(n,7) ! end do end if ! write(*,*) 'Finished determining purifiers on myid == 0' end if ! end if myid==0 call MPI_BCAST ( purif , 7 * npurif , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( npurif , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) end subroutine createpurifiers subroutine purifiers use modglobal , only : ib , ie , jb , je , kb , ke , ih , xf , xh , zh , purif , npurif , lpurif , itot , jtot , Qpu , epu , dy , nsv use modfields , only : um , vm , wm , u0 , v0 , w0 , up , vp , wp , svp , svm , sv0 use modmpi , only : myidx , myidy , nprocx , nprocy implicit none integer :: i , j , k , n , il , iu , jl , ju , kl , ku real :: Apu , dpu , upu , vpu , wpu , udpu real , allocatable :: inpu (:,:,:,:) if ( lpurif . eqv . . false .) return do n = 1 , npurif upu = 0. vpu = 0. wpu = 0. ! Determine flow direction through purifier= select case ( purif ( n , 7 )) ! calculate cross-sectional area, length of purifier and flow speed case ( 1 ) Apu = ( purif ( n , 4 ) - purif ( n , 3 ) + 1 ) * dy * ( zh ( purif ( n , 6 ) + 1 ) - zh ( purif ( n , 5 ))) dpu = xh ( purif ( n , 2 ) + 1 ) - xh ( purif ( n , 1 )) upu = Qpu / Apu case ( 2 ) Apu = ( purif ( n , 4 ) - purif ( n , 3 ) + 1 ) * dy * ( zh ( purif ( n , 6 ) + 1 ) - zh ( purif ( n , 5 ))) dpu = xh ( purif ( n , 2 ) + 1 ) - xh ( purif ( n , 1 )) upu = - Qpu / Apu case ( 3 ) Apu = ( xh ( purif ( n , 2 ) + 1 ) - xh ( purif ( n , 1 ))) * ( zh ( purif ( n , 6 ) + 1 ) - zh ( purif ( n , 5 ))) dpu = ( purif ( n , 4 ) - purif ( n , 3 ) + 1 ) * dy vpu = Qpu / Apu case ( 4 ) Apu = ( xh ( purif ( n , 2 ) + 1 ) - xh ( purif ( n , 1 ))) * ( zh ( purif ( n , 6 ) + 1 ) - zh ( purif ( n , 5 ))) dpu = ( purif ( n , 4 ) - purif ( n , 3 ) + 1 ) * dy vpu = - Qpu / Apu case ( 5 ) Apu = ( purif ( n , 4 ) - purif ( n , 3 ) + 1 ) * dy * ( xh ( purif ( n , 2 ) + 1 ) - xh ( purif ( n , 1 ))) dpu = zh ( purif ( n , 6 ) + 1 ) - zh ( purif ( n , 5 )) wpu = Qpu / Apu case ( 6 ) Apu = ( purif ( n , 4 ) - purif ( n , 3 ) + 1 ) * dy * ( xh ( purif ( n , 2 ) + 1 ) - xh ( purif ( n , 1 ))) dpu = zh ( purif ( n , 6 ) + 1 ) - zh ( purif ( n , 5 )) wpu = - Qpu / Apu case ( 7 ) ! purifier that takes from above and below and feeds outwards Apu = ( purif ( n , 4 ) - purif ( n , 3 ) + 1 ) * dy * ( xh ( purif ( n , 2 ) + 1 ) - xh ( purif ( n , 1 ))) * 2 ! *2 due to geometry of purifier dpu = zh ( purif ( n , 6 ) + 1 ) - zh ( purif ( n , 5 )) / 2 ! half distance to travel before purification? udpu = Qpu / Apu ! new term to be used at purifier faces case ( 8 ) ! one cell purifier that intakes from all side and outputs upwards Apu = 2 * ( purif ( n , 4 ) - purif ( n , 3 ) + 1 ) * dy * ( xh ( purif ( n , 2 ) + 1 ) - xh ( purif ( n , 1 ))) + & 2 * ( xh ( purif ( n , 2 ) + 1 ) - xh ( purif ( n , 1 ))) * ( zh ( purif ( n , 6 ) + 1 ) - zh ( purif ( n , 5 ))) ! sum up 4 horizontal cell faces dpu = 0.5 * ( ( purif ( n , 4 ) - purif ( n , 3 ) + 1 ) * dy + xh ( purif ( n , 2 ) + 1 ) - xh ( purif ( n , 1 )) ) ! average distance from outside cell to centre cell in horizontal directions udpu = Qpu / Apu ! new term to be used at purifier faces end select ! enforce flowrate ! u flowrate il = purif ( n , 1 ) - myidx * itot / nprocx iu = purif ( n , 2 ) + 1 - myidx * itot / nprocx kl = purif ( n , 5 ) ku = purif ( n , 6 ) jl = purif ( n , 3 ) - myidy * jtot / nprocy ju = purif ( n , 4 ) - myidy * jtot / nprocy if ( iu < ib . or . il > ie . or . ju < jb . or . jl > je ) then cycle else if ( iu > ie ) iu = ie if ( il < ib ) il = ib if ( ju > je ) ju = je if ( jl < jb ) jl = jb up ( il : iu , jl : ju , kl : ku ) = 0. um ( il : iu , jl : ju , kl : ku ) = upu u0 ( il : iu , jl : ju , kl : ku ) = upu ! tg3315 !WARNING changed these to u0 as realised RK3... change back to um if not working... !tg3315 14.05.18 have made it do both due to role in RK3, ..m is more crucial to change and may need ..0 end if ! v flowrate il = purif ( n , 1 ) - myidx * itot / nprocx iu = purif ( n , 2 ) - myidx * itot / nprocx kl = purif ( n , 5 ) ku = purif ( n , 6 ) jl = purif ( n , 3 ) - myidy * jtot / nprocy ju = purif ( n , 4 ) + 1 - myidy * jtot / nprocy if ( iu < ib . or . il > ie . or . ju < jb . or . jl > je ) then cycle else if ( iu > ie ) iu = ie if ( il < ib ) il = ib if ( ju > je ) ju = je if ( jl < jb ) jl = jb vp ( il : iu , jl : ju , kl : ku ) = 0. vm ( il : iu , jl : ju , kl : ku ) = vpu v0 ( il : iu , jl : ju , kl : ku ) = vpu end if ! w flowrate il = purif ( n , 1 ) - myidx * itot / nprocx iu = purif ( n , 2 ) - myidx * itot / nprocx kl = purif ( n , 5 ) ku = purif ( n , 6 ) + 1 jl = purif ( n , 3 ) - myidy * jtot / nprocy ju = purif ( n , 4 ) - myidy * jtot / nprocy if ( iu < ib . or . il > ie . or . ju < jb . or . jl > je ) then cycle else if ( iu > ie ) iu = ie if ( il < ib ) il = ib if ( ju > je ) ju = je if ( jl < jb ) jl = jb wp ( il : iu , jl : ju , kl : ku ) = 0. wm ( il : iu , jl : ju , kl : ku ) = wpu w0 ( il : iu , jl : ju , kl : ku ) = wpu end if ! Scalars il = purif ( n , 1 ) - myidx * itot / nprocx iu = purif ( n , 2 ) - myidx * itot / nprocx kl = purif ( n , 5 ) ku = purif ( n , 6 ) jl = purif ( n , 3 ) - myidy * jtot / nprocy ju = purif ( n , 4 ) - myidy * jtot / nprocy if ( iu < ib . or . il > ie . or . ju < jb . or . jl > je ) then cycle else if ( iu > ie ) iu = ie if ( il < ib ) il = ib if ( ju > je ) ju = je if ( jl < jb ) jl = jb where ( sv0 (:,:,:, 1 ) < 0. ) sv0 (:,:,:, 1 ) = 0. !must do this in tstep after svo = ... ! calculate concentration at purifier inlet allocate ( inpu ( il : iu , jl : ju , kl : ku , 1 : nsv )) inpu = 0. select case ( purif ( n , 7 )) case ( 1 ) do i = il , iu inpu ( i ,:,:,:) = svm ( il - 1 , jl : ju , kl : ku ,:) !tg3315 also changed svm -> sv0 change back if stops working ! tg3315 14.05.18 I have undone this now as believe that ..m represents the latest confirmed value whilst ..0 is updated through RK3 timestep. If causes issues then stop! end do case ( 2 ) do i = il , iu inpu ( i ,:,:,:) = svm ( iu + 1 , jl : ju , kl : ku ,:) end do case ( 3 ) do j = jl , ju inpu (:, j ,:,:) = svm ( il : iu , jl - 1 , kl : ku ,:) end do case ( 4 ) do j = jl , ju inpu (:, j ,:,:) = svm ( il : iu , ju + 1 , kl : ku ,:) end do case ( 5 ) do k = kl , ku inpu (:,:, k ,:) = svm ( il : iu , jl : ju , kl - 1 ,:) end do case ( 6 ) do k = kl , ku inpu (:,:, k ,:) = svm ( il : iu , jl : ju , ku + 1 ,:) end do case ( 7 ) inpu (:,:, ku ,:) = svm ( il : iu , jl : ju , ku + 1 ,:) inpu (:,:, kl ,:) = svm ( il : iu , jl : ju , kl - 1 ,:) wm ( il : iu , jl : ju , ku + 1 ) = - udpu w0 ( il : iu , jl : ju , ku + 1 ) = - udpu wm ( il : iu , jl : ju , kl ) = udpu w0 ( il : iu , jl : ju , kl ) = udpu case ( 8 ) !> initially coded for purifiers of cell size = 1 (il=iu,jl=ju,kl=ku) inpu ( il , jl ,:,:) = 0.25 * ( svm ( il - 1 , jl , kl : ku ,:) + svm ( iu + 1 , jl , kl : ku ,:) + svm ( il , jl - 1 , kl : ku ,:) + svm ( il , ju + 1 , kl : ku ,:) ) um ( il , jl : ju , kl : ku ) = udpu u0 ( il , jl : ju , kl : ku ) = udpu vm ( il : iu , jl , kl : ku ) = udpu v0 ( il : iu , jl , kl : ku ) = udpu um ( iu + 1 , jl : ju , kl : ku ) = - udpu u0 ( iu + 1 , jl : ju , kl : ku ) = - udpu vm ( il : iu , ju + 1 , kl : ku ) = - udpu v0 ( il : iu , ju + 1 , kl : ku ) = - udpu end select ! apply sink term to purify at given efficiency svp ( il : iu , jl : ju , kl : ku , 1 ) = svp ( il : iu , jl : ju , kl : ku , 1 ) - & ( Qpu / Apu ) * epu * inpu (:,:,:, 1 ) / dpu if ( nsv > 1 ) then svp ( il : iu , jl : ju , kl : ku , 2 ) = svp ( il : iu , jl : ju , kl : ku , 2 ) - & ( Qpu / Apu ) * 0.7 * inpu (:,:,:, 2 ) / dpu end if if ( nsv > 3 ) then svp ( il : iu , jl : ju , kl : ku , 4 ) = svp ( il : iu , jl : ju , kl : ku , 4 ) - & ( Qpu / Apu ) * 0.65 * inpu (:,:,:, 4 ) / dpu end if deallocate ( inpu ) end if end do ! npurif end subroutine purifiers end module modpurifiers","tags":"","url":"sourcefile/modpurifiers.f90.html"},{"title":"modsubgriddata.f90 – uDALES","text":"Files dependent on this one sourcefile~~modsubgriddata.f90~~AfferentGraph sourcefile~modsubgriddata.f90 modsubgriddata.f90 sourcefile~advection.f90 advection.f90 sourcefile~advection.f90->sourcefile~modsubgriddata.f90 sourcefile~modboundary.f90 modboundary.f90 sourcefile~modboundary.f90->sourcefile~modsubgriddata.f90 sourcefile~moddriver.f90 moddriver.f90 sourcefile~modboundary.f90->sourcefile~moddriver.f90 sourcefile~modchecksim.f90 modchecksim.f90 sourcefile~modchecksim.f90->sourcefile~modsubgriddata.f90 sourcefile~modibm.f90 modibm.f90 sourcefile~modibm.f90->sourcefile~modsubgriddata.f90 sourcefile~modibm.f90->sourcefile~modboundary.f90 sourcefile~modsave.f90 modsave.f90 sourcefile~modsave.f90->sourcefile~modsubgriddata.f90 sourcefile~modstartup.f90 modstartup.f90 sourcefile~modstartup.f90->sourcefile~modsubgriddata.f90 sourcefile~modstartup.f90->sourcefile~modboundary.f90 sourcefile~modstartup.f90->sourcefile~modibm.f90 sourcefile~modsubgrid.f90 modsubgrid.f90 sourcefile~modstartup.f90->sourcefile~modsubgrid.f90 sourcefile~modstartup.f90->sourcefile~moddriver.f90 sourcefile~modinlet.f90 modinlet.f90 sourcefile~modstartup.f90->sourcefile~modinlet.f90 sourcefile~modstatistics.f90 modstatistics.f90 sourcefile~modstatistics.f90->sourcefile~modsubgriddata.f90 sourcefile~modsubgrid.f90->sourcefile~modsubgriddata.f90 sourcefile~modsubgrid.f90->sourcefile~modboundary.f90 sourcefile~modtrees.f90 modtrees.f90 sourcefile~modtrees.f90->sourcefile~modsubgriddata.f90 sourcefile~tstep.f90 tstep.f90 sourcefile~tstep.f90->sourcefile~modsubgriddata.f90 sourcefile~wf_gr.f90 wf_gr.f90 sourcefile~wf_gr.f90->sourcefile~modsubgriddata.f90 sourcefile~wf_uno.f90 wf_uno.f90 sourcefile~wf_uno.f90->sourcefile~modsubgriddata.f90 sourcefile~wfmneutral.f90 wfmneutral.f90 sourcefile~wfmneutral.f90->sourcefile~modsubgriddata.f90 sourcefile~advec_2nd.f90 advec_2nd.f90 sourcefile~advec_2nd.f90->sourcefile~modibm.f90 sourcefile~moddriver.f90->sourcefile~modsave.f90 sourcefile~modfielddump.f90 modfielddump.f90 sourcefile~modfielddump.f90->sourcefile~modibm.f90 sourcefile~modinlet.f90->sourcefile~modsave.f90 sourcefile~modstatsdump.f90 modstatsdump.f90 sourcefile~modstatsdump.f90->sourcefile~modstatistics.f90 sourcefile~modstatsdump.f90->sourcefile~modsubgrid.f90 sourcefile~program.f90 program.f90 sourcefile~program.f90->sourcefile~modboundary.f90 sourcefile~program.f90->sourcefile~modchecksim.f90 sourcefile~program.f90->sourcefile~modibm.f90 sourcefile~program.f90->sourcefile~modsave.f90 sourcefile~program.f90->sourcefile~modstartup.f90 sourcefile~program.f90->sourcefile~modsubgrid.f90 sourcefile~program.f90->sourcefile~modtrees.f90 sourcefile~program.f90->sourcefile~moddriver.f90 sourcefile~program.f90->sourcefile~modfielddump.f90 sourcefile~program.f90->sourcefile~modstatsdump.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !!> \\file modsubdata.f90 !!!  Provides variable definitions for Calculates and applies the Sub Filter Scale diffusion ! !> !!  Calculates and applies the Sub Filter Scale diffusion !> !!  \\author Jasper Tomas, TU Delft !!  \\author Pier Siebesma, K.N.M.I. !!  \\author Stephan de Roode,TU Delft !!  \\author Chiel van Heerwaarden, Wageningen U.R. !!  \\author Thijs Heus,MPI-M !!  \\par Revision list !!  \\todo Documentation ! !  This file is part of DALES. ! ! DALES is free software; you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation; either version 3 of the License, or ! (at your option) any later version. ! ! DALES is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !  Copyright 1993-2009 Delft University of Technology, Wageningen University, Utrecht University, KNMI ! module modsubgriddata implicit none save ! private logical :: ldelta = . false . !<  switch for subgrid length formulation (on/off) logical :: lmason = . false . !<  switch for decreased length scale near the surface logical :: lsmagorinsky = . false . !<  switch for smagorinsky subgrid scheme logical :: lvreman = . true . !<  switch for Vreman (2004) subgrid scheme logical :: lbuoycorr = . false . !<  switch for buoyancy correction in Vreman (2004) subgrid scheme logical :: loneeqn = . false . !<  switch for one-eqn subgrid scheme real :: cf = 2.5 !< filter constant real :: Rigc = 0.25 !< critical Richardson number real :: Prandtl = 0.333 !  real :: Prandtl = 3.0 !  real :: prandtli= 1./3. real :: prandtli real :: cm = 0.12 real :: cn = 0.76 real :: ch1 = 1. real :: ch2 = 2. real :: ce1 = 0.19 real :: ce2 = 0.51 real :: cs = - 1. real :: nmason = 2. !< exponent in Mason correction function real :: alpha_kolm = 1.5 !< factor in Kolmogorov expression for spectral energy real :: beta_kolm = 1. !< factor in Kolmogorov relation for temperature spectrum !  real :: damp   = 1.      !< used in van driest damping function real :: dampmin = 1e-10 !< maximum damping used in van driest/Piomelli damping function real :: c_vreman = 0.07 !< model constant for subgrid-scale model by Vreman (2004) !  real :: c_vreman  = 0.025      !< model constant for subgrid-scale model by Vreman (2004) corresponds with smag_const=0.1 real , allocatable :: ekm (:,:,:) !< k-coefficient for momentum real , allocatable :: ekh (:,:,:) !< k-coefficient for heat and q_tot real , allocatable :: sbdiss (:,:,:) !< dissiation real , allocatable :: sbshr (:,:,:) !< shear production real , allocatable :: sbbuo (:,:,:) !< buoyancy production / destruction real , allocatable :: zlt (:,:,:) !< filter width real , allocatable :: csz (:,:) !< Smagorinsky constant real , allocatable :: damp (:,:,:) !< used in van Driest/Piomelli damping function end module modsubgriddata","tags":"","url":"sourcefile/modsubgriddata.f90.html"},{"title":"modstartup.f90 – uDALES","text":"This file depends on sourcefile~~modstartup.f90~~EfferentGraph sourcefile~modstartup.f90 modstartup.f90 sourcefile~modboundary.f90 modboundary.f90 sourcefile~modstartup.f90->sourcefile~modboundary.f90 sourcefile~moddriver.f90 moddriver.f90 sourcefile~modstartup.f90->sourcefile~moddriver.f90 sourcefile~modfields.f90 modfields.f90 sourcefile~modstartup.f90->sourcefile~modfields.f90 sourcefile~modforces.f90 modforces.f90 sourcefile~modstartup.f90->sourcefile~modforces.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~modstartup.f90->sourcefile~modglobal.f90 sourcefile~modibm.f90 modibm.f90 sourcefile~modstartup.f90->sourcefile~modibm.f90 sourcefile~modibmdata.f90 modibmdata.f90 sourcefile~modstartup.f90->sourcefile~modibmdata.f90 sourcefile~modinlet.f90 modinlet.f90 sourcefile~modstartup.f90->sourcefile~modinlet.f90 sourcefile~modinletdata.f90 modinletdata.f90 sourcefile~modstartup.f90->sourcefile~modinletdata.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~modstartup.f90->sourcefile~modmpi.f90 sourcefile~modsubgrid.f90 modsubgrid.f90 sourcefile~modstartup.f90->sourcefile~modsubgrid.f90 sourcefile~modsubgriddata.f90 modsubgriddata.f90 sourcefile~modstartup.f90->sourcefile~modsubgriddata.f90 sourcefile~modsurfdata.f90 modsurfdata.f90 sourcefile~modstartup.f90->sourcefile~modsurfdata.f90 sourcefile~modthermodynamics.f90 modthermodynamics.f90 sourcefile~modstartup.f90->sourcefile~modthermodynamics.f90 sourcefile~modtimedep.f90 modtimedep.f90 sourcefile~modstartup.f90->sourcefile~modtimedep.f90 sourcefile~modboundary.f90->sourcefile~moddriver.f90 sourcefile~modboundary.f90->sourcefile~modfields.f90 sourcefile~modboundary.f90->sourcefile~modglobal.f90 sourcefile~modboundary.f90->sourcefile~modinletdata.f90 sourcefile~modboundary.f90->sourcefile~modmpi.f90 sourcefile~modboundary.f90->sourcefile~modsubgriddata.f90 sourcefile~modboundary.f90->sourcefile~modsurfdata.f90 sourcefile~moddriver.f90->sourcefile~modfields.f90 sourcefile~moddriver.f90->sourcefile~modglobal.f90 sourcefile~moddriver.f90->sourcefile~modinletdata.f90 sourcefile~moddriver.f90->sourcefile~modmpi.f90 sourcefile~modsave.f90 modsave.f90 sourcefile~moddriver.f90->sourcefile~modsave.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 sourcefile~modforces.f90->sourcefile~modfields.f90 sourcefile~modforces.f90->sourcefile~modglobal.f90 sourcefile~modforces.f90->sourcefile~modibmdata.f90 sourcefile~modforces.f90->sourcefile~modmpi.f90 sourcefile~modforces.f90->sourcefile~modsurfdata.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 sourcefile~modibm.f90->sourcefile~modboundary.f90 sourcefile~modibm.f90->sourcefile~modfields.f90 sourcefile~modibm.f90->sourcefile~modglobal.f90 sourcefile~modibm.f90->sourcefile~modibmdata.f90 sourcefile~modibm.f90->sourcefile~modmpi.f90 sourcefile~modibm.f90->sourcefile~modsubgriddata.f90 sourcefile~modibm.f90->sourcefile~modsurfdata.f90 sourcefile~initfac.f90 initfac.f90 sourcefile~modibm.f90->sourcefile~initfac.f90 sourcefile~modstat_nc.f90 modstat_nc.f90 sourcefile~modibm.f90->sourcefile~modstat_nc.f90 sourcefile~modinlet.f90->sourcefile~modfields.f90 sourcefile~modinlet.f90->sourcefile~modglobal.f90 sourcefile~modinlet.f90->sourcefile~modinletdata.f90 sourcefile~modinlet.f90->sourcefile~modmpi.f90 sourcefile~modinlet.f90->sourcefile~modsurfdata.f90 sourcefile~modinlet.f90->sourcefile~modsave.f90 sourcefile~modsubgrid.f90->sourcefile~modboundary.f90 sourcefile~modsubgrid.f90->sourcefile~modfields.f90 sourcefile~modsubgrid.f90->sourcefile~modglobal.f90 sourcefile~modsubgrid.f90->sourcefile~modinletdata.f90 sourcefile~modsubgrid.f90->sourcefile~modmpi.f90 sourcefile~modsubgrid.f90->sourcefile~modsubgriddata.f90 sourcefile~modsubgrid.f90->sourcefile~modsurfdata.f90 sourcefile~modthermodynamics.f90->sourcefile~modfields.f90 sourcefile~modthermodynamics.f90->sourcefile~modglobal.f90 sourcefile~modthermodynamics.f90->sourcefile~modmpi.f90 sourcefile~modthermodynamics.f90->sourcefile~modsurfdata.f90 sourcefile~modtimedep.f90->sourcefile~modfields.f90 sourcefile~modtimedep.f90->sourcefile~modglobal.f90 sourcefile~modtimedep.f90->sourcefile~modibmdata.f90 sourcefile~modtimedep.f90->sourcefile~modmpi.f90 sourcefile~modtimedep.f90->sourcefile~initfac.f90 sourcefile~initfac.f90->sourcefile~modglobal.f90 sourcefile~initfac.f90->sourcefile~modmpi.f90 sourcefile~modsave.f90->sourcefile~modfields.f90 sourcefile~modsave.f90->sourcefile~modglobal.f90 sourcefile~modsave.f90->sourcefile~modibmdata.f90 sourcefile~modsave.f90->sourcefile~modinletdata.f90 sourcefile~modsave.f90->sourcefile~modmpi.f90 sourcefile~modsave.f90->sourcefile~modsubgriddata.f90 sourcefile~modsave.f90->sourcefile~modsurfdata.f90 sourcefile~modsave.f90->sourcefile~initfac.f90 sourcefile~modstat_nc.f90->sourcefile~modglobal.f90 sourcefile~modstat_nc.f90->sourcefile~modmpi.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~modstartup.f90~~AfferentGraph sourcefile~modstartup.f90 modstartup.f90 sourcefile~program.f90 program.f90 sourcefile~program.f90->sourcefile~modstartup.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> \\file modstartup.f90 !!  Initializes the run !> !! Initializes the run. !> !! Modstartup reads the namelists and initial data, sets the fields and calls !! the inits of the other routines where necessary. Reading of the !! restart files also live in this module. !!  \\author Jasper Tomas, TU Delft !!  \\author Chiel van Heerwaarden, Wageningen U.R. !!  \\author Thijs Heus,MPI-M !!  \\todo documentation !!  \\par Revision list ! !  This file is part of DALES. ! ! DALES is free software; you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation; either version 3 of the License, or ! (at your option) any later version. ! ! DALES is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !  Copyright 1993-2009 Delft University of Technology, Wageningen University, Utrecht University, KNMI ! module modstartup use mpi implicit none ! private ! public :: startup,trestart save integer ( KIND = selected_int_kind ( 6 )) :: irandom = 43 !    * number to seed the randomnizer with integer :: krand = huge ( 0 ) ! returns the largest integer that is not an infinity real :: randu = 0.01 , randthl = 0.0 , randqt = 0.0 !    * uvw,thl and qt amplitude of randomnization contains subroutine readnamelists !-----------------------------------------------------------------| !                                                                 | !     Reads all general options from namoptions                   | !                                                                 | !      Jasper Tomas                 31/03/2014                    | !      Chiel van Heerwaarden        15/06/2007                    | !      Thijs Heus                   15/06/2007                    | !-----------------------------------------------------------------| use modglobal , only : initglobal , iexpnr , runtime , dtmax , & lwarmstart , lstratstart , lfielddump , lreadscal , startfile , tfielddump , fieldvars , tsample , tstatsdump , tstatstart , trestart , & nsv , itot , jtot , ktot , xlen , ylen , xlat , xlon , xday , xtime , lwalldist , & lmoist , lcoriol , igrw_damp , geodamptime , ifnamopt , fname_options , & nscasrc , nscasrcl , iwallmom , iwalltemp , iwallmoist , iwallscal , ipoiss , iadv_mom , iadv_tke , iadv_thl , iadv_qt , iadv_sv , courant , diffnr , ladaptive , author ,& linoutflow , lper2inout , libm , lnudge , lnudgevel , tnudge , nnudge , lles , luoutflowr , lvoutflowr , luvolflowr , lvvolflowr , & uflowrate , vflowrate , lstoreplane , iplane , & lreadmean , iinletgen , inletav , lreadminl , Uinf , Vinf , linletRA , nblocks , & lscalrec , lSIRANEinout , lscasrc , lscasrcl , lscasrcr , lydump , lytdump , lxydump , lxytdump , ltdump , lmintdump , ltkedump , lzerogradtop ,& lkslicedump , lislicedump , ljslicedump , kslice , islice , jslice ,& lzerogradtopscal , lbuoyancy , ltempeq , & lfixinlet , lfixutauin , pi , & thlsrc , ifixuinf , lvinf , tscale , ltempinout , lmoistinout , & lwallfunc , lprofforc , lchem , k1 , JNO2 , rv , rd , tnextEB , tEB , dtEB , bldT , flrT , lperiodicEBcorr , fraction , sinkbase , wsoil , wgrmax , wwilt , wfc , skyLW , GRLAI , rsmin , nfcts , lEB , lwriteEBfiles , nfaclyrs , lconstW , lvfsparse , nnz , lfacTlyrs , & BCxm , BCxT , BCxq , BCxs , BCym , BCyT , BCyq , BCys , BCzp , ds , & BCtopm , BCtopT , BCtopq , BCtops , BCbotm , BCbotT , BCbotq , BCbots , & BCxm_periodic , BCym_periodic , & idriver , tdriverstart , driverjobnr , dtdriver , driverstore , lchunkread , chunkread_size , & lrandomize , prandtlturb , fkar , lwritefac , dtfac , tfac , tnextfac , & ltrees , ntrees , Qstar , dQdt , lad , lsize , r_s , cd , dec , ud , ltreedump , & lpurif , npurif , Qpu , epu , & lheatpump , lfan_hp , nhppoints , Q_dot_hp , QH_dot_hp use modsurfdata , only : z0 , z0h , wtsurf , wttop , wqtop , wqsurf , wsvsurf , wsvtop , wsvsurfdum , wsvtopdum , ps , thvs , thls , thl_top , qt_top , qts use modfields , only : initfields , dpdx , ncname use modpois , only : initpois use modboundary , only : initboundary , ksp use modthermodynamics , only : initthermodynamics , lqlnr , chi_half use modsubgrid , only : initsubgrid use modmpi , only : comm3d , myid , myidx , myidy , cmyid , cmyidx , cmyidy , mpi_integer , mpi_logical , my_real , mpierr , mpi_character , nprocx , nprocy , nbreast , nbrwest , nbrnorth , nbrsouth use modinlet , only : initinlet use modinletdata , only : di , dr , di_test , dti , iangledeg , iangle use modibmdata , only : bctfxm , bctfxp , bctfym , bctfyp , bctfz , bcqfxm , bcqfxp , bcqfym , bcqfyp , bcqfz use modforces , only : calcfluidvolumes use moddriver , only : initdriver use modtimedep , only : ltimedepsurf , ntimedepsurf , ltimedepnudge , ntimedepnudge , & ltimedeplw , ntimedeplw , ltimedepsw , ntimedepsw use modibm , only : nsolpts_u , nsolpts_v , nsolpts_w , nsolpts_c , & nbndpts_u , nbndpts_v , nbndpts_w , nbndpts_c , & nfctsecs_u , nfctsecs_v , nfctsecs_w , nfctsecs_c , & createmasks , lbottom , lnorec use decomp_2d implicit none integer :: ierr logical , dimension ( 3 ) :: periodic_bc integer , dimension ( 2 ) :: myids !declare namelists namelist / RUN / & iexpnr , lwarmstart , lstratstart , startfile , & runtime , dtmax , trestart , ladaptive , & irandom , randu , randthl , randqt , krand , & courant , diffnr , author , & libm , lles , & lper2inout , lwalldist , & lreadmean , & nprocx , nprocy , & lrandomize namelist / DOMAIN / & itot , jtot , ktot , xlen , ylen , & xlat , xlon , xday , xtime , ksp namelist / PHYSICS / & ps , igrw_damp , lmoist , lcoriol , lbuoyancy , ltempeq , & lprofforc , ifixuinf , lvinf , tscale , dpdx , & luoutflowr , lvoutflowr , luvolflowr , lvvolflowr , & uflowrate , vflowrate , & lnudge , lnudgevel , tnudge , nnudge , & ltimedepsurf , ntimedepsurf , ltimedepnudge , ntimedepnudge , & ltimedeplw , ntimedeplw , ltimedepsw , ntimedepsw namelist / DYNAMICS / & lqlnr , ipoiss , & iadv_mom , iadv_tke , iadv_thl , iadv_qt , iadv_sv namelist / BC / & BCxm , BCxT , BCxq , BCxs , & BCym , BCyT , BCyq , BCys , & BCtopm , BCtopT , BCtopq , BCtops , & BCbotm , BCbotT , BCbotq , BCbots , & bctfxm , bctfxp , bctfym , bctfyp , bctfz , & bcqfxm , bcqfxp , bcqfym , bcqfyp , bcqfz , & wttop , thl_top , qt_top , qts , wsvsurfdum , wsvtopdum , & wtsurf , wqsurf , thls , z0 , z0h , BCzp , ds namelist / INLET / & Uinf , Vinf , di , dti , inletav , linletRA , & lstoreplane , lreadminl , lfixinlet , lfixutauin , & lwallfunc namelist / DRIVER / & idriver , tdriverstart , driverjobnr , dtdriver , & driverstore , iplane , iangledeg , & lchunkread , chunkread_size namelist / WALLS / & nblocks , nfcts , iwallmom , iwalltemp , iwallmoist , iwallscal , & nsolpts_u , nsolpts_v , nsolpts_w , nsolpts_c , & nbndpts_u , nbndpts_v , nbndpts_w , nbndpts_c , & nfctsecs_u , nfctsecs_v , nfctsecs_w , nfctsecs_c , lbottom , lnorec , & prandtlturb , fkar , lwritefac , dtfac namelist / ENERGYBALANCE / & lEB , lwriteEBfiles , lperiodicEBcorr , sinkbase , lconstW , dtEB , bldT , flrT , wsoil , wgrmax , wwilt , wfc , & skyLW , GRLAI , rsmin , nfaclyrs , lfacTlyrs , lvfsparse , nnz , fraction namelist / SCALARS / & lreadscal , lscasrc , lscasrcl , lscasrcr , & nsv , nscasrc , nscasrcl !!xS, yS, zS, SS, sigS namelist / CHEMISTRY / & lchem , k1 , JNO2 namelist / OUTPUT / & lfielddump , tfielddump , fieldvars , & ltdump , lydump , lytdump , lxydump , lxytdump , lmintdump , & lkslicedump , kslice , lislicedump , islice , ljslicedump , jslice , ltkedump , tstatsdump , tsample , & tstatstart namelist / TREES / & ltrees , ntrees , cd , dec , ud , lad , Qstar , dQdt , lsize , r_s , ltreedump namelist / PURIFS / & lpurif , npurif , Qpu , epu namelist / HEATPUMP / & lheatpump , lfan_hp , nhppoints , Q_dot_hp , QH_dot_hp if ( myid == 0 ) then if ( command_argument_count () >= 1 ) then call get_command_argument ( 1 , fname_options ) end if !write (*, *) fname_options open ( ifnamopt , file = fname_options , status = 'old' , iostat = ierr ) if ( ierr /= 0 ) then write ( 0 , * ) 'ERROR: Namoptions does not exist' write ( 0 , * ) 'iostat error: ' , ierr stop 1 end if read ( ifnamopt , RUN , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions RUN' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif !write (6, RUN) rewind ( ifnamopt ) read ( ifnamopt , DOMAIN , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions DOMAIN' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif !write (6, DOMAIN) rewind ( ifnamopt ) read ( ifnamopt , PHYSICS , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions PHYSICS' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif !write (6, PHYSICS) rewind ( ifnamopt ) read ( ifnamopt , DYNAMICS , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions DYNAMICS' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif !write (6, DYNAMICS) rewind ( ifnamopt ) read ( ifnamopt , BC , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions BC' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif !write (6, BC) rewind ( ifnamopt ) read ( ifnamopt , INLET , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions INLET' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif !write (6, INLET) rewind ( ifnamopt ) read ( ifnamopt , DRIVER , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'Problem in namoptions DRIVER' write ( 0 , * ) 'iostat error: ' , ierr stop 'ERROR: Problem in namoptions DRIVER' endif !write (6, DRIVER) rewind ( ifnamopt ) read ( ifnamopt , WALLS , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions WALLS' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif !write (6, WALLS) rewind ( ifnamopt ) read ( ifnamopt , ENERGYBALANCE , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions EB' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif !write (6, ENERGYBALANCE) rewind ( ifnamopt ) read ( ifnamopt , SCALARS , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions SCALARS' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif !write (6, SCALARS) rewind ( ifnamopt ) read ( ifnamopt , CHEMISTRY , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions CHEMISTRY' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif !write (6, CHEMISTRY) rewind ( ifnamopt ) read ( ifnamopt , TREES , iostat = ierr ) if ( ierr > 0 ) then print * , 'ERROR: Problem in namoptions TREES' print * , 'iostat error: ' , ierr stop 1 endif !write (6, TREES) rewind ( ifnamopt ) read ( ifnamopt , PURIFS , iostat = ierr ) if ( ierr > 0 ) then print * , 'ERROR: Problem in namoptions PURIFS' print * , 'iostat error: ' , ierr stop 1 endif !write (6, PURIFS) rewind ( ifnamopt ) read ( ifnamopt , HEATPUMP , iostat = ierr ) if ( ierr > 0 ) then print * , 'ERROR: Problem in namoptions HEATPUMP' print * , 'iostat error: ' , ierr stop 1 endif !write (6, HEATPUMP) rewind ( ifnamopt ) read ( ifnamopt , OUTPUT , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions OUTPUT' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif !write (6, OUTPUT) close ( ifnamopt ) end if call MPI_BCAST ( itot , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( jtot , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( ktot , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( nprocx , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( nprocy , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCxm , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCym , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCzp , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) ! if (BCxm .eq. BCxm_periodic .and. nprocx > 1) then !   periodic_bc(1) = .true. ! else !   periodic_bc(1) = .false. ! end if ! ! if (BCym .eq. BCym_periodic .and. nprocy > 1) then !   periodic_bc(2) = .true. ! else !   periodic_bc(2) = .false. ! end if ! ! periodic_bc(3) = .false. ! call decomp_2d_init(itot,jtot,ktot,nprocx,nprocy,periodic_bc) ! !myid = nrank ! !write(cmyid,'(i3.3)') myid ! ! comm3d = DECOMP_2D_COMM_CART_Z ! !write(*,*) \"myid\", myid ! call MPI_CART_COORDS(comm3d,myid,2,myids,mpierr) ! !write(*,*) \"myids\", myids ! myidx = myids(1) ! myidy = myids(2) ! ! write(*,*) \"myid\", \" myids\", myid, myids' ! ! write(cmyidx,'(i3.3)') myidx ! write(cmyidy,'(i3.3)') myidy ! ! call MPI_CART_SHIFT(comm3d, 0,  1, nbrwest,  nbreast ,   mpierr) ! call MPI_CART_SHIFT(comm3d, 1,  1, nbrsouth, nbrnorth,   mpierr) !call init2decomp !write (*, *) \"starting broadcast\" call MPI_BCAST ( iexpnr , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( lwarmstart , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lstratstart , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lfielddump , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lreadscal , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch to read scalar pollutant fields (warm start) call MPI_BCAST ( lscasrc , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! tg3315 call MPI_BCAST ( lscasrcl , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! tg3315 call MPI_BCAST ( lscasrcr , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! tg3315 call MPI_BCAST ( lbuoyancy , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for buoyancy force in modforces call MPI_BCAST ( ltempeq , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for solving adv/diff equation for temperature call MPI_BCAST ( lper2inout , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for restart periodic flow to inoutflow call MPI_BCAST ( libm , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for turning on/off IBM method call MPI_BCAST ( lnudge , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lnudgevel , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( nnudge , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( tnudge , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( ltimedepsurf , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( ltimedepnudge , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( ltimedeplw , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( ltimedepsw , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( ntimedepsurf , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( ntimedepnudge , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( ntimedeplw , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( ntimedepsw , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( lwalldist , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for computing wall distances call MPI_BCAST ( lles , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for turning on/off LES functionality (subgrid model) call MPI_BCAST ( linletRA , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for turning on/off Running Average in inletgenerator call MPI_BCAST ( lfixinlet , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for keeping average inlet velocit and temp fixed at inlet (iinletgen=1,2) call MPI_BCAST ( lfixutauin , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for keeping utau fixed at inlet (iinletgen=1,2) !call MPI_BCAST(xS, 1, MY_REAL, 0, comm3d, mpierr) !call MPI_BCAST(yS, 1, MY_REAL, 0, comm3d, mpierr) !call MPI_BCAST(zS, 1, MY_REAL, 0, comm3d, mpierr) !call MPI_BCAST(SS, 1, MY_REAL, 0, comm3d, mpierr) !call MPI_BCAST(sigS, 1, MY_REAL, 0, comm3d, mpierr) call MPI_BCAST ( idriver , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) ! ae1212: Added switch for driver inlet simulation call MPI_BCAST ( tdriverstart , 1 , MY_REAL , 0 , comm3d , mpierr ) ! ae1212 call MPI_BCAST ( driverjobnr , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) ! ae1212 call MPI_BCAST ( dtdriver , 1 , MY_REAL , 0 , comm3d , mpierr ) ! ae1212 call MPI_BCAST ( driverstore , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( lchunkread , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( chunkread_size , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) !call MPI_BCAST(BCxm, 1, MPI_INTEGER, 0, comm3d, mpierr) call MPI_BCAST ( BCxT , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCxq , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCxs , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) !call MPI_BCAST(BCym, 1, MPI_INTEGER, 0, comm3d, mpierr) call MPI_BCAST ( BCyT , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCyq , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCys , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCtopm , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCtopT , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCtopq , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCtops , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCbotm , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCbotT , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCbotq , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( BCbots , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( ds , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lwallfunc , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for reading mean inlet/recycle plane profiles (Uinl,Urec,Wrec) call MPI_BCAST ( lreadminl , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for reading mean inlet/recycle plane profiles (Uinl,Urec,Wrec) call MPI_BCAST ( iwalltemp , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) ! case (integer) for wall treatment for temperature (1=no wall function/fixed flux, 2=no wall function/fixed value, 3=uno) call MPI_BCAST ( iwallmoist , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) ! case (integer) for wall treatment for moisture (1=no wall function/fixed flux, 2=no wall function/fixed value, 3=uno) call MPI_BCAST ( iwallscal , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( iwallmom , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) ! case (integer) for wall treatment for momentum (1=no wall function, 2=werner-wengle, 3=uno) call MPI_BCAST ( nsolpts_u , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( nsolpts_v , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( nsolpts_w , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( nsolpts_c , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( nbndpts_u , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( nbndpts_v , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( nbndpts_w , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( nbndpts_c , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( nfctsecs_u , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( nfctsecs_v , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( nfctsecs_w , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( nfctsecs_c , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( lbottom , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lnorec , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lwritefac , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( tfac , 1 , MY_REAL , 0 , comm3d , mpierr ) tnextfac = dtfac call MPI_BCAST ( tnextfac , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( luoutflowr , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for turning on/off u-velocity correction for fixed mass outflow rate call MPI_BCAST ( lvoutflowr , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! tg3315: added switch for turning on/off v-velocity correction for fixed mass outflow rate call MPI_BCAST ( luvolflowr , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! bss166: added switch for turning on/off u-velocity correction for fixed volume flow rate call MPI_BCAST ( lvvolflowr , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! bss116: added switch for turning on/off v-velocity correction for fixed volume flow rate call MPI_BCAST ( lstoreplane , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for turning on/off for storing i-plane data to serve as inlet for future sim. call MPI_BCAST ( lreadmean , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! J.Tomas: added switch for reading mean variables from means#MYID#.#EXPNR# call MPI_BCAST ( lydump , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! tg3315 added switch for writing statistics files call MPI_BCAST ( lytdump , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! tg3315 added switch for writing statistics files call MPI_BCAST ( lxydump , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! tg3315 added switch for writing statistics files call MPI_BCAST ( lxytdump , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! tg3315 added switch for writing statistics files call MPI_BCAST ( lkslicedump , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lislicedump , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( ljslicedump , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( kslice , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( islice , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( jslice , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( ltdump , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! tg3315 added switch for writing statistics files call MPI_BCAST ( lmintdump , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! tg3315 added switch for writing statistics files call MPI_BCAST ( ltkedump , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) ! tg3315 added switch for writing tke budget files call MPI_BCAST ( iplane , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) ! J.Tomas: ib+iplane is the i-plane that is stored if lstoreplane is .true. call MPI_BCAST ( startfile , 50 , MPI_CHARACTER , 0 , comm3d , mpierr ) call MPI_BCAST ( author , 80 , MPI_CHARACTER , 0 , comm3d , mpierr ) call MPI_BCAST ( runtime , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( trestart , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( tfielddump , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( tsample , 1 , MY_REAL , 0 , comm3d , mpierr ) !tg3315 call MPI_BCAST ( tstatsdump , 1 , MY_REAL , 0 , comm3d , mpierr ) !tg3315 call MPI_BCAST ( tstatstart , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( tEB , 1 , MY_REAL , 0 , comm3d , mpierr ) tnextEB = dtEB call MPI_BCAST ( tnextEB , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( dtmax , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( nsv , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( nscasrc , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( nscasrcl , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( fieldvars , 50 , MPI_CHARACTER , 0 , comm3d , mpierr ) !call MPI_BCAST(nstat      ,1,MPI_INTEGER,0,comm3d,mpierr) !tg3315 !call MPI_BCAST(ncstat     ,80,MPI_CHARACTER,0,comm3d,mpierr) !tg3315 call MPI_BCAST ( ifixuinf , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( lvinf , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( dpdx , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( tscale , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( itot , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( jtot , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( ktot , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( xlen , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( ylen , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( xlat , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( xlon , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( xday , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( xtime , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( z0 , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( z0h , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( bctfxm , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( bctfxp , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( bctfym , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( bctfyp , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( bctfz , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( bcqfxm , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( bcqfxp , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( bcqfym , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( bcqfyp , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( bcqfz , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( wtsurf , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( wqsurf , 1 , MY_REAL , 0 , comm3d , mpierr ) allocate ( wsvsurf ( 1 : nsv )) wsvsurf = wsvsurfdum ( 1 : nsv ) call MPI_BCAST ( wsvsurf ( 1 : nsv ), nsv , MY_REAL , 0 , comm3d , mpierr ) allocate ( wsvtop ( 1 : nsv )) wsvtop = wsvtopdum ( 1 : nsv ) call MPI_BCAST ( wsvtop ( 1 : nsv ), nsv , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( ps , 1 , MY_REAL , 0 , comm3d , mpierr ) thvs = thls * ( 1. + ( rv / rd - 1. ) * qts ) call MPI_BCAST ( thvs , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( thls , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( thl_top , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( qt_top , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( qts , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lmoist , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lcoriol , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lprofforc , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lchem , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( k1 , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( JNO2 , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( igrw_damp , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( geodamptime , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( wttop , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( wqtop , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( thlsrc , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( uflowrate , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( vflowrate , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( Uinf , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( Vinf , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( di , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( dti , 1 , MY_REAL , 0 , comm3d , mpierr ) dr = di ! initial value is needed di_test = di ! initial value is needed call MPI_BCAST ( iangledeg , 1 , MY_REAL , 0 , comm3d , mpierr ) iangle = iangledeg * pi / 18 0. call MPI_BCAST ( inletav , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lqlnr , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( ksp , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( nblocks , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) ! no. of blocks used in IBM call MPI_BCAST ( nfcts , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( lconstW , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lEB , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lwriteEBfiles , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( wsoil , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( wgrmax , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( wwilt , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( wfc , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( dtEB , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( bldT , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( flrT , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lperiodicEBcorr , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( sinkbase , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( fraction , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( skyLW , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( GRLAI , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( rsmin , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( nfaclyrs , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( lfacTlyrs , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lvfsparse , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( nnz , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( irandom , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( krand , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( randthl , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( randu , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( randqt , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( ladaptive , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( courant , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( diffnr , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( ipoiss , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( iadv_mom , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( iadv_tke , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( iadv_thl , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( iadv_qt , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( iadv_sv ( 1 : nsv ), nsv , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( lrandomize , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( prandtlturb , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( fkar , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( ltrees , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( ntrees , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( ltreedump , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( Qstar , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( dQdt , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lsize , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lad , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( r_s , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( cd , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( dec , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( ud , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lpurif , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( npurif , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( Qpu , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( epu , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lheatpump , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lfan_hp , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( nhppoints , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( Q_dot_hp , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( QH_dot_hp , 1 , MY_REAL , 0 , comm3d , mpierr ) ! ! Allocate and initialize core modules ! call initglobal ! !write (*, *) \"done initglobal\" ! call initfields ! !write (*, *) \"done initfields\" ! call initboundary ! !write (*, *) \"done initboundary\" ! call initthermodynamics ! ! write (*, *) \"done initthermodynamics\" ! ! !!depreated!! ! ! ! call initsurface ! ! write (*, *) \"done initsurface\" ! call initsubgrid ! !write (*, *) \"done initsubgrid\" ! ! call initpois ! ! write (*, *) \"done initpois\" ! ! call initinlet ! added by J. Tomas: initialize inlet generator ! ! write (*, *) \"done initinlet\" ! call initdriver  ! added by ae1212: initialise driver inlet ! ! write(*,*) \"done initdriver\" ! call checkinitvalues ! !write (*, *) \"done checkinitvalues\" ! call initpois ! !write (*, *) \"done initpois\" ! ! write (6, *) 'Determine masking matrices' ! call createmasks ! determine walls/blocks ! ! write (6, *) 'Finished determining masking matrices' ! ! ! calculate fluid volume and outlet areas, needs masking matrices ! call calcfluidvolumes ! ! ! call readinitfiles ! !write (*, *) \"done readinitfiles\" ! ! write (*, *) \"done startup\" ! ! ! ! call createscals ! ! write (*, *) \"done create scals\" end subroutine readnamelists subroutine init2decomp use decomp_2d use modglobal , only : itot , jtot , ktot , BCxm , BCym , BCxm_periodic , Bcym_periodic use modmpi , only : comm3d , myid , myidx , myidy , cmyidx , cmyidy , nprocx , nprocy , & nbreast , nbrwest , nbrnorth , nbrsouth , mpierr implicit none logical , dimension ( 3 ) :: periodic_bc integer , dimension ( 2 ) :: myids if ( BCxm . eq . BCxm_periodic . and . nprocx > 1 ) then periodic_bc ( 1 ) = . true . else periodic_bc ( 1 ) = . false . end if if ( BCym . eq . BCym_periodic . and . nprocy > 1 ) then periodic_bc ( 2 ) = . true . else periodic_bc ( 2 ) = . false . end if periodic_bc ( 3 ) = . false . call decomp_2d_init ( itot , jtot , ktot , nprocx , nprocy , periodic_bc ) comm3d = DECOMP_2D_COMM_CART_Z call MPI_CART_COORDS ( comm3d , myid , 2 , myids , mpierr ) myidx = myids ( 1 ) myidy = myids ( 2 ) write ( cmyidx , '(i3.3)' ) myidx write ( cmyidy , '(i3.3)' ) myidy call MPI_CART_SHIFT ( comm3d , 0 , 1 , nbrwest , nbreast , mpierr ) call MPI_CART_SHIFT ( comm3d , 1 , 1 , nbrsouth , nbrnorth , mpierr ) end subroutine init2decomp subroutine checkinitvalues !-----------------------------------------------------------------| !                                                                 | !      Thijs Heus   TU Delft  9/2/2006                            | !                                                                 | !     purpose.                                                    | !     --------                                                    | !                                                                 | !      checks whether crucial parameters are set correctly        | !                                                                 | !     interface.                                                  | !     ----------                                                  | !                                                                 | !     *checkinitvalues* is called from *program*.                 | !                                                                 | !-----------------------------------------------------------------| use modsurfdata , only : wtsurf , wqsurf , qts , ps use modglobal , only : itot , ktot , jtot , ylen , xlen , ib , ie , dtmax , runtime , & startfile , lwarmstart , lstratstart , lmoist , nsv , & BCxm , BCxT , BCxq , BCxs , BCym , BCyT , BCyq , BCys , BCtopm , BCbotm , & BCbotm_wfneutral , BCtopm_pressure , & BCxm_periodic , BCxT_periodic , BCxq_periodic , & BCxm_profile , BCxT_profile , BCxq_profile , & BCxm_driver , BCxT_driver , BCxq_driver , BCxs_driver , & BCym_periodic , BCym_profile , BCyT_periodic , BCyT_profile , & BCyq_periodic , BCyq_profile , & iinletgen , linoutflow , ltempeq , iwalltemp , iwallmom ,& ipoiss , POISS_FFT2D , POISS_FFT3D , POISS_CYC ,& lydump , lytdump , luoutflowr , lvoutflowr ,& lhdriver , lqdriver , lsdriver use modmpi , only : myid , comm3d , mpierr , nprocx , nprocy use modglobal , only : idriver implicit none real :: d ( 1 : itot - 1 ) logical :: inequi if ( mod ( jtot , nprocy ) /= 0 ) then if ( myid == 0 ) then write ( 0 , * ) 'STOP ERROR IN NUMBER OF PROCESSORS' write ( 0 , * ) 'nprocy must divide jtot!!! ' write ( 0 , * ) 'nprocy and jtot are: ' , nprocy , jtot end if call MPI_FINALIZE ( mpierr ) stop 1 end if if ( ipoiss == POISS_FFT2D ) then if ( mod ( itot , nprocx ) /= 0 ) then if ( myid == 0 ) then write ( 0 , * ) 'STOP ERROR IN NUMBER OF PROCESSORS' write ( 0 , * ) 'nprocx must divide itot!!! ' write ( 0 , * ) 'nprocx and itot are: ' , nprocx , itot end if call MPI_FINALIZE ( mpierr ) stop 1 end if end if if ( mod ( ktot , nprocy ) /= 0 ) then ! Only when doing CR if ( myid == 0 ) then write ( 0 , * ) 'STOP ERROR IN NUMBER OF PROCESSORS' write ( 0 , * ) 'nprocs must divide ktot!!! ' write ( 0 , * ) 'nprocs and ktot are: ' , nprocy , ktot end if call MPI_FINALIZE ( mpierr ) stop 1 end if !Check Namoptions if ( runtime < 0 ) then write ( 0 , * ) 'ERROR: runtime out of range/not set' stop 1 end if if ( dtmax < 0 ) then write ( 0 , * ) 'ERROR: dtmax out of range/not set' stop 1 end if if ( ps < 0 ) then write ( 0 , * ) 'ERROR: psout of range/not set' stop 1 end if if ( xlen < 0 ) then write ( 0 , * ) 'ERROR: xlen out of range/not set' stop 1 end if if ( ylen < 0 ) then write ( 0 , * ) 'ERROR: ylen out of range/not set' stop 1 end if if (( lwarmstart ) . or . ( lstratstart )) then if ( startfile == '' ) then write ( 0 , * ) 'ERROR: no restartfile set' stop 1 end if end if ! Call neutral wall function when air temperature not evolved or if constant heat flux. if ((( ltempeq . eqv . . false .) . or . ( iwalltemp == 1 )) . and . ( iwallmom == 2 )) then if ( myid == 0 ) write ( * , * ) \"Changing to neutral wall function\" iwallmom = 3 BCbotm = BCbotm_wfneutral end if select case ( BCxm ) case ( BCxm_periodic ) !if (myid == 0) write(*,*) \"Periodic boundary conditions for velocity in x direction\" if ( ltempeq . and . ( BCxT . ne . BCxT_periodic ) . and . ( myid == 0 )) then write ( * , * ) \"Warning: temperature not periodic in x, consider setting BCxT = \" , BCxT_periodic end if if ( lmoist . and . ( BCxq . ne . BCxq_periodic ) . and . ( myid == 0 )) then write ( * , * ) \"Warning: moisture not periodic in x, consider setting BCxq = \" , BCxq_periodic end if case ( BCxm_profile ) linoutflow = . true . call MPI_BCAST ( linoutflow , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) !if (myid == 0) write(*, *) \"x inflow velocity given by profile\" if ( ltempeq . and . ( BCxT . ne . BCxT_profile ) . and . ( myid == 0 )) then write ( * , * ) \"Warning: x inflow temperature not given by profile, & &consider setting BCxT = \" , BCxT_profile end if if ( lmoist . and . ( BCxq . ne . BCxq_profile ) . and . ( myid == 0 )) then write ( * , * ) \"Warning: x inflow moisture not given by profile, & &consider setting BCxq = \" , BCxq_profile end if if ( BCtopm . ne . BCtopm_pressure ) then if ( myid == 0 ) write ( * , * ) \"inflow-outflow: allowing vertical velocity at top, setting BCtopm = 3\" BCtopm = BCtopm_pressure end if case ( BCxm_driver ) linoutflow = . true . idriver = 2 call MPI_BCAST ( linoutflow , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) call MPI_BCAST ( idriver , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) !if (myid == 0) write (*, *) \"x inflow velocity given by file from precursor simulation\" if ( ltempeq ) then if ( BCxT == BCxT_driver ) then lhdriver = . true . else lhdriver = . false . if ( myid == 0 ) write ( * , * ) \"Warning: x inflow temperature not given by precursor.\" end if end if if ( lmoist ) then if ( BCxq == BCxq_driver ) then lqdriver = . true . else lqdriver = . false . if ( myid == 0 ) write ( * , * ) \"Warning: x inflow humidity not given by precursor.\" end if end if if ( nsv > 0 ) then if ( BCxs == BCxs_driver ) then lsdriver = . true . else lsdriver = . false . if ( myid == 0 ) write ( * , * ) \"Warning: x inflow scalars not given by precursor.\" end if end if if ( BCtopm . ne . BCtopm_pressure ) then if ( myid == 0 ) write ( * , * ) \"inflow-outflow: allowing vertical velocity at top, setting BCtopm = 3\" BCtopm = BCtopm_pressure end if end select select case ( BCym ) case ( BCym_periodic ) !if (myid == 0) write(*,*) \"Periodic boundary conditions for velocity in y direction\" if ( ltempeq . and . ( BCyT . ne . BCyT_periodic ) . and . ( myid == 0 )) then write ( * , * ) \"Warning: temperature not periodic in y, consider setting BCxT = \" , BCxT_periodic end if if ( lmoist . and . ( BCyq . ne . BCyq_periodic ) . and . ( myid == 0 )) then write ( * , * ) \"Warning: moisture not periodic in y, consider setting BCxq = \" , BCxq_periodic end if case ( BCym_profile ) linoutflow = . true . call MPI_BCAST ( linoutflow , 1 , MPI_LOGICAL , 0 , comm3d , mpierr ) !if (myid == 0) write(*, *) \"y inflow velocity given by profile\" if ( ltempeq . and . ( BCyT . ne . BCyT_profile ) . and . ( myid == 0 )) then write ( * , * ) \"Warning: y inflow temperature not given by profile, & &consider setting BCyT = \" , BCyT_profile end if if ( lmoist . and . ( BCyq . ne . BCyq_profile ) . and . ( myid == 0 )) then write ( * , * ) \"Warning: y inflow moisture not given by profile, & &consider setting BCyq = \" , BCyq_profile end if if ( BCtopm . ne . BCtopm_pressure . and . ( myid == 0 )) then write ( * , * ) \"Warning: allowing vertical velocity at top might be necessary, & &consider setting BCtopm = \" , BCtopm_pressure end if end select if (( lydump . or . lytdump ) . and . ( nprocx > 1 )) then write ( * , * ) \"Error: y-averaged statistics not currently implemented for nprocx > 1.\" stop 1 end if if (( luoutflowr ) . and . ( nprocx > 1 )) then write ( * , * ) \"Error: constant x outflow only possible for nprocx = 1.\" stop 1 end if if (( lvoutflowr ) . and . ( nprocy > 1 )) then write ( * , * ) \"Error: constant y outflow only possible for nprocy = 1.\" stop 1 end if end subroutine checkinitvalues subroutine readinitfiles use modfields , only : u0 , v0 , w0 , um , vm , wm , thlm , thl0 , thl0h , qtm , qt0 , qt0h , uinit , vinit , & ql0 , ql0h , thv0h , sv0 , svm , e12m , e120 , & dudxls , dudyls , dvdxls , dvdyls , dthldxls , dthldyls , & dqtdxls , dqtdyls , dqtdtls , dpdx , dpdxl , dpdyl , & wfls , whls , ug , vg , pgx , pgy , uprof , vprof , thlprof , qtprof , e12prof , svprof , & v0av , u0av , qt0av , ql0av , thl0av , qt0av , sv0av , exnf , exnh , presf , presh , rhof , & thlpcar , uav , thvh , thvf , IIc , IIcs , IIu , IIus , IIv , IIvs , IIw , IIws , u0h , thl0c use modglobal , only : ib , ie , ih , ihc , jb , je , jh , jhc , kb , ke , kh , khc , kmax , dtmax , dt , runtime , timeleft , timee , ntimee , ntrun , btime , dt_lim , nsv ,& zf , zh , dzf , dzh , rv , rd , grav , cp , rlv , pref0 , om23_gs , jgb , jge , Uinf , Vinf , dy , & rslabs , e12min , dzh , dtheta , dqt , dsv , cexpnr , ifinput , lwarmstart , lstratstart , trestart , numol , & ladaptive , tnextrestart , jmax , imax , xh , xf , linoutflow , lper2inout , iinletgen , lreadminl , & uflowrate , vflowrate , ltempeq , prandtlmoli , freestreamav , & tnextfielddump , tfielddump , tsample , tstatsdump , startfile , lprofforc , lchem , k1 , JNO2 ,& idriver , dtdriver , driverstore , tdriverstart , tdriverstart_cold , tdriverdump , lchunkread , xlen , ylen , itot , jtot , ibrank , ierank , jbrank , jerank , BCxm , BCym , lrandomize , BCxq , BCxs , BCxT , BCyq , BCys , BCyT , BCxm_driver ,& tEB , tnextEB , dtEB , BCxs_custom , lEB , lfacTlyrs , tfac , tnextfac , dtfac use modsubgriddata , only : ekm , ekh , loneeqn use modsurfdata , only : wtsurf , wqsurf , wsvsurf , & thls , thvs , ps , qts , svs , sv_top ! use modsurface,        only : surface,dthldz use modboundary , only : boundary , tqaver , halos use modmpi , only : slabsum , myid , comm3d , mpierr , my_real , avexy_ibm , myidx , myidy use modthermodynamics , only : thermodynamics , calc_halflev use modinletdata , only : Uinl , Urec , Wrec , u0inletbc , v0inletbc , w0inletbc , ubulk , vbulk , irecy , Utav , Ttav , & uminletbc , vminletbc , wminletbc , u0inletbcold , v0inletbcold , w0inletbcold , & storeu0inletbc , storev0inletbc , storew0inletbc , nstepread , nfile , Tinl , & Trec , tminletbc , t0inletbcold , t0inletbc , storet0inletbc , utaui , ttaui , iangle ,& u0driver , umdriver , v0driver , vmdriver , w0driver , e120driver , tdriver , thl0driver , qt0driver , storetdriver ,& storeu0driver , storeumdriver , storev0driver , storew0driver , storee120driver , storethl0driver , storeqt0driver ,& nstepreaddriver use modinlet , only : readinletfile use moddriver , only : readdriverfile , initdriver , drivergen , readdriverfile_chunk use decomp_2d , only : exchange_halo_z , update_halo , decomp_main integer i , j , k , n real , allocatable :: height (:), th0av (:) real , dimension ( ib - ih : ie + ih , jb - jh : je + jh , kb : ke + kh ) :: thv0 real , dimension ( kb : ke ) :: uaverage ! volume averaged u-velocity real , dimension ( kb : ke ) :: vaverage ! volume averaged v-velocity real , dimension ( kb : ke ) :: uaverager ! recycle plane real , dimension ( kb : ke ) :: uaveragei ! inlet plane real , dimension ( kb : ke ) :: taverager ! recycle plane real , dimension ( kb : ke ) :: taveragei ! inlet plane real , dimension ( kb : ke + 1 ) :: waverage real , dimension ( kb : ke + 1 ) :: uprofrot real , dimension ( kb : ke + 1 ) :: vprofrot real , dimension ( kb : ke + kh ) :: u_init , v_init , thl_init , qt_init real tv , ran , ran1 character ( 80 ) chmess allocate ( height ( kb : ke + kh )) allocate ( th0av ( kb : ke + kh )) if ( lstratstart ) then ! Switch ! Read restart files as in lwarmstart call readrestartfiles um = u0 vm = v0 wm = w0 thlm = thl0 !do this before or just not? qtm = qt0 svm = sv0 e12m = e120 ! Overwrite thlm, thl0, qtm, qt0 from prof.inp.xxx if ( myid == 0 ) then open ( ifinput , file = 'prof.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess !write (*, '(a80)') chmess read ( ifinput , '(a80)' ) chmess do k = kb , ke read ( ifinput , * ) & height ( k ), & thlprof ( k ), & qtprof ( k ), & uprof ( k ), & vprof ( k ), & e12prof ( k ) end do close ( ifinput ) ! write (*, *) 'height    thl     qt      u      v     e12' ! do k = ke, kb, -1 !    write (*, '(f7.1,2f8.1,3f7.1)') & !       height(k), & !       thlprof(k), & !       qtprof(k), & !       uprof(k), & !       vprof(k), & !       e12prof(k) ! ! end do end if !myid=0 ! MPI broadcast thl and qt call MPI_BCAST ( thlprof , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( qtprof , kmax , MY_REAL , 0 , comm3d , mpierr ) do k = kb , ke do j = jb - 1 , je + 1 do i = ib - 1 , ie + 1 thl0 ( i , j , k ) = thlprof ( k ) thlm ( i , j , k ) = thlprof ( k ) qt0 ( i , j , k ) = qtprof ( k ) qtm ( i , j , k ) = qtprof ( k ) end do end do end do !ILS13 reintroduced thv !tg3315 this part may wrong, could need to use call calc_halflev ! exnf = (presf/pref0)**(rd/cp)  !exner functions not in restart files ! anymore.. or at least not read ! exnh = (presh/pref0)**(rd/cp) !   write(*,*) \"exnf\",enf !   write(*,*) \"exnh\",exnh do k = kb , ke + kh do j = jb , je do i = ib , ie !write(*,*) \"thl0h\",thl0h(i,j,k) thv0h ( i , j , k ) = ( thl0h ( i , j , k ) + rlv * ql0h ( i , j , k ) / ( cp )) & * ( 1 + ( rv / rd - 1 ) * qt0h ( i , j , k ) - rv / rd * ql0h ( i , j , k )) end do end do end do do j = j , je do i = ib , ie do k = kb , ke + kh thv0 ( i , j , k ) = ( thl0 ( i , j , k ) + rlv * ql0 ( i , j , k ) / ( cp )) & * ( 1 + ( rv / rd - 1 ) * qt0 ( i , j , k ) - rv / rd * ql0 ( i , j , k )) end do end do end do thvh = 0. ! call slabsum(thvh,kb,ke,thv0h,ib-ih,ie+ih,jb-jh,je+jh,kb-kh,ke+kh,ib,ie,jb,je,kb,ke) ! redefine halflevel thv using calculated thv call avexy_ibm ( thvh ( kb : ke + kh ), thv0h ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIw ( ib : ie , jb : je , kb : ke + kh ), IIws ( kb : ke + kh ),. false .) ! thvh = thvh/rslabs thvf = 0.0 call avexy_ibm ( thvf ( kb : ke + kh ), thv0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) ! call slabsum(thvf,kb,ke,thv0,ib-ih,ie+ih,jb-jh,je+jh,kb-kh,ke+kh,ib,ie,jb,je,kb,ke) ! thvf = thvf/rslabs else !if not lstratstart if (. not . lwarmstart ) then !******************************************************************** !    1.0 prepare initial fields from files 'prof.inp' and 'scalar.inp' !    ---------------------------------------------------------------- !-------------------------------------------------------------------- !    1.1 read fields !----------------------------------------------------------------- dt = dtmax / 10 0. timee = 0. if ( myid == 0 ) then open ( ifinput , file = 'prof.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess !write (*, '(a80)') chmess read ( ifinput , '(a80)' ) chmess do k = kb , ke read ( ifinput , * ) & height ( k ), & thlprof ( k ), & qtprof ( k ), & uprof ( k ), & vprof ( k ), & e12prof ( k ) end do ! Apply rotation in horizontal !write (6, *) 'iangle = ', iangle !uprofrot = uprof*cos(iangle) - vprof*sin(iangle) !vprofrot = vprof*cos(iangle) + uprof*sin(iangle) !uprof = uprofrot !vprof = vprofrot close ( ifinput ) ! write (*, *) 'height    thl     qt      u      v     e12' ! do k = ke, kb, -1 !    !write (*, '(f7.1,2f8.1,3f7.1)') & !    write (*, *) & !       height(k), & !       thlprof(k), & !       qtprof(k), & !       uprof(k), & !       vprof(k), & !       e12prof(k) ! ! end do if ( loneeqn ) then if ( minval ( e12prof ( kb : ke )) < e12min ) then write ( * , * ) 'e12 value is zero (or less) in prof.inp' do k = kb , ke e12prof ( k ) = max ( e12prof ( k ), e12min ) end do end if end if end if ! end if myid==0 ! MPI broadcast numbers reading call MPI_BCAST ( thlprof , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( qtprof , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( uprof , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( vprof , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( e12prof , kmax , MY_REAL , 0 , comm3d , mpierr ) do k = kb , ke do j = jb - 1 , je + 1 do i = ib - 1 , ie + 1 thl0 ( i , j , k ) = thlprof ( k ) thlm ( i , j , k ) = thlprof ( k ) qt0 ( i , j , k ) = qtprof ( k ) qtm ( i , j , k ) = qtprof ( k ) u0 ( i , j , k ) = uprof ( k ) um ( i , j , k ) = uprof ( k ) v0 ( i , j , k ) = vprof ( k ) vm ( i , j , k ) = vprof ( k ) w0 ( i , j , k ) = 0.0 wm ( i , j , k ) = 0.0 e120 ( i , j , k ) = e12prof ( k ) e12m ( i , j , k ) = e12prof ( k ) !        ekm (i,j,k) = 0.0 !        ekh (i,j,k) = 0.0 ekm ( i , j , k ) = numol ekh ( i , j , k ) = numol end do end do end do do k = kb , ke do j = jb - jhc , je + jhc do i = ib - ihc , ie + ihc thl0c ( i , j , k ) = thlprof ( k ) end do end do end do ! if (ibrank) then ! do j=jb-1,je+1 !   um(ib,j,kb:ke) = uprof !   um(ib-1,j,kb:ke) = uprof ! end do ! end if ! ! if (ierank) then ! do j=jb-1,je+1 !   !um(ie,j,kb:ke) = uprof !   um(ie+1,j,kb:ke) = uprof ! end do ! end if ekh (:, :, ke + 1 ) = ekh (:, :, ke ) ! also for start up ! ILS13 30.11.17, added, not sure if necessary ! ILS13 30.11.1, commented do j = jb - jh , je + jh do i = ib - ih , ie + ih thl0 ( i , j , ke + 1 ) = thl0 ( i , j , ke ) thl0 ( i , j , kb - 1 ) = thl0 ( i , j , kb ) end do end do if ( lrandomize ) then !! add random fluctuations krand = min ( krand , ke ) do k = kb , krand call randomnize ( um , k , randu , irandom , ih , jh ) end do do k = kb , krand call randomnize ( vm , k , randu , irandom , ih , jh ) end do do k = kb , krand call randomnize ( wm , k , randu , irandom , ih , jh ) end do end if !       do k=kb+1,ke-1 !       do j=jb,je !       do i=ib+1,ie-1 !         call random_number(ran) !         ran1 = -1. +2.*ran !         wm(i,j,k)=wm(i,j,k)+ 0.1*Uinf*ran1 !       end do !       end do !       end do ! !       do k=kb+1,ke-1 !       do j=jb,je !       do i=ib+2,ie-1 !         call random_number(ran) !         ran1 = -1. +2.*ran !         um(i,j,k)=um(i,j,k)+ 0.1*Uinf*ran1 !       end do !       end do !       end do ! !       do k=kb+1,ke-1 !       do j=jb,je !       do i=ib+1,ie-1 !         call random_number(ran) !         ran1 = -1. +2.*ran !         vm(i,j,k)=vm(i,j,k)+ 0.1*Uinf*ran1 !       end do !       end do !       end do ! SO: Manually override fields ! if (((BCxm == 1) .and. (BCym == 1)) .or. ((BCxm == 6) .and. (BCym == 6))) then !   ! TGV (assumes equidistant x grid) !   do i = ib-1,ie+1 !     do j = jb-1,je+1 !       do k = kb-1,ke+1 !         um(i,j,k) = 1. * sin(4.*atan(1.) * 2. * (dx*((i-1)+myidx*imax)) / ylen) & !         * cos(4.*atan(1.) * 2. * (dy*((0.5+(j-1))+myidy*jmax)) / ylen) !& !         !* cos(4.*atan(1.) * 2. * zf(k) / ylen) !         vm(i,j,k) = 1. *-cos(4.*atan(1.) * 2. * (dx*((0.5+(i-1))+myidx*imax)) / ylen)  & !         * sin(4.*atan(1.) * 2. * (dy*((j-1)+myidy*jmax)) / ylen) !& !         !* cos(4.*atan(1.) * 2. * zf(k) / ylen) !         wm(i,j,k) = 0. !       end do !     end do !   end do ! end if ! ! For shear case ! um(:,:,ke+1) = um(:,:,ke) ! um(ib-1,:,:) = um(ib,:,:) ! um(ie-1,:,:) = um(ie,:,:) ! um(:,jb-1,:) = um(:,jb,:) ! um(:,je+1,:) = um(:,je,:) u0 = um v0 = vm w0 = wm call halos uinit = um vinit = vm ! ! zeros ! do i = ib,ie !   do j = jb,je !     do k = kb,ke !       um(i,j,k) = 0. !       u0(i,j,k) = um(i,j,k) !       uinit(i,j,k) = um(i,j,k) !       vm(i,j,k) = 0. !       v0(i,j,k) = vm(i,j,k) !       vinit(i,j,k) = vm(i,j,k) !       wm(i,j,k) = 0. !       w0(i,j,k) = 0. !     end do !   end do ! end do ! ! ones ! do i = ib,ie !   do j = jb,je !     do k = kb,ke !       um(i,j,k) = 1. !       u0(i,j,k) = um(i,j,k) !       uinit(i,j,k) = um(i,j,k) !       vm(i,j,k) = 1. !       v0(i,j,k) = vm(i,j,k) !       vinit(i,j,k) = vm(i,j,k) !       wm(i,j,k) = 0. !       w0(i,j,k) = 0. !     end do !   end do ! end do ! do i = ib,ie !   do j = jb,je !     do k = kb,ke !       um(i,j,k) = (i + myidx*imax) * (j + myidy*jmax) !       u0(i,j,k) = (i + myidx*imax) * (j + myidy*jmax) !       vm(i,j,k) = 0. !       v0(i,j,k) = 0. !       wm(i,j,k) = 0. !       w0(i,j,k) = 0. !     end do !   end do ! end do uaverage = 0. ! call slabsum(uaverage, kb, ke, um, ib - 1, ie + 1, jb - 1, je + 1, kb - 1, ke + 1, ib, ie, jb, je, kb, ke) do k = kb , ke uaverage ( k ) = uprof ( k ) * dzf ( k ) end do ubulk = sum ( uaverage ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) ! averaged u-velocity inflow profile !write (6, *) 'Modstartup: ubulk=', ubulk vaverage = 0. ! call slabsum(vaverage, kb, ke, vm, ib - 1, ie + 1, jb - 1, je + 1, kb - 1, ke + 1, ib, ie, jb, je, kb, ke) do k = kb , ke vaverage ( k ) = vprof ( k ) * dzf ( k ) end do vbulk = sum ( vaverage ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) ! averaged u-velocity inflow profile ! Set average inlet profile to initial inlet profile in case of inletgenerator mode if ( iinletgen == 1 ) then uaverage = 0. call slabsum ( uaverage , kb , ke , um , ib - 1 , ie + 1 , jb - 1 , je + 1 , kb - 1 , ke + 1 , ib , ie , jb , je , kb , ke ) do k = kb , ke uaverage ( k ) = uprof ( k ) * dzf ( k ) end do ubulk = sum ( uaverage ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) ! volume-averaged u-velocity write ( 6 , * ) 'Modstartup: ubulk=' , ubulk Utav ( ib : ie , kb : ke ) = um ( ib : ie , jb , kb : ke ) Uinl = um ( ib , jb , kb : ke ) ! set the initial time-averaged inlet profile equal to um Urec = um ( ib , jb , kb : ke ) ! set the initial time-averaged inlet profile equal to um Wrec ( kb : ke + 1 ) = wm ( ib , jb , kb : ke + 1 ) ! set the initial time-averaged inlet profile equal to mean w-profile u0inletbcold ( jb : je , kb : ke ) = um ( ib , jb : je , kb : ke ) v0inletbcold ( jb : je , kb : ke ) = vm ( ib - 1 , jb : je , kb : ke ) w0inletbcold ( jb : je , kb : ke + 1 ) = wm ( ib - 1 , jb : je , kb : ke + 1 ) uminletbc ( jb : je , kb : ke ) = um ( ib , jb : je , kb : ke ) vminletbc ( jb : je , kb : ke ) = vm ( ib - 1 , jb : je , kb : ke ) wminletbc ( jb : je , kb : ke ) = wm ( ib - 1 , jb : je , kb : ke ) u0inletbc ( jb : je , kb : ke ) = um ( ib , jb : je , kb : ke ) v0inletbc ( jb : je , kb : ke ) = vm ( ib - 1 , jb : je , kb : ke ) w0inletbc ( jb : je , kb : ke + 1 ) = wm ( ib - 1 , jb : je , kb : ke + 1 ) utaui = sqrt ( abs ( 2 * numol * Uinl ( kb ) / dzf ( kb ))) ! average streamwise friction at inlet (need for first time step) if ( ltempeq ) then Ttav ( ib : ie , kb : ke ) = thlm ( ib : ie , jb , kb : ke ) ! set the initial time-averaged inlet profile equal to thlm Tinl = thlm ( ib , jb , kb : ke ) ! set the initial time-averaged inlet profile equal to thlm Trec = thlm ( ib , jb , kb : ke ) ! set the initial time-averaged inlet profile equal to thlm t0inletbcold ( jb : je , kb : ke ) = thlm ( ib - 1 , jb : je , kb : ke ) t0inletbc ( jb : je , kb : ke ) = thl0 ( ib - 1 , jb : je , kb : ke ) tminletbc ( jb : je , kb : ke ) = thlm ( ib - 1 , jb : je , kb : ke ) ttaui = numol * prandtlmoli * 2. * ( Tinl ( kb ) - thls ) / ( dzf ( kb ) * utaui ) ! average friction temp. at inlet (need for first time step) end if ! add random perturbations if ( myid == 0 ) then call random_number ( ran ) ran1 = - 1. + 2. * ran write ( 6 , * ) 'random=' , ran , ran1 call random_number ( ran ) ran1 = - 1. + 2. * ran write ( 6 , * ) 'random=' , ran , ran1 call random_number ( ran ) ran1 = - 1. + 2. * ran write ( 6 , * ) 'random=' , ran , ran1 call random_number ( ran ) ran1 = - 1. + 2. * ran write ( 6 , * ) 'random=' , ran , ran1 call random_number ( ran ) ran1 = - 1. + 2. * ran write ( 6 , * ) 'random=' , ran , ran1 call random_number ( ran ) ran1 = - 1. + 2. * ran write ( 6 , * ) 'random=' , ran , ran1 end if do k = kb + 1 , kb + 48 do j = jb , je do i = ib + 1 , ie - 1 call random_number ( ran ) ran1 = - 1. + 2. * ran wm ( i , j , k ) = wm ( i , j , k ) + 0.1 * Uinf * ran1 end do end do end do !       do k=kb+1,ke-1 do k = kb + 1 , kb + 48 do j = jb , je do i = ib + 2 , ie - 1 call random_number ( ran ) ran1 = - 1. + 2. * ran um ( i , j , k ) = um ( i , j , k ) + 0.1 * Uinf * ran1 end do end do end do !       do k=kb+1,ke-1 do k = kb + 1 , kb + 48 do j = jb , je do i = ib + 1 , ie - 1 call random_number ( ran ) ran1 = - 1. + 2. * ran vm ( i , j , k ) = vm ( i , j , k ) + 0.1 * Uinf * ran1 end do end do end do u0 = um v0 = vm w0 = wm else if ( iinletgen == 2 ) then nfile = nfile + 1 call readinletfile u0inletbc (:, :) = storeu0inletbc (:, :, nstepread ) v0inletbc (:, :) = storev0inletbc (:, :, nstepread ) w0inletbc (:, :) = storew0inletbc (:, :, nstepread ) uminletbc (:, :) = storeu0inletbc (:, :, nstepread ) vminletbc (:, :) = storev0inletbc (:, :, nstepread ) wminletbc (:, :) = storew0inletbc (:, :, nstepread ) ! determine bulk velocity call slabsum ( uaverage , kb , ke , u0 , ib - 1 , ie + 1 , jb - 1 , je + 1 , kb - 1 , ke + 1 , ib , ie , jb , je , kb , ke ) uaverage = uaverage / (( ie - ib + 1 ) * ( jge - jgb + 1 )) ! this gives the i-j-averaged velocity (only correct for equidistant grid?) do k = kb , ke uaverage ( k ) = uaverage ( k ) * dzf ( k ) end do ubulk = sum ( uaverage ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) ! volume-averaged u-velocity write ( 6 , * ) 'Modstartup: ubulk=' , ubulk elseif ( idriver == 2 ) then ! idriver if ( ibrank ) then if ( lchunkread ) then call readdriverfile_chunk else call readdriverfile end if call drivergen end if ! do k = kb, ke !    do j = jb-1, je+1 !       do i = ib-1, ie+1 !          u0(i, j, k) = u0driver(j, k) !          um(i, j, k) = umdriver(j, k) !          v0(i, j, k) = v0driver(j, k) !          vm(i, j, k) = vmdriver(j, k) !       end do !    end do ! end do ! if(myid==0) then ! write(*,*) 'Driver inlet velocity' ! do n=1,driverstore ! write (*,'(f9.2,e20.12)') storetdriver(n),     storeu0driver(1,32,n) ! end do ! endif ! call slabsum(uaverage,kb,ke,u0,ib-1,ie+1,jb-1,je+1,kb-1,ke+1,ib,ie,jb,je,kb,ke) ! uaverage = uaverage / ((ie-ib+1)*(jge-jgb+1))  ! this gives the i-j-averaged velocity (only correct for equidistant grid?) ! call avexy_ibm(uaverage(kb:ke),u0(ib:ie,jb:je,kb:ke),ib,ie,jb,je,kb,ke,ih,jh,kh,IIu(ib:ie,jb:je,kb:ke),IIus(kb:ke),.false.) ! do k=kb,ke !   uaverage(k) = uaverage(k)*dzf(k) ! end do ubulk = sum ( uaverage ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) !volume-averaged u-velocity ! if (myid==0) then !    write(6,*) 'Modstartup: ubulk=',ubulk ! end if elseif ( idriver == 1 ) then if ( runtime < tdriverstart ) then if ( myid == 0 ) write ( * , * ) 'Warning! No driver files will be written as runtime < tdriverstart.' else if ( trestart /= ( tdriverstart + ( driverstore - 1 ) * dtdriver )) then trestart = ( tdriverstart + ( driverstore - 1 ) * dtdriver ) end if if ( myid == 0 ) then write ( * , '(A,F15.5)' ) 'Warning! for driver simulation, trestart gets set as & (tdriverstart + (driverstore-1)*dtdriver), ignoring the & trestart mentioned in namoptions. Hence, trestart = ' ,( tdriverstart + ( driverstore - 1 ) * dtdriver ) if ( runtime >= tdriverstart . and . runtime + 1e-10 < ( tdriverstart + ( driverstore - 1 ) * dtdriver )) then write ( * , * ) 'Warning! Driver files cannot be written upto ' , driverstore , ' steps. & &Consider taking runtime >= (tdriverstart + (driverstore-1)*dtdriver).' end if end if end if call drivergen end if !--------------------------------------------------------------- !  1.2 randomnize fields !--------------------------------------------------------------- !     if (iinletgen /= 2 .and. iinletgen /= 1) then !       write(6,*) 'randomnizing temperature!' !       krand  = min(krand,ke) !        do k = kb,ke !edited tg3315 krand --> ke !          call randomnize(thlm,k,randthl,irandom,ih,jh) !          call randomnize(thl0,k,randthl,irandom,ih,jh) !        end do !       end if svprof = 0. if ( myid == 0 ) then if ( nsv > 0 ) then open ( ifinput , file = 'scalar.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess read ( ifinput , '(a80)' ) chmess do k = kb , ke read ( ifinput , * ) & height ( k ), & ( svprof ( k , n ), n = 1 , nsv ) end do ! open (ifinput, file='scalar.inp.'//cexpnr) ! write (6, *) 'height   sv(1) --------- sv(nsv) ' ! do k = ke, kb, -1 !    write (6, *) & !       height(k), & !       (svprof(k, n), n=1, nsv) ! end do end if end if ! end if myid==0 call MPI_BCAST ( svprof , ( ke + kh - ( kb - kh )) * nsv , MY_REAL , 0 , comm3d , mpierr ) if ( BCxs /= BCxs_custom ) then do k = kb , ke do j = jb - 1 , je + 1 do i = ib - 1 , ie + 1 do n = 1 , nsv sv0 ( i , j , k , n ) = svprof ( k , n ) svm ( i , j , k , n ) = svprof ( k , n ) end do end do end do end do end if if ( nsv > 0 ) then !tg3315 set these variables here for now and repeat for warmstart allocate ( sv_top ( 1 : nsv )) sv_top (:) = svprof ( ke , 1 : nsv ) call MPI_BCAST ( sv_top , nsv , MY_REAL , 0 , comm3d , mpierr ) !write(*,*) 'svprof', svprof !write(*,*) 'sv_top', sv_top end if !do n = 1,nsv !  do j = jb - jhc, je + jhc !    do i = ib - ihc, ie + ihc !      svm(i, j, ke + 1, n) = svm(i, j, ke) !      sv0(i, j, kb - 1, n) = sv0(i, j, kb) !    end do !  end do !end do !----------------------------------------------------------------- !    2.2 Initialize surface layer !----------------------------------------------------------------- !ILS13 reintroduced thv !tg3315 this part may wrong, could need to use call calc_halflev ! exnf = (presf/pref0)**(rd/cp)  !exner functions not in restart files ! anymore.. or at least not read ! exnh = (presh/pref0)**(rd/cp) ! ! call boundary ! tg3315 17.10.17 having this in startup was causing issues for running with lmoist ! turned of when pot. temp = temp. ! SO: can't do this yet because uses u0 and it does not include halo cells call thermodynamics ! turned off when pot. temp = temp. ! !    call boundary !    call thermodynamics ! turned off when pot. temp = temp. else !if lwarmstart !write (*, *) \"doing warmstart\" call readrestartfiles ! average initial profiles call avexy_ibm ( u_init ( kb : ke + kh ), u0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIu ( ib : ie , jb : je , kb : ke + kh ), IIus ( kb : ke + kh ),. false .) call avexy_ibm ( v_init ( kb : ke + kh ), v0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIv ( ib : ie , jb : je , kb : ke + kh ), IIvs ( kb : ke + kh ),. false .) call avexy_ibm ( thl_init ( kb : ke + kh ), thl0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) call avexy_ibm ( qt_init ( kb : ke + kh ), qt0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) if ( myid == 0 ) then ! Read profiles from file (potentially for forcing) open ( ifinput , file = 'prof.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess !write (*, '(a80)') chmess read ( ifinput , '(a80)' ) chmess do k = kb , ke read ( ifinput , * ) & height ( k ), & thlprof ( k ), & qtprof ( k ), & uprof ( k ), & vprof ( k ), & e12prof ( k ) end do close ( ifinput ) ! Write initial profile open ( ifinput , file = 'prof_restart.' // cexpnr ) write ( ifinput , * ) '# SDBL flow' write ( ifinput , * ) '# z thl qt u v e12' do k = kb , ke write ( ifinput , '(f20.15,5f12.6)' ) & height ( k ), & thl_init ( k ), & qt_init ( k ), & u_init ( k ), & v_init ( k ), & e12prof ( k ) end do close ( ifinput ) ! Apply rotation in horizontal !write (6, *) 'iangle = ', iangle !uprofrot = uprof*cos(iangle) - vprof*sin(iangle) !vprofrot = vprof*cos(iangle) + uprof*sin(iangle) !uprof = uprofrot !vprof = vprofrot if ( loneeqn ) then if ( minval ( e12prof ( kb : ke )) < e12min ) then write ( * , * ) 'e12 value is zero (or less) in prof.inp' do k = kb , ke e12prof ( k ) = max ( e12prof ( k ), e12min ) end do end if end if end if ! end if myid==0 ! MPI broadcast numbers reading call MPI_BCAST ( thlprof , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( qtprof , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( uprof , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( vprof , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( e12prof , kmax , MY_REAL , 0 , comm3d , mpierr ) btime = timee um = u0 vm = v0 wm = w0 thlm = thl0 qtm = qt0 svm = sv0 ! What if nsv=0? e12m = e120 ekm (:, :, :) = numol ekh (:, :, :) = numol * prandtlmoli !tg3315 added because wttop using ekh in modboundary which is called in startup ekh (:, :, ke + 1 ) = ekh (:, :, ke ) ! also for start up if ( idriver == 1 ) then !driverstore = (timeleft - tdriverstart)/dtdriver + 1 !if(myid==0) then !  write(*,*) 'driverstore: ', driverstore !end if if ( timee >= tdriverstart ) then tdriverstart_cold = tdriverstart tdriverstart = timee if ( trestart /= ( driverstore - 1 ) * dtdriver ) then trestart = ( driverstore - 1 ) * dtdriver end if if ( myid == 0 ) then write ( * , '(A,F15.5)' ) \"Warning! during warmstart of driver simulat ion, tdriverstart & &gets overwritten by the time instant of initd restartfile, ignoring the & &tdriverstart mentioned in namoptions. Hence, tdriverstart = \" , timee write ( * , '(A,F15.5)' ) 'Warning! for this driver simulation, trestart gets set as & (driverstore-1)*dtdriver, ignoring the trestart mentioned & in namoptions. Hence, trestart = ' ,( driverstore - 1 ) * dtdriver if ( runtime < ( driverstore - 1 ) * dtdriver ) then write ( * , * ) 'Warning! Driver files cannot be written upto ' , driverstore , ' steps. & &Consider taking runtime >= (driverstore-1)*dtdriver).' end if end if else ! if (timee<tdriverstart) if ( trestart /= ( tdriverstart + ( driverstore - 1 ) * dtdriver - btime )) then trestart = ( tdriverstart + ( driverstore - 1 ) * dtdriver ) - btime end if if ( myid == 0 ) then write ( * , '(A,F15.5)' ) 'Warning! for this driver simulation, trestart gets set as & (tdriverstart + (driverstore-1)*dtdriver - btime), ignoring the & trestart mentioned in namoptions. Hence, trestart = ' ,( tdriverstart + ( driverstore - 1 ) * dtdriver ) - btime if ( ( timee + runtime ) < ( tdriverstart + ( driverstore - 1 ) * dtdriver ) ) then write ( * , * ) 'Warning! Driver files cannot be written upto ' , driverstore , ' steps. & &Consider taking runtime + ' , timee , ' >= (tdriverstart + (driverstore-1)*dtdriver).' end if end if end if call drivergen tdriverdump = tdriverstart endif !ILS13 reintroduced thv call calc_halflev ! exnf = (presf/pref0)**(rd/cp)  !exner functions not in restart files ! anymore.. or at least not read ! exnh = (presh/pref0)**(rd/cp) !   write(*,*) \"exnf\",enf !   write(*,*) \"exnh\",exnh do j = jb , je do i = ib , ie do k = kb , ke + kh !write(*,*) \"thl0h\",thl0h(i,j,k) thv0h ( i , j , k ) = ( thl0h ( i , j , k ) + rlv * ql0h ( i , j , k ) / ( cp )) & * ( 1 + ( rv / rd - 1 ) * qt0h ( i , j , k ) - rv / rd * ql0h ( i , j , k )) end do end do end do do j = j , je do i = ib , ie do k = kb , ke + kh thv0 ( i , j , k ) = ( thl0 ( i , j , k ) + rlv * ql0 ( i , j , k ) / ( cp )) & * ( 1 + ( rv / rd - 1 ) * qt0 ( i , j , k ) - rv / rd * ql0 ( i , j , k )) end do end do end do thvh = 0. ! call slabsum(thvh,kb,ke,thv0h,ib-ih,ie+ih,jb-jh,je+jh,kb-kh,ke+kh,ib,ie,jb,je,kb,ke) ! redefine halflevel thv using calculated thv call avexy_ibm ( thvh ( kb : ke + kh ), thv0h ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIw ( ib : ie , jb : je , kb : ke + kh ), IIws ( kb : ke + kh ),. false .) ! thvh = thvh/rslabs thvf = 0.0 call avexy_ibm ( thvf ( kb : ke + kh ), thv0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) ! call slabsum(thvf,kb,ke,thv0,ib-ih,ie+ih,jb-jh,je+jh,kb-kh,ke+kh,ib,ie,jb,je,kb,ke) ! thvf = thvf/rslabs ! Set average inlet profile to initial inlet profile in case of inletgenerator mode uaverage = 0. uaveragei = 0. uaverager = 0. waverage = 0. taveragei = 0. taverager = 0. if ( iinletgen == 1 ) then call slabsum ( uaveragei , kb , ke , u0 , ib - 1 , ie + 1 , jb - 1 , je + 1 , kb - 1 , ke + 1 , ib , ib , jb , je , kb , ke ) call slabsum ( uaverager , kb , ke , u0 , ib - 1 , ie + 1 , jb - 1 , je + 1 , kb - 1 , ke + 1 , irecy , irecy , jb , je , kb , ke ) call slabsum ( waverage , kb , ke + 1 , w0 , ib - 1 , ie + 1 , jb - 1 , je + 1 , kb - 1 , ke + 1 , ib , ie , jb , je , kb , ke + 1 ) call slabsum ( uaverage , kb , ke , u0 , ib - 1 , ie + 1 , jb - 1 , je + 1 , kb - 1 , ke + 1 , ib , ie , jb , je , kb , ke ) uaverage = uaverage / (( ie - ib + 1 ) * ( jge - jgb + 1 )) ! this gives the i-j-averaged velocity (only correct for equidistant grid?) uaveragei = uaveragei / ( jge - jgb + 1 ) ! this gives the j-averaged u-velocity at the inlet uaverager = uaverager / ( jge - jgb + 1 ) ! this gives the j-averaged u-velocity at the recycle plane waverage = waverage / (( ie - ib + 1 ) * ( jge - jgb + 1 )) ! this gives the i-j-averaged w-velocity (only correct for equidistant grid?) if ( ltempeq ) then call slabsum ( taveragei , kb , ke , thl0 , ib - 1 , ie + 1 , jb - 1 , je + 1 , kb - 1 , ke + 1 , ib , ie , jb , je , kb , ke ) call slabsum ( taverager , kb , ke , thl0 , ib - 1 , ie + 1 , jb - 1 , je + 1 , kb - 1 , ke + 1 , irecy - 1 , irecy - 1 , jb , je , kb , ke ) taveragei = taveragei / (( ie - ib + 1 ) * ( jge - jgb + 1 )) ! this gives the j-averaged temperature at the inlet taverager = taverager / ( jge - jgb + 1 ) ! this gives the j-averaged temperature at the recycle plane end if if (. not . lreadminl ) then if ( myid == 0 ) then write ( 6 , * ) 'uaverage(kb)=' , uaverage ( kb ) write ( 6 , * ) 'uaverage(ke)=' , uaverage ( ke ) write ( 6 , * ) 'waverage(ke)=' , waverage ( ke ) write ( 6 , * ) 'waverage(ke-20)=' , waverage ( ke - 20 ) write ( 6 , * ) 'taveragei(kb)=' , taveragei ( kb ) write ( 6 , * ) 'taveragei(ke)=' , taveragei ( ke ) end if Utav = 0. do i = ib , ie Utav ( i , :) = uaverage end do Uinl = uaverage ! set the initial time-averaged inlet profile equal to mean u-profile read from means write ( 6 , * ) 'Uinl(kb+10)=' , Uinl ( kb + 10 ) utaui = sqrt ( abs ( 2 * numol * Uinl ( kb ) / dzf ( kb ))) ! average streamwise friction at inlet (need for first time step) Urec = uaverage ! set the initial time-averaged inlet profile equal to mean u-profile Wrec ( kb : ke + 1 ) = waverage ( kb : ke + 1 ) ! set the initial time-averaged inlet profile equal to mean w-profile Wrec ( kb ) = 0. ! set the initial time-averaged inlet profile equal to zero if ( ltempeq ) then Ttav = 0. do i = ib , ie Ttav ( i , :) = taveragei (:) end do Tinl = taveragei Trec = taveragei ttaui = numol * prandtlmoli * 2. * ( Tinl ( kb ) - thls ) / ( dzf ( kb ) * utaui ) ! friction temp. at inlet (need at first time step) end if else ! -> lreadminl -> Uinl, Urec, Wrec already read call slabsum ( uaverage , kb , ke , u0 , ib - 1 , ie + 1 , jb - 1 , je + 1 , kb - 1 , ke + 1 , ib , ie , jb , je , kb , ke ) uaverage = uaverage / (( ie - ib + 1 ) * ( jge - jgb + 1 )) ! this gives the i-j-averaged velocity (only correct for equidistant grid?) end if ! determine bulk velocity do k = kb , ke uaverage ( k ) = uaverage ( k ) * dzf ( k ) end do ubulk = sum ( uaverage ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) ! volume-averaged u-velocity write ( 6 , * ) 'Modstartup: ubulk=' , ubulk do k = kb , ke do j = jb , je uminletbc ( j , k ) = um ( ib , j , k ) vminletbc ( j , k ) = vm ( ib - 1 , j , k ) u0inletbcold ( j , k ) = um ( ib , j , k ) v0inletbcold ( j , k ) = vm ( ib - 1 , j , k ) u0inletbc ( j , k ) = um ( ib , j , k ) v0inletbc ( j , k ) = vm ( ib - 1 , j , k ) end do end do do k = kb , ke + 1 do j = jb , je wminletbc ( j , k ) = wm ( ib - 1 , j , k ) w0inletbcold ( j , k ) = wm ( ib - 1 , j , k ) w0inletbc ( j , k ) = wm ( ib - 1 , j , k ) end do end do if ( ltempeq ) then do k = kb , ke do j = jb , je tminletbc ( j , k ) = thlm ( ib - 1 , j , k ) t0inletbcold ( j , k ) = thlm ( ib - 1 , j , k ) t0inletbc ( j , k ) = thlm ( ib - 1 , j , k ) end do end do end if write ( 6 , * ) 'uminletbc(jb,kb),um(ib,jb,kb)=' , uminletbc ( jb , kb ), um ( ib , jb , kb ) write ( 6 , * ) 'uminletbc(jb+1,kb+10),um(ib,jb+1,kb+10)=' , uminletbc ( jb + 1 , kb + 10 ), um ( ib , jb + 1 , kb + 10 ) write ( 6 , * ) 'uminletbc(je,kb+10),um(ib,je,kb+10)=' , uminletbc ( je , kb + 10 ), um ( ib , je , kb + 10 ) else if ( iinletgen == 2 ) then nfile = nfile + 1 write ( 6 , * ) 'Loading inletfile' call readinletfile u0inletbc (:, :) = storeu0inletbc (:, :, nstepread ) v0inletbc (:, :) = storev0inletbc (:, :, nstepread ) w0inletbc (:, :) = storew0inletbc (:, :, nstepread ) uminletbc (:, :) = storeu0inletbc (:, :, nstepread ) vminletbc (:, :) = storev0inletbc (:, :, nstepread ) wminletbc (:, :) = storew0inletbc (:, :, nstepread ) if ( ltempeq ) then t0inletbc (:, :) = storet0inletbc (:, :, nstepread ) tminletbc (:, :) = storet0inletbc (:, :, nstepread ) end if ! determine bulk velocity call slabsum ( uaverage , kb , ke , u0 , ib - 1 , ie + 1 , jb - 1 , je + 1 , kb - 1 , ke + 1 , ib , ie , jb , je , kb , ke ) uaverage = uaverage / (( ie - ib + 1 ) * ( jge - jgb + 1 )) ! this gives the i-j-averaged velocity (only correct for equidistant grid?) do k = kb , ke uaverage ( k ) = uaverage ( k ) * dzf ( k ) end do ubulk = sum ( uaverage ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) ! volume-averaged u-velocity write ( 6 , * ) 'Modstartup: ubulk=' , ubulk elseif ( idriver == 2 ) then ! idriver if ( ibrank ) then if ( lchunkread ) then call readdriverfile_chunk else call readdriverfile end if call drivergen end if !call slabsum(uaverage,kb,ke,u0,ib-1,ie+1,jb-1,je+1,kb-1,ke+1,ib,ie,jb,je,kb,ke) !uaverage = uaverage / ((ie-ib+1)*(jge-jgb+1))  ! this gives the i-j-averaged velocity (only correct for equidistant grid?) ! call avexy_ibm(uaverage(kb:ke),u0(ib:ie,jb:je,kb:ke),ib,ie,jb,je,kb,ke,ih,jh,kh,IIu(ib:ie,jb:je,kb:ke),IIus(kb:ke),.false.) ! do k=kb,ke !   uaverage(k) = uaverage(k)*dzf(k) ! end do ! ubulk = sum(uaverage(kb:ke))/(zh(ke+1)-zh(kb)) !volume-averaged u-velocity ! if (myid==0) then !    write(6,*) 'Modstartup: ubulk=',ubulk ! end if end if ! iinletgen/idriver if ( lper2inout ) then ! if the restart starts from a periodic simulation to in/outflow, lper2inout should be set to .true. if ( myid == 0 ) then write ( 6 , * ) 'per2inout=.true. -> reading inlet profile from prof.inp.XXX and scalar.inp.XXX' open ( ifinput , file = 'prof.inp.' // cexpnr ) !  read the inlet profile from prof.inp read ( ifinput , '(a80)' ) chmess write ( * , '(a80)' ) chmess read ( ifinput , '(a80)' ) chmess do k = kb , ke read ( ifinput , * ) & height ( k ), & thlprof ( k ), & qtprof ( k ), & uprof ( k ), & vprof ( k ), & e12prof ( k ) end do svprof = 0. if ( nsv > 0 ) then open ( ifinput , file = 'scalar.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess read ( ifinput , '(a80)' ) chmess do k = kb , ke read ( ifinput , * ) & height ( k ), & ( svprof ( k , n ), n = 1 , nsv ) end do open ( ifinput , file = 'scalar.inp.' // cexpnr ) write ( 6 , * ) 'height   sv(1) --------- sv(nsv) ' do k = ke , kb , - 1 write ( 6 , * ) & height ( k ), & ( svprof ( k , n ), n = 1 , nsv ) end do end if end if ! end if myid==0 ! MPI broadcast numbers reading call MPI_BCAST ( thlprof , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( uprof , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( vprof , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( e12prof , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( qtprof , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( svprof , ( ke + kh - ( kb - kh )) * nsv , MY_REAL , 0 , comm3d , mpierr ) else if ( linoutflow ) then ! restart of inoutflow simulation: reproduce inlet boundary condition from restartfile do j = jb - 1 , je + 1 do k = kb , ke + 1 uprof ( k ) = u0 ( ib , j , k ) vprof ( k ) = ( v0 ( ib - 1 , j , k ) + v0 ( ib , j , k )) / 2 thlprof ( k ) = ( thl0 ( ib - 1 , j , k ) + thl0 ( ib , j , k )) / 2 qtprof ( k ) = ( qt0 ( ib - 1 , j , k ) + qt0 ( ib , j , k )) / 2 e12prof ( k ) = ( e120 ( ib - 1 , j , k ) + e120 ( ib , j , k )) / 2 do n = 1 , nsv svprof ( k , n ) = ( sv0 ( ib - 1 , j , k , n ) + sv0 ( ib , j , k , n )) / 2 enddo enddo enddo ! outlet bulk velocity call slabsum ( uaverage , kb , ke , u0 , ib - 1 , ie + 1 , jb - 1 , je + 1 , kb - 1 , ke + 1 , ib , ie , jb , je , kb , ke ) uaverage = uaverage / (( ie - ib + 1 ) * ( jge - jgb + 1 )) ! this gives the i-j-averaged velocity (only correct for equidistant grid?) ! determine bulk velocity do k = kb , ke uaverage ( k ) = uaverage ( k ) * dzf ( k ) end do ubulk = sum ( uaverage ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) ! volume-averaged u-velocity write ( 6 , * ) 'Modstartup: ubulk=' , ubulk else ! else per2per... read svprof regardless... ! tg3315 read svprof (but do not use regardless of above...) svprof = 0. if ( myid == 0 ) then if ( nsv > 0 ) then open ( ifinput , file = 'scalar.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess read ( ifinput , '(a80)' ) chmess do k = kb , ke read ( ifinput , * ) & height ( k ), & ( svprof ( k , n ), n = 1 , nsv ) end do open ( ifinput , file = 'scalar.inp.' // cexpnr ) write ( 6 , * ) 'height   sv(1) --------- sv(nsv) ' do k = ke , kb , - 1 write ( 6 , * ) & height ( k ), & ( svprof ( k , n ), n = 1 , nsv ) end do end if end if ! end if myid==0 call MPI_BCAST ( svprof , ( ke + kh - ( kb - kh )) * nsv , MY_REAL , 0 , comm3d , mpierr ) if ( nsv > 0 ) then !tg3315 set these variables here for now and repeat for warmstart allocate ( sv_top ( 1 : nsv )) sv_top (:) = svprof ( ke , 1 : nsv ) call MPI_BCAST ( sv_top , nsv , MY_REAL , 0 , comm3d , mpierr ) end if end if ! end if lper2inout u0av = 0.0 v0av = 0.0 thl0av = 0.0 qt0av = 0.0 th0av = 0.0 sv0av = 0. ! call slabsum(u0av  ,kb,ke+kh,u0(:,:,kb:ke+kh)  ,ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) call avexy_ibm ( u0av ( kb : ke + kh ), u0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIu ( ib : ie , jb : je , kb : ke + kh ), IIus ( kb : ke + kh ),. false .) ! call slabsum(v0av  ,kb,ke+kh,v0(:,:,kb:ke+kh)  ,ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) call avexy_ibm ( v0av ( kb : ke + kh ), v0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIv ( ib : ie , jb : je , kb : ke + kh ), IIvs ( kb : ke + kh ),. false .) ! call slabsum(thl0av,kb,ke+kh,thl0(:,:,kb:ke+kh),ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) call avexy_ibm ( thl0av ( kb : ke + kh ), thl0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) ! call slabsum(qt0av,kb,ke+kh,qt0(:,:,kb:ke+kh),ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) call avexy_ibm ( qt0av ( kb : ke + kh ), qt0 ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) do n = 1 , nsv ! call slabsum(sv0av(kb,n),kb,ke+kh,sv0(ib-ih,jb-jh,kb,n),ib-ih,ie+ih,jb-jh,je+jh,kb,ke+kh,ib,ie,jb,je,kb,ke+kh) call avexy_ibm ( sv0av ( kb : ke + khc , n ), sv0 ( ib : ie , jb : je , kb : ke + khc , n ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + khc ), IIcs ( kb : ke + khc ),. false .) end do ! CvH - only do this for fixed timestepping. In adaptive dt comes from restartfile if (. not . ladaptive ) dt = dtmax !  call boundary if ( lEB . and . ( lfacTlyrs . eqv . . false .)) then if ( myid == 0 ) write ( * , * ) \"Warmstarting an EB simulation - consider setting internal facet temperatures\" end if end if ! lwarmstart end if ! not lstratstart !----------------------------------------------------------------- !    2.1 read and initialise fields !----------------------------------------------------------------- if ( myid == 0 ) then open ( ifinput , file = 'lscale.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess read ( ifinput , '(a80)' ) chmess ! write (6, *) ' height  u_geo  v_geo  pgx  pgy  subs     ' & !    , '   dqtdx      dqtdy        dqtdtls     thl_rad ' do k = kb , ke read ( ifinput , * ) & height ( k ), & ug ( k ), & vg ( k ), & pgx ( k ), & pgy ( k ), & wfls ( k ), & dqtdxls ( k ), & dqtdyls ( k ), & dqtdtls ( k ), & thlpcar ( k ) end do close ( ifinput ) ! do k = ke, kb, -1 !    write (6, '(3f7.1,5e12.4)') & !       height(k), & !       ug(k), & !       vg(k), & !       pgx(k), & !       pgy(k), & !       wfls(k), & !       dqtdxls(k), & !       dqtdyls(k), & !       dqtdtls(k), & !       thlpcar(k) ! end do end if ! end myid==0 ! MPI broadcast variables read in call MPI_BCAST ( ug , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( vg , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( pgx , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( pgy , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( wfls , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( dqtdxls , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( dqtdyls , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( dqtdtls , kmax , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( thlpcar , kmax , MY_REAL , 0 , comm3d , mpierr ) !----------------------------------------------------------------- !    2.3 make large-scale horizontal pressure gradient !----------------------------------------------------------------- !******include rho if rho = rho(z) /= 1.0 *********** if ( lprofforc ) then !tg3315 do k = kb , ke dpdxl ( k ) = - pgx ( k ) - dpdx !-om23_gs*ug(k)-pgx(k)-dpdx dpdyl ( k ) = - pgy ( k ) end do else do k = kb , ke !dpdxl(k) =  om23_gs*vg(k) !dpdyl(k) = -om23_gs*ug(k) !dpdxl(k) =  -ug(k) !dpdyl(k) =  -vg(k) dpdxl ( k ) = om23_gs * vg ( k ) - pgx ( k ) - dpdx !corriolis forcing and pressure gradient dpdyl ( k ) = - om23_gs * ug ( k ) - pgy ( k ) end do endif !----------------------------------------------------------------- !    2.4 large-scale subsidence, reintroduced ILS13 05.06.2014 !----------------------------------------------------------------- whls ( kb ) = 0.0 do k = kb + 1 , ke whls ( k ) = ( wfls ( k ) * dzf ( k - 1 ) + wfls ( k - 1 ) * dzf ( k )) / ( 2 * dzh ( k )) end do whls ( ke + 1 ) = ( wfls ( ke ) + dzf ( ke ) * ( wfls ( ke ) - wfls ( ke - 1 )) / dzh ( ke )) ! tg3315 31/07/18 removed a 0.5 !    idtmax = floor(dtmax/tres) btime = timee !    timeleft=ceiling(runtime/tres) timeleft = runtime dt_lim = timeleft !    write(6,*) 'real(dt)*tres= ',rdt, ' dtmax/100= ',dtmax/100 if (( lwarmstart ) . or . ( lstratstart )) then ! tg3315 to have cumulative number on restart files read ( startfile ( 6 : 13 ), '(i8)' ) ntrun ! ntrun = ichar(startfile(6:13)) else ntrun = 0 end if ntimee = nint ( timee / dtmax ) tnextrestart = btime + trestart tnextfielddump = btime + tfielddump tEB = btime tnextEB = btime + dtEB tfac = btime tnextfac = btime + dtfac deallocate ( height , th0av ) !    call boundary end subroutine readinitfiles subroutine readrestartfiles use modsurfdata , only : ustar , thlflux , qtflux , svflux , dudz , dvdz , dthldz , dqtdz , ps , thls , qts , thvs , oblav , & wtsurf use modfields , only : u0 , v0 , w0 , thl0 , qt0 , ql0 , ql0h , qtav , qlav , e120 , dthvdz , presf , presh , sv0 , mindist , wall , & uav , vav , wav , uuav , vvav , wwav , uvav , uwav , vwav , svav , thlav , thl2av , sv2av , pres0 , svm , & svprof , viscratioav , thluav , thlvav , thlwav , svuav , svvav , svwav , presav , & uusgsav , vvsgsav , wwsgsav , uwsgsav , thlusgsav , thlwsgsav , svusgsav , svwsgsav , tkesgsav , & strain2av , nusgsav use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , dtheta , dqt , dsv , startfile , timee , totavtime , runavtime , & iexpnr , ntimee , rk3step , ifinput , nsv , runtime , dt , cexpnr , lreadmean , lreadminl , & totinletav , lreadscal , ltempeq , dzf , numol , prandtlmoli use modmpi , only : cmyid , cmyidx , cmyidy , myid use modsubgriddata , only : ekm use modinlet , only : zinterpolate1d , zinterpolatet1d , zinterpolatew1d , zinterpolate2d , & Uinl , Urec , Wrec , Utav , Tinl , Trec , & kbin , kein , lzinzsim , utaui , Ttav , ttaui real , dimension ( ib : ie , jb : je , kb : ke ) :: dummy3d real , dimension ( ib : ie , kbin : kein ) :: Utavin real , dimension ( ib : ie , kbin : kein ) :: Ttavin real , dimension ( kbin : kein ) :: Uinlin real , dimension ( kbin : kein ) :: Urecin real , dimension ( kbin : kein ) :: Tinlin real , dimension ( kbin : kein ) :: Trecin real , dimension ( kbin : kein + 1 ) :: Wrecin character ( 50 ) :: name , name2 , name4 real dummy integer i , j , k , n !******************************************************************** !    1.0 Read initfiles !----------------------------------------------------------------- name = startfile name ( 5 : 5 ) = 'd' name ( 15 : 17 ) = cmyidx name ( 19 : 21 ) = cmyidy !write (6, *) 'loading ', name open ( unit = ifinput , file = name , form = 'unformatted' , status = 'old' ) read ( ifinput ) ((( mindist ( i , j , k ), i = ib , ie ), j = jb , je ), k = kb , ke ) read ( ifinput ) (((( wall ( i , j , k , n ), i = ib , ie ), j = jb , je ), k = kb , ke ), n = 1 , 5 ) read ( ifinput ) ((( u0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) read ( ifinput ) ((( v0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) read ( ifinput ) ((( w0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) read ( ifinput ) ((( pres0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) read ( ifinput ) ((( thl0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) read ( ifinput ) ((( e120 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) read ( ifinput ) ((( ekm ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) read ( ifinput ) ((( qt0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) read ( ifinput ) ((( ql0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) read ( ifinput ) ((( ql0h ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) read ( ifinput ) timee , dt close ( ifinput ) !write (6, *) 'finished loading ', name if (( nsv > 0 ) . and . ( lreadscal )) then name ( 5 : 5 ) = 's' !write (6, *) 'loading ', name open ( unit = ifinput , file = name , form = 'unformatted' ) read ( ifinput ) (((( sv0 ( i , j , k , n ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ), n = 1 , nsv ) read ( ifinput ) timee close ( ifinput ) !write (6, *) 'finished loading ', name elseif (( nsv > 0 ) . and . (. not . lreadscal )) then sv0 = 0. svprof = 0. end if ! read mean variables if asked for by lreadmean name2 = 'means   .' name2 ( 6 : 8 ) = cmyid name2 ( 10 : 12 ) = cexpnr if ( lreadmean ) then write ( 6 , * ) 'Reading meansXXX.XXX, proc = ' , myid open ( unit = ifinput , file = name2 , form = 'unformatted' ) read ( ifinput ) totavtime , nsv read ( ifinput ) ((( uav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) ((( vav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) ((( wav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) ((( thlav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) ((( qtav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) ((( qlav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) ((( presav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) (((( svav ( i , j , k , n ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ), n = 1 , nsv ) read ( ifinput ) ((( viscratioav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) ((( uuav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) ((( vvav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) ((( wwav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) ((( thl2av ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) (((( sv2av ( i , j , k , n ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ), n = 1 , nsv ) read ( ifinput ) ((( uvav ( i , j , k ), i = ib , ie + ih ), j = jb , je + jh ), k = kb , ke ) read ( ifinput ) ((( uwav ( i , j , k ), i = ib , ie + ih ), j = jb , je ), k = kb , ke + kh ) read ( ifinput ) ((( vwav ( i , j , k ), i = ib , ie ), j = jb , je + jh ), k = kb , ke + kh ) read ( ifinput ) ((( thluav ( i , j , k ), i = ib , ie ), j = jb , je ), k = kb , ke ) read ( ifinput ) ((( thlvav ( i , j , k ), i = ib , ie ), j = jb , je + jh ), k = kb , ke ) read ( ifinput ) ((( thlwav ( i , j , k ), i = ib , ie ), j = jb , je ), k = kb , ke + kh ) read ( ifinput ) (((( svuav ( i , j , k , n ), i = ib , ie ), j = jb , je ), k = kb , ke ), n = 1 , nsv ) read ( ifinput ) (((( svvav ( i , j , k , n ), i = ib , ie ), j = jb , je + jh ), k = kb , ke ), n = 1 , nsv ) read ( ifinput ) (((( svwav ( i , j , k , n ), i = ib , ie ), j = jb , je ), k = kb , ke + kh ), n = 1 , nsv ) close ( ifinput ) write ( 6 , * ) 'Total averaging time so far: ' , totavtime ! read <x'y'>_SGS to file. name2 = 'SGS__   .' name2 ( 6 : 8 ) = cmyid name2 ( 10 : 12 ) = cexpnr open ( unit = ifinput , file = name2 , form = 'unformatted' ) read ( ifinput ) dummy , dummy read ( ifinput ) ((( uusgsav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) ((( vvsgsav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) ((( wwsgsav ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb - kh , ke + kh ) read ( ifinput ) ((( uwsgsav ( i , j , k ), i = ib , ie + ih ), j = jb , je ), k = kb , ke + kh ) read ( ifinput ) ((( dummy3d ( i , j , k ), i = ib , ie ), j = jb , je ), k = kb , ke ) ! this is dissresav, which will be computed using other mean quantities read ( ifinput ) ((( tkesgsav ( i , j , k ), i = ib , ie ), j = jb , je ), k = kb , ke ) read ( ifinput ) ((( dummy3d ( i , j , k ), i = ib , ie ), j = jb , je ), k = kb , ke ) ! this is disssgsav, which will be computed using other mean quantities read ( ifinput ) ((( strain2av ( i , j , k ), i = ib , ie ), j = jb , je ), k = kb , ke ) ! <SijSij> (NOT <Sij><Sij> !!) (average over time) read ( ifinput ) ((( nusgsav ( i , j , k ), i = ib , ie ), j = jb , je ), k = kb , ke ) ! <nu_sgs> (average over time) read ( ifinput ) ((( thlusgsav ( i , j , k ), i = ib , ie + ih ), j = jb , je ), k = kb , ke ) read ( ifinput ) ((( thlwsgsav ( i , j , k ), i = ib , ie ), j = jb , je ), k = kb , ke + kh ) read ( ifinput ) (((( svusgsav ( i , j , k , n ), i = ib , ie + ih ), j = jb , je ), k = kb , ke ), n = 1 , nsv ) read ( ifinput ) (((( svwsgsav ( i , j , k , n ), i = ib , ie ), j = jb , je ), k = kb , ke + kh ), n = 1 , nsv ) close ( ifinput ) end if ! read mean profiles for inlet generator if ( lreadminl ) then if (. not . lzinzsim ) then name4 = 'meaninlet.   ' name4 ( 11 : 13 ) = cexpnr open ( unit = ifinput , file = name4 , form = 'unformatted' ) read ( ifinput ) totinletav ! interval of time-average read ( ifinput ) ( Uinlin ( k ), k = kbin , kein ) read ( ifinput ) ( Urecin ( k ), k = kbin , kein ) read ( ifinput ) ( Wrecin ( k ), k = kbin , kein + 1 ) read ( ifinput ) (( Utavin ( i , k ), i = ib , ie ), k = kbin , kein ) close ( ifinput ) call zinterpolate1d ( Uinlin , Uinl ) ! interpolate inlet profile to zgrid call zinterpolate1d ( Urecin , Urec ) call zinterpolatew1d ( Wrecin , Wrec ) call zinterpolate2d ( Utavin , Utav ) if ( ltempeq ) then name4 = 'tempinlet.   ' name4 ( 11 : 13 ) = cexpnr open ( unit = ifinput , file = name4 , form = 'unformatted' ) read ( ifinput ) totinletav ! interval of time-average read ( ifinput ) ( Tinlin ( k ), k = kbin , kein ) read ( ifinput ) ( Trecin ( k ), k = kbin , kein ) read ( ifinput ) (( Ttavin ( i , k ), i = ib , ie ), k = kbin , kein ) close ( ifinput ) call zinterpolatet1d ( Tinlin , Tinl ) call zinterpolatet1d ( Trecin , Trec ) call zinterpolate2d ( Ttavin , Ttav ) end if ! ltempeq else !lzinzsim=.true. -> inlet grid equals sim grid name4 = 'meaninlet.   ' name4 ( 11 : 13 ) = cexpnr open ( unit = ifinput , file = name4 , form = 'unformatted' ) read ( ifinput ) totinletav ! interval of time-average read ( ifinput ) ( Uinl ( k ), k = kb , ke ) read ( ifinput ) ( Urec ( k ), k = kb , ke ) read ( ifinput ) ( Wrec ( k ), k = kb , ke + 1 ) read ( ifinput ) (( Utav ( i , k ), i = ib , ie ), k = kb , ke ) close ( ifinput ) if ( ltempeq ) then name4 = 'tempinlet.   ' name4 ( 11 : 13 ) = cexpnr open ( unit = ifinput , file = name4 , form = 'unformatted' ) read ( ifinput ) totinletav ! interval of time-average read ( ifinput ) ( Tinl ( k ), k = kb , ke ) read ( ifinput ) ( Trec ( k ), k = kb , ke ) read ( ifinput ) (( Ttav ( i , k ), i = ib , ie ), k = kb , ke ) close ( ifinput ) end if ! ltempeq end if ! lzinzsim utaui = sqrt ( abs ( 2 * numol * Uinl ( kb ) / dzf ( kb ))) ! average streamwise friction at inlet (need for first time step) if ( ltempeq ) then ttaui = numol * prandtlmoli * 2. * ( Tinl ( kb ) - thls ) / ( dzf ( kb ) * utaui ) end if end if !(lreadminl) end subroutine readrestartfiles subroutine exitmodules use modfields , only : exitfields use modglobal , only : exitglobal use modmpi , only : exitmpi use modpois , only : exitpois use modsubgrid , only : exitsubgrid use modthermodynamics , only : exitthermodynamics use modinlet , only : exitinlet call exitthermodynamics call exitsubgrid call exitpois call exitfields call exitglobal call exitinlet call exitmpi end subroutine exitmodules subroutine randomnize ( field , klev , ampl , ir , ihl , jhl ) use modmpi , only : myid , nprocs use modglobal , only : ib , ie , imax , jmax , jb , je , kb , ke , kh , ierank , BCxm integer ( KIND = selected_int_kind ( 6 )) :: imm , ia , ic , ir integer ihl , jhl integer i , j , klev integer m , mfac real ran , ampl real field ( ib - ihl : ie + ihl , jb - jhl : je + jhl , kb - kh : ke + kh ) parameter ( imm = 134456 , ia = 8121 , ic = 28411 ) if ( myid > 0 ) then mfac = myid * jmax * imax do m = 1 , mfac ir = mod (( ir ) * ia + ic , imm ) end do end if ! if (ierank .and. BCxm > 1) then !   do j = jb, je !     do i = ib, ie-1 !       ir = mod((ir)*ia + ic, imm) !       ran = real(ir)/real(imm) !       field(i, j, klev) = field(i, j, klev) + (ran - 0.5)*2.0*ampl !     end do !   end do ! else do j = jb , je do i = ib , ie ir = mod (( ir ) * ia + ic , imm ) ran = real ( ir ) / real ( imm ) field ( i , j , klev ) = field ( i , j , klev ) + ( ran - 0.5 ) * 2.0 * ampl end do end do !end if if ( nprocs - 1 - myid > 0 ) then mfac = ( nprocs - 1 - myid ) * imax * jmax do m = 1 , mfac ir = mod (( ir ) * ia + ic , imm ) end do end if return end subroutine randomnize ! subroutine createmasks !    use modglobal, only:ib, ie, ih, ihc, jb, je, jh, jhc, kb, ke, kh, khc, rslabs, jmax, nblocks,& !       ifinput, cexpnr, libm, jtot, block !    use modfields, only:IIc, IIu, IIv, IIw, IIuw, IIvw, IIuv, IIct, IIwt, IIut, IIuwt, IIvt,& !       IIcs, IIus, IIuws, IIvws, IIuvs, IIvs, IIws, & !       um, u0, vm, v0, wm, w0 !    use modmpi, only:myid, comm3d, mpierr, MY_REAL, nprocs, & !       cmyid, excjs !    ! use initfac, only:block !    integer k, n, il, iu, jl, ju, kl, ku !    integer :: IIcl(kb:ke + khc), IIul(kb:ke + khc), IIvl(kb:ke + khc), IIwl(kb:ke + khc), IIuwl(kb:ke + khc), IIvwl(kb:ke + khc), IIuvl(kb:ke + khc) !    integer :: IIcd(ib:ie, kb:ke) !    integer :: IIwd(ib:ie, kb:ke) !    integer :: IIuwd(ib:ie, kb:ke) !    integer :: IIud(ib:ie, kb:ke) !    integer :: IIvd(ib:ie, kb:ke) !    character(80) chmess, name2 ! !    ! II*l needn't be defined up to ke_khc, but for now would require large scale changes in modstatsdump so if works leave as is ! tg3315 04/07/18 ! !    if (.not. libm) then !       IIc(:, :, :) = 1 !       IIu(:, :, :) = 1 !       IIv(:, :, :) = 1 !       IIw(:, :, :) = 1 !       IIuw(:, :, :) = 1 !       IIvw(:, :, :) = 1 !       IIuv(:, :, :) = 1 !       IIcs(:) = nint(rslabs) !       IIus(:) = nint(rslabs) !       IIvs(:) = nint(rslabs) !       IIws(:) = nint(rslabs) !       IIuws(:) = nint(rslabs) !       IIvws(:) = nint(rslabs) !       IIuvs(:) = nint(rslabs) !       IIct(:, :) = jtot !       IIut(:, :) = jtot !       IIvt(:, :) = jtot !       IIwt(:, :) = jtot !       IIuwt(:, :) = jtot !       return !    end if ! !    allocate (block(1:nblocks, 1:11)) ! !    if (myid == 0) then !       if (nblocks > 0) then !          open (ifinput, file='blocks.inp.'//cexpnr) !          read (ifinput, '(a80)') chmess !          read (ifinput, '(a80)') chmess !          do n = 1, nblocks !             read (ifinput, *) & !                block(n, 1), & !                block(n, 2), & !                block(n, 3), & !                block(n, 4), & !                block(n, 5), & !                block(n, 6), & !                block(n, 7), & !                block(n, 8), & !                block(n, 9), & !                block(n, 10), & !                block(n, 11) !          end do !          close (ifinput) ! !          do n = 1, nblocks !             write (6, *) & !                n, & !                block(n, 1), & !                block(n, 2), & !                block(n, 3), & !                block(n, 4), & !                block(n, 5), & !                block(n, 6) !          end do !       end if !nblocks>0 !    end if !myid ! !    call MPI_BCAST(block, 11*nblocks, MPI_INTEGER, 0, comm3d, mpierr) ! !    ! Create masking matrices !    IIc = 1; IIu = 1; IIv = 1; IIct = 1; IIw = 1; IIuw = 1; IIvw = 1; IIuv = 1; IIwt = 1; IIut = 1; IIvt = 1; IIuwt = 1; IIcs = 1; IIus = 1; IIvs = 1; IIws = 1; IIuws = 1; IIvws = 1; IIuvs = 1 ! !    do n = 1, nblocks !       il = block(n, 1) !       iu = block(n, 2) !       !kl = block(n, 5) !       kl = kb ! tg3315 changed as buildings for lEB must start at kb+1 not kb with no block below !       ku = block(n, 6) !       jl = block(n, 3) - myid*jmax !       ju = block(n, 4) - myid*jmax !       if (ju < jb - 1 .or. jl > je) then !          cycle !       else !          if (ju >= je) then !tg3315 04/07/18 to avoid ju+1 when is last cell... !             if (jl < jb) jl = jb !             ju = je ! !             ! Masking matrices !tg3315 !             IIc(il:iu, jl:ju, kl:ku) = 0 !             IIu(il:iu + 1, jl:ju, kl:ku) = 0 !             IIv(il:iu, jl:ju, kl:ku) = 0 !             IIw(il:iu, jl:ju, kl:ku + 1) = 0 !             IIuw(il:iu + 1, jl:ju, kl:ku + 1) = 0 !             IIvw(il:iu, jl:ju, kl:ku + 1) = 0 !             IIuv(il:iu + 1, jl:ju, kl:ku) = 0 ! !          else if (ju == jb - 1) then ! if end of block is in cell before proc ! !             IIv(il:iu, jb, kl:ku) = 0 !             IIvw(il:iu, jb, kl:ku + 1) = 0 !             IIuv(il:iu + 1, jb, kl:ku) = 0 ! !          else ! ju is in this proc... !             if (jl < jb) jl = jb ! !             ! Masking matrices !tg3315 !             IIc(il:iu, jl:ju, kl:ku) = 0 !             IIu(il:iu + 1, jl:ju, kl:ku) = 0 !             IIv(il:iu, jl:ju + 1, kl:ku) = 0 !             IIw(il:iu, jl:ju, kl:ku + 1) = 0 !             IIuw(il:iu + 1, jl:ju, kl:ku + 1) = 0 !             IIvw(il:iu, jl:ju + 1, kl:ku + 1) = 0 !             IIuv(il:iu + 1, jl:ju + 1, kl:ku) = 0 ! !          end if ! !          ! ensure that ghost cells know where blocks are !tg3315 this is not necessary !          ! if (jl<jb+jh)  IIc(il:iu,je+jh,kl:ku) = 0 !          ! if (jl<jb+jhc) IIc(il:iu,je+jhc,kl:ku) = 0 !          ! if (ju>je-jh)  IIc(il:iu,jb-jh,kl:ku) = 0 !          ! if (ju>je-jhc) IIc(il:iu,jb-jhc,kl:ku) = 0 ! !          ! if (il<ib+ih)  IIc(ie+ih,jl:ju,kl:ku) = 0 !          ! if (il<ib+ihc) IIc(ie+ihc,jl:ju,kl:ku) = 0 !          ! if (iu>ie-ih)  IIc(ib-ih,jl:ju,kl:ku) = 0 !          ! if (iu>ie-ihc) IIc(ib-ihc,jl:ju,kl:ku) = 0 ! !       end if !    end do ! !    IIw(:, :, kb) = 0; IIuw(:, :, kb) = 0; IIvw(:, :, kb) = 0 ! !    ! for correct ghost cells from adjacent processors !tg3315 ?unsure if this is correct !    ! tg3315 22/11/17 does not work because II is an integer and needs real numbers... !tg3315 not necessary !    !call excjs( IIc  , ib,ie,jb,je,kb,ke+khc,ihc,jhc) !    !call excjs( IIu  , ib,ie,jb,je,kb,ke+khc,ihc,jhc) !    !call excjs( IIv  , ib,ie,jb,je,kb,ke+khc,ihc,jhc) !    !call excjs( IIw  , ib,ie,jb,je,kb,ke+khc,ihc,jhc) ! !    do k = kb, ke + khc !       IIcl(k) = sum(IIc(ib:ie, jb:je, k)) !       IIul(k) = sum(IIu(ib:ie, jb:je, k)) !       IIvl(k) = sum(IIv(ib:ie, jb:je, k)) !       IIwl(k) = sum(IIw(ib:ie, jb:je, k)) !       IIuwl(k) = sum(IIuw(ib:ie, jb:je, k)) !       IIvwl(k) = sum(IIvw(ib:ie, jb:je, k)) !       IIuvl(k) = sum(IIuv(ib:ie, jb:je, k)) !    enddo ! !    call MPI_ALLREDUCE(IIcl, IIcs, ke + khc - kb + 1, MPI_INTEGER, & !                       MPI_SUM, comm3d, mpierr) !    call MPI_ALLREDUCE(IIul, IIus, ke + khc - kb + 1, MPI_INTEGER, & !                       MPI_SUM, comm3d, mpierr) !    call MPI_ALLREDUCE(IIvl, IIvs, ke + khc - kb + 1, MPI_INTEGER, & !                       MPI_SUM, comm3d, mpierr) !    call MPI_ALLREDUCE(IIwl, IIws, ke + khc - kb + 1, MPI_INTEGER, & !                       MPI_SUM, comm3d, mpierr) !    call MPI_ALLREDUCE(IIuwl, IIuws, ke + khc - kb + 1, MPI_INTEGER, & !                       MPI_SUM, comm3d, mpierr) !    call MPI_ALLREDUCE(IIvwl, IIvws, ke + khc - kb + 1, MPI_INTEGER, & !                       MPI_SUM, comm3d, mpierr) !    call MPI_ALLREDUCE(IIuvl, IIuvs, ke + khc - kb + 1, MPI_INTEGER, & !                       MPI_SUM, comm3d, mpierr) ! !    IIcd(ib:ie, kb:ke) = sum(IIc(ib:ie, jb:je, kb:ke), DIM=2) !    IIwd(ib:ie, kb:ke) = sum(IIw(ib:ie, jb:je, kb:ke), DIM=2) !    IIuwd(ib:ie, kb:ke) = sum(IIuw(ib:ie, jb:je, kb:ke), DIM=2) !    IIud(ib:ie, kb:ke) = sum(IIu(ib:ie, jb:je, kb:ke), DIM=2) !    IIvd(ib:ie, kb:ke) = sum(IIv(ib:ie, jb:je, kb:ke), DIM=2) ! !    call MPI_ALLREDUCE(IIwd(ib:ie, kb:ke), IIwt(ib:ie, kb:ke), (ke - kb + 1)*(ie - ib + 1), MPI_INTEGER, MPI_SUM, comm3d, mpierr) !    call MPI_ALLREDUCE(IIcd(ib:ie, kb:ke), IIct(ib:ie, kb:ke), (ke - kb + 1)*(ie - ib + 1), MPI_INTEGER, MPI_SUM, comm3d, mpierr) !    call MPI_ALLREDUCE(IIuwd(ib:ie, kb:ke), IIuwt(ib:ie, kb:ke), (ke - kb + 1)*(ie - ib + 1), MPI_INTEGER, MPI_SUM, comm3d, mpierr) !    call MPI_ALLREDUCE(IIud(ib:ie, kb:ke), IIut(ib:ie, kb:ke), (ke - kb + 1)*(ie - ib + 1), MPI_INTEGER, MPI_SUM, comm3d, mpierr) !    call MPI_ALLREDUCE(IIvd(ib:ie, kb:ke), IIvt(ib:ie, kb:ke), (ke - kb + 1)*(ie - ib + 1), MPI_INTEGER, MPI_SUM, comm3d, mpierr) ! !    ! masking matrix for switch if entire slab is blocks !    !if (IIcs(kb) == 0) then !    !  IIbl = 0 !    !else !    !  IIbl = 1 !    !end if ! !    !where (IIcs == 0) !    !IIcs = nint(rslabs) !    !endwhere !    !where (IIus == 0) !    !IIus = nint(rslabs) !    !endwhere !    !where (IIvs == 0) !    !IIvs = nint(rslabs) !    !endwhere !    !where (IIws == 0) !    !IIws = nint(rslabs) !    !endwhere !    !where (IIuws == 0) !    !IIuws = nint(rslabs) !    !endwhere !    !where (IIvws == 0) !    !IIvws = nint(rslabs) !    !endwhere ! !    ! use masking matrices to set 0 in blocks from start? tg3315 13/12/17 !    ! um(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) = IIu(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh)*um(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) !    ! vm(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) = IIv(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh)*vm(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) !    ! wm(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) = IIw(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh)*wm(ib-ih:ie+ih,jb-jh:je+jh,kb:ke+kh) ! !    ! u0 = um !    ! v0 = vm !    ! w0 = wm ! ! end subroutine createmasks end module modstartup","tags":"","url":"sourcefile/modstartup.f90.html"},{"title":"program.f90 – uDALES","text":"This file depends on sourcefile~~program.f90~~EfferentGraph sourcefile~program.f90 program.f90 sourcefile~heatpump.f90 heatpump.f90 sourcefile~program.f90->sourcefile~heatpump.f90 sourcefile~initfac.f90 initfac.f90 sourcefile~program.f90->sourcefile~initfac.f90 sourcefile~modboundary.f90 modboundary.f90 sourcefile~program.f90->sourcefile~modboundary.f90 sourcefile~modchecksim.f90 modchecksim.f90 sourcefile~program.f90->sourcefile~modchecksim.f90 sourcefile~moddriver.f90 moddriver.f90 sourcefile~program.f90->sourcefile~moddriver.f90 sourcefile~modeb.f90 modEB.f90 sourcefile~program.f90->sourcefile~modeb.f90 sourcefile~modfielddump.f90 modfielddump.f90 sourcefile~program.f90->sourcefile~modfielddump.f90 sourcefile~modfields.f90 modfields.f90 sourcefile~program.f90->sourcefile~modfields.f90 sourcefile~modforces.f90 modforces.f90 sourcefile~program.f90->sourcefile~modforces.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~program.f90->sourcefile~modglobal.f90 sourcefile~modibm.f90 modibm.f90 sourcefile~program.f90->sourcefile~modibm.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~program.f90->sourcefile~modmpi.f90 sourcefile~modpurifiers.f90 modpurifiers.f90 sourcefile~program.f90->sourcefile~modpurifiers.f90 sourcefile~modsave.f90 modsave.f90 sourcefile~program.f90->sourcefile~modsave.f90 sourcefile~modstartup.f90 modstartup.f90 sourcefile~program.f90->sourcefile~modstartup.f90 sourcefile~modstat_nc.f90 modstat_nc.f90 sourcefile~program.f90->sourcefile~modstat_nc.f90 sourcefile~modstatsdump.f90 modstatsdump.f90 sourcefile~program.f90->sourcefile~modstatsdump.f90 sourcefile~modsubgrid.f90 modsubgrid.f90 sourcefile~program.f90->sourcefile~modsubgrid.f90 sourcefile~modthermodynamics.f90 modthermodynamics.f90 sourcefile~program.f90->sourcefile~modthermodynamics.f90 sourcefile~modtimedep.f90 modtimedep.f90 sourcefile~program.f90->sourcefile~modtimedep.f90 sourcefile~modtrees.f90 modtrees.f90 sourcefile~program.f90->sourcefile~modtrees.f90 sourcefile~heatpump.f90->sourcefile~modfields.f90 sourcefile~heatpump.f90->sourcefile~modglobal.f90 sourcefile~heatpump.f90->sourcefile~modmpi.f90 sourcefile~initfac.f90->sourcefile~modglobal.f90 sourcefile~initfac.f90->sourcefile~modmpi.f90 sourcefile~modboundary.f90->sourcefile~moddriver.f90 sourcefile~modboundary.f90->sourcefile~modfields.f90 sourcefile~modboundary.f90->sourcefile~modglobal.f90 sourcefile~modboundary.f90->sourcefile~modmpi.f90 sourcefile~modinletdata.f90 modinletdata.f90 sourcefile~modboundary.f90->sourcefile~modinletdata.f90 sourcefile~modsubgriddata.f90 modsubgriddata.f90 sourcefile~modboundary.f90->sourcefile~modsubgriddata.f90 sourcefile~modsurfdata.f90 modsurfdata.f90 sourcefile~modboundary.f90->sourcefile~modsurfdata.f90 sourcefile~modchecksim.f90->sourcefile~modfields.f90 sourcefile~modchecksim.f90->sourcefile~modglobal.f90 sourcefile~modchecksim.f90->sourcefile~modmpi.f90 sourcefile~modchecksim.f90->sourcefile~modsubgriddata.f90 sourcefile~moddriver.f90->sourcefile~modfields.f90 sourcefile~moddriver.f90->sourcefile~modglobal.f90 sourcefile~moddriver.f90->sourcefile~modmpi.f90 sourcefile~moddriver.f90->sourcefile~modsave.f90 sourcefile~moddriver.f90->sourcefile~modinletdata.f90 sourcefile~modeb.f90->sourcefile~initfac.f90 sourcefile~modeb.f90->sourcefile~modglobal.f90 sourcefile~modeb.f90->sourcefile~modmpi.f90 sourcefile~modeb.f90->sourcefile~modstat_nc.f90 sourcefile~modfielddump.f90->sourcefile~modfields.f90 sourcefile~modfielddump.f90->sourcefile~modglobal.f90 sourcefile~modfielddump.f90->sourcefile~modibm.f90 sourcefile~modfielddump.f90->sourcefile~modmpi.f90 sourcefile~modfielddump.f90->sourcefile~modstat_nc.f90 sourcefile~modfielddump.f90->sourcefile~modsurfdata.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 sourcefile~modforces.f90->sourcefile~modfields.f90 sourcefile~modforces.f90->sourcefile~modglobal.f90 sourcefile~modforces.f90->sourcefile~modmpi.f90 sourcefile~modibmdata.f90 modibmdata.f90 sourcefile~modforces.f90->sourcefile~modibmdata.f90 sourcefile~modforces.f90->sourcefile~modsurfdata.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 sourcefile~modibm.f90->sourcefile~initfac.f90 sourcefile~modibm.f90->sourcefile~modboundary.f90 sourcefile~modibm.f90->sourcefile~modfields.f90 sourcefile~modibm.f90->sourcefile~modglobal.f90 sourcefile~modibm.f90->sourcefile~modmpi.f90 sourcefile~modibm.f90->sourcefile~modstat_nc.f90 sourcefile~modibm.f90->sourcefile~modibmdata.f90 sourcefile~modibm.f90->sourcefile~modsubgriddata.f90 sourcefile~modibm.f90->sourcefile~modsurfdata.f90 sourcefile~modpurifiers.f90->sourcefile~modfields.f90 sourcefile~modpurifiers.f90->sourcefile~modglobal.f90 sourcefile~modpurifiers.f90->sourcefile~modmpi.f90 sourcefile~modsave.f90->sourcefile~initfac.f90 sourcefile~modsave.f90->sourcefile~modfields.f90 sourcefile~modsave.f90->sourcefile~modglobal.f90 sourcefile~modsave.f90->sourcefile~modmpi.f90 sourcefile~modsave.f90->sourcefile~modibmdata.f90 sourcefile~modsave.f90->sourcefile~modinletdata.f90 sourcefile~modsave.f90->sourcefile~modsubgriddata.f90 sourcefile~modsave.f90->sourcefile~modsurfdata.f90 sourcefile~modstartup.f90->sourcefile~modboundary.f90 sourcefile~modstartup.f90->sourcefile~moddriver.f90 sourcefile~modstartup.f90->sourcefile~modfields.f90 sourcefile~modstartup.f90->sourcefile~modforces.f90 sourcefile~modstartup.f90->sourcefile~modglobal.f90 sourcefile~modstartup.f90->sourcefile~modibm.f90 sourcefile~modstartup.f90->sourcefile~modmpi.f90 sourcefile~modstartup.f90->sourcefile~modsubgrid.f90 sourcefile~modstartup.f90->sourcefile~modthermodynamics.f90 sourcefile~modstartup.f90->sourcefile~modtimedep.f90 sourcefile~modstartup.f90->sourcefile~modibmdata.f90 sourcefile~modinlet.f90 modinlet.f90 sourcefile~modstartup.f90->sourcefile~modinlet.f90 sourcefile~modstartup.f90->sourcefile~modinletdata.f90 sourcefile~modstartup.f90->sourcefile~modsubgriddata.f90 sourcefile~modstartup.f90->sourcefile~modsurfdata.f90 sourcefile~modstat_nc.f90->sourcefile~modglobal.f90 sourcefile~modstat_nc.f90->sourcefile~modmpi.f90 sourcefile~modstatsdump.f90->sourcefile~modfields.f90 sourcefile~modstatsdump.f90->sourcefile~modglobal.f90 sourcefile~modstatsdump.f90->sourcefile~modmpi.f90 sourcefile~modstatsdump.f90->sourcefile~modstat_nc.f90 sourcefile~modstatsdump.f90->sourcefile~modsubgrid.f90 sourcefile~modstatistics.f90 modstatistics.f90 sourcefile~modstatsdump.f90->sourcefile~modstatistics.f90 sourcefile~modstatsdump.f90->sourcefile~modsurfdata.f90 sourcefile~modsubgrid.f90->sourcefile~modboundary.f90 sourcefile~modsubgrid.f90->sourcefile~modfields.f90 sourcefile~modsubgrid.f90->sourcefile~modglobal.f90 sourcefile~modsubgrid.f90->sourcefile~modmpi.f90 sourcefile~modsubgrid.f90->sourcefile~modinletdata.f90 sourcefile~modsubgrid.f90->sourcefile~modsubgriddata.f90 sourcefile~modsubgrid.f90->sourcefile~modsurfdata.f90 sourcefile~modthermodynamics.f90->sourcefile~modfields.f90 sourcefile~modthermodynamics.f90->sourcefile~modglobal.f90 sourcefile~modthermodynamics.f90->sourcefile~modmpi.f90 sourcefile~modthermodynamics.f90->sourcefile~modsurfdata.f90 sourcefile~modtimedep.f90->sourcefile~initfac.f90 sourcefile~modtimedep.f90->sourcefile~modfields.f90 sourcefile~modtimedep.f90->sourcefile~modglobal.f90 sourcefile~modtimedep.f90->sourcefile~modmpi.f90 sourcefile~modtimedep.f90->sourcefile~modibmdata.f90 sourcefile~modtrees.f90->sourcefile~modfields.f90 sourcefile~modtrees.f90->sourcefile~modglobal.f90 sourcefile~modtrees.f90->sourcefile~modmpi.f90 sourcefile~modtrees.f90->sourcefile~modibmdata.f90 sourcefile~modtrees.f90->sourcefile~modsubgriddata.f90 sourcefile~modtrees.f90->sourcefile~modsurfdata.f90 sourcefile~modinlet.f90->sourcefile~modfields.f90 sourcefile~modinlet.f90->sourcefile~modglobal.f90 sourcefile~modinlet.f90->sourcefile~modmpi.f90 sourcefile~modinlet.f90->sourcefile~modsave.f90 sourcefile~modinlet.f90->sourcefile~modinletdata.f90 sourcefile~modinlet.f90->sourcefile~modsurfdata.f90 sourcefile~modstatistics.f90->sourcefile~modfields.f90 sourcefile~modstatistics.f90->sourcefile~modglobal.f90 sourcefile~modstatistics.f90->sourcefile~modmpi.f90 sourcefile~modstatistics.f90->sourcefile~modstat_nc.f90 sourcefile~modstatistics.f90->sourcefile~modsubgriddata.f90 sourcefile~modstatistics.f90->sourcefile~modsurfdata.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> \\file program.f90 !! Main program !! \\section License License !!  This file is part of DALES. !! !!  DALES is free software; you can redistribute it and/or modify it under the !! terms of the GNU General Public License as published by the Free Software !! Foundation; either version 3 of the License, or (at your option) any later !! version. !! !!  DALES is distributed in the hope that it will be useful, but WITHOUT ANY !! WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A !! PARTICULAR PURPOSE.  See the GNU General Public License for more details. !! !!  You should have received a copy of the GNU General Public License along with !! this program.  If not, see <http://www.gnu.org/licenses/>. !! !!  Copyright 1993-2009 Delft University of Technology, Wageningen University, !! Utrecht University, KNMI !! program DALESURBAN !Version 48 !!---------------------------------------------------------------- !!     0.0    USE STATEMENTS FOR CORE MODULES !!---------------------------------------------------------------- use modmpi , only : initmpi , exitmpi , myid , starttimer use modglobal , only : initglobal , rk3step , timeleft use modstartup , only : readnamelists , init2decomp , checkinitvalues , readinitfiles , exitmodules use modfields , only : initfields use modsave , only : writerestartfiles use modboundary , only : initboundary , boundary , grwdamp , halos use modthermodynamics , only : initthermodynamics , thermodynamics use modsubgrid , only : initsubgrid , subgrid use modforces , only : calcfluidvolumes , forces , coriolis , lstend , fixuinf1 , fixuinf2 , fixthetainf , nudge , masscorr , shiftedPBCs , periodicEBcorr use modpois , only : initpois , poisson use modibm , only : initibm , createmasks , ibmwallfun , ibmnorm , bottom use modtrees , only : createtrees , trees use modpurifiers , only : createpurifiers , purifiers use modheatpump , only : init_heatpump , heatpump , exit_heatpump use initfac , only : readfacetfiles use modEB , only : initEB , EB use moddriver , only : initdriver !---------------------------------------------------------------- !     0.1     USE STATEMENTS FOR ADDONS STATISTICAL ROUTINES !---------------------------------------------------------------- use modchecksim , only : initchecksim , checksim use modstat_nc , only : initstat_nc use modfielddump , only : initfielddump , fielddump , exitfielddump use modstatsdump , only : initstatsdump , statsdump , exitstatsdump !tg3315 use modtimedep , only : inittimedep , timedep implicit none !---------------------------------------------------------------- !     1      READ NAMELISTS,INITIALISE GRID, CONSTANTS AND FIELDS !---------------------------------------------------------------- call initmpi !call startup call readnamelists call init2decomp call checkinitvalues call initglobal call initfields call initboundary call initthermodynamics call initsubgrid ! call initinlet call initdriver call initpois call readfacetfiles ! These should be combined once file format is sorted call initibm call createmasks call calcfluidvolumes call readinitfiles call createscals !--------------------------------------------------------- !      2     INITIALIZE STATISTICAL ROUTINES AND ADD-ONS !--------------------------------------------------------- call initchecksim ! Could be deprecated call initstat_nc ! Could be deprecated call initstatsdump call initEB call inittimedep call initfielddump call boundary call createtrees call createpurifiers call init_heatpump !call fielddump !------------------------------------------------------ !   3.0   MAIN TIME LOOP !------------------------------------------------------ !write(*,*) 'Starting rank ', myid call starttimer do while (( timeleft > 0 ) . or . ( rk3step < 3 )) call tstep_update call timedep !----------------------------------------------------- !   3.2   ADVECTION AND DIFFUSION !----------------------------------------------------- call advection ! includes predicted pressure gradient term call shiftedPBCs call subgrid !----------------------------------------------------- !   3.3   THE SURFACE LAYER !----------------------------------------------------- call bottom !----------------------------------------------------- !   3.4   REMAINING TERMS !----------------------------------------------------- call coriolis !remaining terms of ns equation call forces !remaining terms of ns equation call lstend !large scale forcings call nudge ! nudge top cells of fields to enforce steady-state call ibmwallfun ! immersed boundary forcing: only shear forces. call periodicEBcorr call masscorr ! correct pred. velocity pup to get correct mass flow call ibmnorm ! immersed boundary forcing: set normal velocities to zero call EB call trees call heatpump call scalsource ! adds continuous forces in specified region of domain !------------------------------------------------------ !   3.4   EXECUTE ADD ONS !------------------------------------------------------ call fixuinf2 call fixuinf1 !----------------------------------------------------------------------- !   3.5  PRESSURE FLUCTUATIONS, TIME INTEGRATION AND BOUNDARY CONDITIONS !----------------------------------------------------------------------- call grwdamp !damping at top of the model call poisson call purifiers !placing of purifiers here may need to be checked call tstep_integrate call halos call checksim call fielddump call statsdump call boundary !call fixthetainf ! deprecated !----------------------------------------------------- !   3.6   LIQUID WATER CONTENT AND DIAGNOSTIC FIELDS !----------------------------------------------------- call thermodynamics !----------------------------------------------------- !   3.7  WRITE RESTARTFILES AND DO STATISTICS !------------------------------------------------------ call writerestartfiles end do !------------------------------------------------------- !             END OF TIME LOOP !------------------------------------------------------- !-------------------------------------------------------- !    4    FINALIZE ADD ONS AND THE MAIN PROGRAM !------------------------------------------------------- call exitfielddump call exitstatsdump !tg3315 call exit_heatpump !call exitmodules !call exittest call exitmpi end program DALESURBAN","tags":"","url":"sourcefile/program.f90.html"},{"title":"modforces.f90 – uDALES","text":"This file depends on sourcefile~~modforces.f90~~EfferentGraph sourcefile~modforces.f90 modforces.f90 sourcefile~modfields.f90 modfields.f90 sourcefile~modforces.f90->sourcefile~modfields.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~modforces.f90->sourcefile~modglobal.f90 sourcefile~modibmdata.f90 modibmdata.f90 sourcefile~modforces.f90->sourcefile~modibmdata.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~modforces.f90->sourcefile~modmpi.f90 sourcefile~modsurfdata.f90 modsurfdata.f90 sourcefile~modforces.f90->sourcefile~modsurfdata.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~modforces.f90~~AfferentGraph sourcefile~modforces.f90 modforces.f90 sourcefile~modstartup.f90 modstartup.f90 sourcefile~modstartup.f90->sourcefile~modforces.f90 sourcefile~program.f90 program.f90 sourcefile~program.f90->sourcefile~modforces.f90 sourcefile~program.f90->sourcefile~modstartup.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> \\file modforces.f90 !!  Calculates the other forces and sources in the equations. !> !!  Calculates the other forces and sources in the equations. !> !!  This includes the large scale forcings, the coriolis and the subsidence !!  \\author Jasper Tomas, TU Delft  March 31 2014 !!  \\author Pier Siebesma, K.N.M.I. !!  \\author Stephan de Roode,TU Delft !!  \\author Chiel van Heerwaarden, Wageningen U.R. !!  \\author Thijs Heus,MPI-M !!  \\par Revision list !!  Only the routine 'forces' is used !!  \\todo Documentation !  This file is part of DALES. ! ! DALES is free software; you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation; either version 3 of the License, or ! (at your option) any later version. ! ! DALES is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !  Copyright 1993-2009 Delft University of Technology, Wageningen University, Utrecht University, KNMI ! module modforces !Calculates additional forces and large scale tendencies implicit none save private public :: forces , coriolis , lstend , fixuinf1 , fixuinf2 , fixthetainf ,& detfreestream , detfreestrtmp , nudge ,& masscorr , uoutletarea , voutletarea , fluidvolume , calcfluidvolumes , shiftedPBCs , periodicEBcorr contains subroutine forces !-----------------------------------------------------------------| !                                                                 | !      Hans Cuijpers   I.M.A.U.                                   | !      Pier Siebesma   K.N.M.I.     06/01/1995                    | !                                                                 | !     purpose.                                                    | !     --------                                                    | !                                                                 | !      Calculates all other terms in the N-S equation,            | !      except for the diffusion and advection terms.              | !                                                                 | !**   interface.                                                  | !     ----------                                                  | !                                                                 | !     *forces* is called from *program*.                          | !                                                                 | !-----------------------------------------------------------------| !  use modglobal, only : i1,j1,kmax,dzh,dzf,grav use modglobal , only : ib , ie , jb , je , kb , ke , kh , dzhi , dzf , grav , lbuoyancy use modfields , only : u0 , v0 , w0 , up , vp , wp , thv0h , dpdxl , dpdyl , thlp , thlpcar , thvh use modibmdata , only : nxwallsnorm , xwallsnorm use modsurfdata , only : thvs use modmpi , only : myid implicit none real thvsi integer i , j , k , n , jm , jp , km , kp if ( lbuoyancy ) then !ILS13 replace thvsi by thvh ! thvsi = 1./thvsi do k = kb + 1 , ke do j = jb , je do i = ib , ie up ( i , j , k ) = up ( i , j , k ) - dpdxl ( k ) vp ( i , j , k ) = vp ( i , j , k ) - dpdyl ( k ) wp ( i , j , k ) = wp ( i , j , k ) + grav * ( thv0h ( i , j , k ) - thvh ( k )) / thvh ( k ) end do end do end do else do k = kb + 1 , ke do j = jb , je do i = ib , ie up ( i , j , k ) = up ( i , j , k ) - dpdxl ( k ) vp ( i , j , k ) = vp ( i , j , k ) - dpdyl ( k ) ! IS+HJ      wp(i,j,k) = wp(i,j,k) end do end do end do end if !     ---------------------------------------------- !     add radiative heating to potential temperature !     ---------------------------------------------- do k = kb , ke do j = jb , je do i = ib , ie thlp ( i , j , k ) = thlp ( i , j , k ) + thlpcar ( k ) end do end do end do !     -------------------------------------------- !     special treatment for lowest full level: k=1 !     -------------------------------------------- do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie up ( i , j , kb ) = up ( i , j , kb ) - dpdxl ( kb ) vp ( i , j , kb ) = vp ( i , j , kb ) - dpdyl ( kb ) wp ( i , j , kb ) = 0.0 end do end do !     ----------------------------------------------end i,j-loop return end subroutine forces subroutine detfreestream ( freestream ) use modglobal , only : ib , ie , jb , je , kb , ke , kh , dxf , xh , dt ,& Uinf , Vinf , lvinf , dy use modfields , only : u0 , dpdxl , dgdt , dpdx , v0 , u0av , v0av use modmpi , only : myid , comm3d , mpierr , mpi_sum , my_real , nprocs implicit none real , intent ( out ) :: freestream real utop , vtop , dum integer i , j if ( lvinf ) then freestream = v0av ( ke ) else freestream = u0av ( ke ) end if end subroutine detfreestream subroutine detfreestrtmp ( freestrtmp ) use modglobal , only : ib , ie , jb , je , kb , ke , kh , dxf , xh , dt ,& Uinf use modfields , only : thl0 , dpdxl , dgdt , dpdx use modmpi , only : myid , comm3d , mpierr , mpi_sum , my_real , nprocs implicit none real , intent ( out ) :: freestrtmp real ttop integer i , j ttop = 0. do j = jb , je do i = ib , ie ttop = ttop + thl0 ( i , j , ke ) * dxf ( i ) end do end do ttop = ttop / ( ( je - jb + 1 ) * ( xh ( ie + 1 ) - xh ( ib ) ) ) call MPI_ALLREDUCE ( ttop , freestrtmp , 1 , MY_REAL , MPI_SUM , comm3d , mpierr ) freestrtmp = freestrtmp / nprocs end subroutine detfreestrtmp subroutine fixuinf2 use modglobal , only : ib , ie , jb , je , kb , ke , kh , dxf , xh , dt ,& Uinf , ifixuinf , tscale , timee , rk3step , inletav ,& freestreamav , freestrtmpav , ltempeq use modsurfdata , only : thl_top use modfields , only : u0 , thl0 , dpdxl , dgdt , dpdx , thlsrcdt use modmpi , only : myid , comm3d , mpierr , mpi_sum , my_real , nprocs implicit none real utop , freestream , freestrtmp , rk3coef integer i , j utop = 0. if (( ifixuinf == 2 ) . and . ( rk3step == 3 )) then call detfreestream ( freestream ) freestreamav = freestream * dt / inletav + ( 1. - dt / inletav ) * freestreamav ! Write some statistics to monitoring file ! if (myid==0) then !   open(unit=11,file='freestr.txt',position='append') !   write(11,3002) timee,freestream,freestreamav !   3002      format (13(6e14.6)) !   close(11) ! endif !    dgdt =  (1./tscale) * (freestream - Uinf) !    dgdt =  (1./dt) * (freestreamav - Uinf) dgdt = ( 1. / tscale ) * ( freestreamav - Uinf ) ! plus sign because dpdx is SUBTRACTED from Navier-Stokes eqs !    dgdt =  (1./inletav) * (freestreamav - Uinf) !    if (ltempeq) then  !tg3315 commented !      call detfreestrtmp(freestrtmp) !      freestrtmpav=  freestrtmp*dt/inletav + (1.-dt/inletav)*freestrtmpav !      thlsrcdt = -(1./tscale) * (freestrtmpav - thl_top)   ! minus sign because thlsr is ADDED to Navier-Stokes eqs. !      if (myid==0) then !        open(unit=11,file='theta_top.txt',position='append') !        write(11,3009) timee,freestrtmp,freestrtmpav !3009    format (13(6e20.12)) !        close(11) !      endif !    end if end if end subroutine fixuinf2 subroutine fixuinf1 use modglobal , only : ib , ie , jb , je , kb , ke , kh , dxf , xh , dt ,& Uinf , Vinf , ifixuinf , tscale , timee , rk3step , inletav ,& freestreamav , lvinf use modfields , only : u0 , dpdxl , dgdt , dpdx , up , vp , u0av , v0av use modmpi , only : myid , comm3d , mpierr , mpi_sum , my_real , nprocs implicit none real utop , freestream , rk3coef integer i , j , k utop = 0. if (( ifixuinf == 1 ) . and . ( rk3step == 3 )) then ! rk3coef = dt / (4. - dble(rk3step)) ! do j =jb,je !   do i =ib,ie !     utop = utop + 0.5*(u0(i,j,ke)+u0(i+1,j,ke))*dxf(i) !   end do ! end do ! utop = utop / ( (je-jb+1)*(xh(ie+1)-xh(ib) ) ) ! call MPI_ALLREDUCE(utop,    freestream,1,MY_REAL,MPI_SUM,comm3d,mpierr) ! freestream = freestream / nprocs ! Write some statistics to monitoring file ! if (myid==0 .and. rk3step==3) then ! ! dpdxl(:) = dpdx + (1./rk3coef) * (freestream - Uinf) ! dpdxl(:) = dpdx + (1./dt) * (freestream - Uinf) !call detfreestream(freestream) ! write(*,*) \"freestream\",freestream if ( lvinf ) then do k = kb , ke do i = ib , ie do j = jb , je vp ( i , j , k ) = vp ( i , j , k ) - ( 1. / dt ) * ( v0av ( ke ) - Vinf ) enddo enddo enddo end if !else do k = kb , ke do j = jb , je do i = ib , ie up ( i , j , k ) = up ( i , j , k ) - ( 1. / dt ) * ( u0av ( ke ) - Uinf ) enddo enddo enddo !endif ! if (myid==0) then !   write(*,*), \"freestream\", freestream !   write(*,*), \"Uinf\", Uinf !   open(unit=11,file='freestr.txt',position='append') !   write(11,3003) timee,freestream !   3003    format (13(6e20.12)) !   close(11) !   open(unit=11,file='dpdx___.txt',position='append') !   write(11,3002) timee,dpdxl(kb),dpdxl(kb)-dpdx !   3002    format (13(6e20.12)) !   close(11) ! endif end if end subroutine fixuinf1 subroutine fixthetainf use modglobal , only : ib , ie , jb , je , kb , ke , kh , dxf , xh , dt ,& Uinf , ifixuinf , tscale , timee , rk3step , inletav ,& freestreamav , thlsrc , ltempeq use modfields , only : thl0 use modmpi , only : myid , comm3d , mpierr , mpi_sum , my_real , nprocs use modsurfdata , only : thl_top implicit none real ttop , freestreamtheta , rk3coef integer i , j ttop = 0. ! if (ifixuinf==1 .and. rk3step==3 .and. ltempeq) then !tg3315 commented !   rk3coef = dt / (4. - dble(rk3step)) !   do j =jb,je !     do i =ib,ie !       ttop = ttop + thl0(i,j,ke)*dxf(i) !     end do !   end do !   ttop = ttop / ( (je-jb+1)*(xh(ie+1)-xh(ib) ) ) !   call MPI_ALLREDUCE(ttop,    freestreamtheta,1,MY_REAL,MPI_SUM,comm3d,mpierr) !   freestreamtheta = freestreamtheta / nprocs !   thlsrc = -(1./dt) * (freestreamtheta - thl_top) !     if (myid==0) then !       open(unit=11,file='theta_top.txt',position='append') !       write(11,3003) timee,freestreamtheta !       3003    format (13(6e20.12)) !       close(11) !       open(unit=11,file='thlsrc.txt',position='append') !       write(11,3002) timee,thlsrc !       3002    format (13(6e20.12)) !       close(11) !     endif ! end if end subroutine fixthetainf subroutine masscorr !> correct the velocities to get prescribed flow rate use modglobal , only : ib , ie , jb , je , ih , jh , kb , ke , kh , dzf , dxf , dy , zh , dt , rk3step ,& uflowrate , vflowrate , linoutflow ,& luoutflowr , lvoutflowr , luvolflowr , lvvolflowr use modfields , only : um , up , vm , vp , uouttot , udef , vouttot , vdef ,& uoutarea , voutarea , fluidvol , IIu , IIv , IIus , IIvs use modmpi , only : myid , comm3d , mpierr , nprocs , MY_REAL , sumy_ibm , sumx_ibm , avexy_ibm real , dimension ( kb : ke + kh ) :: uvol real , dimension ( kb : ke + kh ) :: vvol real , dimension ( kb : ke + kh ) :: uvolold real , dimension ( kb : ke + kh ) :: vvolold real , dimension ( kb : ke ) :: uout real , dimension ( kb : ke ) :: vout real , dimension ( kb : ke ) :: uoutold real , dimension ( kb : ke ) :: voutold real rk3coef , rk3coefi ,& uoutflow , voutflow ,& uflowrateold , vflowrateold integer i , j , k if ((. not . linoutflow ) . and . ( luoutflowr )) then rk3coef = dt / ( 4. - dble ( rk3step )) rk3coefi = 1 / rk3coef ! Assumes ie=itot udef = 0. uout = 0. uoutflow = 0. uoutold = 0. ! integrate u fixed at outlet ie along y call sumy_ibm ( uout , up ( ie , jb : je , kb : ke ) * dy , ie , ie , jb , je , kb , ke , IIu ( ie , jb : je , kb : ke )) ! u tendency at previous time step call sumy_ibm ( uoutold , um ( ie , jb : je , kb : ke ) * dy , ie , ie , jb , je , kb , ke , IIu ( ie , jb : je , kb : ke )) ! u at previous time step ! integrate u in z do k = kb , ke uout ( k ) = rk3coef * uout ( k ) * dzf ( k ) uoutold ( k ) = uoutold ( k ) * dzf ( k ) end do uoutflow = sum ( uout ( kb : ke )) uflowrateold = sum ( uoutold ( kb : ke )) ! average over outflow area uoutflow = uoutflow / uoutarea uflowrateold = uflowrateold / uoutarea ! flow correction to match outflow rate udef = uflowrate - ( uoutflow + uflowrateold ) do k = kb , ke do j = jb , je do i = ib , ie up ( i , j , k ) = up ( i , j , k ) + udef * rk3coefi end do end do end do ! bss116 calculate uouttot which is used in modboundary. ! this really should be in the routine directly! uouttot = sum ( uout ( kb : ke )) ! mass flow rate at outlet elseif ((. not . linoutflow ) . and . ( luvolflowr )) then rk3coef = dt / ( 4. - dble ( rk3step )) rk3coefi = 1 / rk3coef udef = 0. uoutflow = 0. uvol = 0. uvolold = 0. ! Assumes equidistant grid call avexy_ibm ( uvol ( kb : ke + kh ), up ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIu ( ib : ie , jb : je , kb : ke + kh ), IIus ( kb : ke + kh ),. false .) call avexy_ibm ( uvolold ( kb : ke + kh ), um ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIu ( ib : ie , jb : je , kb : ke + kh ), IIus ( kb : ke + kh ),. false .) ! average over fluid volume uoutflow = rk3coef * sum ( uvol ( kb : ke ) * dzf ( kb : ke )) / zh ( ke + 1 ) uflowrateold = sum ( uvolold ( kb : ke ) * dzf ( kb : ke )) / zh ( ke + 1 ) ! flow correction to match outflow rate udef = uflowrate - ( uoutflow + uflowrateold ) do k = kb , ke do j = jb , je do i = ib , ie up ( i , j , k ) = up ( i , j , k ) + udef * rk3coefi end do end do end do end if if ((. not . linoutflow ) . and . ( lvoutflowr )) then rk3coef = dt / ( 4. - dble ( rk3step )) rk3coefi = 1 / rk3coef ! Assumes je=jtot vdef = 0. vout = 0. voutflow = 0. voutold = 0. ! integrate v fixed at outlet je along x ! if (myid==nprocs-1) then !    do k=kb,ke !       vout(k) = sum(vp(ib:ie,je,k)*IIv(ib:ie,je,k)*dxf(ib:ie))  ! v tendency at previous time step !       voutold(k) = sum(vm(ib:ie,je,k)*IIv(ib:ie,je,k)*dxf(ib:ie))  ! v at previous time step !    end do ! end if call sumy_ibm ( vout , vp ( ib : je , je , kb : ke ) * dxf ( 1 ), ib , ie , je , je , kb , ke , IIv ( ib : ie , je , kb : ke )) ! v tendency at previous time step call sumy_ibm ( voutold , vm ( ib : ie , je , kb : ke ) * dxf ( 1 ), ib , ie , je , je , kb , ke , IIv ( ib : ie , je , kb : ke )) ! v at previous time step ! integrate v in z do k = kb , ke vout ( k ) = rk3coef * vout ( k ) * dzf ( k ) voutold ( k ) = voutold ( k ) * dzf ( k ) end do voutflow = sum ( vout ( kb : ke )) vflowrateold = sum ( voutold ( kb : ke )) ! average over outflow area voutflow = voutflow / voutarea vflowrateold = vflowrateold / voutarea ! flow correction to match outflow rate vdef = vflowrate - ( voutflow + vflowrateold ) do k = kb , ke do j = jb , je do i = ib , ie vp ( i , j , k ) = vp ( i , j , k ) + vdef * rk3coefi end do end do end do elseif ((. not . linoutflow ) . and . ( lvvolflowr )) then rk3coef = dt / ( 4. - dble ( rk3step )) rk3coefi = 1 / rk3coef vdef = 0. voutflow = 0. vvol = 0. vvolold = 0. ! Assumes equidistant grid call avexy_ibm ( vvol ( kb : ke + kh ), vp ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIv ( ib : ie , jb : je , kb : ke + kh ), IIvs ( kb : ke + kh ),. false .) call avexy_ibm ( vvolold ( kb : ke + kh ), vm ( ib : ie , jb : je , kb : ke + kh ), ib , ie , jb , je , kb , ke , ih , jh , kh , IIv ( ib : ie , jb : je , kb : ke + kh ), IIvs ( kb : ke + kh ),. false .) ! average over fluid volume voutflow = rk3coef * sum ( vvol ( kb : ke ) * dzf ( kb : ke )) / zh ( ke + 1 ) vflowrateold = sum ( vvolold ( kb : ke ) * dzf ( kb : ke )) / zh ( ke + 1 ) ! flow correction to match outflow rate vdef = vflowrate - ( voutflow + vflowrateold ) do k = kb , ke do j = jb , je do i = ib , ie vp ( i , j , k ) = vp ( i , j , k ) + vdef * rk3coefi end do end do end do end if end subroutine masscorr subroutine uoutletarea ( area ) ! calculates outlet area of domain for u-velocity excluding blocks use modglobal , only : ib , ie , jb , je , kb , ke , dy , dzf , ierank use modfields , only : IIc use modmpi , only : sumy_ibm implicit none real , intent ( out ) :: area real , dimension ( kb : ke ) :: sumy integer k sumy = 0. ! integrate fluid area at outflow plane in y ! Assumes ie=itot call sumy_ibm ( sumy , IIc ( ie , jb : je , kb : ke ) * dy , ie , ie , jb , je , kb , ke , IIc ( ie , jb : je , kb : ke )) ! integrate fluid area at outflow plane in z do k = kb , ke sumy ( k ) = sumy ( k ) * dzf ( k ) end do area = sum ( sumy ( kb : ke )) end subroutine uoutletarea subroutine voutletarea ( area ) ! calculates outlet area of domain for v-velocity excluding blocks use modglobal , only : ib , ie , jb , je , kb , ke , dxf , dzf , jerank use modfields , only : IIc use modmpi , only : sumx_ibm implicit none real , intent ( out ) :: area real , dimension ( kb : ke ) :: sumx integer k sumx = 0. ! integrate fluid area at outflow plane in x ! Assumes je=jtot call sumx_ibm ( sumx , IIc ( ib : ie , je , kb : ke ) * dxf ( 1 ), ib , ie , je , je , kb , ke , IIc ( ib : ie , je , kb : ke )) ! integrate fluid area at outflow plane in z do k = kb , ke sumx ( k ) = sumx ( k ) * dzf ( k ) end do area = sum ( sumx ( kb : ke )) end subroutine voutletarea subroutine fluidvolume ( volume ) ! calculates fluid volume of domain excluding blocks use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , dy , dxf , dzf use modfields , only : IIc , IIcs use modmpi , only : sumy_ibm , avexy_ibm implicit none real , intent ( out ) :: volume real , dimension ( ib : ie , kb : ke ) :: sumy real , dimension ( kb : ke + kh ) :: sumxy integer k sumy = 0. sumxy = 0. ! ! integrate fluid volume in y ! call sumy_ibm(sumy,IIc(ib:ie,jb:je,kb:ke)*dy,ib,ie,jb,je,kb,ke,IIc(ib:ie,jb:je,kb:ke)) ! ! ! integrate fluid area in x ! do k=kb,ke !   sumxy(k) = sum(sumy(ib:ie,k)*dxf(ib:ie)) ! end do ! Equidistant x call avexy_ibm ( sumxy ( kb : ke + kh ), IIc ( ib : ie , jb : je , kb : ke + kh ) * dxf ( 1 ) * dy , ib , ie , jb , je , kb , ke , ih , jh , kh , IIc ( ib : ie , jb : je , kb : ke + kh ), IIcs ( kb : ke + kh ),. false .) ! integrate fluid area in z volume = sum ( sumxy ( kb : ke ) * dzf ( kb : ke )) end subroutine fluidvolume subroutine calcfluidvolumes !> calculates fluid volume and outlet areas, excluding blocks !> and saves it to variables from modfields use modfields , only : uoutarea , voutarea , fluidvol implicit none real :: volume ! calculate outlet area call uoutletarea ( volume ) uoutarea = volume ! calculate outlet area call voutletarea ( volume ) voutarea = volume ! calculate fluid volume call fluidvolume ( volume ) fluidvol = volume end subroutine calcfluidvolumes subroutine coriolis !-----------------------------------------------------------------| !                                                                 | !      Thijs Heus TU Delft                                        | !                                                                 | !     purpose.                                                    | !     --------                                                    | !                                                                 | !      Calculates the Coriolis force.                             | !                                                                 | !**   interface.                                                  | !     ----------                                                  | !                                                                 | !     *coriolis* is called from *program*.                        | !                                                                 | !-----------------------------------------------------------------| ! use modglobal, only : i1,j1,kmax,dzh,dzf,om22,om23 use modglobal , only : ib , ie , jb , je , kb , ke , kh , dzh , dzf , om22 , om23 , lcoriol , lprofforc , timee use modfields , only : u0 , v0 , w0 , up , vp , wp , ug , vg use modmpi , only : myid implicit none integer i , j , k , jm , jp , km , kp real , dimension ( kb : ke + kh ) :: ugg real om23g if ( lcoriol ) then ! if (myid==0) then !   write(*,*) \"up before coriol\",up(3,3,ke) ! end if do k = kb + 1 , ke kp = k + 1 km = k - 1 do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie up ( i , j , k ) = up ( i , j , k ) & + (( v0 ( i , j , k ) + v0 ( i , jp , k ) + v0 ( i - 1 , j , k ) + v0 ( i - 1 , jp , k )) * om23 * 0.25 ) & - (( w0 ( i , j , k ) + w0 ( i , j , kp ) + w0 ( i - 1 , j , kp ) + w0 ( i - 1 , j , k )) * om22 * 0.25 ) vp ( i , j , k ) = vp ( i , j , k ) & - (( u0 ( i , j , k ) + u0 ( i , jm , k ) + u0 ( i + 1 , jm , k ) + u0 ( i + 1 , j , k )) * om23 * 0.25 ) wp ( i , j , k ) = wp ( i , j , k ) + (( ( dzf ( km ) * ( u0 ( i , j , k ) + u0 ( i + 1 , j , k ) ) & + dzf ( k ) * ( u0 ( i , j , km ) + u0 ( i + 1 , j , km )) ) / dzh ( k ) ) & * om22 * 0.25 ) end do end do ! -------------------------------------------end i&j-loop end do ! -------------------------------------------end k-loop ! -------------------------------------------- ! special treatment for lowest full level: k=1 ! -------------------------------------------- do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie up ( i , j , kb ) = up ( i , j , kb ) & + ( v0 ( i , j , kb ) + v0 ( i , jp , kb ) + v0 ( i - 1 , j , kb ) + v0 ( i - 1 , jp , kb )) * om23 * 0.25 & - ( w0 ( i , j , kb ) + w0 ( i , j , kb + 1 ) + w0 ( i - 1 , j , kb + 1 ) + w0 ( i - 1 , j , kb )) * om22 * 0.25 vp ( i , j , kb ) = vp ( i , j , kb ) & - ( u0 ( i , j , kb ) + u0 ( i , jm , kb ) + u0 ( i + 1 , jm , kb ) + u0 ( i + 1 , j , kb )) * om23 * 0.25 wp ( i , j , kb ) = 0.0 end do end do ! ----------------------------------------------end i,j-loop ! if (myid==0) then !   write(*,*) \"up after coriol\",up(3,3,ke) ! end if elseif ( lprofforc ) then ugg (:) = ug (:) om23g = om23 do k = kb + 1 , ke do j = jb , je do i = ib , ie up ( i , j , k ) = up ( i , j , k ) + om23g * ( ugg ( k ) - u0 ( i , j , k )) enddo enddo enddo ! -------------------------------------------- ! special treatment for lowest full level: k=1 ! -------------------------------------------- do j = jb , je jp = j + 1 jm = j - 1 do i = ib , ie up ( i , j , kb ) = up ( i , j , kb ) + om23g * ( ugg ( kb ) - u0 ( i , j , kb )) enddo enddo ! if (myid==0) then !   write(*,*) \"up after profforc\",up(3,3,ke) ! end if endif !lcoriol and lprofforc return end subroutine coriolis subroutine lstend !-----------------------------------------------------------------| !                                                                 | !*** *lstend*  calculates large-scale tendencies                  | !                                                                 | !      Pier Siebesma   K.N.M.I.     06/01/1995                    | !                                                                 | !     purpose.                                                    | !     --------                                                    | !                                                                 | !     calculates and adds large-scale tendencies due to           | !     large scale advection and subsidence.                       | !                                                                 | !**   interface.                                                  | !     ----------                                                  | !                                                                 | !             *lstend* is called from *program*.                  | !                                                                 | !-----------------------------------------------------------------| use modglobal , only : ib , ie , jb , je , kb , ke , kh , dzh , nsv , lmomsubs use modfields , only : up , vp , thlp , qtp , svp ,& whls , u0av , v0av , thl0av , qt0av , sv0av ,& dudxls , dudyls , dvdxls , dvdyls , dthldxls , dthldyls , dqtdxls , dqtdyls , dqtdtls use modmpi , only : myid implicit none integer k , n real subs_thl , subs_qt , subs_u , subs_v , subs_sv ! if (ltimedep) then !   ! call ls ! end if ! if (myid==0) then !   write(*,*) \"up before lstend\",up(3,3,ke) ! end if ! 1. DETERMINE LARGE SCALE TENDENCIES !    -------------------------------- ! 1.1 lowest model level above surface : only downward component subs_u = 0. subs_v = 0. subs_thl = 0. subs_qt = 0. subs_sv = 0. k = kb if ( whls ( k + 1 ). lt . 0 ) then !neglect effect of mean ascending on tendencies at the lowest full level subs_thl = whls ( k + 1 ) * ( thl0av ( k + 1 ) - thl0av ( k )) / dzh ( k + 1 ) ! tg3315 ils13 bss116 31/07/18 Dales 4.0 multiplies these by 0.5. To reduce subsidence towards the ground? Have removed subs_qt = whls ( k + 1 ) * ( qt0av ( k + 1 ) - qt0av ( k ) ) / dzh ( k + 1 ) if ( lmomsubs ) then subs_u = whls ( k + 1 ) * ( u0av ( k + 1 ) - u0av ( k ) ) / dzh ( k + 1 ) subs_v = whls ( k + 1 ) * ( v0av ( k + 1 ) - v0av ( k ) ) / dzh ( k + 1 ) endif do n = 1 , nsv subs_sv = whls ( k + 1 ) * ( sv0av ( k + 1 , n ) - sv0av ( k , n ) ) / dzh ( k + 1 ) ! svp(2:i1,2:j1,1,n) = svp(2:i1,2:j1,1,n)-subs_sv svp ( ib : ie , jb : je , kb , n ) = svp ( ib : ie , jb : je , kb , n ) - subs_sv enddo endif thlp ( ib : ie , jb : je , k ) = thlp ( ib : ie , jb : je , k ) - u0av ( k ) * dthldxls ( k ) - v0av ( k ) * dthldyls ( k ) - subs_thl qtp ( ib : ie , jb : je , k ) = qtp ( ib : ie , jb : je , k ) - u0av ( k ) * dqtdxls ( k ) - v0av ( k ) * dqtdyls ( k ) - subs_qt + dqtdtls ( k ) up ( ib : ie , jb : je , k ) = up ( ib : ie , jb : je , k ) - u0av ( k ) * dudxls ( k ) - v0av ( k ) * dudyls ( k ) - subs_u vp ( ib : ie , jb : je , k ) = vp ( ib : ie , jb : je , k ) - u0av ( k ) * dvdxls ( k ) - v0av ( k ) * dvdyls ( k ) - subs_v ! 1.2 other model levels twostream do k = kb + 1 , ke if ( whls ( k + 1 ). lt . 0 ) then !downwind scheme for subsidence subs_thl = whls ( k + 1 ) * ( thl0av ( k + 1 ) - thl0av ( k )) / dzh ( k + 1 ) subs_qt = whls ( k + 1 ) * ( qt0av ( k + 1 ) - qt0av ( k )) / dzh ( k + 1 ) do n = 1 , nsv subs_sv = whls ( k + 1 ) * ( sv0av ( k + 1 , n ) - sv0av ( k , n )) / dzh ( k + 1 ) svp ( ib : ie , jb : je , k , n ) = svp ( ib : ie , jb : je , k , n ) - subs_sv enddo if ( lmomsubs ) then subs_u = whls ( k + 1 ) * ( u0av ( k + 1 ) - u0av ( k )) / dzh ( k + 1 ) subs_v = whls ( k + 1 ) * ( v0av ( k + 1 ) - v0av ( k )) / dzh ( k + 1 ) endif else !downwind scheme for mean upward motions subs_thl = whls ( k ) * ( thl0av ( k ) - thl0av ( k - 1 )) / dzh ( k ) subs_qt = whls ( k ) * ( qt0av ( k ) - qt0av ( k - 1 )) / dzh ( k ) do n = 1 , nsv subs_sv = whls ( k ) * ( sv0av ( k , n ) - sv0av ( k - 1 , n )) / dzh ( k ) svp ( ib : ie , jb : je , k , n ) = svp ( ib : ie , jb : je , k , n ) - subs_sv enddo if ( lmomsubs ) then subs_u = whls ( k ) * ( u0av ( k ) - u0av ( k - 1 )) / dzh ( k ) subs_v = whls ( k ) * ( v0av ( k ) - v0av ( k - 1 )) / dzh ( k ) endif endif thlp ( ib : ie , jb : je , k ) = thlp ( ib : ie , jb : je , k ) - u0av ( k ) * dthldxls ( k ) - v0av ( k ) * dthldyls ( k ) - subs_thl qtp ( ib : ie , jb : je , k ) = qtp ( ib : ie , jb : je , k ) - u0av ( k ) * dqtdxls ( k ) - v0av ( k ) * dqtdyls ( k ) - subs_qt + dqtdtls ( k ) up ( ib : ie , jb : je , k ) = up ( ib : ie , jb : je , k ) - u0av ( k ) * dudxls ( k ) - v0av ( k ) * dudyls ( k ) - subs_u vp ( ib : ie , jb : je , k ) = vp ( ib : ie , jb : je , k ) - u0av ( k ) * dvdxls ( k ) - v0av ( k ) * dvdyls ( k ) - subs_v enddo return end subroutine lstend subroutine nudge use modglobal , only : kb , ke , lmoist , ltempeq , lnudge , lnudgevel , tnudge , nnudge , numol , nsv use modfields , only : thlp , qtp , svp , sv0av , thl0av , qt0av , up , vp , u0av , v0av , uprof , vprof , thlprof , qtprof , svprof use modmpi , only : myid implicit none integer :: k , n if ( lnudge . eqv . . false .) return if ( lnudgevel ) then do k = kb + nnudge , ke up (:,:, k ) = up (:,:, k ) - ( u0av ( k ) - uprof ( k )) / tnudge vp (:,:, k ) = vp (:,:, k ) - ( v0av ( k ) - vprof ( k )) / tnudge end do end if do n = 1 , nsv do k = kb + nnudge , ke svp (:,:, k , n ) = svp (:,:, k , n ) - ( sv0av ( k , n ) - svprof ( k , n )) / tnudge end do end do if ( ltempeq ) then do k = kb + nnudge , ke thlp (:,:, k ) = thlp (:,:, k ) - ( thl0av ( k ) - thlprof ( k )) / tnudge end do end if !ltempeq if ( lmoist ) then do k = kb + nnudge , ke qtp (:,:, k ) = qtp (:,:, k ) - ( qt0av ( k ) - qtprof ( k )) / tnudge end do end if !lmoist end subroutine nudge subroutine periodicEBcorr ! added by cew216 ! ! use a volume sink to counter a  heat/moisture flux from the SEB ! ! sink acts above buildings ! ! use initfac, only :  max_height_index use modfields , only : thlp , qtp !use modglobal, only: ltempeq, lperiodicEBcorr, ib, ie, jb, je, kb, ke, imax, jtot use modglobal , only : ltempeq , lmoist , lperiodicEBcorr , ib , ie , jb , je , kb , ke ,& itot , jtot , totheatflux , sinkbase , totqflux , & zh , dx , dy , dzh , fraction use modmpi , only : comm3d , mpierr , MY_REAL , myid , MPI_SUM ! integer :: i , j , k , n , M real :: tot_Tflux , tot_qflux , sensible_heat_out , latent_heat_out , R_theta , R_q , H_proj , E_proj , R_theta_scaled , R_q_scaled , abl_height , phi_theta_t , phi_q_t !, !tot_qflux !, sink_points ! !write(*,*) 'lperiodicEBcorr ', lperiodicEBcorr !write(*,*) 'fraction', fraction if ( lperiodicEBcorr . eqv . . false .) return ! !call MPI_ALLREDUCE(bctfluxsum,   tot_Tflux,1,MY_REAL,MPI_SUM,comm3d,mpierr) !call MPI_ALLREDUCE(bcqfluxsum,   tot_qflux,1,MY_REAL,MPI_SUM,comm3d,mpierr) call MPI_ALLREDUCE ( totheatflux , tot_Tflux , 1 , MY_REAL , MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( totqflux , tot_qflux , 1 , MY_REAL , MPI_SUM , comm3d , mpierr ) ! Grylls 2021;  R=(phitop-phibot)/l= -phibot/hABL ! Since tot_Tflux = phibot/LxLydeltaV ! according to  M if use new tot_Tflux then we have phibot = tot_heatflux/lxly ! then define phitop = (1-frac)phibot ! R = frac*(phitop-phibot)/l ! then needs scaling because of the sink based! code this and comment it. !name sinkbase with a k so we now its a vertical index !!!! The point is to define phitop phibot and R above the loop so the stuff in the loop looks like the eqns. ! Do the same for humidity ! This follows the work in Grylls 2021 H_proj = tot_Tflux / ( itot * jtot ) ! [Kms&#94;-1]This is total heat flux in divided by the domain cross section. E_proj = tot_qflux / ( itot * jtot ) abl_height = ke / fraction ! We reverse engineer the ABL height from domain height and fraction R_theta = H_proj / abl_height ![Ks&#94;-1] This is the forcing F\\theta from Grylls 2021 R_q = E_proj / abl_height ! Ke is the number of points in the vertical over which we would apply R if we included the canopy M = ke - ( sinkbase + 1 ) + 1 ! The number of points over which we will apply rscaled. We only apply the forcing above the canopy so it has to be made bigger. R_theta_scaled = R_theta * ke / ( M ) ! [Ks&#94;-1]The forcing is scaled up beacuse we do not apply it to the whole volume, only to points above the canopy. We add one to sinkbase to be above the buildings and add 1 to (ke-(sinkbase+1)) to correctly count the points. R_q_scaled = R_q * ke / ( M ) !phi_theta_t = 0 ! For debugging the flux profile !(1-fraction)*H_proj! The heat flux out the top of the domain. phi_theta_t = ( 1 - fraction ) * H_proj phi_q_t = ( 1 - fraction ) * E_proj if ( ltempeq ) then do i = ib , ie do j = jb , je do k = sinkbase + 1 , ke !max_height_index +1 , ke ! Only apply the correction over the volume above the buidlings !thlp(i,j,k) = thlp(i,j,k) + fraction*tot_Tflux*(zh(k+1)-zh(k))/(imax*jtot*(zh(ke+1) - zh(max_height_index+1))) !thlp(i,j,k) = thlp(i,j,k) - fraction*tot_Tflux/(itot*jtot*(ke-sinkbase)) ! Most recent working version pre M changes cew216 20240112 thlp ( i , j , k ) = thlp ( i , j , k ) + R_theta_scaled end do end do end do !end if !sensible_heat_out = (1-fraction)*tot_Tflux/(itot*jtot) do i = ib , ie do j = jb , je thlp ( i , j , ke ) = thlp ( i , j , ke ) + phi_theta_t end do end do end if ! ! ! if ( lmoist ) then do i = ib , ie do j = jb , je do k = sinkbase + 1 , ke ! Only apply the correction over the volume above the buidlings !qtp(i,j,k) = qtp(i,j,k) + fraction*tot_qflux*(zh(k+1)-zh(k))/(imax*jtot*(zh(ke+1) - zh(max_height_index+1))) !qtp(i,j,k) = qtp(i,j,k) - fraction*tot_qflux/(itot*jtot*(ke-sinkbase)) qtp ( i , j , k ) = qtp ( i , j , k ) + R_q_scaled end do end do end do latent_heat_out = ( 1 - fraction ) * tot_qflux / ( itot * jtot * ( zh ( ke + 1 ) - zh ( ke ))) do i = ib , ie do j = jb , je qtp ( i , j , ke ) = qtp ( i , j , ke ) + phi_q_t end do end do end if ! !write(*,*) 'fraction', fraction end subroutine periodicEBcorr subroutine shiftedPBCs ! Nudge the flow in a region near the outlet use modglobal , only : ib , itot , ie , jb , je , kb , ke , xh , ds , dyi , xlen , rk3step , dt , pi use modfields , only : u0 , v0 , w0 , u0av , up , vp , wp , vm use decomp_2d , only : zstart integer :: i , j , k , ig real :: vs , RHS , rk3coef if ( ds > 0 ) then rk3coef = dt / ( 4. - dble ( rk3step )) do i = ib , ie ig = i + zstart ( 1 ) - 1 ! global i position if ( ig > int ( itot / 2 )) then do j = jb , je do k = kb , ke vs = 0.5 * pi * ds / ( 0.5 * xlen ) * u0av ( k ) * sin ( pi * ( xh ( ig ) - xh ( int ( itot / 2 ))) / ( 0.5 * xlen )) up ( i , j , k ) = up ( i , j , k ) - vs * ( u0 ( i , j , k ) - u0 ( i , j - 1 , k )) * dyi vp ( i , j , k ) = vp ( i , j , k ) - vs * ( v0 ( i , j , k ) - v0 ( i , j - 1 , k )) * dyi wp ( i , j , k ) = wp ( i , j , k ) - vs * ( w0 ( i , j , k ) - w0 ( i , j - 1 , k )) * dyi end do end do end if end do end if end subroutine shiftedPBCs end module modforces","tags":"","url":"sourcefile/modforces.f90.html"},{"title":"modsave.f90 – uDALES","text":"This file depends on sourcefile~~modsave.f90~~EfferentGraph sourcefile~modsave.f90 modsave.f90 sourcefile~initfac.f90 initfac.f90 sourcefile~modsave.f90->sourcefile~initfac.f90 sourcefile~modfields.f90 modfields.f90 sourcefile~modsave.f90->sourcefile~modfields.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~modsave.f90->sourcefile~modglobal.f90 sourcefile~modibmdata.f90 modibmdata.f90 sourcefile~modsave.f90->sourcefile~modibmdata.f90 sourcefile~modinletdata.f90 modinletdata.f90 sourcefile~modsave.f90->sourcefile~modinletdata.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~modsave.f90->sourcefile~modmpi.f90 sourcefile~modsubgriddata.f90 modsubgriddata.f90 sourcefile~modsave.f90->sourcefile~modsubgriddata.f90 sourcefile~modsurfdata.f90 modsurfdata.f90 sourcefile~modsave.f90->sourcefile~modsurfdata.f90 sourcefile~initfac.f90->sourcefile~modglobal.f90 sourcefile~initfac.f90->sourcefile~modmpi.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~modsave.f90~~AfferentGraph sourcefile~modsave.f90 modsave.f90 sourcefile~moddriver.f90 moddriver.f90 sourcefile~moddriver.f90->sourcefile~modsave.f90 sourcefile~modinlet.f90 modinlet.f90 sourcefile~modinlet.f90->sourcefile~modsave.f90 sourcefile~program.f90 program.f90 sourcefile~program.f90->sourcefile~modsave.f90 sourcefile~program.f90->sourcefile~moddriver.f90 sourcefile~modboundary.f90 modboundary.f90 sourcefile~program.f90->sourcefile~modboundary.f90 sourcefile~modstartup.f90 modstartup.f90 sourcefile~program.f90->sourcefile~modstartup.f90 sourcefile~modibm.f90 modibm.f90 sourcefile~program.f90->sourcefile~modibm.f90 sourcefile~modsubgrid.f90 modsubgrid.f90 sourcefile~program.f90->sourcefile~modsubgrid.f90 sourcefile~modfielddump.f90 modfielddump.f90 sourcefile~program.f90->sourcefile~modfielddump.f90 sourcefile~modstatsdump.f90 modstatsdump.f90 sourcefile~program.f90->sourcefile~modstatsdump.f90 sourcefile~modboundary.f90->sourcefile~moddriver.f90 sourcefile~modstartup.f90->sourcefile~moddriver.f90 sourcefile~modstartup.f90->sourcefile~modinlet.f90 sourcefile~modstartup.f90->sourcefile~modboundary.f90 sourcefile~modstartup.f90->sourcefile~modibm.f90 sourcefile~modstartup.f90->sourcefile~modsubgrid.f90 sourcefile~modibm.f90->sourcefile~modboundary.f90 sourcefile~modsubgrid.f90->sourcefile~modboundary.f90 sourcefile~advec_2nd.f90 advec_2nd.f90 sourcefile~advec_2nd.f90->sourcefile~modibm.f90 sourcefile~modfielddump.f90->sourcefile~modibm.f90 sourcefile~modstatsdump.f90->sourcefile~modsubgrid.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> \\file modsave.f90 !! Writes restart and data files. !> !! modsave.f90 writes the restart and data files !!  \\author Jasper Tomas, June 4th 2015 !!  \\todo documentation !!  \\par Revision list ! !  This file is part of DALES. ! ! DALES is free software; you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation; either version 3 of the License, or ! (at your option) any later version. ! ! DALES is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !  Copyright 1993-2009 Delft University of Technology, Wageningen University, Utrecht University, KNMI ! module modsave implicit none ! private ! public :: writerestartfiles, writedatafiles save contains !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine writerestartfiles use mpi use modsurfdata , only : ustar , thlflux , qtflux , svflux , dudz , dvdz , dthldz , dqtdz , ps , thls , qts , thvs , oblav use modfields , only : u0 , v0 , w0 , thl0 , qt0 , ql0 , ql0h , e120 , dthvdz , presf , presh , sv0 , mindist , wall ,& uav , vav , wav , uuav , vvav , wwav , uvav , uwav , vwav , thlav , thl2av , qtav , qlav , ql2av , qt2av , svav , sv2av , momthick ,& friction , displthick , pres0 , viscratioav , thluav , thlvav , thlwav , qtuav , qtvav , qtwav , qluav , qlvav , qlwav , svuav , svvav , svwav ,& upupav , vpvpav , wpwpav , thlpthlpav , qlpqlpav , qtpqtpav , svpsvpav , upvpav , upwpav , vpwpav , thlpupav , thlpvpav ,& thlpwpav , qlpupav , qlpvpav , qlpwpav , qtpupav , qtpvpav , qtpwpav , svpupav , svpvpav , svpwpav , presav ,& uusgsav , vvsgsav , wwsgsav , uwsgsav , thlusgsav , thlwsgsav , qlusgsav , qlwsgsav , qtusgsav , qtwsgsav , svusgsav , svwsgsav , tkesgsav ,& strain2av , disssgsav , t_vav , tvmx , tvmy , tvmz , tsgsmx1 , tsgsmx2 , tsgsmy1 , tsgsmy2 , tsgsmz1 ,& tsgsmz2 , t_sgsav , nusgsav , tpm , t_pav , ttmx , ttmy , ttmz , t_tav , p_bav , d_sgsav , p_tav , tkeadv use modglobal , only : ib , ie , ih , jb , je , jh , kb , ke , kh , trestart , tnextrestart , dt_lim , timee , btime , xh ,& cexpnr , ntimee , rk3step , ifoutput , nsv , timeleft , dt , ntrun , totavtime ,& iinletgen , timee , runavtime , inletav , totinletav , linletRA , ltempeq , lmoist ,& dzf , dzfi , dzhi , dxf , dxfi , dyi , dxhi , nstore , numol , dy2i , grav , libm , jmax , nblocks use modmpi , only : cmyid , cmyidx , cmyidy , myid , slabsum , excjs , comm3d use modsubgriddata , only : ekm use modibmdata , only : ibmxforcevol use initfac , only : block use modinletdata , only : Urec , Wrec , Uinl , Utav , QLinl , QTinl , QLrec , QTrec , QTtav , QLtav , Ttav , upupavinl , vpvpavinl , wpwpavinl , upwpavinl ,& thlpthlpavinl , thlpupavinl , thlpwpavinl , qlpqlpavinl , qlpupavinl , qlpwpavinl , qtpqtpavinl , qtpupavinl , qtpwpavinl , Tinl , Trec , nstepread implicit none logical :: lexitnow = . false . integer imin , ihour integer i , j , k , n , im , ip , jm , jp , jpp , km , kp , kpp , il , iu , jl , ju , kl , ku character ( 25 ) name , name2 , name3 , name4 , linkname integer :: ierr , err_code if ( timee == 0 ) return !    if (rk3step /=3) return if (( iinletgen == 2 ) . and . ( nstepread == nstore )) then ! This overrules the need for rk3step to be 3 in case of reading inletfiles write ( 6 , * ) 'Writing restartfiles after reading in new inletfiles' else if ( rk3step /= 3 ) return ! Normal check end if if ( myid == 0 ) then name = 'exit_now.' // cexpnr inquire ( file = trim ( name ), EXIST = lexitnow ) end if call MPI_Bcast ( lexitnow , 1 , MPI_LOGICAL , 0 , comm3d , ierr ) if ( ierr /= 0 ) then if ( myid == 0 ) then print * , \"Error in MPI Broadcast!\" end if err_code = ierr call MPI_Abort ( MPI_COMM_WORLD , err_code , ierr ) end if if ((( timee >= tnextrestart )) . or . (( lexitnow ) . or . ( nstepread == nstore + 1 ))) then tnextrestart = tnextrestart + trestart name = 'initd        _   _   .' write ( name ( 6 : 13 ) , '(i8.8)' ) ntrun name ( 15 : 17 ) = cmyidx name ( 19 : 21 ) = cmyidy name ( 23 : 25 ) = cexpnr open ( ifoutput , file = name , form = 'unformatted' , status = 'replace' ) write ( ifoutput ) ((( mindist ( i , j , k ), i = ib , ie ), j = jb , je ), k = kb , ke ) write ( ifoutput ) (((( wall ( i , j , k , n ), i = ib , ie ), j = jb , je ), k = kb , ke ), n = 1 , 5 ) write ( ifoutput ) ((( u0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) write ( ifoutput ) ((( v0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) write ( ifoutput ) ((( w0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) write ( ifoutput ) ((( pres0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) write ( ifoutput ) ((( thl0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) write ( ifoutput ) ((( e120 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) write ( ifoutput ) ((( ekm ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) write ( ifoutput ) ((( qt0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) write ( ifoutput ) ((( ql0 ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) write ( ifoutput ) ((( ql0h ( i , j , k ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ) write ( ifoutput ) timee , dt if ( myid == 0 ) then write ( * , * ) '-------------------------' write ( * , * ) 'Saving initd restart file' write ( * , * ) 'ntrun ::: ' , ntrun write ( * , * ) 'timee ::: ' , timee write ( * , * ) '-------------------------' endif close ( ifoutput ) if ( nsv > 0 ) then name = 'inits        _   _   .' write ( name ( 6 : 13 ) , '(i8.8)' ) ntrun name ( 15 : 17 ) = cmyidx name ( 19 : 21 ) = cmyidy name ( 23 : 25 ) = cexpnr open ( ifoutput , file = name , form = 'unformatted' ) write ( ifoutput ) (((( sv0 ( i , j , k , n ), i = ib - ih , ie + ih ), j = jb - jh , je + jh ), k = kb , ke + kh ), n = 1 , nsv ) write ( ifoutput ) timee close ( ifoutput ) end if if ( myid == 0 ) then write ( * , '(A,F15.7,A,I4)' ) 'dump at time = ' , timee , ' unit = ' , ifoutput end if end if end subroutine writerestartfiles end module modsave","tags":"","url":"sourcefile/modsave.f90.html"},{"title":"modchecksim.f90 – uDALES","text":"This file depends on sourcefile~~modchecksim.f90~~EfferentGraph sourcefile~modchecksim.f90 modchecksim.f90 sourcefile~modfields.f90 modfields.f90 sourcefile~modchecksim.f90->sourcefile~modfields.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~modchecksim.f90->sourcefile~modglobal.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~modchecksim.f90->sourcefile~modmpi.f90 sourcefile~modsubgriddata.f90 modsubgriddata.f90 sourcefile~modchecksim.f90->sourcefile~modsubgriddata.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~modchecksim.f90~~AfferentGraph sourcefile~modchecksim.f90 modchecksim.f90 sourcefile~program.f90 program.f90 sourcefile~program.f90->sourcefile~modchecksim.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> \\file modchecksim.f90 !!  Monitors Courant and Peclet numbers, and divergence. !> !!  Monitors Courant and Peclet numbers, and divergence. !> !!  These numbers are put out to screen either every tcheck seconds, or every time step (if tcheck=0). !!  \\autor Jasper Tomas, TU Delft, June 4th 2015 !!  \\author Thijs Heus,MPI-M !!  \\author Hans Cuijpers, KNMI !!  \\par Revision list !  This file is part of DALES. ! ! DALES is free software; you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation; either version 3 of the License, or ! (at your option) any later version. ! ! DALES is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !  Copyright 1993-2009 Delft University of Technology, Wageningen University, Utrecht University, KNMI ! ! module modchecksim use modglobal , only : longint implicit none private public initchecksim , checksim real :: tcheck = 0. !integer(kind=longint) :: tnext = 3600.,itcheck real :: tnext = 0. real :: dtmn = 0. , ndt = 0. save contains !> Initializing Checksim. Read out the namelist, initializing the variables subroutine initchecksim use modglobal , only : ifnamopt , fname_options , dtmax , ladaptive , btime use modmpi , only : myid , my_real , comm3d , mpierr implicit none integer :: ierr namelist / NAMCHECKSIM / & tcheck if ( myid == 0 ) then open ( ifnamopt , file = fname_options , status = 'old' , iostat = ierr ) read ( ifnamopt , NAMCHECKSIM , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'ERROR: Problem in namoptions NAMCHECKSIM' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif !write(6 ,NAMCHECKSIM) close ( ifnamopt ) if ((. not . ladaptive ) . and . ( tcheck < dtmax )) then tcheck = dtmax end if end if call MPI_BCAST ( tcheck , 1 , MY_REAL , 0 , comm3d , mpierr ) !    itcheck = floor(tcheck/tres) tnext = tcheck + btime end subroutine initchecksim !>Run checksim. Timekeeping, and output subroutine checksim use modglobal , only : timee , rk3step , dt_lim , dt use modmpi , only : myid implicit none character ( 20 ) :: timeday if ( timee == 0.0 ) return if ( rk3step /= 3 ) return dtmn = dtmn + dt ; ndt = ndt + 1. if ( timee < tnext ) return tnext = tnext + tcheck dtmn = dtmn / ndt if ( myid == 0 ) then call date_and_time ( time = timeday ) write ( * , * ) '=================================================================' write ( * , '(3A,F15.5,A,F12.9)' ) 'Time of Day: ' , timeday ( 1 : 10 ), '    Time of Simulation: ' , timee , '    dt: ' , dtmn end if call calccourant call calcdiffnr call chkdiv dtmn = 0. ndt = 0. end subroutine checksim !>      Calculates the courant number as in max(w)*deltat/deltaz subroutine calccourant use modglobal , only : ib , ie , jb , je , kb , ke , kh , dxhi , dyi , dzhi , dt , timee use modfields , only : um , vm , wm use modmpi , only : myid , comm3d , mpierr , mpi_max , my_real implicit none real :: courtotl , courtot integer :: i , j , k courtotl = 0.0 courtot = 0.0 do k = kb , ke do j = jb , je do i = ib , ie courtotl = max ( courtotl ,( um ( i , j , k ) * dxhi ( i ) + vm ( i , j , k ) * dyi + wm ( i , j , k ) * dzhi ( k )) * dtmn ) end do end do end do call MPI_ALLREDUCE ( courtotl , courtot , 1 , MY_REAL , MPI_MAX , comm3d , mpierr ) if ( myid == 0 ) then write ( * , '(A,ES10.2)' ) 'Courant numbers (x,y,z,tot):' , courtot end if return end subroutine calccourant !> Calculates the diffusion number as max(ekm) *deltat/deltax**2 subroutine calcdiffnr use modglobal , only : ib , ie , jb , je , kb , ke , kh , dxh2i , dy2i , dzh , dt , timee use modsubgriddata , only : ekm , ekh use modmpi , only : myid , comm3d , mpierr , mpi_max , my_real implicit none real diffnrtotl , diffnrtot integer :: i , j , k diffnrtotl = 0. diffnrtot = 0. do k = kb , ke do j = jb , je do i = ib , ie !      diffnrtotl = max(diffnrtotl,  ekm(i,j,k)*(1/dzh(k)**2 + dxh2i(i) + dy2i)*dtmn )  ! or should I interpolate ekm to the correct position? diffnrtotl = max ( diffnrtotl , ekm ( i , j , k ) * ( 1 / dzh ( k ) ** 2 + dxh2i ( i ) + dy2i ) * dtmn , & ekh ( i , j , k ) * ( 1 / dzh ( k ) ** 2 + dxh2i ( i ) + dy2i ) * dtmn ) ! or should I interpolate ekm to the correct position? end do end do end do call MPI_ALLREDUCE ( diffnrtotl , diffnrtot , 1 , MY_REAL , MPI_MAX , comm3d , mpierr ) if ( myid == 0 ) then write ( 6 , '(A,ES10.2)' ) 'Diffusion number:' , diffnrtot end if return end subroutine calcdiffnr !ils13, 13.08.18: currently unused, not called !> tg3315 27/02/18 - was not outputting cell Peclet number so added this to give cell Reynolds number subroutine calcreyn use modglobal , only : ib , ie , jb , je , ke , kb , dy , dxh , dzh use modfields , only : u0 , v0 , w0 use modmpi , only : myid , comm3d , mpi_sum , mpi_max , my_real , mpierr use modsubgriddata , only : ekm , ekh implicit none real reyntotl , reyntot integer :: i , j , k reyntotl = 0. reyntot = 0. do k = kb , ke do j = jb , je do i = ib , ie reyntotl = max ( reyntotl , u0 ( i , j , k ) * dxh ( i ) / ekm ( i , j , k ), v0 ( i , j , k ) * dy / ekm ( i , j , k ), & w0 ( i , j , k ) * dzh ( k ) / ekm ( i , j , k )) ! or should I interpolate ekm to the correct position? end do end do end do call MPI_ALLREDUCE ( reyntotl , reyntot , 1 , MY_REAL , MPI_MAX , comm3d , mpierr ) if ( myid == 0 ) then write ( 6 , '(A,ES10.2)' ) 'Cell Reynolds number:' , reyntot end if end subroutine calcreyn !> Checks local and total divergence subroutine chkdiv use modglobal , only : ib , ie , jb , je , ke , kb , dx , dxi , dy , dyi , dzf , dzfi use modfields , only : u0 , v0 , w0 !,divergentie use modmpi , only : myid , comm3d , mpi_sum , mpi_max , my_real , mpierr implicit none real div , divmax , divtot real divmaxl , divtotl integer i , j , k divmax = 0. divtot = 0. divmaxl = 0. divtotl = 0. do k = kb , ke do j = jb , je do i = ib , ie div = & ( u0 ( i + 1 , j , k ) - u0 ( i , j , k ) ) * dxi + & ( v0 ( i , j + 1 , k ) - v0 ( i , j , k ) ) * dyi + & ( w0 ( i , j , k + 1 ) - w0 ( i , j , k ) ) * dzfi ( k ) !      divergentie(i,j,k)=div divmaxl = max ( divmaxl , abs ( div )) divtotl = divtotl + div * dx * dy * dzf ( k ) end do end do end do call MPI_ALLREDUCE ( divtotl , divtot , 1 , MY_REAL , & MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( divmaxl , divmax , 1 , MY_REAL , & MPI_MAX , comm3d , mpierr ) if ( myid == 0 ) then write ( 6 , '(A,2ES11.2)' ) 'divmax, divtot = ' , divmax , divtot end if return end subroutine chkdiv end module modchecksim","tags":"","url":"sourcefile/modchecksim.f90.html"},{"title":"modtest.f90 – uDALES","text":"Source Code module modtest use MPI use decomp_2d implicit none contains subroutine inittest integer :: nx = 64 , ny = 64 , nz = 64 !integer :: p_row=2, p_col=2 integer :: p_row = 0 , p_col = 0 integer :: ierror call MPI_INIT ( ierror ) !call MPI_COMM_RANK(MPI_COMM_WORLD,nrank,ierr) !call MPI_COMM_SIZE(MPI_COMM_WORLD,nproc,ierr) !call decomp_2d_init(nx,ny,nz,p_row,p_col) call decomp_2d_init ( nx , ny , nz , p_row , p_col ) write ( * , * ) xstart write ( * , * ) ystart write ( * , * ) zstart write ( * , * ) xend write ( * , * ) yend write ( * , * ) zend write ( * , * ) xsize write ( * , * ) ysize write ( * , * ) zsize end subroutine inittest subroutine exittest integer :: ierror call decomp_2d_finalize call MPI_FINALIZE ( ierror ) end subroutine exittest end module modtest","tags":"","url":"sourcefile/modtest.f90.html"},{"title":"modinlet.f90 – uDALES","text":"This file depends on sourcefile~~modinlet.f90~~EfferentGraph sourcefile~modinlet.f90 modinlet.f90 sourcefile~modfields.f90 modfields.f90 sourcefile~modinlet.f90->sourcefile~modfields.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~modinlet.f90->sourcefile~modglobal.f90 sourcefile~modinletdata.f90 modinletdata.f90 sourcefile~modinlet.f90->sourcefile~modinletdata.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~modinlet.f90->sourcefile~modmpi.f90 sourcefile~modsave.f90 modsave.f90 sourcefile~modinlet.f90->sourcefile~modsave.f90 sourcefile~modsurfdata.f90 modsurfdata.f90 sourcefile~modinlet.f90->sourcefile~modsurfdata.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 sourcefile~modsave.f90->sourcefile~modfields.f90 sourcefile~modsave.f90->sourcefile~modglobal.f90 sourcefile~modsave.f90->sourcefile~modinletdata.f90 sourcefile~modsave.f90->sourcefile~modmpi.f90 sourcefile~modsave.f90->sourcefile~modsurfdata.f90 sourcefile~initfac.f90 initfac.f90 sourcefile~modsave.f90->sourcefile~initfac.f90 sourcefile~modibmdata.f90 modibmdata.f90 sourcefile~modsave.f90->sourcefile~modibmdata.f90 sourcefile~modsubgriddata.f90 modsubgriddata.f90 sourcefile~modsave.f90->sourcefile~modsubgriddata.f90 sourcefile~initfac.f90->sourcefile~modglobal.f90 sourcefile~initfac.f90->sourcefile~modmpi.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~modinlet.f90~~AfferentGraph sourcefile~modinlet.f90 modinlet.f90 sourcefile~modstartup.f90 modstartup.f90 sourcefile~modstartup.f90->sourcefile~modinlet.f90 sourcefile~program.f90 program.f90 sourcefile~program.f90->sourcefile~modstartup.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! modinlet.f90 contains the method of Lund (1998) to a generate a turbulent inlet profile. !! The velocity is extracted from a recycle plane, rescaled, and used as inlet condition !! Note that due to the staggered grid arrangement the u-components are recycled from !! cell(irecycl,:,:), while the v- and w- components are read from cell (irecycle-1,:,:). !! This is because the inlet condition is located at i=ib for u, and at i=ib-1 for v and w. !! !! Also the method of Kong (2000) is added to generate a turbulent temperature inlet profile !! !!  \\author Jasper Tomas,TU Delft, June 4th 2015 !!  \\par Revision list !!  \\todo Documentation ! !  This file is part of DALES. ! ! DALES is free software; you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation; either version 3 of the License, or ! (at your option) any later version. ! ! DALES is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program.  If not, see <http://www.gnu.org/licenses/>. ! !  Copyright 1993-2009 Delft University of Technology, Wageningen University, Utrecht University, KNMI ! module modinlet use mpi use modinletdata implicit none save public :: initinlet , exitinlet , momentumthickness , blthickness , dispthickness , writeinletfile , readinletfile , enthalpythickness , inletgen , inletgennotemp , zinterpolate1d , zinterpolatew1d , zinterpolatet1d , zinterpolate2d , blthicknesst , momentumthicknessexp , dispthicknessexp contains subroutine initinlet use modglobal , only : ih , ib , ie , jh , jb , je , kb , ke , kh , iinletgen , iplane , xf , lstoreplane , nstore , Uinf , ltempeq , pi , zf , zh use modfields , only : um use modmpi , only : myid , nprocs implicit none real :: pfi , epsi integer :: k if ( iinletgen == 1 ) then allocate ( Utav ( ib : ie , kb : ke )) allocate ( Uinl ( kb : ke )) allocate ( Winl ( kb : ke + 1 )) allocate ( Urec ( kb : ke )) allocate ( Wrec ( kb : ke + 1 )) allocate ( u0inletbc ( jb : je , kb : ke )) allocate ( v0inletbc ( jb : je , kb : ke )) allocate ( w0inletbc ( jb : je , kb : ke + 1 )) allocate ( u0inletbcold ( jb : je , kb : ke )) allocate ( v0inletbcold ( jb : je , kb : ke )) allocate ( w0inletbcold ( jb : je , kb : ke + 1 )) allocate ( uminletbc ( jb : je , kb : ke )) allocate ( vminletbc ( jb : je , kb : ke )) allocate ( wminletbc ( jb : je , kb : ke + 1 )) allocate ( uaver ( ib : ie , kb : ke )) allocate ( zirf ( kb : ke )) allocate ( ziif ( kb : ke )) allocate ( zirh ( kb : ke + 1 )) allocate ( ziih ( kb : ke + 1 )) allocate ( zorf ( kb : ke )) allocate ( zoif ( kb : ke )) allocate ( zorh ( kb : ke + 1 )) allocate ( zoih ( kb : ke + 1 )) allocate ( loclowif ( kb : ke )) allocate ( locupif ( kb : ke )) allocate ( loclowih ( kb : ke + 1 )) allocate ( locupih ( kb : ke + 1 )) allocate ( loclowof ( kb : ke )) allocate ( locupof ( kb : ke )) allocate ( loclowoh ( kb : ke + 1 )) allocate ( locupoh ( kb : ke + 1 )) allocate ( displ ( ib : ie )) allocate ( displold ( ib : ie )) allocate ( upupavinl ( kb : ke )) allocate ( vpvpavinl ( kb : ke )) allocate ( wpwpavinl ( kb : ke )) allocate ( upwpavinl ( kb : ke )) allocate ( thlpthlpavinl ( kb : ke )) allocate ( thlpupavinl ( kb : ke )) allocate ( thlpwpavinl ( kb : ke )) allocate ( heavif ( kb : ke )) allocate ( heavih ( kb : ke + 1 )) if ( lstoreplane ) then allocate ( storeu0inletbc ( jb : je , kb : ke , 1 : nstore )) allocate ( storev0inletbc ( jb : je , kb : ke , 1 : nstore )) allocate ( storew0inletbc ( jb : je , kb : ke + 1 , 1 : nstore )) end if epsi = 0.25 * di do k = kb , ke pfi = zf ( k ) - 1.2 * di - epsi if ( pfi < - epsi ) then heavif ( k ) = 1. elseif ( pfi <= epsi ) then heavif ( k ) = 0.5 * ( 1. - ( pfi / epsi ) - ( 1. / pi ) * sin ( pi * pfi / epsi )) elseif ( pfi > epsi ) then heavif ( k ) = 0. end if end do do k = kb , ke + 1 pfi = zh ( k ) - 1.2 * di - epsi if ( pfi < - epsi ) then heavih ( k ) = 1. elseif ( pfi <= epsi ) then heavih ( k ) = 0.5 * ( 1. - ( pfi / epsi ) - ( 1. / pi ) * sin ( pi * pfi / epsi )) elseif ( pfi > epsi ) then heavih ( k ) = 0. end if end do if ( ltempeq ) then allocate ( Ttav ( ib : ie , kb : ke )) allocate ( taver ( ib : ie , kb : ke )) allocate ( Tinl ( kb : ke )) allocate ( Trec ( kb : ke )) allocate ( t0inletbc ( jb : je , kb : ke )) allocate ( t0inletbcold ( jb : je , kb : ke )) allocate ( tminletbc ( jb : je , kb : ke )) allocate ( zotr ( kb : ke )) allocate ( zoti ( kb : ke )) allocate ( loclowot ( kb : ke )) allocate ( locupot ( kb : ke )) allocate ( heavit ( kb : ke )) if ( lstoreplane ) then allocate ( storet0inletbc ( jb : je , kb : ke , 1 : nstore )) end if ! Heaviside function for temperature epsi = 0.25 * dti do k = kb , ke pfi = zf ( k ) - 1.2 * dti - epsi if ( pfi < - epsi ) then heavit ( k ) = 1. elseif ( pfi <= epsi ) then heavit ( k ) = 0.5 * ( 1. - ( pfi / epsi ) - ( 1. / pi ) * sin ( pi * pfi / epsi )) elseif ( pfi > epsi ) then heavit ( k ) = 0. end if end do end if displ = 0. displold = 0. irecy = ib + iplane ! index of recycle plane equals iplane (read from namoptions) xfm = sum ( xf ( ib : ie )) / ( ie - ib + 1 ) ! mean(xf) xf2m = sum ( xf ( ib : ie ) ** 2. ) / ( ie - ib + 1 ) ! mean(xf&#94;2) !  btime = timee                              ! this is done to make sure btime is set when avint is computed correctly at startup (only for RA) else if ( iinletgen == 2 ) then allocate ( storeu0inletbc ( jb : je , kb : ke , 1 : nstore )) allocate ( storev0inletbc ( jb : je , kb : ke , 1 : nstore )) allocate ( storew0inletbc ( jb : je , kb : ke + 1 , 1 : nstore )) allocate ( u0rot ( 1 : nstore , jb - jh : je + jh , kb : ke )) allocate ( v0rot ( 1 : nstore , jb - jh : je + jh , kb : ke )) allocate ( u0inletbc ( jb : je , kb : ke )) allocate ( v0inletbc ( jb : je , kb : ke )) allocate ( w0inletbc ( jb : je , kb : ke + 1 )) allocate ( u0inletbcold ( jb : je , kb : ke )) allocate ( v0inletbcold ( jb : je , kb : ke )) allocate ( w0inletbcold ( jb : je , kb : ke + 1 )) allocate ( uminletbc ( jb : je , kb : ke )) allocate ( vminletbc ( jb : je , kb : ke )) allocate ( wminletbc ( jb : je , kb : ke + 1 )) if ( ltempeq ) then allocate ( storet0inletbc ( jb : je , kb : ke , 1 : nstore )) allocate ( t0inletbc ( jb : je , kb : ke )) allocate ( t0inletbcold ( jb : je , kb : ke )) allocate ( tminletbc ( jb : je , kb : ke )) end if !iangle = iangledeg * pi / 180.  ! convert degrees to radians irecy = ib + iplane ! read coordinates of inletprofile call readzincoord !    ddispdx      = 0.00038/Uinf        ! this value should becomputed from the w0 computed in the inletgenerator ddispdx = wtop / Uinf ! wtop is read from zgrid.inf ddispdxold = ddispdx ! this value should becomputed from the w0 computed in the inletgenerator !    inlfactor    = nprocs/nprocsinl     ! nprocs should be larger or equal to nprocsin! !    write(6,*) 'inlfactor= ',inlfactor else return end if end subroutine initinlet subroutine inletgen use modglobal , only : ib , ie , jb , je , jtot , kb , ke , zf , zh , dzf , dzhi , timee , btime , totavtime , rk3step , dt , numol , iplane , lles , iinletgen , inletav , runavtime , Uinf , lwallfunc , linletRA , totinletav , lstoreplane , nstore , prandtlmoli , numol , grav , lbuoyancy , lfixinlet , luvolflowr , lfixutauin use modfields , only : u0 , v0 , w0 , thl0 , wm , uprof use modsurfdata , only : thls , thl_top use modsave , only : writerestartfiles use modmpi , only : slabsum , myid implicit none real , dimension ( ib : ib , jb : je , kb : ke ) :: uinletbc2 ! dummy variable real , dimension ( ib : ib , jb : je , kb : ke ) :: tinletbc2 ! dummy variable real , dimension ( jb : je , kb : ke ) :: uprec ! velocity fluctuation (up_rec = u0 - Urec) real , dimension ( jb : je , kb : ke ) :: vprec ! velocity fluctuation (vp_rec = v0 - 0) real , dimension ( jb : je , kb : ke + 1 ) :: wprec ! velocity fluctuation (wp_rec = w0 - Wrec) real , dimension ( jb : je , kb : ke ) :: tprec ! temperature fluctuation (tp_rec = t0 - Trec) real , dimension ( jb : je , kb : ke ) :: upinli , vpinli ! = gamma * (uprec,v interpolated to zii grid) real , dimension ( jb : je , kb : ke ) :: tpinli ! = lambda  * (tprec   interpolated to zii grid) real , dimension ( jb : je , kb : ke ) :: upinlo , vpinlo ! = gamma * (uprec,v interpolated to zoi grid) real , dimension ( jb : je , kb : ke ) :: tpinlo ! = lambda  * (tprec   interpolated to zoti grid) real , dimension ( jb : je , kb : ke + 1 ) :: wpinli ! = gamma * (wprec   interpolated to zii grid) real , dimension ( jb : je , kb : ke + 1 ) :: wpinlo ! = gamma * (wprec   interpolated to zoi grid) real , dimension ( kb : ke ) :: udiff ! difference between Uinl and Urec !    real,dimension(kb:ke)   :: Urecdiff                ! difference between Urec new and old real , dimension ( kb : ke ) :: urav ! j-averaged u-velocity (not time-averaged) real , dimension ( kb : ke ) :: trav ! j-averaged temperature (not time-averaged) real , dimension ( kb : ke ) :: uravdzf ! j-averaged u-velocity (not time-averaged) times dzf real , dimension ( kb : ke ) :: uinldzf ! j-averaged u-velocity (not time-averaged) times dzf real , dimension ( kb : ke ) :: Urecdzf ! Urec times dzf real , dimension ( kb : ke + 1 ) :: wrav ! j-averaged w-velocity (not time-averaged) real , dimension ( kb : ke ) :: Uinli ! = gamma * (Urec interpolated to ziif grid points) real , dimension ( kb : ke + 1 ) :: Winli ! = gamma * (Wrec interpolated to ziih grid points) real , dimension ( kb : ke ) :: Tinli ! = lambda  * (Trec interpolated to ziif grid points) real , dimension ( kb : ke ) :: Uinlo ! = gamma * (Urec interpolated to zioif grid points) real , dimension ( kb : ke + 1 ) :: Winlo ! = gamma * (Wrec interpolated to zoih grid points) real , dimension ( kb : ke ) :: Tinlo ! = lambda  * (Trec interpolated to zoti grid points) real , dimension ( kb : ke ) :: wfuncf ! weight function at full level real , dimension ( kb : ke + 1 ) :: wfunch ! weight function at half level real , dimension ( kb : ke ) :: wfunct ! weight function at full level real :: utaur2 , utaui2 ! (utau)&#94;2 at recycle station and inlet real :: gamm ! utaui / utaur real :: lamb ! ttaui / ttaur real :: avint , avinti ! avering interval real :: alpha , beta ! factors used in the Weight function !    real                    :: totalu                  ! total u-velocity at outlet real :: Urectot ! total u-velocity at recycle plane real :: rk3coef !    real                    :: di_test                 ! BL thickness as measured from Uinl real :: utop ! j-averaged top velocity real :: interval real :: dtinrk ! RK time step in inlet data real :: rk3coefin ! Cumulative RK time step in inlet data real :: dr_old real :: scalef ! scale factor to scale instantaneous velocity profile with to get constant mass flux real :: totaluinl ! bulk velocity at the inlet !    real                    :: q0                      ! heat flux integer i , j , k , kk , kdamp if ( iinletgen == 1 ) then u0inletbcold = u0inletbc v0inletbcold = v0inletbc w0inletbcold = w0inletbc t0inletbcold = t0inletbc ! temperature totaluold = totalu displold = displ ddispdxold = ddispdx ! compute time-average velocities rk3coef = dt / ( 4. - dble ( rk3step )) if ( rk3step == 1 ) then deltat = rk3coef elseif ( rk3step == 2 ) then deltat = rk3coef - ( dt / 3. ) elseif ( rk3step == 3 ) then deltat = rk3coef - ( dt / 2. ) end if if ( linletRA ) then ! this is a switch to use 'running average' avint = totinletav + timee - btime ! runav interval = averaging interval previuous sim  + current elapsed sim time else avint = inletav end if avinti = 1. / avint uaver = 0. taver = 0. do i = ib , ie call slabsum ( uaver ( i ,:), kb , ke , u0 ( i : i , jb : je , kb : ke ), i , i , jb , je , kb , ke , i , i , jb , je , kb , ke ) call slabsum ( taver ( i ,:), kb , ke , thl0 ( i : i , jb : je , kb : ke ), i , i , jb , je , kb , ke , i , i , jb , je , kb , ke ) end do wrav = 0. call slabsum ( wrav ( kb : ke + 1 ), kb , ke , w0 ( irecy - 1 : irecy - 1 , jb : je , kb : ke + 1 ), irecy - 1 , irecy - 1 , jb , je , kb , ke + 1 , irecy - 1 , irecy - 1 , jb , je , kb , ke + 1 ) trav = 0. call slabsum ( trav ( kb : ke ), kb , ke , thl0 ( irecy - 1 : irecy - 1 , jb : je , kb : ke ), irecy - 1 , irecy - 1 , jb , je , kb , ke , irecy - 1 , irecy - 1 , jb , je , kb , ke ) uaver = uaver / jtot ! average over j-direction taver = taver / jtot ! average over j-direction urav = uaver ( irecy ,:) wrav = wrav / jtot ! average over j-direction trav = trav / jtot ! average over j-direction do k = kb , ke Urec ( k ) = urav ( k ) * deltat * avinti + ( 1. - deltat * avinti ) * Urec ( k ) Trec ( k ) = trav ( k ) * deltat * avinti + ( 1. - deltat * avinti ) * Trec ( k ) end do do k = kb , ke + 1 Wrec ( k ) = wrav ( k ) * deltat * avinti + ( 1. - deltat * avinti ) * Wrec ( k ) end do do k = kb , ke do i = ib , ie Utav ( i , k ) = uaver ( i , k ) * deltat * avinti + ( 1. - deltat * avinti ) * Utav ( i , k ) Ttav ( i , k ) = taver ( i , k ) * deltat * avinti + ( 1. - deltat * avinti ) * Ttav ( i , k ) end do end do !    Urec = Urec +(Uinf-Urec(ke))     ! make sure at the recycle plane the top velocity equals Uinf !    Urecdiff = Urecdiff - Urec !    if (myid==0) then !      write(6,*) 'Urec_old - Urec_new (kb+40)=',Urecdiff(kb+40) !    end if !! check if Urec contains NaN !    if (myid==0) then !      write(6,*) 'Checking Urec for NaN' !      do k=kb,ke !        if (ISNAN(Urec(k))) then !          write(6,*) 'Urec(k)=NaN at k=kb+', k-kb !        end if !      end do !      write(6,*) 'Finished checking Urec for NaN' !    end if !    if (myid==0) then !      write(6,*) 'myid, Urec(ke)=',myid, Urec(ke) !      write(6,*) 'wrav(ke), Wrec(ke)=',wrav(ke), Wrec(ke) !      write(6,*) 'wrav(ke-1), Wrec(ke-1)=',wrav(ke-1), Wrec(ke-1) !      write(6,*) 'wrav(ke-10), Wrec(ke-10)=',wrav(ke-10), Wrec(ke-10) !      write(6,*) 'wrav(ke-30), Wrec(ke-30)=',wrav(ke-30), Wrec(ke-30) !      write(6,*) 'wrav(kb+10), Wrec(kb+10)=',wrav(kb+10), Wrec(kb+10) !      write(6,*) 'wrav(kb+11), Wrec(kb+11)=',wrav(kb+11), Wrec(kb+11) !    end if ! compute velocity fluctuation at recycle station do k = kb , ke do j = jb , je uprec ( j , k ) = u0 ( irecy , j , k ) - Urec ( k ) vprec ( j , k ) = v0 ( irecy - 1 , j , k ) ! mean v is zero tprec ( j , k ) = thl0 ( irecy - 1 , j , k ) - Trec ( k ) end do end do do k = kb , ke + 1 do j = jb , je wprec ( j , k ) = w0 ( irecy - 1 , j , k ) - Wrec ( k ) ! note that w-velocity is taken at i=irecy-1 !! end do end do if ( lwallfunc ) then call wallawinlet ( Urec ( kb ), dzf ( kb ), numol , utaur2 ) ! compute wall shear stress at recycle station else utaur2 = 2. * numol * Urec ( kb ) / dzf ( kb ) end if utaur = sqrt ( abs ( utaur2 )) ! compute utau at recycle station ! heat flux at recycle station (isothermal wall) q = alpha * dT/dz = (nu/prandtl) * dT/dz !    q0 = numol*prandtlmoli*(Trec(kb) - Trec(kb-1)) * dzhi(kb) q0 = numol * prandtlmoli * 2 * ( Trec ( kb ) - thls ) / dzf ( kb ) ttaur = q0 / utaur ! ttau = q/(rho*cp*utau) =  (alpha *dT/dz) / utau ! compute momentum thickness at inlet and recycle plane if ( lbuoyancy ) then lmor = ( thls * utaur ** 2 ) / ( 0.41 * grav * ttaur ) ! L = -T0*utau&#94;3 / kappa*g*<w'T'> = !     write(6,*) 'Initial dr,myid, utaur, ttaur, Lmor =', dr,myid,utaur,ttaur,lmor !     lmor = 0.3; lmoi = ( thls * utaui ** 2 ) / ( 0.41 * grav * ttaui ) ! L = -T0*utau&#94;3 / kappa*g*<w'T'> = !     lmoi = 0.3; !     write(6,*) 'Initial di_test,myid, utaui, ttaui, Lmoi =', di_test,myid,utaui,ttaui,lmoi dr_old = dr !     call blthicknessmo(dr,utaur,lmor)                    ! Also needed for momentumthickness call blthicknesst ( dr , Urec , 0.99 ) ! changed back to this one (instead of the above) !     call momentumthicknessmo(thetai,utaui,di,lmoi) !     call momentumthicknessmo(thetar,utaur,dr,lmor) call momentumthicknessexp ( thetai , Uinl ) call momentumthicknessexp ( thetar , Urec ) else !     call blthickness(dr,utaur)                           ! Also needed for momentumthickness call blthicknesst ( dr , Urec , 0.99 ) !     call momentumthickness(thetai,utaui,di) !     call momentumthickness(thetar,utaur,dr) call momentumthicknessexp ( thetai , Uinl ) call momentumthicknessexp ( thetar , Urec ) end if call enthalpythickness ( thetati , Tinl , Uinl ) call enthalpythickness ( thetatr , Trec , Urec ) !   call blthickness(dr,utaur) call blthicknesst ( dtr , Trec - thls , 0.99 ) ! compute utau at inlet from interior field !    if (thetai == 0.) then !      write(6,*) '!!! thetai = 0, myid=',myid !    else if (thetar == 0.) then !      write(6,*) '!!! thetar = 0, myid=',myid !      thetar=0.00001 !    else !      utaui = utaur* (thetar/thetai)**(1./8.)    ! See Lund (1998): 'Similar to Ludwig-Tillmann correlation' if (. not . lfixutauin ) then utaui = utaur * abs ( thetar / thetai ) ** ( 1. / 8. ) ! See Lund (1998): 'Similar to Ludwig-Tillmann correlation' end if if ( thetati == 0. ) then thetati = 0.0000001 end if ttaui = ttaur * abs ( thetatr / thetati ) ** ( 1. / 8. ) ! See Kong (2000): !    end if gamm = utaui / utaur ! Gamma in Lund (1998) if ( ttaur == 0. ) then ttaur = 0.0000001 end if lamb = ttaui / ttaur ! Lambda in Kong (2000) ! compute inner scaling coordinates zirf = utaur * zf / numol ! inner scaling zf-coordinate at recycle station zirh = utaur * zh / numol ! inner scaling zh-coordinate at recycle station ziif = utaui * zf / numol ! inner scaling zf-coordinate at inlet station ziih = utaui * zh / numol ! inner scaling zh-coordinate at inlet station ! compute outer scaling coordinates zorf = zf / dr ! outer scaling zf-coor as measured from Uinldinate at recycle station zorh = zh / dr ! outer scaling zh-coordinate at recycle station zoif = zf / di ! outer scaling zf-coordinate at inlet station  (could be done once, actually..) zoih = zh / di ! outer scaling zf-coordinate at inlet station  (could be done once, actually..) zotr = zf / dtr ! temperature outer scaling zf-coordinate at recycle station zoti = zf / dti ! temperature outer scaling zf-coordinate at inlet station !!!!! Interpolation starts here !!! First inner coordinates ! determine which elements are needed when recycle velocity profile is interpolated on inlet plane ! for u(,v)-components (zf) do k = kb , ke do kk = kb , ke if ( zirf ( kk ) >= ziif ( k )) then locupif ( k ) = kk loclowif ( k ) = kk - 1 exit elseif ( kk == ke ) then locupif ( k ) = ke + 1 ! this means extrapolation! loclowif ( k ) = ke - 1 ! waarom niet ke? of wordt dit niet gebruikt? end if end do end do ! for w-components (zh) do k = kb , ke + 1 do kk = kb , ke + 1 if ( zirh ( kk ) >= ziih ( k )) then locupih ( k ) = kk loclowih ( k ) = kk - 1 exit elseif ( kk == ke + 1 ) then locupih ( k ) = ke + 2 ! this means extrapolation! loclowih ( k ) = ke end if end do end do !!! Finished with inner coordinates !!! Do the same trick for outer coordinates ! determine which elements are needed when recycle velocity profile is interpolated on inlet plane ! for u(,v)-components (zf) do k = kb , ke do kk = kb , ke if ( zorf ( kk ) >= zoif ( k )) then locupof ( k ) = kk loclowof ( k ) = kk - 1 exit elseif ( kk == ke ) then locupof ( k ) = ke + 1 ! this means extrapolation! loclowof ( k ) = ke - 1 end if end do end do ! for w-components (zh) do k = kb , ke + 1 do kk = kb , ke + 1 if ( zorh ( kk ) >= zoih ( k )) then locupoh ( k ) = kk loclowoh ( k ) = kk - 1 exit elseif ( kk == ke + 1 ) then locupoh ( k ) = ke + 2 ! this means extrapolation! loclowoh ( k ) = ke end if end do end do !!! Finished with outer coordinates !!! Outer coordinates for temperature do k = kb , ke do kk = kb , ke if ( zotr ( kk ) >= zoti ( k )) then locupot ( k ) = kk loclowot ( k ) = kk - 1 exit elseif ( kk == ke ) then locupot ( k ) = ke + 1 ! this means extrapolation! loclowot ( k ) = ke - 1 end if end do end do !!! Finished with outer coordinates temperature !!! Now really interpolate !!! First inner coordinates ! compute Urec on zii grid do k = kb , ke if ( locupif ( k ) == ke + 1 ) then ! indicator for extrapolation! !        Uinli(k) = Urec(ke) + (Urec(ke) - Urec(ke-1)) / (zirf(ke)-zirf(ke-1)) * (ziif(k)-zirf(ke)) Uinli ( k ) = Urec ( ke ) Tinli ( k ) = Trec ( ke ) elseif ( loclowif ( k ) == kb - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) Uinli ( k ) = Urec ( kb ) / zirf ( kb ) * ziif ( k ) !        Tinli(k) = thls + Trec(kb)/zirf(kb)*ziif(k) !        Tinli(k) = (Trec(kb)-thls)/zirf(kb)*ziif(k) Tinli ( k ) = thls + ( Trec ( kb ) - thls ) / zirf ( kb ) * ziif ( k ) else ! normal interpolation Uinli ( k ) = Urec ( loclowif ( k )) + ( Urec ( locupif ( k )) - Urec ( loclowif ( k ))) / ( zirf ( locupif ( k )) - zirf ( loclowif ( k ))) * ( ziif ( k ) - zirf ( loclowif ( k ))) Tinli ( k ) = Trec ( loclowif ( k )) + ( Trec ( locupif ( k )) - Trec ( loclowif ( k ))) / ( zirf ( locupif ( k )) - zirf ( loclowif ( k ))) * ( ziif ( k ) - zirf ( loclowif ( k ))) if (( ziif ( k ) . gt . zirf ( locupif ( k ))) . or . ( ziif ( k ) . lt . zirf ( loclowif ( k )))) then write ( 6 , * ) '!!!Mistake in Interpolation !!!!' end if end if end do ! compute Wrec on zii grid Winli ( kb ) = 0.0 ! corresponds to ground level do k = kb + 1 , ke + 1 if ( locupih ( k ) == ke + 2 ) then ! indicator for extrapolation! !        Winli(k) = Wrec(ke+1) + (Wrec(ke+1) - Wrec(ke)) / (zirh(ke+1)-zirh(ke)) * (ziih(k)-zirh(ke+1)) Winli ( k ) = Wrec ( ke + 1 ) else ! normal interpolation Winli ( k ) = Wrec ( loclowih ( k )) + ( Wrec ( locupih ( k )) - Wrec ( loclowih ( k ))) / ( zirh ( locupih ( k )) - zirh ( loclowih ( k ))) * ( ziih ( k ) - zirh ( loclowih ( k ))) end if end do ! compute u- and v- and t-fluctuation on zii grid do k = kb , ke if ( locupif ( k ) == ke + 1 ) then ! indicator for extrapolation! !        upinli(:,k) = uprec(:,ke) + (uprec(:,ke) - uprec(:,ke-1)) / (zirf(ke)-zirf(ke-1)) * (ziif(k)-zirf(ke)) upinli (:, k ) = 0. vpinli (:, k ) = 0. tpinli (:, k ) = 0. elseif ( loclowif ( k ) == kb - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) upinli (:, k ) = uprec (:, kb ) / zirf ( kb ) * ziif ( k ) vpinli (:, k ) = vprec (:, kb ) / zirf ( kb ) * ziif ( k ) tpinli (:, k ) = tprec (:, kb ) / zirf ( kb ) * ziif ( k ) else ! normal interpolation upinli (:, k ) = uprec (:, loclowif ( k )) + ( uprec (:, locupif ( k )) - uprec (:, loclowif ( k ))) / ( zirf ( locupif ( k )) - zirf ( loclowif ( k ))) * ( ziif ( k ) - zirf ( loclowif ( k ))) vpinli (:, k ) = vprec (:, loclowif ( k )) + ( vprec (:, locupif ( k )) - vprec (:, loclowif ( k ))) / ( zirf ( locupif ( k )) - zirf ( loclowif ( k ))) * ( ziif ( k ) - zirf ( loclowif ( k ))) tpinli (:, k ) = tprec (:, loclowif ( k )) + ( tprec (:, locupif ( k )) - tprec (:, loclowif ( k ))) / ( zirf ( locupif ( k )) - zirf ( loclowif ( k ))) * ( ziif ( k ) - zirf ( loclowif ( k ))) end if end do ! compute w-fluctuation on zii grid do k = kb + 1 , ke + 1 !      if (locupih(k) == ke+1) then      ! indicator for extrapolation! if ( locupih ( k ) == ke + 2 ) then ! indicator for extrapolation! !        wpinli(:,k) = wprec(:,ke+1) + (wprec(:,ke+1) - wprec(:,ke)) / (zirh(ke+1)-zirh(ke)) * (ziih(k)-zirh(ke+1)) wpinli (:, k ) = 0. else ! normal interpolation wpinli (:, k ) = wprec (:, loclowih ( k )) + ( wprec (:, locupih ( k )) - wprec (:, loclowih ( k ))) / ( zirh ( locupih ( k )) - zirh ( loclowih ( k ))) * ( ziih ( k ) - zirh ( loclowih ( k ))) end if end do !! Finished with interpolating inner variables !! Continue with interpolating outer variables ! compute Urec on zoi grid do k = kb , ke if ( locupof ( k ) == ke + 1 ) then ! indicator for extrapolation! !        Uinlo(k) = Urec(ke) + (Urec(ke) - Urec(ke-1)) / (zorf(ke)-zorf(ke-1)) * (zoif(k)-zorf(ke)) !        Uinlo(k) = Urec(ke) Uinlo ( k ) = Uinf elseif ( loclowof ( k ) == kb - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) Uinlo ( k ) = Urec ( kb ) / zorf ( kb ) * zoif ( k ) else ! normal interpolation Uinlo ( k ) = Urec ( loclowof ( k )) + ( Urec ( locupof ( k )) - Urec ( loclowof ( k ))) / ( zorf ( locupof ( k )) - zorf ( loclowof ( k ))) * ( zoif ( k ) - zorf ( loclowof ( k ))) end if end do ! compute Wrec on zii grid Winlo ( kb ) = 0.0 ! corresponds to ground level do k = kb + 1 , ke + 1 if ( locupoh ( k ) == ke + 2 ) then ! indicator for extrapolation! !        Winlo(k) = Wrec(ke+1) + (Wrec(ke+1) - Wrec(ke)) / (zorh(ke+1)-zorh(ke)) * (zoih(k)-zorh(ke+1)) Winlo ( k ) = Wrec ( ke + 1 ) else ! normal interpolation Winlo ( k ) = Wrec ( loclowoh ( k )) + ( Wrec ( locupoh ( k )) - Wrec ( loclowoh ( k ))) / ( zorh ( locupoh ( k )) - zorh ( loclowoh ( k ))) * ( zoih ( k ) - zorh ( loclowoh ( k ))) end if end do ! compute u- and v-fluctuation on zoi grid do k = kb , ke if ( locupof ( k ) == ke + 1 ) then ! indicator for extrapolation! !        upinlo(:,k) = uprec(:,ke) + (uprec(:,ke) - uprec(:,ke-1)) / (zorf(ke)-zorf(ke-1)) * (zoif(k)-zorf(ke)) upinlo (:, k ) = 0. vpinlo (:, k ) = 0. elseif ( loclowof ( k ) == kb - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) upinlo (:, k ) = uprec (:, kb ) / zorf ( kb ) * zoif ( k ) vpinlo (:, k ) = vprec (:, kb ) / zorf ( kb ) * zoif ( k ) else ! normal interpolation upinlo (:, k ) = uprec (:, loclowof ( k )) + ( uprec (:, locupof ( k )) - uprec (:, loclowof ( k ))) / ( zorf ( locupof ( k )) - zorf ( loclowof ( k ))) * ( zoif ( k ) - zorf ( loclowof ( k ))) vpinlo (:, k ) = vprec (:, loclowof ( k )) + ( vprec (:, locupof ( k )) - vprec (:, loclowof ( k ))) / ( zorf ( locupof ( k )) - zorf ( loclowof ( k ))) * ( zoif ( k ) - zorf ( loclowof ( k ))) end if end do ! compute w-fluctuation on zoi grid do k = kb + 1 , ke + 1 if ( locupoh ( k ) == ke + 2 ) then ! indicator for extrapolation! !        wpinlo(:,k) = wprec(:,ke+1) + (wprec(:,ke+1) - wprec(:,ke)) / (zorh(ke+1)-zorh(ke)) * (zoih(k)-zorh(ke+1)) wpinlo (:, k ) = 0. else ! normal interpolation wpinlo (:, k ) = wprec (:, loclowoh ( k )) + ( wprec (:, locupoh ( k )) - wprec (:, loclowoh ( k ))) / ( zorh ( locupoh ( k )) - zorh ( loclowoh ( k ))) * ( zoih ( k ) - zorh ( loclowoh ( k ))) end if end do !! Finished interpolating outer velocity variables !! Interpolating outer temperature ! mean temperature do k = kb , ke if ( locupot ( k ) == ke + 1 ) then ! indicator for extrapolation! Tinlo ( k ) = thl_top elseif ( loclowot ( k ) == kb - 1 ) then ! interprets this as extrapolation to bottom (use Tinlo=thls at z+=0) !        Tinlo(k) = Trec(kb)/zotr(kb) * zoti(k) !        Tinlo(k) = (Trec(kb)-thls)/zotr(kb) * zoti(k) Tinlo ( k ) = thls + ( Trec ( kb ) - thls ) / zotr ( kb ) * zoti ( k ) else ! normal interpolation Tinlo ( k ) = Trec ( loclowot ( k )) + ( Trec ( locupot ( k )) - Trec ( loclowot ( k ))) / ( zotr ( locupot ( k )) - zotr ( loclowot ( k ))) * ( zoti ( k ) - zotr ( loclowot ( k ))) end if end do ! fluctuating temperature do k = kb , ke if ( locupot ( k ) == ke + 1 ) then ! indicator for extrapolation! !        upinlo(:,k) = uprec(:,ke) + (uprec(:,ke) - uprec(:,ke-1)) / (zorf(ke)-zorf(ke-1)) * (zoif(k)-zorf(ke)) tpinlo (:, k ) = 0. elseif ( loclowot ( k ) == kb - 1 ) then ! interprets this as extrapolation to bottom (use t=0 at z+=0) tpinlo (:, k ) = tprec (:, kb ) / zotr ( kb ) * zoti ( k ) else ! normal interpolation tpinlo (:, k ) = tprec (:, loclowot ( k )) + ( tprec (:, locupot ( k )) - tprec (:, loclowot ( k ))) / ( zotr ( locupot ( k )) - zotr ( loclowot ( k ))) * ( zoti ( k ) - zotr ( loclowot ( k ))) end if end do !! Finished interpolating out temperature !!!!! Finished Interpolation! !!!!! ! compute rescaled inner variables ! Winli = Winli (interpolation is enough) Uinli = gamm * Uinli Tinli = lamb * Tinli + ( 1. - lamb ) * thls ! this is different for isoflux wall! upinli = gamm * upinli vpinli = gamm * vpinli wpinli = gamm * wpinli tpinli = lamb * tpinli ! See Kong (2000) ! compute rescaled outer variables ! Winlo = Winlo (interpolation is enough) Uinlo = gamm * Uinlo + ( 1. - gamm ) * Uinf Tinlo = lamb * Tinlo + ( 1. - lamb ) * thl_top !    Uinlo = gamm* Uinlo  + (1.- gamm)*Urec(ke) upinlo = gamm * upinlo vpinlo = gamm * vpinlo wpinlo = gamm * wpinlo tpinlo = lamb * tpinlo ! See Kong (2000) !    utop = Uinlo(ke) !    Uinlo = Uinlo +(Uinf-utop)     ! make sure at the inlet the mean top velocity equals Uinf !! add defect velocity to make sure the j-averaged velocity at the top equals Uinf !    utop = Uinlo(ke) !    do k=kb,ke !        Uinlo(k) = Uinlo(k)*Uinf/utop !    end do ! Compute weight function (alpha=4, b=0.2) alpha = 4. beta = 0.2 wfuncf = 0.5 * ( 1. + tanh ( alpha * ( zoif - beta ) / (( 1. - 2. * beta ) * zoif + beta ) ) / tanh ( alpha ) ) ! for full level height wfunch = 0.5 * ( 1. + tanh ( alpha * ( zoih - beta ) / (( 1. - 2. * beta ) * zoih + beta ) ) / tanh ( alpha ) ) ! for half level height wfunct = 0.5 * ( 1. + tanh ( alpha * ( zoti - beta ) / (( 1. - 2. * beta ) * zoti + beta ) ) / tanh ( alpha ) ) ! for temperature (full level height) do k = kb , ke if ( wfuncf ( k ) . gt . 1. ) then wfuncf ( k ) = 1. end if if ( wfunct ( k ) . gt . 1. ) then wfunct ( k ) = 1. end if end do do k = kb , ke + 1 if ( wfunch ( k ) . gt . 1. ) then wfunch ( k ) = 1. end if end do !    write(6,*) 'maxval(wfuncf)=', maxval(wfuncf) !    write(6,*) 'maxval(wfunch)=', maxval(wfunch) ! Compute the velocity components for the inlet BC do k = kb , ke do j = jb , je !      u0inletbc(j,k) = (Uinli(k)+ upinli(j,k))*(1.-wfuncf(k)) +  (Uinlo(k) + upinlo(j,k))* wfuncf(k) !      v0inletbc(j,k) =            vpinli(j,k) *(1.-wfuncf(k)) +              vpinlo(j,k) * wfuncf(k) !      t0inletbc(j,k) = (Tinli(k)+ tpinli(j,k))*(1.-wfunct(k)) +  (Tinlo(k) + tpinlo(j,k))* wfunct(k) u0inletbc ( j , k ) = ( Uinli ( k ) + upinli ( j , k ) * heavif ( k )) * ( 1. - wfuncf ( k )) + ( Uinlo ( k ) + upinlo ( j , k ) * heavif ( k )) * wfuncf ( k ) v0inletbc ( j , k ) = vpinli ( j , k ) * heavif ( k ) * ( 1. - wfuncf ( k )) + vpinlo ( j , k ) * heavif ( k ) * wfuncf ( k ) t0inletbc ( j , k ) = ( Tinli ( k ) + tpinli ( j , k ) * heavit ( k )) * ( 1. - wfunct ( k )) + ( Tinlo ( k ) + tpinlo ( j , k ) * heavit ( k )) * wfunct ( k ) end do end do do k = kb , ke + 1 do j = jb , je w0inletbc ( j , k ) = ( Winli ( k ) + wpinli ( j , k ) * heavih ( k )) * ( 1 - wfunch ( k )) + ( Winlo ( k ) + wpinlo ( j , k ) * heavih ( k )) * wfunch ( k ) end do end do w0inletbc (:, kb ) = 0. w0inletbc (:, ke + 1 ) = 0. !!    kdamp = kb + floor(0.75*(ke-kb+1)) !    kdamp = kb + 144  ! => zf = 2.24 !    do k=kdamp,ke !    do j=jb,je !      if (u0inletbc(j,k) > Uinf) then !        u0inletbc(j,k) = Uinf !      end if !    end do !    end do ! Compute j-averaged inlet U  (used for compute thetai) uinletbc2 ( ib , jb : je , kb : ke ) = u0inletbc ( jb : je , kb : ke ) ! this is just a dummy variable to give uninletbc the right dimension in slabsum tinletbc2 ( ib , jb : je , kb : ke ) = t0inletbc ( jb : je , kb : ke ) ! this is just a dummy variable to give tninletbc the right dimension in slabsum urav = 0. trav = 0. call slabsum ( urav , kb , ke , uinletbc2 , ib , ib , jb , je , kb , ke , ib , ib , jb , je , kb , ke ) call slabsum ( trav , kb , ke , tinletbc2 , ib , ib , jb , je , kb , ke , ib , ib , jb , je , kb , ke ) !    call slabsum(urav  ,kb,ke,u0 ,ib-1,ie+1,jb-1,je+1,kb-1,ke+1,ib,ib,jb,je,kb,ke) urav = urav / jtot ! average over j-direction trav = trav / jtot ! average over j-direction ! determine bulk velocity of new profile do k = kb , ke uravdzf ( k ) = urav ( k ) * dzf ( k ) end do totalu = sum ( uravdzf ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) ! Area-averaged outflow velocity ! rescale the instantaneous profile to keep mass flux constant (tot avoid pressure fluctuations) if ( luvolflowr ) then do k = kb , ke uinldzf ( k ) = Uinl ( k ) * dzf ( k ) end do totaluinl = sum ( uinldzf ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) ! Area-averaged inflow velocity scalef = totaluinl / totalu ! compute factor to scale the velocity profile with u0inletbc (:,:) = u0inletbc (:,:) * scalef ! rescale the velocity profile to have constant mass-flux urav (:) = urav (:) * scalef ! also rescale the part that is added to the mean end if !! add defect velocity to make sure the mass flow is the same as the initial mass flow !   u0inletbc = u0inletbc + (ubulk-totalu) !   urav      = urav      + (ubulk-totalu) !! add defect velocity to make sure the j-averaged velocity at the top equals Uinf !    utop = urav(ke) !    do k=kb,ke !      do j=jb,je !        u0inletbc(j,k) = u0inletbc(j,k)*Uinf/utop !      end do !      urav(k) = urav(k)*Uinf/utop !    end do !    u0inletbc = u0inletbc + (Uinf-utop) !    urav      = urav      + (Uinf-utop) !    if (myid==0) then !    write(6,*) 'u0inletbc(jb+2,ke)', u0inletbc !    end if ! Compute j- and time-averaged  inlet U  (used for compute thetai) if (. not . lfixinlet ) then ! only update the average inlet profiles when lfixinlet .eqv..false. do k = kb , ke Uinl ( k ) = urav ( k ) * deltat * avinti + ( 1. - deltat * avinti ) * Uinl ( k ) end do end if do k = kb , ke Tinl ( k ) = trav ( k ) * deltat * avinti + ( 1. - deltat * avinti ) * Tinl ( k ) end do !    utop = Uinl(ke) !    Uinl = Uinl +(Uinf-utop)     ! make sure at the inlet the mean top velocity equals Uinf !    uminletbc = uminletbc + (Uinf-utop) ! write inletplane to array (and to file after 1000 time steps) if ( lstoreplane ) then storeu0inletbc (:,:, nstepread ) = u0inletbc (:,:) storev0inletbc (:,:, nstepread ) = v0inletbc (:,:) storew0inletbc (:,:, nstepread ) = w0inletbc (:,:) storet0inletbc (:,:, nstepread ) = t0inletbc (:,:) nstepread = nstepread + 1 if ( nstepread == nstore + 1 ) then nfile = nfile + 1 ! next file number call writeinletfile ! write 1000 time steps to file call writerestartfiles nstepread = 1 ! reset counter end if ! nstepread == 1001 end if ! lstoreplane if ( rk3step == 1 ) then uminletbc = u0inletbc vminletbc = v0inletbc wminletbc = w0inletbc tminletbc = t0inletbc end if if ( lbuoyancy ) then !     call blthicknessmo(di_test,utaui,lmoi) call blthicknesst ( di_test , Uinl , 0.99 ) !     call dispthicknessmo(displ)  ! needed in top BC call dispthicknessexp ( displ ) else !     call blthickness(di_test,utaui) call blthicknesst ( di_test , Uinl , 0.99 ) !     call dispthickness(displ)  ! needed in top BC call dispthicknessexp ( displ ) end if call blthicknesst ( dti_test , Tinl - thls , 0.99 ) if (( myid == 0 ) . and . ( rk3step == 3 )) then write ( 6 , * ) 'Inlet Gen: gamma,lambda=' , gamm , lamb write ( 6 , * ) 'Inlet Gen: Uinl(ke),Tinl(ke)=' , Uinl ( ke ), Tinl ( ke ) write ( 6 , * ) 'Inlet Gen: utaui,utaur =' , utaui , utaur write ( 6 , * ) 'Inlet Gen: ttaui,ttaur =' , ttaui , ttaur write ( 6 , * ) 'Inlet Gen: Lmoi,Lmor =' , lmoi , lmor write ( 6 , * ) 'Inlet Gen: deltar, deltai_test' , dr , di_test write ( 6 , * ) 'Inlet Gen: deltatr, deltati_test' , dtr , dti_test write ( 6 , * ) 'Inlet Gen: d*i, d*r=' , displ ( ib ), displ ( irecy ) write ( 6 , * ) 'Inlet Gen: thetai,thetar' , thetai , thetar write ( 6 , * ) 'Inlet Gen: thetati,thetatr' , thetati , thetatr if ( luvolflowr ) then write ( 6 , * ) 'Inlet Gen: mass flux correction factor = ' , scalef !       write(6,*) 'Inlet Gen: mass flux                   = ',totalreadu write ( 6 , * ) 'Inlet Gen: mass flux                   = ' , totaluinl end if end if elseif ( iinletgen == 2 ) then if ( myid == 0 ) then write ( 6 , * ) 'nstepread=' , nstepread end if u0inletbcold = u0inletbc v0inletbcold = v0inletbc w0inletbcold = w0inletbc t0inletbcold = t0inletbc ! determine time step interval in simulation rk3coef = dt / ( 4. - dble ( rk3step )) if ( rk3step == 1 ) then deltat = rk3coef elseif ( rk3step == 2 ) then deltat = rk3coef - ( dt / 3. ) elseif ( rk3step == 3 ) then deltat = rk3coef - ( dt / 2. ) end if ! determine time step interval in inlet data rk3coefin = dtin / ( 4. - dble ( rk3stepin )) if ( rk3stepin == 1 ) then dtinrk = rk3coefin elseif ( rk3stepin == 2 ) then dtinrk = rk3coefin - ( dtin / 3. ) elseif ( rk3stepin == 3 ) then dtinrk = rk3coefin - ( dtin / 2. ) end if interval = dtinrk - elapstep elapstep = elapstep + deltat if ( elapstep > dtinrk ) then ! use new value at next time step nstepread = nstepread + 1 elapstep = mod ( elapstep , dtinrk ) rk3stepin = mod ( rk3stepin , 3 ) + 1 rk3coefin = dtin / ( 4. - dble ( rk3stepin )) if ( rk3stepin == 1 ) then dtinrk = rk3coefin elseif ( rk3stepin == 2 ) then dtinrk = rk3coefin - ( dtin / 3. ) elseif ( rk3stepin == 3 ) then dtinrk = rk3coefin - ( dtin / 2. ) end if u0inletbc (:,:) = storeu0inletbc (:,:, nstepread ) v0inletbc (:,:) = storev0inletbc (:,:, nstepread ) w0inletbc (:,:) = storew0inletbc (:,:, nstepread ) t0inletbc (:,:) = storet0inletbc (:,:, nstepread ) if ( nstepread == nstore ) then nfile = nfile + 1 call readinletfile call writerestartfiles nstepread = 0 end if interval = dtinrk deltat = elapstep !        write(6,*) 'dtinrk,deltat=', dtinrk,deltat end if u0inletbc (:,:) = ( 1. - deltat / interval ) * u0inletbc (:,:) + ( deltat / interval ) * storeu0inletbc (:,:, nstepread + 1 ) v0inletbc (:,:) = ( 1. - deltat / interval ) * v0inletbc (:,:) + ( deltat / interval ) * storev0inletbc (:,:, nstepread + 1 ) w0inletbc (:,:) = ( 1. - deltat / interval ) * w0inletbc (:,:) + ( deltat / interval ) * storew0inletbc (:,:, nstepread + 1 ) t0inletbc (:,:) = ( 1. - deltat / interval ) * t0inletbc (:,:) + ( deltat / interval ) * storet0inletbc (:,:, nstepread + 1 ) !! massflow correction uinletbc2 ( ib , jb : je , kb : ke ) = u0inletbc ( jb : je , kb : ke ) ! this is just a dummy variable to give uninletbc the right dimension in slabsum urav = 0. call slabsum ( urav , kb , ke , uinletbc2 , ib , ib , jb , je , kb , ke , ib , ib , jb , je , kb , ke ) urav = urav / jtot ! average over j-direction ! determine bulk velocity of new (interpolated) profile do k = kb , ke uravdzf ( k ) = urav ( k ) * dzf ( k ) end do totalu = sum ( uravdzf ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) ! Area-averaged outflow velocity ! rescale the instantaneous profile to keep mass flux constant (tot avoid pressure fluctuations) scalef = totalreadu / totalu ! compute factor to scale the velocity profile with u0inletbc (:,:) = u0inletbc (:,:) * scalef ! rescale the velocity profile to have constant mass-flux !! end of massflow correction of interpolated streamwise velocity if ( rk3step == 1 ) then uminletbc = u0inletbc vminletbc = v0inletbc wminletbc = w0inletbc tminletbc = t0inletbc end if end if ! iinletgen end subroutine inletgen subroutine inletgennotemp use modglobal , only : ib , ie , jb , je , jb , jtot , kb , ke , zf , zh , dzf , dzhi , timee , btime , totavtime , rk3step , dt , numol , iplane , lles , iinletgen , inletav , runavtime , Uinf , lwallfunc , linletRA , totinletav , lstoreplane , nstore , lfixinlet , lfixutauin , luvolflowr use modfields , only : u0 , v0 , w0 , wm , uprof use modsave , only : writerestartfiles use modmpi , only : slabsum , myid implicit none real , dimension ( ib : ib , jb : je , kb : ke ) :: uinletbc2 ! dummy variable real , dimension ( jb : je , kb : ke ) :: uprec ! velocity fluctuation (up_rec = u0 - Urec) real , dimension ( jb : je , kb : ke ) :: vprec ! velocity fluctuation (vp_rec = v0 - 0) real , dimension ( jb : je , kb : ke + 1 ) :: wprec ! velocity fluctuation (wp_rec = w0 - Wrec) real , dimension ( jb : je , kb : ke ) :: upinli , vpinli ! = gamma * (uprec,v interpolated to zii grid) real , dimension ( jb : je , kb : ke ) :: upinlo , vpinlo ! = gamma * (uprec,v interpolated to zoi grid) real , dimension ( jb : je , kb : ke + 1 ) :: wpinli ! = gamma * (wprec   interpolated to zii grid) real , dimension ( jb : je , kb : ke + 1 ) :: wpinlo ! = gamma * (wprec   interpolated to zoi grid) real , dimension ( kb : ke ) :: udiff ! difference between Uinl and Urec !    real,dimension(kb:ke)   :: Urecdiff                ! difference between Urec new and old real , dimension ( kb : ke ) :: urav ! j-averaged u-velocity (not time-averaged) real , dimension ( kb : ke ) :: uravdzf ! j-averaged u-velocity (not time-averaged) times dzf real , dimension ( kb : ke ) :: uinldzf ! j-averaged u-velocity (not time-averaged) times dzf real , dimension ( kb : ke ) :: Urecdzf ! Urec times dzf real , dimension ( kb : ke + 1 ) :: wrav ! j-averaged w-velocity (not time-averaged) real , dimension ( kb : ke ) :: Uinli ! = gamma * (Urec interpolated to ziif grid points) real , dimension ( kb : ke + 1 ) :: Winli ! = gamma * (Wrec interpolated to ziih grid points) real , dimension ( kb : ke ) :: Uinlo ! = gamma * (Urec interpolated to zioif grid points) real , dimension ( kb : ke + 1 ) :: Winlo ! = gamma * (Wrec interpolated to zoih grid points) real , dimension ( kb : ke ) :: wfuncf ! weight function at full level real , dimension ( kb : ke + 1 ) :: wfunch ! weight function at half level real :: utaur2 , utaui2 ! (utau)&#94;2 at recycle station and inlet real :: gamm ! utaui / utaur real :: avint , avinti ! avering interval real :: alpha , beta ! factors used in the Weight function !    real                    :: totalu                  ! total u-velocity at outlet real :: Urectot ! total u-velocity at recycle plane real :: rk3coef !    real                    :: di_test                 ! BL thickness as measured from Uinl real :: utop ! j-averaged top velocity real :: interval real :: dtinrk ! RK time step in inlet data real :: rk3coefin ! Cumulative RK time step in inlet data real :: dr_old real :: scalef ! scale factor to scale instantaneous velocity profile with to get constant mass flux real :: totaluinl ! bulk velocity at the inlet integer i , j , k , kk if ( iinletgen == 1 ) then u0inletbcold = u0inletbc v0inletbcold = v0inletbc w0inletbcold = w0inletbc totaluold = totalu displold = displ ddispdxold = ddispdx ! compute time-average velocities rk3coef = dt / ( 4. - dble ( rk3step )) if ( rk3step == 1 ) then deltat = rk3coef elseif ( rk3step == 2 ) then deltat = rk3coef - ( dt / 3. ) elseif ( rk3step == 3 ) then deltat = rk3coef - ( dt / 2. ) end if if ( linletRA ) then ! this is a switch to use 'running average' avint = totinletav + timee - btime ! runav interval = averaging interval previuous sim  + current elapsed sim time else avint = inletav end if avinti = 1. / avint uaver = 0. do i = ib , ie call slabsum ( uaver ( i ,:), kb , ke , u0 ( i : i , jb : je , kb : ke ), i , i , jb , je , kb , ke , i , i , jb , je , kb , ke ) end do wrav = 0. call slabsum ( wrav ( kb : ke + 1 ), kb , ke , w0 ( irecy - 1 : irecy - 1 , jb : je , kb : ke + 1 ), irecy - 1 , irecy - 1 , jb , je , kb , ke + 1 , irecy - 1 , irecy - 1 , jb , je , kb , ke + 1 ) uaver = uaver / jtot ! average over j-direction urav = uaver ( irecy ,:) wrav = wrav / jtot ! average over j-direction do k = kb , ke Urec ( k ) = urav ( k ) * deltat * avinti + ( 1. - deltat * avinti ) * Urec ( k ) end do do k = kb , ke + 1 Wrec ( k ) = wrav ( k ) * deltat * avinti + ( 1. - deltat * avinti ) * Wrec ( k ) end do do k = kb , ke do i = ib , ie Utav ( i , k ) = uaver ( i , k ) * deltat * avinti + ( 1. - deltat * avinti ) * Utav ( i , k ) end do end do ! compute velocity fluctuation at recycle station do k = kb , ke do j = jb , je uprec ( j , k ) = u0 ( irecy , j , k ) - Urec ( k ) vprec ( j , k ) = v0 ( irecy - 1 , j , k ) ! mean v is zero end do end do do k = kb , ke + 1 do j = jb , je wprec ( j , k ) = w0 ( irecy - 1 , j , k ) - Wrec ( k ) ! note that w-velocity is taken at i=irecy-1 !! end do end do if ( lwallfunc ) then call wallawinlet ( Urec ( kb ), dzf ( kb ), numol , utaur2 ) ! compute wall shear stress at recycle station else utaur2 = 2. * numol * Urec ( kb ) / dzf ( kb ) end if utaur = sqrt ( abs ( utaur2 )) ! compute utau at recycle station ! compute momentum thickness at inlet and recycle plane dr_old = dr !   call blthickness(dr,utaur)                     ! also needed for thetar call blthicknesst ( dr , Urec , 0.99 ) !   call momentumthickness(thetai,utaui,di)        ! di is kept fixed call momentumthicknessexp ( thetai , Uinl ) !   call momentumthickness(thetar,utaur,dr) call momentumthicknessexp ( thetar , Urec ) !   call blthickness(dr,utaur) if (. not . lfixutauin ) then utaui = utaur * abs ( thetar / thetai ) ** ( 1. / 8. ) ! See Lund (1998): 'Similar to Ludwig-Tillmann correlation' end if gamm = utaui / utaur ! Gamma in Lund (1998) ! compute inner scaling coordinates zirf = utaur * zf / numol ! inner scaling zf-coordinate at recycle station zirh = utaur * zh / numol ! inner scaling zh-coordinate at recycle station ziif = utaui * zf / numol ! inner scaling zf-coordinate at inlet station ziih = utaui * zh / numol ! inner scaling zh-coordinate at inlet station ! compute outer scaling coordinates zorf = zf / dr ! outer scaling zf-coor as measured from Uinldinate at recycle station zorh = zh / dr ! outer scaling zh-coordinate at recycle station zoif = zf / di ! outer scaling zf-coordinate at inlet station  (could be done once, actually..) zoih = zh / di ! outer scaling zf-coordinate at inlet station  (could be done once, actually..) !!!!! Interpolation starts here !!! First inner coordinates ! determine which elements are needed when recycle velocity profile is interpolated on inlet plane ! for u(,v)-components (zf) do k = kb , ke do kk = kb , ke if ( zirf ( kk ) >= ziif ( k )) then locupif ( k ) = kk loclowif ( k ) = kk - 1 exit elseif ( kk == ke ) then locupif ( k ) = ke + 1 ! this means extrapolation! loclowif ( k ) = ke - 1 ! waarom niet ke? of wordt dit niet gebruikt? end if end do end do ! for w-components (zh) do k = kb , ke + 1 do kk = kb , ke + 1 if ( zirh ( kk ) >= ziih ( k )) then locupih ( k ) = kk loclowih ( k ) = kk - 1 exit elseif ( kk == ke + 1 ) then locupih ( k ) = ke + 2 ! this means extrapolation! loclowih ( k ) = ke end if end do end do !!! Finished with inner coordinates !!! Do the same trick for outer coordinates ! determine which elements are needed when recycle velocity profile is interpolated on inlet plane ! for u(,v)-components (zf) do k = kb , ke do kk = kb , ke if ( zorf ( kk ) >= zoif ( k )) then locupof ( k ) = kk loclowof ( k ) = kk - 1 exit elseif ( kk == ke ) then locupof ( k ) = ke + 1 ! this means extrapolation! loclowof ( k ) = ke - 1 end if end do end do ! for w-components (zh) do k = kb , ke + 1 do kk = kb , ke + 1 if ( zorh ( kk ) >= zoih ( k )) then locupoh ( k ) = kk loclowoh ( k ) = kk - 1 exit elseif ( kk == ke + 1 ) then locupoh ( k ) = ke + 2 ! this means extrapolation! loclowoh ( k ) = ke end if end do end do !!! Finished with outer coordinates !!! Now really interpolate !!! First inner coordinates ! compute Urec on zii grid do k = kb , ke if ( locupif ( k ) == ke + 1 ) then ! indicator for extrapolation! !        Uinli(k) = Urec(ke) + (Urec(ke) - Urec(ke-1)) / (zirf(ke)-zirf(ke-1)) * (ziif(k)-zirf(ke)) Uinli ( k ) = Urec ( ke ) elseif ( loclowif ( k ) == kb - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) Uinli ( k ) = Urec ( kb ) / zirf ( kb ) * ziif ( k ) else ! normal interpolation Uinli ( k ) = Urec ( loclowif ( k )) + ( Urec ( locupif ( k )) - Urec ( loclowif ( k ))) / ( zirf ( locupif ( k )) - zirf ( loclowif ( k ))) * ( ziif ( k ) - zirf ( loclowif ( k ))) if (( ziif ( k ) . gt . zirf ( locupif ( k ))) . or . ( ziif ( k ) . lt . zirf ( loclowif ( k )))) then write ( 6 , * ) '!!!Mistake in Interpolation !!!!' end if end if end do ! compute Wrec on zii grid Winli ( kb ) = 0.0 ! corresponds to ground level do k = kb + 1 , ke + 1 if ( locupih ( k ) == ke + 2 ) then ! indicator for extrapolation! !        Winli(k) = Wrec(ke+1) + (Wrec(ke+1) - Wrec(ke)) / (zirh(ke+1)-zirh(ke)) * (ziih(k)-zirh(ke+1)) Winli ( k ) = Wrec ( ke + 1 ) else ! normal interpolation Winli ( k ) = Wrec ( loclowih ( k )) + ( Wrec ( locupih ( k )) - Wrec ( loclowih ( k ))) / ( zirh ( locupih ( k )) - zirh ( loclowih ( k ))) * ( ziih ( k ) - zirh ( loclowih ( k ))) end if end do ! compute u- and v- and t-fluctuation on zii grid do k = kb , ke if ( locupif ( k ) == ke + 1 ) then ! indicator for extrapolation! !        upinli(:,k) = uprec(:,ke) + (uprec(:,ke) - uprec(:,ke-1)) / (zirf(ke)-zirf(ke-1)) * (ziif(k)-zirf(ke)) upinli (:, k ) = 0. vpinli (:, k ) = 0. elseif ( loclowif ( k ) == kb - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) upinli (:, k ) = uprec (:, kb ) / zirf ( kb ) * ziif ( k ) vpinli (:, k ) = vprec (:, kb ) / zirf ( kb ) * ziif ( k ) else ! normal interpolation upinli (:, k ) = uprec (:, loclowif ( k )) + ( uprec (:, locupif ( k )) - uprec (:, loclowif ( k ))) / ( zirf ( locupif ( k )) - zirf ( loclowif ( k ))) * ( ziif ( k ) - zirf ( loclowif ( k ))) vpinli (:, k ) = vprec (:, loclowif ( k )) + ( vprec (:, locupif ( k )) - vprec (:, loclowif ( k ))) / ( zirf ( locupif ( k )) - zirf ( loclowif ( k ))) * ( ziif ( k ) - zirf ( loclowif ( k ))) end if end do ! compute w-fluctuation on zii grid do k = kb + 1 , ke + 1 !      if (locupih(k) == ke+1) then      ! indicator for extrapolation! if ( locupih ( k ) == ke + 2 ) then ! indicator for extrapolation! !        wpinli(:,k) = wprec(:,ke+1) + (wprec(:,ke+1) - wprec(:,ke)) / (zirh(ke+1)-zirh(ke)) * (ziih(k)-zirh(ke+1)) wpinli (:, k ) = 0. else ! normal interpolation wpinli (:, k ) = wprec (:, loclowih ( k )) + ( wprec (:, locupih ( k )) - wprec (:, loclowih ( k ))) / ( zirh ( locupih ( k )) - zirh ( loclowih ( k ))) * ( ziih ( k ) - zirh ( loclowih ( k ))) end if end do !! Finished with interpolating inner variables !! Continue with interpolating outer variables ! compute Urec on zoi grid do k = kb , ke if ( locupof ( k ) == ke + 1 ) then ! indicator for extrapolation! !        Uinlo(k) = Urec(ke) + (Urec(ke) - Urec(ke-1)) / (zorf(ke)-zorf(ke-1)) * (zoif(k)-zorf(ke)) !        Uinlo(k) = Urec(ke) Uinlo ( k ) = Uinf elseif ( loclowof ( k ) == kb - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) Uinlo ( k ) = Urec ( kb ) / zorf ( kb ) * zoif ( k ) else ! normal interpolation Uinlo ( k ) = Urec ( loclowof ( k )) + ( Urec ( locupof ( k )) - Urec ( loclowof ( k ))) / ( zorf ( locupof ( k )) - zorf ( loclowof ( k ))) * ( zoif ( k ) - zorf ( loclowof ( k ))) end if end do ! compute Wrec on zii grid Winlo ( kb ) = 0.0 ! corresponds to ground level do k = kb + 1 , ke + 1 if ( locupoh ( k ) == ke + 2 ) then ! indicator for extrapolation! !        Winlo(k) = Wrec(ke+1) + (Wrec(ke+1) - Wrec(ke)) / (zorh(ke+1)-zorh(ke)) * (zoih(k)-zorh(ke+1)) Winlo ( k ) = Wrec ( ke + 1 ) else ! normal interpolation Winlo ( k ) = Wrec ( loclowoh ( k )) + ( Wrec ( locupoh ( k )) - Wrec ( loclowoh ( k ))) / ( zorh ( locupoh ( k )) - zorh ( loclowoh ( k ))) * ( zoih ( k ) - zorh ( loclowoh ( k ))) end if end do ! compute u- and v-fluctuation on zoi grid do k = kb , ke if ( locupof ( k ) == ke + 1 ) then ! indicator for extrapolation! !        upinlo(:,k) = uprec(:,ke) + (uprec(:,ke) - uprec(:,ke-1)) / (zorf(ke)-zorf(ke-1)) * (zoif(k)-zorf(ke)) upinlo (:, k ) = 0. vpinlo (:, k ) = 0. elseif ( loclowof ( k ) == kb - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) upinlo (:, k ) = uprec (:, kb ) / zorf ( kb ) * zoif ( k ) vpinlo (:, k ) = vprec (:, kb ) / zorf ( kb ) * zoif ( k ) else ! normal interpolation upinlo (:, k ) = uprec (:, loclowof ( k )) + ( uprec (:, locupof ( k )) - uprec (:, loclowof ( k ))) / ( zorf ( locupof ( k )) - zorf ( loclowof ( k ))) * ( zoif ( k ) - zorf ( loclowof ( k ))) vpinlo (:, k ) = vprec (:, loclowof ( k )) + ( vprec (:, locupof ( k )) - vprec (:, loclowof ( k ))) / ( zorf ( locupof ( k )) - zorf ( loclowof ( k ))) * ( zoif ( k ) - zorf ( loclowof ( k ))) end if end do ! compute w-fluctuation on zoi grid do k = kb + 1 , ke + 1 if ( locupoh ( k ) == ke + 2 ) then ! indicator for extrapolation! !        wpinlo(:,k) = wprec(:,ke+1) + (wprec(:,ke+1) - wprec(:,ke)) / (zorh(ke+1)-zorh(ke)) * (zoih(k)-zorh(ke+1)) wpinlo (:, k ) = 0. else ! normal interpolation wpinlo (:, k ) = wprec (:, loclowoh ( k )) + ( wprec (:, locupoh ( k )) - wprec (:, loclowoh ( k ))) / ( zorh ( locupoh ( k )) - zorh ( loclowoh ( k ))) * ( zoih ( k ) - zorh ( loclowoh ( k ))) end if end do !! Finished interpolating outer velocity variables !!!!! Finished Interpolation! !!!!! ! compute rescaled inner variables ! Winli = Winli (interpolation is enough) Uinli = gamm * Uinli upinli = gamm * upinli vpinli = gamm * vpinli wpinli = gamm * wpinli ! compute rescaled outer variables ! Winlo = Winlo (interpolation is enough) Uinlo = gamm * Uinlo + ( 1. - gamm ) * Uinf !    Uinlo = gamm* Uinlo  + (1.- gamm)*Urec(ke) upinlo = gamm * upinlo vpinlo = gamm * vpinlo wpinlo = gamm * wpinlo ! Compute weight function (alpha=4, b=0.2) alpha = 4. beta = 0.2 wfuncf = 0.5 * ( 1. + tanh ( alpha * ( zoif - beta ) / (( 1. - 2. * beta ) * zoif + beta ) ) / tanh ( alpha ) ) ! for full level height wfunch = 0.5 * ( 1. + tanh ( alpha * ( zoih - beta ) / (( 1. - 2. * beta ) * zoih + beta ) ) / tanh ( alpha ) ) ! for half level height do k = kb , ke if ( wfuncf ( k ) . gt . 1. ) then wfuncf ( k ) = 1. end if end do do k = kb , ke + 1 if ( wfunch ( k ) . gt . 1. ) then wfunch ( k ) = 1. end if end do ! Compute the velocity components for the inlet BC do k = kb , ke do j = jb , je u0inletbc ( j , k ) = ( Uinli ( k ) + upinli ( j , k )) * ( 1. - wfuncf ( k )) + ( Uinlo ( k ) + upinlo ( j , k )) * wfuncf ( k ) v0inletbc ( j , k ) = vpinli ( j , k ) * ( 1. - wfuncf ( k )) + vpinlo ( j , k ) * wfuncf ( k ) end do end do do k = kb , ke + 1 do j = jb , je w0inletbc ( j , k ) = ( Winli ( k ) + wpinli ( j , k )) * ( 1 - wfunch ( k )) + ( Winlo ( k ) + wpinlo ( j , k )) * wfunch ( k ) end do end do w0inletbc (:, kb ) = 0. w0inletbc (:, ke + 1 ) = 0. ! Compute j-averaged inlet U  (used for compute thetai) uinletbc2 ( ib , jb : je , kb : ke ) = u0inletbc ( jb : je , kb : ke ) ! this is just a dummy variable to give uninletbc the right dimension in slabsum urav = 0. call slabsum ( urav , kb , ke , uinletbc2 , ib , ib , jb , je , kb , ke , ib , ib , jb , je , kb , ke ) urav = urav / jtot ! average over j-direction ! determine bulk velocity of new profile do k = kb , ke uravdzf ( k ) = urav ( k ) * dzf ( k ) end do totalu = sum ( uravdzf ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) ! Area-averaged outflow velocity ! correct instantaneous inflow velocity for constant mass-flux if ( luvolflowr ) then do k = kb , ke uinldzf ( k ) = Uinl ( k ) * dzf ( k ) end do totaluinl = sum ( uinldzf ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) ! Area-averaged inflow velocity that should be kept scalef = totaluinl / totalu ! compute factor to scale the velocity profile with u0inletbc (:,:) = u0inletbc (:,:) * scalef ! rescale the velocity profile to have constant mass-flux urav (:) = urav (:) * scalef ! also rescale the part that is added to the mean end if ! Compute j- and time-averaged  inlet U  (used for compute thetai) if (. not . lfixinlet ) then ! only update the average inlet profiles when lfixinlet .eqv..false. do k = kb , ke Uinl ( k ) = urav ( k ) * deltat * avinti + ( 1. - deltat * avinti ) * Uinl ( k ) end do end if ! write inletplane to array (and to file after 1000 time steps) if ( lstoreplane ) then storeu0inletbc (:,:, nstepread ) = u0inletbc (:,:) storev0inletbc (:,:, nstepread ) = v0inletbc (:,:) storew0inletbc (:,:, nstepread ) = w0inletbc (:,:) nstepread = nstepread + 1 if ( nstepread == nstore + 1 ) then nfile = nfile + 1 ! next file number call writeinletfile ! write 1000 time steps to file call writerestartfiles nstepread = 1 ! reset counter end if ! nstepread == 1001 end if ! lstoreplane if ( rk3step == 1 ) then uminletbc = u0inletbc vminletbc = v0inletbc wminletbc = w0inletbc end if !   call blthickness(di_test,utaui) call blthicknesst ( di_test , Uinl , 0.99 ) !   call dispthickness(displ)  ! needed in top BC call dispthicknessexp ( displ ) ! needed in top BC if (( myid == 0 ) . and . ( rk3step == 3 )) then write ( 6 , * ) 'Inlet Gen: gamma=' , gamm write ( 6 , * ) 'Inlet Gen: Uinl(ke)=' , Uinl ( ke ) write ( 6 , * ) 'Inlet Gen: utaui,utaur =' , utaui , utaur write ( 6 , * ) 'Inlet Gen: deltar, deltai_test' , dr , di_test write ( 6 , * ) 'Inlet Gen: d*i, d*r=' , displ ( ib ), displ ( irecy ) write ( 6 , * ) 'Inlet Gen: thetai,thetar' , thetai , thetar if ( luvolflowr ) then write ( 6 , * ) 'Inlet Gen: mass flux correction factor = ' , scalef !       write(6,*) 'Inlet Gen: mass flux                   = ',totalreadu write ( 6 , * ) 'Inlet Gen: mass flux                   = ' , totaluinl end if end if elseif ( iinletgen == 2 ) then if ( myid == 0 ) then write ( 6 , * ) 'nstepread=' , nstepread end if u0inletbcold = u0inletbc v0inletbcold = v0inletbc w0inletbcold = w0inletbc ! determine time step interval in simulation rk3coef = dt / ( 4. - dble ( rk3step )) if ( rk3step == 1 ) then deltat = rk3coef elseif ( rk3step == 2 ) then deltat = rk3coef - ( dt / 3. ) elseif ( rk3step == 3 ) then deltat = rk3coef - ( dt / 2. ) end if ! determine time step interval in inlet data rk3coefin = dtin / ( 4. - dble ( rk3stepin )) if ( rk3stepin == 1 ) then dtinrk = rk3coefin elseif ( rk3stepin == 2 ) then dtinrk = rk3coefin - ( dtin / 3. ) elseif ( rk3stepin == 3 ) then dtinrk = rk3coefin - ( dtin / 2. ) end if interval = dtinrk - elapstep elapstep = elapstep + deltat if ( elapstep > dtinrk ) then ! use new value at next time step nstepread = nstepread + 1 elapstep = mod ( elapstep , dtinrk ) rk3stepin = mod ( rk3stepin , 3 ) + 1 rk3coefin = dtin / ( 4. - dble ( rk3stepin )) if ( rk3stepin == 1 ) then dtinrk = rk3coefin elseif ( rk3stepin == 2 ) then dtinrk = rk3coefin - ( dtin / 3. ) elseif ( rk3stepin == 3 ) then dtinrk = rk3coefin - ( dtin / 2. ) end if u0inletbc (:,:) = storeu0inletbc (:,:, nstepread ) v0inletbc (:,:) = storev0inletbc (:,:, nstepread ) w0inletbc (:,:) = storew0inletbc (:,:, nstepread ) if ( nstepread == nstore ) then nfile = nfile + 1 call readinletfile call writerestartfiles nstepread = 0 end if interval = dtinrk deltat = elapstep !        write(6,*) 'dtinrk,deltat=', dtinrk,deltat end if u0inletbc (:,:) = ( 1. - deltat / interval ) * u0inletbc (:,:) + ( deltat / interval ) * storeu0inletbc (:,:, nstepread + 1 ) v0inletbc (:,:) = ( 1. - deltat / interval ) * v0inletbc (:,:) + ( deltat / interval ) * storev0inletbc (:,:, nstepread + 1 ) w0inletbc (:,:) = ( 1. - deltat / interval ) * w0inletbc (:,:) + ( deltat / interval ) * storew0inletbc (:,:, nstepread + 1 ) !! massflow correction uinletbc2 ( ib , jb : je , kb : ke ) = u0inletbc ( jb : je , kb : ke ) ! this is just a dummy variable to give uninletbc the right dimension in slabsum urav = 0. call slabsum ( urav , kb , ke , uinletbc2 , ib , ib , jb , je , kb , ke , ib , ib , jb , je , kb , ke ) urav = urav / jtot ! average over j-direction ! determine bulk velocity of new (interpolated) profile do k = kb , ke uravdzf ( k ) = urav ( k ) * dzf ( k ) end do totalu = sum ( uravdzf ( kb : ke )) / ( zh ( ke + 1 ) - zh ( kb )) ! Area-averaged outflow velocity ! rescale the instantaneous profile to keep mass flux constant (tot avoid pressure fluctuations) scalef = totalreadu / totalu ! compute factor to scale the velocity profile with u0inletbc (:,:) = u0inletbc (:,:) * scalef ! rescale the velocity profile to have constant mass-flux !! end of massflow correction of interpolated streamwise velocity if ( rk3step == 1 ) then uminletbc = u0inletbc vminletbc = v0inletbc wminletbc = w0inletbc end if end if ! iinletgen end subroutine inletgennotemp subroutine momentumthicknessexp ( output , uinput ) use modglobal , only : jb , kb , ke , dzf !,Uinf use modinletdata , only : ubulk use modmpi , only : myid implicit none real , dimension ( kb : ke ), intent ( in ) :: uinput !< input velocity real , intent ( out ) :: output !< momentum thickness real , dimension ( kb : ke ) :: mthick !       real    :: umax integer :: k !      write(6,*) 'uinletbc(jb,ke),Uinl(ke)=', uinletbc(jb,ke),uinput(ke) !       umax = maxval(uinput) do k = kb , ke mthick ( k ) = (( uinput ( k ) / uinput ( ke )) - ( uinput ( k ) ** 2. / uinput ( ke ) ** 2. ) ) * dzf ( k ) !         mthick(k) = ((uinput(k)/umax) - (uinput(k)**2. / umax**2.) )*dzf(k) end do output = sum ( mthick ) ! momentum thickness end subroutine momentumthicknessexp subroutine momentumthickness ( output , ustar , blth ) use modglobal , only : pi , Uinf !    use modinletdata, only : ubulk !   use modmpi, only    : myid implicit none real , intent ( in ) :: ustar ! friction velocity real , intent ( in ) :: blth ! boundary layer thickness real , intent ( out ) :: output ! momentum thickness real :: B = 5.0 ! Wake parameter real :: C = 0.5 ! Coles parameter real :: kappa = 0.41 ! Von k�r�n constant real :: lam ! = Uinf/ustar lam = Uinf / ustar output = (( 1. + C ) / ( kappa * lam ) - ( 1. / (( kappa ** 2 ) * ( lam ** 2 ))) * ( 2. + 2. * C * ( 1.852 / pi + 1. ) + ( 3. / 2. ) * ( C ** 2 ))) * blth end subroutine momentumthickness subroutine momentumthicknessmo ( output , ustar , blth , lmo ) use modglobal , only : pi , Uinf !    use modinletdata, only : ubulk !   use modmpi, only    : myid implicit none real , intent ( in ) :: ustar ! friction velocity real , intent ( in ) :: lmo ! Obukhov length real , intent ( in ) :: blth ! boundary layer thickness real , intent ( out ) :: output ! momentum thickness real :: B = 5.0 ! Wake parameter real :: C = 0.5 ! Coles parameter real :: kappa = 0.41 ! Von k�r�n constant real :: cmo = 0.702 ! constant in MO theory (0.135*5.2) real :: lam ! = Uinf/ustar lam = Uinf / ustar output = ( 1. + C + 0.5 * cmo * blth / lmo ) / ( kappa * lam ) - ( 1. / (( kappa ** 2 ) * ( lam ** 2 ))) * ( 2. + 2. * C * ( 1.852 / pi + 1. ) + ( 3. / 2. ) * ( C ** 2 ) + ( blth - 0.25 ) * 2. * cmo / lmo + ( 1. + 4. / pi ) * blth * C * cmo / lmo + ( 1. / 6. ) * (( cmo / lmo ) ** 2 ) * ( blth ** 2 ) ) * blth end subroutine momentumthicknessmo subroutine enthalpythickness ( output , tinput , uinput ) use modglobal , only : jb , kb , ke , dzf !,Uinf use modinletdata , only : ubulk use modsurfdata , only : thls use modmpi , only : myid implicit none real , dimension ( kb : ke ), intent ( in ) :: tinput !< input temperature real , dimension ( kb : ke ), intent ( in ) :: uinput !< input velocity real , intent ( out ) :: output !< momentum thickness real , dimension ( kb : ke ) :: ethick real thlsdummy integer :: k thlsdummy = thls if ( tinput ( ke ) == thls ) then thlsdummy = thls - 0.000001 end if do k = kb , ke !         ethick(k) = (uinput(k)/uinput(ke)) * ((tinput(k) - tinput(ke)) /(thls - tinput(ke)) )*dzf(k) ethick ( k ) = ( uinput ( k ) / uinput ( ke )) * (( tinput ( k ) - tinput ( ke )) / ( thlsdummy - tinput ( ke )) ) * dzf ( k ) end do output = sum ( ethick ) ! enthalpy thickness if ( output == 0. ) then output = 0.000001 end if end subroutine enthalpythickness subroutine dispthicknessexp ( output ) ! output is an array of length (ib:ie)) containing displacement thickness values use modglobal , only : ib , ie , kb , ke , dzf , xf !,Uinf implicit none real , dimension ( ib : ie ), intent ( out ) :: output !< dispacement thickness real , dimension ( kb : ke ) :: dthick !       real    :: umax real :: dispm real :: disp2m real :: xfdispm integer :: i , k ! write(6,*) 'Uinl(ke)=', uinput(ke) do i = ib , ie !       umax = maxval(Utav(i,:)) do k = kb , ke dthick ( k ) = ( 1. - Utav ( i , k ) / Utav ( i , ke )) * dzf ( k ) ! time-averaged, j-averaged velocity !         dthick(k) = (1.- Utav(i,k)/ umax) *dzf(k)       ! time-averaged, j-averaged velocity end do output ( i ) = sum ( dthick ) ! displacement thickness end do dispm = sum ( output ( ib : ie )) / ( ie - ib + 1 ) ! mean(displacement) disp2m = sum ( output ( ib : ie ) ** 2. ) / ( ie - ib + 1 ) ! mean(displacement&#94;2) xfdispm = sum ( xf ( ib : ie ) * output ( ib : ie )) / ( ie - ib + 1 ) ! mean(xf*displ) ddispdx = ( xfdispm - ( xfm * dispm )) / ( xf2m - xfm ** 2. ) ! this is d/dx(delta*) !       ddispdx = 0.    ! for the test !       dinl    = dispm - ddispdx*xfm                         ! this is the starting value (delta* = dinl + d/dx(delta)*x) end subroutine dispthicknessexp subroutine dispthickness ( output ) ! output is an array of length (ib:ie)) containing displacement thickness values use modglobal , only : ib , ie , kb , ke , dzf , xf , Uinf , numol implicit none real , dimension ( ib : ie ), intent ( out ) :: output !< dispacement thickness !       real, dimension(kb:ke)                    :: dthick real :: dispm real :: disp2m real :: xfdispm real :: ustar , blth real :: B = 5.0 ! Wake parameter real :: C = 0.5 ! Coles parameter real :: kappa = 0.41 ! Von k�r�n constant real :: lam ! = Uinf/ustar integer :: i do i = ib , ie ustar = sqrt ( abs ( 2 * numol * Utav ( i , kb ) / dzf ( kb ))) ! average streamwise friction lam = Uinf / ustar blth = ( lam * numol / Uinf ) * exp ( kappa * ( lam - B ) - 2. * C ) ! See App. Lund et al. output ( i ) = (( 1. + C ) / ( kappa * lam ) ) * blth end do dispm = sum ( output ( ib : ie )) / ( ie - ib + 1 ) ! mean(displacement) disp2m = sum ( output ( ib : ie ) ** 2. ) / ( ie - ib + 1 ) ! mean(displacement&#94;2) xfdispm = sum ( xf ( ib : ie ) * output ( ib : ie )) / ( ie - ib + 1 ) ! mean(xf*displ) ddispdx = ( xfdispm - ( xfm * dispm )) / ( xf2m - xfm ** 2. ) ! this is d/dx(delta*) end subroutine dispthickness subroutine dispthicknessmo ( output ) ! output is an array of length (ib:ie)) containing displacement thickness values use modglobal , only : ib , ie , kb , ke , dzf , xf , Uinf , numol , grav , prandtlmoli use modsurfdata , only : thls implicit none real , dimension ( ib : ie ), intent ( out ) :: output !< dispacement thickness !       real, dimension(kb:ke)                    :: dthick real :: dispm real :: disp2m real :: xfdispm real :: ustar , tstar , blth real :: B = 5.0 ! Wake parameter real :: C = 0.5 ! Coles parameter real :: kappa = 0.41 ! Von k�rm�n constant real :: cmo = 0.702 ! constant in MO theory (0.135*5.2) real :: lam ! = Uinf/ustar real :: func , dfunc , utaunu , lmo integer :: i , n blth = di ! initial value do i = ib , ie ustar = sqrt ( abs ( 2. * numol * Utav ( i , kb ) / dzf ( kb ))) ! average streamwise friction at x-location tstar = numol * prandtlmoli * 2. * ( Ttav ( i , kb ) - thls ) / ( dzf ( kb ) * ustar ) ! average shear temp. at x-location lmo = ( thls * ustar ** 2 ) / ( kappa * grav * tstar ) ! obukhov length at this x-location if (( lmo >= 1000 0. ) . or . ( lmo <= 0.01 )) then lmo = 100 0. end if !         lmo = 0.3  !! TEMPORARY utaunu = ustar / numol lam = Uinf / ustar do n = 1 , 10 ! Newton Raphson method to find BL height !           write(6,*) 'blth,ustar,tstar,Lmo =',blth,ustar,tstar,lmo func = log ( blth ) + ( cmo * blth / lmo ) + log ( utaunu ) - kappa * ( lam - B ) + 2. * C !           func   = log(blth) + log(utaunu) - kappa*(lam-B) +2.*C dfunc = 1. / blth + cmo / lmo blth = blth - ( func / dfunc ) if ( blth <= 0. ) then blth = di end if end do output ( i ) = (( 1. + C + 0.5 * cmo * blth / lmo ) / ( kappa * lam ) ) * blth end do dispm = sum ( output ( ib : ie )) / ( ie - ib + 1 ) ! mean(displacement) disp2m = sum ( output ( ib : ie ) ** 2. ) / ( ie - ib + 1 ) ! mean(displacement&#94;2) xfdispm = sum ( xf ( ib : ie ) * output ( ib : ie )) / ( ie - ib + 1 ) ! mean(xf*displ) ddispdx = ( xfdispm - ( xfm * dispm )) / ( xf2m - xfm ** 2. ) ! this is d/dx(delta*) end subroutine dispthicknessmo ! thermal boundary layer thickness subroutine blthicknesst ( output , uinput , criterion ) use modglobal , only : kb , ke , zh , zf implicit none real , dimension ( kb : ke ), intent ( in ) :: uinput !< input velocity real , intent ( in ) :: criterion !< criterion for BL thickness computation (e.g. 0.95 or 0.99) real , intent ( out ) :: output !< BL thickness based on input criterion !       real, dimension(kb:ke)             :: mthick real :: ucrit !       real                               :: umax integer :: k !     umax = maxval(uinput) ucrit = uinput ( ke ) * criterion ! Velocity at which BL-thickness is reached !     ucrit = umax*criterion  ! Velocity at which BL-thickness is reached do k = kb , ke if ( uinput ( k ) . GT . criterion * uinput ( ke )) then if ( k == kb ) then output = zh ( kb ) + ( zf ( k ) - zh ( k )) / uinput ( k ) * ucrit ! interpolate z to BL-height exit else output = zf ( k - 1 ) + ( zf ( k ) - zf ( k - 1 )) / ( uinput ( k ) - uinput ( k - 1 )) * ( ucrit - uinput ( k - 1 )) !  interpolate z to BL-height exit end if else if ( k == ke ) then output = zf ( ke ) ! maximum BL thickness end if end do end subroutine blthicknesst !  subroutine blthickness(output,uinput,criterion) ! !    use modglobal, only : kb,ke,zh,zf !    implicit none ! !       real, dimension(kb:ke), intent(in) :: uinput     !< input velocity !       real, intent(in)                   :: criterion  !< criterion for BL thickness computation (e.g. 0.95 or 0.99) !       real, intent(out)                  :: output     !< BL thickness based on input criterion !!       real, dimension(kb:ke)             :: mthick !       real                               :: ucrit !!       real                               :: umax !       integer :: k ! !!     umax = maxval(uinput) !     ucrit = uinput(ke)*criterion  ! Velocity at which BL-thickness is reached !!     ucrit = umax*criterion  ! Velocity at which BL-thickness is reached !     do k=kb,ke !       if (uinput(k) .GT. criterion*uinput(ke)) then !         if (k==kb) then !           output = zh(kb)+ (zf(k)-zh(k))/uinput(k)*ucrit ! interpolate z to BL-height !           exit !         else !           output = zf(k-1) + (zf(k)-zf(k-1))/(uinput(k)-uinput(k-1))*(ucrit-uinput(k-1)) ! interpolate z to BL-height !           exit !         end if !       else if (k==ke) then !         output = zf(ke)      ! maximum BL thickness !       end if !     end do !   end subroutine blthickness subroutine blthickness ( output , ustar ) use modglobal , only : numol , Uinf implicit none real , intent ( in ) :: ustar ! friction velocity real , intent ( out ) :: output !< BL thickness based on law of the wake !       real, dimension(kb:ke)             :: mthick !       real                               :: ucrit !       real                               :: umax !       integer :: k real :: B = 5.0 ! Wake parameter real :: C = 0.5 ! Coles parameter real :: kappa = 0.41 ! Von k�r�n constant real :: lam ! = Uinf/ustar lam = Uinf / ustar output = ( lam * numol / Uinf ) * exp ( kappa * ( lam - B ) - 2. * C ) ! See App. Lund et al. end subroutine blthickness subroutine blthicknessmo ( output , ustar , lmo ) ! This routine compute the BL thicknes for a buoyancy affected boundary layer: ! Newton-Raphson method is used use modglobal , only : numol , Uinf implicit none real , intent ( in ) :: ustar ! friction velocity real , intent ( in ) :: lmo ! Obukhov length real , intent ( inout ) :: output !< BL thickness based on law of the wake !       real, dimension(kb:ke)             :: mthick !       real                               :: ucrit !       real                               :: umax !       integer :: k real :: B = 5.0 ! Wake parameter real :: C = 0.5 ! Coles parameter real :: kappa = 0.41 ! Von k�r�n constant real :: cmo = 0.702 ! Constant in MO theory (0.135*5.2) real :: lam ! = Uinf/ustar real :: func , dfunc , utaunu integer :: n utaunu = ustar / numol lam = Uinf / ustar !       write(6,*) 'Initial delta, Lmo =', output,lmo do n = 1 , 10 func = log ( output ) + ( cmo * output / lmo ) + log ( utaunu ) - kappa * ( lam - B ) + 2. * C !         func   = log(output) + log(utaunu) - kappa*(lam-B) +2.*C dfunc = 1. / output + cmo / lmo output = output - ( func / dfunc ) if ( output <= 0. ) then output = di end if end do !       write(6,*) 'Computed delta, Lmo =', output,lmo end subroutine blthicknessmo subroutine wallawinlet ( utan , dx , visc , tau ) ! this should be the same as wallaw in modboundary!!! This routine is just ! copied to avoid circular dependencies implicit none real , intent ( in ) :: utan , dx , visc real , intent ( out ) :: tau real const1 , const2 , const3 , const4 real tausub , taupow real sub , dutan , utankr , utanabs real aaa , bbb real dxi parameter ( aaa = 8.3 ) parameter ( bbb = 0.1428571429 ) dxi = 1. / dx const1 = 0.5 * ( 1. - bbb ) * aaa ** (( 1. + bbb ) / ( 1. - bbb )) const2 = ( 1. + bbb ) / aaa const3 = aaa ** ( 2. / ( 1. - bbb )) const4 = 2. / ( 1. + bbb ) utanabs = abs ( utan ) utankr = 0.5 * visc * dxi * const3 dutan = utankr - utanabs sub = max ( sign ( 1. , dutan ), 0. ) tausub = 2. * visc * utanabs * dxi !      taupow3   =   const1 * (visc * dxi)**(1.+bbb) + (const2 * (visc * !      dxi)**bbb) * utanabs taupow = ( const1 * ( visc * dxi ) ** ( 1. + bbb ) + ( const2 * ( visc * dxi ) ** bbb ) * utanabs ) ** const4 !      if (taupow3<=0) then !        write(6,*) 'taupow3 <=0!!!' !      end if tau = sub * tausub + ( 1. - sub ) * taupow tau = sign ( tau , utan ) ! give tau the same sign as utan return end subroutine wallawinlet subroutine writeinletfile use modglobal , only : jb , je , kb , ke , cexpnr , ifoutput , nstore , ltempeq use modmpi , only : cmyid , myid !    use modinletdata, only : storeu0inletbc,storev0inletbc,storew0inletbc,nfile implicit none integer fileid integer j , k , n character ( 24 ) name name = 'inlet/inlet_    k   .' write ( name ( 13 : 16 ) , '(i4.4)' ) nfile name ( 18 : 20 ) = cmyid name ( 22 : 24 ) = cexpnr write ( 6 , * ) 'Writing Inlet velocity: ' , name open ( ifoutput , file = name , form = 'unformatted' , position = 'append' ) write ( ifoutput ) ((( storeu0inletbc ( j , k , n ), j = jb , je ), k = kb , ke ), n = 1 , nstore ) write ( ifoutput ) ((( storev0inletbc ( j , k , n ), j = jb , je ), k = kb , ke ), n = 1 , nstore ) write ( ifoutput ) ((( storew0inletbc ( j , k , n ), j = jb , je ), k = kb , ke + 1 ), n = 1 , nstore ) close ( ifoutput ) if ( ltempeq ) then name = 'inlet/itemp_    k   .' write ( name ( 13 : 16 ) , '(i4.4)' ) nfile name ( 18 : 20 ) = cmyid name ( 22 : 24 ) = cexpnr write ( 6 , * ) 'Writing Inlet temperature: ' , name open ( ifoutput , file = name , form = 'unformatted' , position = 'append' ) write ( ifoutput ) ((( storet0inletbc ( j , k , n ), j = jb , je ), k = kb , ke ), n = 1 , nstore ) close ( ifoutput ) end if end subroutine writeinletfile subroutine readinletfile use modglobal , only : ib , jb , je , jmax , kb , ke , cexpnr , ifinput , nstore , ltempeq , ntrun , zh , jtot , jh use modmpi , only : cmyid , myid , nprocs , slabsum , excjs !    use modinletdata, only : storeu0inletbc,storev0inletbc,storew0inletbc,nfile implicit none real , dimension ( ib : ib , jb : jb + inlfactor * jmax - 1 , kbin : kein ) :: udummy real , dimension ( kbin : kein ) :: uread real , dimension ( kbin : kein ) :: ureaddzfin real , dimension ( jb : jb + jtotin - 1 , kbin : kein , 1 : nstore ) :: storeu0inold real , dimension ( jb : jb + jtotin - 1 , kbin : kein , 1 : nstore ) :: storev0inold real , dimension ( jb : jb + jtotin - 1 , kbin : kein + 1 , 1 : nstore ) :: storew0inold real , dimension ( jb : jb + jtotin - 1 , kbin : kein , 1 : nstore ) :: storet0inold real , dimension ( jb : jb + jtotdum - 1 , kbin : kein , 1 : nstore ) :: storeu0indum real , dimension ( jb : jb + jtotdum - 1 , kbin : kein , 1 : nstore ) :: storev0indum real , dimension ( jb : jb + jtotdum - 1 , kbin : kein + 1 , 1 : nstore ) :: storew0indum real , dimension ( jb : jb + jtotdum - 1 , kbin : kein , 1 : nstore ) :: storet0indum real , dimension ( jb : je , kbin : kein , 1 : nstore ) :: storeu0innew real , dimension ( jb : je , kbin : kein , 1 : nstore ) :: storev0innew real , dimension ( jb : je , kbin : kein + 1 , 1 : nstore ) :: storew0innew real , dimension ( jb : je , kbin : kein , 1 : nstore ) :: storet0innew integer filen , filee integer fileid integer j , k , n , js , jf , jfdum , jsdum character ( 24 ) name filen = - 5 ! should be checked carefully if in use ever jfdum = jbdum - 1 ! initial value do fileid = filenumstart , filenumstart + ( filestoread - 1 ) if ( filen == - 1 ) then filen = nprocsinl - 1 ! -1 means the last proc (periodic) else filen = fileid - floor ( real ( fileid ) / real ( nprocsinl )) * nprocsinl ! loop over proc's end if write ( 6 , * ) '!!!!! filen = ' , filen name = 'inlet/inlet_    k   .' write ( name ( 13 : 16 ) , '(i4.4)' ) nfile write ( name ( 18 : 20 ) , '(i3.3)' ) filen name ( 22 : 24 ) = cexpnr write ( 6 , * ) 'Reading Inlet velocity: ' , name open ( unit = ifinput , file = name , form = 'unformatted' ) read ( ifinput ) ((( storeu0inold ( j , k , n ), j = jbin , jein ), k = kbin , kein ), n = 1 , nstore ) read ( ifinput ) ((( storev0inold ( j , k , n ), j = jbin , jein ), k = kbin , kein ), n = 1 , nstore ) read ( ifinput ) ((( storew0inold ( j , k , n ), j = jbin , jein ), k = kbin , kein + 1 ), n = 1 , nstore ) close ( ifinput ) if ( ltempeq ) then name = 'inlet/itemp_    k   .' write ( name ( 13 : 16 ) , '(i4.4)' ) nfile write ( name ( 18 : 20 ) , '(i3.3)' ) filen name ( 22 : 24 ) = cexpnr write ( 6 , * ) 'Reading Inlet temperature: ' , name open ( unit = ifinput , file = name , form = 'unformatted' ) read ( ifinput ) ((( storet0inold ( j , k , n ), j = jbin , jein ), k = kbin , kein ), n = 1 , nstore ) close ( ifinput ) end if ! determine start and end indices if ( filen == procinlo ) then js = jbeg else js = jbin end if if ( filen == procinup ) then jf = jend else jf = jein end if jsdum = jfdum + 1 jfdum = jsdum + ( jf - js ) !        if (jsdum >= 3) write(6,*) 'myid, jsdum = ',myid, jsdum !        if (jfdum >= 3) write(6,*) 'myid, jfdum = ',myid, jfdum !!! put values from original in dummy variable storeu0indum ( jsdum : jfdum ,:,:) = storeu0inold ( js : jf ,:,:) ! s: start  f: final storev0indum ( jsdum : jfdum ,:,:) = storev0inold ( js : jf ,:,:) ! s: start  f: final storew0indum ( jsdum : jfdum ,:,:) = storew0inold ( js : jf ,:,:) ! s: start  f: final if ( ltempeq ) then storet0indum ( jsdum : jfdum ,:,:) = storet0inold ( js : jf ,:,:) ! s: start  f: final end if end do ! loop over original inlet files ! now interpolate in y call yinterpolate ( storeu0indum , storeu0innew , kbin , kein ) call yinterpolate ( storev0indum , storev0innew , kbin , kein ) call yinterpolate ( storew0indum , storew0innew , kbin , kein + 1 ) call yinterpolate ( storet0indum , storet0innew , kbin , kein ) if (. not . lzinzsim ) then ! interpolate when zin =/ zsim call zinterpolate ( storeu0innew (:,:,:), storeu0inletbc ) ! interpolate inlet profile to zgrid call zinterpolate ( storev0innew (:,:,:), storev0inletbc ) ! interpolate inlet profile to zgrid call zinterpolatew ( storew0innew (:,:,:), storew0inletbc ) ! interpolate inlet profile to zgrid if ( ltempeq ) then call zinterpolatet ( storet0innew (:,:,:), storet0inletbc ) ! interpolate inlet profile to zgrid end if else storeu0inletbc (:,:,:) = storeu0inold (:,:,:) storev0inletbc (:,:,:) = storev0inold (:,:,:) storew0inletbc (:,:,:) = storew0inold (:,:,:) if ( ltempeq ) then storet0inletbc (:,:,:) = storet0inold (:,:,:) end if end if if ( iangle /= 0.0 ) then ! modify for inflow angle do n = 1 , nstore do k = kb , ke do j = jb , je u0rot ( n , j , k ) = storeu0inletbc ( j , k , n ) ! swap indices in order v0rot ( n , j , k ) = storev0inletbc ( j , k , n ) ! to use excjs end do end do end do call excjs ( u0rot , 1 , nstore , jb , je , kb , ke , 0 , jh ) call excjs ( v0rot , 1 , nstore , jb , je , kb , ke , 0 , jh ) !         write(6,*) 'v0rot(1,je+1,30) = ',v0rot(1,je+1,30) do n = 1 , nstore do k = kb , ke do j = jb , je ! apply horizontal rotation (neglecting the delta_x difference) storeu0inletbc ( j , k , n ) = u0rot ( n , j , k ) * cos ( iangle ) - 0.5 * sin ( iangle ) * ( v0rot ( n , j , k ) + v0rot ( n , j + 1 , k )) storev0inletbc ( j , k , n ) = v0rot ( n , j , k ) * cos ( iangle ) + 0.5 * sin ( iangle ) * ( u0rot ( n , j , k ) + u0rot ( n , j - 1 , k )) end do end do end do end if ! iangle =/0.0 end subroutine readinletfile subroutine zinterpolate ( input , output ) use modglobal , only : jb , je , kb , ke , zf , nstore implicit none real , dimension ( jb : je , kbin : kein , 1 : nstore ), intent ( in ) :: input real , dimension ( jb : je , kb : ke , 1 : nstore ), intent ( inout ) :: output integer k do k = kb , ke if ( linuf ( k ) == kein + 1 ) then ! indicator for extrapolation! output (:, k ,:) = input (:, kein ,:) elseif ( linlf ( k ) == kbin - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) output (:, k ,:) = input (:, kbin ,:) / zfin ( kbin ) * zf ( k ) !        output(:,k,:) = input(:,kbin,:)   ! temeperature is not zero at the wall, so line above is wrong else ! normal interpolation output (:, k ,:) = input (:, linlf ( k ),:) + ( input (:, linuf ( k ),:) - input (:, linlf ( k ),:)) / ( zfin ( linuf ( k )) - zfin ( linlf ( k ))) * ( zf ( k ) - zfin ( linlf ( k ))) if (( zf ( k ) . gt . zfin ( linuf ( k ))) . or . ( zf ( k ) . lt . zfin ( linlf ( k )))) then write ( 6 , * ) '!!!Mistake in zinterpolate !!!!' end if end if end do end subroutine zinterpolate subroutine zinterpolate1d ( input , output ) use modglobal , only : kb , ke , zf implicit none real , dimension ( kbin : kein ), intent ( in ) :: input real , dimension ( kb : ke ), intent ( inout ) :: output integer k do k = kb , ke if ( linuf ( k ) == kein + 1 ) then ! indicator for extrapolation! output ( k ) = input ( kein ) elseif ( linlf ( k ) == kbin - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) output ( k ) = input ( kbin ) / zfin ( kbin ) * zf ( k ) !        output(:,k,:) = input(:,kbin,:)   ! temeperature is not zero at the wall, so line above is wrong else ! normal interpolation output ( k ) = input ( linlf ( k )) + ( input ( linuf ( k )) - input ( linlf ( k ))) / ( zfin ( linuf ( k )) - zfin ( linlf ( k ))) * ( zf ( k ) - zf ( linlf ( k ))) if (( zf ( k ) . gt . zfin ( linuf ( k ))) . or . ( zf ( k ) . lt . zfin ( linlf ( k )))) then write ( 6 , * ) '!!!Mistake in zinterpolate1d !!!!' end if end if end do end subroutine zinterpolate1d subroutine zinterpolate2d ( input , output ) use modglobal , only : ib , ie , kb , ke , zf , nstore implicit none real , dimension ( ib : ie , kbin : kein ), intent ( in ) :: input real , dimension ( ib : ie , kb : ke ), intent ( inout ) :: output integer k do k = kb , ke if ( linuf ( k ) == kein + 1 ) then ! indicator for extrapolation! output (:, k ) = input (:, kein ) elseif ( linlf ( k ) == kbin - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) output (:, k ) = input (:, kbin ) / zfin ( kbin ) * zf ( k ) !        output(:,k,:) = input(:,kbin,:)   ! temeperature is not zero at the wall, so line above is wrong else ! normal interpolation output (:, k ) = input (:, linlf ( k )) + ( input (:, linuf ( k )) - input (:, linlf ( k ))) / ( zfin ( linuf ( k )) - zfin ( linlf ( k ))) * ( zf ( k ) - zf ( linlf ( k ))) if (( zf ( k ) . gt . zfin ( linuf ( k ))) . or . ( zf ( k ) . lt . zfin ( linlf ( k )))) then write ( 6 , * ) '!!!Mistake in zinterpolate2d !!!!' end if end if end do end subroutine zinterpolate2d subroutine zinterpolatew ( input , output ) use modglobal , only : jb , je , kb , ke , zh , nstore implicit none real , dimension ( jb : je , kbin : kein + 1 , 1 : nstore ), intent ( in ) :: input real , dimension ( jb : je , kb : ke + 1 , 1 : nstore ), intent ( inout ) :: output integer k do k = kb , ke + 1 if ( linuh ( k ) == kein + 2 ) then ! indicator for extrapolation! output (:, k ,:) = input (:, kein + 1 ,:) elseif ( linlh ( k ) == kbin - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) output (:, k ,:) = input (:, kbin ,:) ! =0 !        output(:,k,:) = input(:,kbin,:)/zhin(kbin) * zh(k) !        output(:,k,:) = input(:,kbin,:)   ! temeperature is not zero at the wall, so line above is wrong else ! normal interpolation output (:, k ,:) = input (:, linlh ( k ),:) + ( input (:, linuh ( k ),:) - input (:, linlh ( k ),:)) / ( zhin ( linuh ( k )) - zhin ( linlh ( k ))) * ( zh ( k ) - zhin ( linlh ( k ))) if (( zh ( k ) . gt . zhin ( linuh ( k ))) . or . ( zh ( k ) . lt . zhin ( linlh ( k )))) then write ( 6 , * ) '!!!Mistake in zinterpolatew !!!!' end if end if end do end subroutine zinterpolatew subroutine zinterpolatew1d ( input , output ) use modglobal , only : kb , ke , zh implicit none real , dimension ( kbin : kein + 1 ), intent ( in ) :: input real , dimension ( kb : ke + 1 ), intent ( inout ) :: output integer k do k = kb , ke + 1 if ( linuh ( k ) == kein + 2 ) then ! indicator for extrapolation! output ( k ) = input ( kein + 1 ) elseif ( linlh ( k ) == kbin - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) output ( k ) = input ( kbin ) !=0 !        output(k) = input(kbin)/zhin(kbin) * zh(k) !        output(:,k,:) = input(:,kbin,:)   ! temeperature is not zero at the wall, so line above is wrong else ! normal interpolation output ( k ) = input ( linlh ( k )) + ( input ( linuh ( k )) - input ( linlh ( k ))) / ( zhin ( linuh ( k )) - zhin ( linlh ( k ))) * ( zh ( k ) - zh ( linlh ( k ))) if (( zh ( k ) . gt . zhin ( linuh ( k ))) . or . ( zh ( k ) . lt . zhin ( linlh ( k )))) then write ( 6 , * ) '!!!Mistake in zinterpolatew1d !!!!' end if end if end do end subroutine zinterpolatew1d subroutine zinterpolatet ( input , output ) use modglobal , only : jb , je , kb , ke , zf , nstore use modsurfdata , only : thls implicit none real , dimension ( jb : je , kbin : kein , 1 : nstore ), intent ( in ) :: input real , dimension ( jb : je , kb : ke , 1 : nstore ), intent ( inout ) :: output integer k do k = kb , ke if ( linuf ( k ) == kein + 1 ) then ! indicator for extrapolation! output (:, k ,:) = input (:, kein ,:) elseif ( linlf ( k ) == kbin - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) output (:, k ,:) = thls + ( input (:, kb ,:) - thls ) / zfin ( kbin ) * zf ( k ) !         output(:,k,:) = (input(:,kb,:)-thls)/zfin(kbin)*zf(k) !        output(:,k,:) = input(:,kbin,:)/zfin(kbin) * zf(k) !        output(:,k,:) = input(:,kbin,:)   ! temeperature is not zero at the wall, so line above is wrong else ! normal interpolation output (:, k ,:) = input (:, linlf ( k ),:) + ( input (:, linuf ( k ),:) - input (:, linlf ( k ),:)) / ( zfin ( linuf ( k )) - zfin ( linlf ( k ))) * ( zf ( k ) - zfin ( linlf ( k ))) if (( zf ( k ) . gt . zfin ( linuf ( k ))) . or . ( zf ( k ) . lt . zfin ( linlf ( k )))) then write ( 6 , * ) '!!!Mistake in zinterpolatet !!!!' end if end if end do end subroutine zinterpolatet subroutine zinterpolatet1d ( input , output ) use modglobal , only : jb , je , kb , ke , zf , nstore use modsurfdata , only : thls implicit none real , dimension ( kbin : kein ), intent ( in ) :: input real , dimension ( kb : ke ), intent ( inout ) :: output integer k do k = kb , ke if ( linuf ( k ) == kein + 1 ) then ! indicator for extrapolation! output ( k ) = input ( kein ) elseif ( linlf ( k ) == kbin - 1 ) then ! interprets this as extrapolation to bottom (use u=0 at z+=0) output ( k ) = ( input ( kb ) - thls ) / zfin ( kbin ) * zf ( k ) !        output(:,k,:) = input(:,kbin,:)/zfin(kbin) * zf(k) !        output(:,k,:) = input(:,kbin,:)   ! temeperature is not zero at the wall, so line above is wrong else ! normal interpolation output ( k ) = input ( linlf ( k )) + ( input ( linuf ( k )) - input ( linlf ( k ))) / ( zfin ( linuf ( k )) - zfin ( linlf ( k ))) * ( zf ( k ) - zf ( linlf ( k ))) if (( zf ( k ) . gt . zfin ( linuf ( k ))) . or . ( zf ( k ) . lt . zfin ( linlf ( k )))) then write ( 6 , * ) '!!!Mistake in zinterpolatet1d !!!!' end if end if end do end subroutine zinterpolatet1d subroutine yinterpolate ( input , output , ks , kf ) use modglobal , only : jb , je , nstore integer , intent ( in ) :: ks integer , intent ( in ) :: kf real , dimension ( jbdum : jedum , ks : kf , 1 : nstore ), intent ( in ) :: input real , dimension ( jb : je , ks : kf , 1 : nstore ), intent ( inout ) :: output integer j do j = jb , je !      if (np==0 .and. yloclowf(j)==) output ( j ,:,:) = input ( yloclowf ( j ),:,:) + ( input ( ylocupf ( j ),:,:) - input ( yloclowf ( j ),:,:)) / ( yfdum ( ylocupf ( j )) - yfdum ( yloclowf ( j ))) * ( yf ( j ) - yfdum ( yloclowf ( j ))) end do end subroutine yinterpolate subroutine yinterpolateh ( input , output , ks , kf ) use modglobal , only : jb , je , nstore integer , intent ( in ) :: ks integer , intent ( in ) :: kf real , dimension ( jbdum : jedum , ks : kf , 1 : nstore ), intent ( in ) :: input real , dimension ( jb : je , ks : kf , 1 : nstore ), intent ( inout ) :: output integer j , jj do j = jb , je !      if (np==0 .and. yloclowf(j)==) output ( j ,:,:) = input ( yloclowh ( j ),:,:) + ( input ( ylocuph ( j ),:,:) - input ( yloclowh ( j ),:,:)) / ( yhdum ( ylocuph ( j )) - yhdum ( yloclowh ( j ))) * ( yh ( j ) - yhdum ( yloclowh ( j ))) end do end subroutine yinterpolateh subroutine readzincoord use modglobal , only : kb , ke , kh , ifinput , zf , zh , ylen , jb , je , dy use modmpi , only : myid , mpi_integer , comm3d , mpierr , my_real , nprocs implicit none character ( 72 ) chmess character ( 20 ) namezinlet character ( 20 ) namezinfo integer ierr , k , kk , kmaxin , j , jj real ysizeproc namelist / INFO / nprocsinl , jgtotinl , kmaxin , dtin , wtop , totalreadu namezinlet = 'zgrid.inl' namezinfo = 'zgrid.inf' if ( myid == 0 ) then open ( ifinput , file = namezinfo , status = 'old' , iostat = ierr ) if ( ierr /= 0 ) then write ( 0 , * ) 'ERROR: zgrid.inf does not exist' stop 1 end if read ( ifinput , INFO , iostat = ierr ) if ( ierr > 0 ) then write ( 0 , * ) 'Problem in zgrid.inf INFO' write ( 0 , * ) 'iostat error: ' , ierr stop 1 endif write ( 6 , INFO ) close ( ifinput ) end if kbin = 0 kein = kmaxin - 1 call MPI_BCAST ( nprocsinl , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( jgtotinl , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( kbin , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( kein , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) call MPI_BCAST ( dtin , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( wtop , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( totalreadu , 1 , MY_REAL , 0 , comm3d , mpierr ) allocate ( zhin ( kbin : kein + 1 )) allocate ( zfin ( kbin : kein + 1 )) allocate ( dzfin ( kbin - 1 : kein + 1 )) allocate ( dzhin ( kbin : kein + 1 )) if ( myid == 0 ) then write ( 6 , * ) 'loading ' , namezinlet open ( ifinput , file = namezinlet ) read ( ifinput , '(a72)' ) chmess read ( ifinput , '(a72)' ) chmess do k = kbin , kein read ( ifinput , * ) zfin ( k ) end do close ( ifinput ) zhin ( kbin ) = 0.0 do k = kbin , kein zhin ( k + 1 ) = zhin ( k ) + 2.0 * ( zfin ( k ) - zhin ( k )) end do zfin ( kein + kh ) = zfin ( kein ) + 2.0 * ( zhin ( kein + kh ) - zfin ( kein )) do k = kbin , kein dzfin ( k ) = zhin ( k + 1 ) - zhin ( k ) end do dzfin ( kein + 1 ) = dzfin ( kein ) dzfin ( kbin - 1 ) = dzfin ( kbin ) dzhin ( kbin ) = 2 * zfin ( kbin ) do k = kbin + 1 , kein + kh dzhin ( k ) = zfin ( k ) - zfin ( k - 1 ) end do ! check if the inlet mesh and the simulation mesh differ do k = kb , min ( ke , kein ) if ( abs ( zfin ( k ) - zf ( k )) > 1e-7 ) then lzinzsim = . false . end if enddo end if ! myid==0 ! MPI broadcast kmax elements from zf call MPI_BCAST ( zfin , kein - kbin + 2 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( zhin , kein - kbin + 2 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( dzfin , kein - kbin + 3 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( dzhin , kein - kbin + 2 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( lzinzsim , 1 , MPI_INTEGER , 0 , comm3d , mpierr ) if (. not . lzinzsim ) then if ( myid == 0 ) then write ( 6 , * ) 'zgrid.inl does not equal zgrid.inp: Inlet will be interpolated in z' end if !      allocate(linlf(kbin:kein)) !      allocate(linuf(kbin:kein)) !      allocate(linlh(kbin:kein+1)) !      allocate(linuh(kbin:kein+1)) allocate ( linlf ( kb : ke )) allocate ( linuf ( kb : ke )) allocate ( linlh ( kb : ke + 1 )) allocate ( linuh ( kb : ke + 1 )) ! zf do k = kb , ke do kk = kbin , kein if ( zfin ( kk ) >= zf ( k )) then linuf ( k ) = kk linlf ( k ) = kk - 1 exit elseif ( kk == kein ) then linuf ( k ) = kein + 1 ! this means extrapolation! linlf ( k ) = kein - 1 ! waarom niet ke? of wordt dit niet gebruikt? end if end do end do ! for w-components (zh) do k = kb , ke + 1 do kk = kbin , kein + 1 if ( zhin ( kk ) >= zh ( k )) then linuh ( k ) = kk linlh ( k ) = kk - 1 exit elseif ( kk == kein + 1 ) then linuh ( k ) = kein + 2 ! this means extrapolation! linlh ( k ) = kein end if end do end do else ! lzinzsim  -> grids are equal if ( myid == 0 ) then write ( 6 , * ) 'zgrid.inl equals zgrid.inp: Inlet will not be interpolated in z' end if end if ! Now prepare everything for interpolation in y-direction jgbin = 1 jgein = jgbin + jgtotinl - 1 jtotin = jgtotinl / nprocsinl jbin = 1 jein = 1 + jtotin - 1 ysizeproc = ylen / nprocs dyin = ylen / jgtotinl jbdum = 1 jtotdum = ceiling ( ysizeproc / real ( dyin )) + 1 ! dummy indices jedum = jbdum + jtotdum - 1 !     allocate(yf   (jb    :je)) allocate ( yf ( jb : je + 1 )) allocate ( yh ( jb : je + 1 )) allocate ( yfin ( jgbin : jgein + 1 )) allocate ( yhin ( jgbin - 1 : jgein + 1 )) !     allocate(yfdum(jbdum :jedum)) allocate ( yfdum ( jbdum : jedum + 1 )) allocate ( yhdum ( jbdum : jedum + 1 )) allocate ( yloclowf ( jb : je + 1 )) allocate ( ylocupf ( jb : je + 1 )) allocate ( yloclowh ( jb : je + 1 )) allocate ( ylocuph ( jb : je + 1 )) ! make global y-grid (equidistant) for inlet data do j = jgbin - 1 , jgein + 1 yhin ( j ) = ( j - jgbin ) * dyin end do do j = jgbin , jgein + 1 yfin ( j ) = yhin ( j ) + 0.5 * dyin end do ! make new y-grid (equidistant) do j = jb , je + 1 yh ( j ) = myid * ( ylen / nprocs ) + ( j - jb ) * dy yf ( j ) = yh ( j ) + 0.5 * dy end do ! check which original cells are needed for interpolation do j = jgein + 1 , jgbin , - 1 if ( yhin ( j ) <= yh ( jb )) then if ( yfin ( j ) <= yf ( jb )) then procinlo = floor ( real ( j - jgbin ) / real ( jtotin )) ! this is the first cell to consider filenumstart = procinlo jgbeg = j jbeg = j - ( procinlo * jtotin ) !            jend = jbeg+jtotdum-1 jj = j + jtotdum - 1 !            procinup = floor((j-jgbin)/real(jtotin)) !            procinup = floor((j-jgbin+1)/real(jtotin)) procinup = floor ( real ( jj - jgbin ) / real ( jtotin )) filenumend = procinup jend = jj - ( procinup * jtotin ) procinup = procinup - floor ( real ( procinup ) / real ( nprocsinl )) * nprocsinl ! continue on first procinl again else if ( j == jgbin ) then jgbeg = j - 1 jbeg = jein procinlo = nprocsinl - 1 filenumstart = - 1 jj = j + jtotdum - 2 procinup = floor ( real ( jj - jgbin ) / real ( jtotin )) filenumend = procinup jend = jj - ( procinup * jtotin ) procinup = procinup - floor ( real ( procinup ) / real ( nprocsinl )) * nprocsinl !continue on first procinl again else procinlo = floor ( real ( j - jgbin - 1 ) / real ( jtotin )) ! One cell lower is needed filenumstart = procinlo jgbeg = j - 1 jbeg = j - ( procinlo * jtotin ) - 1 jj = j + jtotdum - 2 procinup = floor ( real ( jj - jgbin ) / real ( jtotin )) filenumend = procinup jend = jj - ( procinup * jtotin ) procinup = procinup - floor ( real ( procinup ) / real ( nprocsinl )) * nprocsinl ! continue on first procinl again end if ! j=jgbin end if exit end if end do write ( 6 , * ) '!! myid,procinlo,jbeg,procinup,jend,jgbeg = ' , myid , procinlo , jbeg , procinup , jend , jgbeg ! make dummy y-grid (equidistant) do j = jbdum , jedum + 1 yhdum ( j ) = yhin ( jgbeg ) + ( j - jbdum + 1 ) * dyin yfdum ( j ) = yhdum ( j ) + 0.5 * dyin end do !      if (procoldup /= procoldlo) then !        write(6,*) '!!! Start-cell and end-cell are not in the same file!!!' !      end if filestoread = filenumend - filenumstart + 1 ! no. of files to be read !      write(6,*) '!! procinlo,procinup = ',procinlo,procinup !      write(6,*) '!! jbin,jein,jbeg,jend= ',jbin,jein,jbeg,jend ! for components defined on yf do j = jb , je do jj = jbdum + 1 , jedum + 1 if ( yfdum ( jj ) >= yf ( j )) then ylocupf ( j ) = jj yloclowf ( j ) = jj - 1 exit end if end do end do ! for components defined on yh do j = jb , je + 1 do jj = jbdum + 1 , jedum + 1 if ( yhdum ( jj ) >= yh ( j )) then ylocuph ( j ) = jj yloclowh ( j ) = jj - 1 exit end if end do end do end subroutine readzincoord subroutine exitinlet use modglobal , only : iinletgen , lstoreplane , ltempeq if ( iinletgen == 1 ) then deallocate ( Uinl , Winl , Urec , Wrec , u0inletbc , v0inletbc , w0inletbc , zirf , ziif , ziih , zirh , zorf , zoif , zorh , zoih , loclowif , locupif , loclowih , locupih , loclowof , locupof , loclowoh , locupoh , uminletbc , vminletbc , wminletbc , u0inletbcold , v0inletbcold , w0inletbcold , Utav , upupavinl , vpvpavinl , wpwpavinl , upwpavinl , thlpthlpavinl , thlpupavinl , thlpwpavinl ) if ( ltempeq ) then deallocate ( t0inletbc , tminletbc , t0inletbcold , loclowot , locupot , zotr , zoti , Tinl , Trec ) end if if ( lstoreplane ) then deallocate ( storeu0inletbc , storev0inletbc , storew0inletbc ) if ( ltempeq ) then deallocate ( storet0inletbc ) end if end if else if ( iinletgen == 2 ) then deallocate ( storeu0inletbc , storev0inletbc , storew0inletbc , u0inletbc , v0inletbc , w0inletbc , uminletbc , vminletbc , wminletbc , u0inletbcold , v0inletbcold , w0inletbcold ) if ( ltempeq ) then deallocate ( t0inletbc , tminletbc , t0inletbcold , storet0inletbc ) end if end if end subroutine exitinlet end module","tags":"","url":"sourcefile/modinlet.f90.html"},{"title":"heatpump.f90 – uDALES","text":"This file depends on sourcefile~~heatpump.f90~~EfferentGraph sourcefile~heatpump.f90 heatpump.f90 sourcefile~modfields.f90 modfields.f90 sourcefile~heatpump.f90->sourcefile~modfields.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~heatpump.f90->sourcefile~modglobal.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~heatpump.f90->sourcefile~modmpi.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~heatpump.f90~~AfferentGraph sourcefile~heatpump.f90 heatpump.f90 sourcefile~program.f90 program.f90 sourcefile~program.f90->sourcefile~heatpump.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module modheatpump use mpi implicit none private public :: init_heatpump , heatpump , exit_heatpump save integer , allocatable :: idhppts_global (:,:) ! Global heat pump points array (indices with respect to cell centered coordinates) logical , allocatable :: lhpptsrank (:) ! Logical array indicating if heat pump points are on this rank real :: thl_dot_hp ! Rate of change of temperature due to heat loss from the heat pump in [Km&#94;3/s] real :: w_hp_exhaust ! Exhaust velocity at heat pump points in [m/s] contains subroutine init_heatpump use modglobal , only : lheatpump , nhppoints , Q_dot_hp , QH_dot_hp , rhoa , cp , ifinput , cexpnr , ltempeq , dxi , dyi use modmpi , only : myid , comm3d , mpierr use decomp_2d , only : zstart , zend implicit none integer :: n character ( 80 ) :: chmess if (. not .( lheatpump ) . or . . not .( ltempeq ) . or . ( nhppoints < 1 )) return allocate ( idhppts_global ( nhppoints , 3 )) ! Allocate global heat pump points array allocate ( lhpptsrank ( nhppoints )) ! Allocate logical array for heat pump points on this rank ! read global heat pump points if ( myid == 0 ) then open ( ifinput , file = 'heatpump.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess read ( ifinput , '(a80)' ) chmess do n = 1 , nhppoints read ( ifinput , * ) idhppts_global ( n , 1 ), idhppts_global ( n , 2 ), idhppts_global ( n , 3 ) end do close ( ifinput ) end if ! Broadcast the heat pump points to all processes call MPI_BCAST ( idhppts_global , nhppoints * 3 , MPI_INTEGER , 0 , comm3d , mpierr ) ! Determine whether points are on this rank do n = 1 , nhppoints if (( idhppts_global ( n , 1 ) >= zstart ( 1 ) . and . idhppts_global ( n , 1 ) <= zend ( 1 )) . and . & ( idhppts_global ( n , 2 ) >= zstart ( 2 ) . and . idhppts_global ( n , 2 ) <= zend ( 2 ))) then lhpptsrank ( n ) = . true . else lhpptsrank ( n ) = . false . end if end do thl_dot_hp = QH_dot_hp / ( nhppoints * rhoa * cp ) ! Calculate temperature change rate from heat loss [Km&#94;3/s] w_hp_exhaust = ( Q_dot_hp / nhppoints ) * dxi * dyi ! Calculate exhaust velocity at heat pump points [m/s] end subroutine init_heatpump subroutine heatpump use modglobal , only : lheatpump , lfan_hp , nhppoints , dxi , dyi , dzfi , ltempeq use modfields , only : wm , w0 , wp , thlp use modmpi , only : myidx , myidy use decomp_2d , only : zsize implicit none integer :: n , i , j , k if (. not .( lheatpump ) . or . . not .( ltempeq ) . or . ( nhppoints < 1 )) return do n = 1 , nhppoints if ( lhpptsrank ( n )) then i = idhppts_global ( n , 1 ) - myidx * zsize ( 1 ) j = idhppts_global ( n , 2 ) - myidy * zsize ( 2 ) k = idhppts_global ( n , 3 ) if ( lfan_hp ) then ! Heat pump fan is on wm ( i , j , k + 1 ) = w_hp_exhaust ! Set exhaust velocity at heat pump point [m/s], at input 'w' cell face k+1 w0 ( i , j , k + 1 ) = w_hp_exhaust wp ( i , j , k + 1 ) = 0. end if thlp ( i , j , k ) = thlp ( i , j , k ) - thl_dot_hp * dxi * dyi * dzfi ( k ) ! [K/s], at cell center k end if end do end subroutine heatpump subroutine exit_heatpump use modglobal , only : lheatpump , nhppoints , ltempeq implicit none if (. not .( lheatpump ) . or . . not .( ltempeq ) . or . ( nhppoints < 1 )) return deallocate ( idhppts_global , lhpptsrank ) ! Deallocate global heat pump points array and logical array end subroutine exit_heatpump end module modheatpump","tags":"","url":"sourcefile/heatpump.f90.html"},{"title":"modtrees.f90 – uDALES","text":"This file depends on sourcefile~~modtrees.f90~~EfferentGraph sourcefile~modtrees.f90 modtrees.f90 sourcefile~modfields.f90 modfields.f90 sourcefile~modtrees.f90->sourcefile~modfields.f90 sourcefile~modglobal.f90 modglobal.f90 sourcefile~modtrees.f90->sourcefile~modglobal.f90 sourcefile~modibmdata.f90 modibmdata.f90 sourcefile~modtrees.f90->sourcefile~modibmdata.f90 sourcefile~modmpi.f90 modmpi.f90 sourcefile~modtrees.f90->sourcefile~modmpi.f90 sourcefile~modsubgriddata.f90 modsubgriddata.f90 sourcefile~modtrees.f90->sourcefile~modsubgriddata.f90 sourcefile~modsurfdata.f90 modsurfdata.f90 sourcefile~modtrees.f90->sourcefile~modsurfdata.f90 sourcefile~modfields.f90->sourcefile~modglobal.f90 sourcefile~modglobal.f90->sourcefile~modmpi.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~modtrees.f90~~AfferentGraph sourcefile~modtrees.f90 modtrees.f90 sourcefile~program.f90 program.f90 sourcefile~program.f90->sourcefile~modtrees.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> \\file modetrees.f90 !!tg3315, ns4513, 20 Mar 2017 !> Input trees into DALES model. module modtrees use mpi implicit none save contains subroutine createtrees use modglobal , only : ltrees , ntrees , tree , cexpnr , ifinput , zh , zf , dzh , dzfi , dzhi , dzf , Qstar ,& dec , lad , kb , ke , cp , rhoa , ntree_max , dQdt , tr_A , dy , xh use modfields , only : um , vm , wm , thlm , qt0 , svp , up , vp , wp , thlp , qtp , Rn , clai , qc , qa , ladzh , ladzf use modmpi , only : myid , comm3d , mpierr , MY_REAL use modsurfdata , only : wtsurf use modibmdata , only : bctfz implicit none integer :: n , k real :: Rq character ( 80 ) chmess if (( ltrees . eqv . . false .) . or . ( ntrees == 0 )) return allocate ( tree ( ntrees , 6 )) ! read global trees if ( myid == 0 ) then ! write(*,*) '1, myid, ntrees, ltrees, cexpnr', myid, ntrees, ltrees, cexpnr if ( ntrees > 0 ) then open ( ifinput , file = 'trees.inp.' // cexpnr ) read ( ifinput , '(a80)' ) chmess read ( ifinput , '(a80)' ) chmess do n = 1 , ntrees read ( ifinput , * ) & tree ( n , 1 ), & tree ( n , 2 ), & tree ( n , 3 ), & tree ( n , 4 ), & tree ( n , 5 ), & tree ( n , 6 ) end do ! write (6,*) 'Tree number,   il, iu, jl, ju, kl, ku ' ! do n=1,ntrees !   write (1,*) & !         n , & !         tree(n,1), & !         tree(n,2), & !         tree(n,3), & !         tree(n,4), & !         tree(n,5), & !         tree(n,6) ! end do close ( ifinput ) end if end if ! end if myid==0 ! call MPI_BCAST(ntrees ,1,MPI_INTEGER ,0,comm3d,mpierr) call MPI_BCAST ( tree , 6 * ntrees , MPI_INTEGER , 0 , comm3d , mpierr ) !! capability to read lad of trees from a lad.inp.xxx file !! tg3315 commented - for now assume constant lad or hardcode as seen below !if (myid==0) then !  allocate(ladt(nlad)) !  if (nlad>0) then !    open (ifinput,file='lad.inp.'//cexpnr) !    read (ifinput,'(a80)') chmess !    do n=1,nlad !      read (ifinput,*) & !            ladt(n) !      end do !    write (*,*) 'lad' !    do n=1,nlad !      write (1,*) & !            n , & !            ladt(n) !    end do !  end if ! input into leaf area density array (cell faces) !lad(tree(1,5):tree(1,6)+1) = ladt !defined at cell faces ! initialise tree variables that are constant in time ! calculate clai for tallest possible tree ! assume no grid stretching in lowest layer with trees if ( myid == 0 ) then ntree_max = maxval ( tree (:, 6 )) - minval ( tree (:, 5 )) + 1 ! hard code non-uniform lad profiles - temporary if (. false .) then ladzh ( 1 : ntree_max ) = ( / 0.1 , 0.11 , 0.12 , 0.14 , 0.16 , 0.19 , 0.22 , 0.265 , 0.31 , 0.335 , 0.36 , 0.37 , 0.38 , 0.3725 , 0.365 , 0.3375 , 0.31 , 0.2375 , 0.165 , 0.0875 / ) !LAI =2 from Shaw, 1992 ! assumes lad at ntree_max+1 is 0.! else ladzh ( 1 : ntree_max + 1 ) = lad !up to ntree_max+1 cos ladzh is at cell faces end if ! interpolate to find lad at cell centres do k = 1 , ntree_max ladzf ( k ) = 0.5 * ( ladzh ( k ) + ladzh ( k + 1 )) end do ! clai at cell faces using lad at cell centre do k = 1 , ntree_max clai ( k ) = sum ( 0.5 * ( ladzh ( k : ntree_max ) + ladzh ( k + 1 : ntree_max + 1 )) * ( dzf ( maxval ( tree (:, 6 )) - ntree_max + k : maxval ( tree (:, 6 ))))) end do ! Net radiation at cell faces! !W/m&#94;2 do k = 1 , ntree_max + 1 Rn ( k ) = Qstar * exp ( - dec * clai ( k )) end do ! Change in radiation over each layer (at cell centres) W/m&#94;2 do k = 1 , ntree_max qc ( k ) = Rn ( k + 1 ) - Rn ( k ) end do ! incorporate the distributed storage term - updated for zero heat storage in tree do k = 1 , ntree_max qa ( k ) = qc ( k ) !(1 - Rq*0.11) * qc(k) - 0.11*Rq*dQdt + Rq*12.3 end do ! write relevant fields ! write(*,*) 'ntree_max', ntree_max ! write(*,*) 'qa', qa(1:ntree_max) ! write(*,*) 'qc', qc(1:ntree_max) ! write(*,*) 'clai', clai(1:ntree_max+1) ! write(*,*) 'Rn', Rn(1:ntree_max+1) ! write(*,*) 'ladzf', ladzf ! write(*,*) 'ladzh', ladzh end if !apply storage to set wtsurf and bctfz as a function of Qstar wtsurf = - (( 1 - 0.7 ) * Qstar - 0.33 * dQdt + 38 ) / ( rhoa * cp ) bctfz = - (( 1 - 0.7 ) * Qstar - 0.33 * dQdt + 38 ) / ( rhoa * cp ) ! calc tree cover area - used to apply steady-state boundary condition if ( myid == 0 ) then do n = 1 , ntrees tr_A = tr_A + ( xh ( tree ( n , 2 ) + 1 ) - xh ( tree ( n , 1 ))) * dy * ( tree ( n , 4 ) - tree ( n , 3 ) + 1 ) end do end if ! write updated ground and roof heat fluxes write ( * , * ) 'wtsurf' , wtsurf write ( * , * ) 'bctfz' , bctfz ! broadcast variables call MPI_BCAST ( ntree_max , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( tr_A , 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( Rn , ke + 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( qc , ke + 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( clai , ke + 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( qa , ke + 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( ladzf , ke + 1 , MY_REAL , 0 , comm3d , mpierr ) call MPI_BCAST ( ladzh , ke + 1 , MY_REAL , 0 , comm3d , mpierr ) end subroutine createtrees subroutine trees use modglobal , only : ib , ie , jb , je , kb , ke , ih , jh , dzf , xh , dxf , numol , prandtlmol , rlv , cp , tree ,& ntrees , ltrees , itot , jtot , cd , ud , lmoist , nsv , dxf , dy , dzf , dzfi , zf , dy , zh ,& ltempeq , pref0 , r_s , lad , rhoa , ntree_max , lsize , Qstar , dQdt , BCxs , tr_A ,& rslabs , kmax , rv , rd use modfields , only : um , vm , wm , thlm , qtm , svp , up , vp , wp , thlp , qtp , svm , Rn , qc , qa , thlm , clai ,& ladzf , ladzh , IIcs , tr_omega ,& tr_u , tr_v , tr_w , tr_qt , tr_qtR , tr_qtA , tr_thl , tr_sv , thlpcar use modmpi , only : myidx , myidy , mpi_sum , mpierr , comm3d , mpierr , my_real , nprocx , nprocy use modsurfdata , only : wtsurf , wttop , wqtop use modibmdata , only : bctfz use modsubgriddata , only : ekh implicit none integer :: i , j , k , n , m , il , iu , jl , ju , kl , ku real :: e_sat , e_vap , qh , qe , shade , r_a , s , D , numoli , gam , Rq , qhmin , qhmax , omega real :: Vq_dum , Vq_dum2 , Vq_dum3 , VT_dum , VT_dum2 , VT_dum3 , wTbot_dum , wTbot_dum2 , wTbot , wTbot_dum3 numoli = 1 / numol gam = ( cp * pref0 * rv ) / ( rlv * rd ) qhmin = 0. ; qhmax = 0. if ( ltrees . eqv . . false .) return ! dummy variables used for steady-state BC calculation VT_dum2 = 0. Vq_dum2 = 0. wTbot_dum2 = 0. ! loop over all tree canopies do n = 1 , ntrees ! drag in z-direction il = tree ( n , 1 ) - myidx * itot / nprocx iu = tree ( n , 2 ) - myidx * itot / nprocx kl = tree ( n , 5 ) ku = tree ( n , 6 ) + 1 jl = tree ( n , 3 ) - myidy * jtot / nprocy ju = tree ( n , 4 ) - myidy * jtot / nprocy if ( iu < ib . or . il > ie . or . ju < jb . or . jl > je ) then cycle else if ( iu > ie ) iu = ie if ( il < ib ) il = ib if ( ju > je ) ju = je if ( jl < jb ) jl = jb do k = kl , ku do j = jl , ju do i = il , iu tr_w ( i , j , k ) = - cd * ladzh ( ntree_max - ( ku - k ) + 1 ) * wm ( i , j , k ) * & sqrt ( wm ( i , j , k ) ** 2 & + ( 0.25 * ( um ( i , j , k ) + um ( i + 1 , j , k ) + um ( i , j , k - 1 ) + um ( i + 1 , j , k - 1 ))) ** 2 & + ( 0.25 * ( vm ( i , j , k ) + vm ( i , j + 1 , k ) + vm ( i , j , k - 1 ) + vm ( i , j + 1 , k - 1 ))) ** 2 ) end do end do end do end if ! drag in y-direction il = tree ( n , 1 ) - myidx * itot / nprocx iu = tree ( n , 2 ) - myidx * itot / nprocx kl = tree ( n , 5 ) ku = tree ( n , 6 ) jl = tree ( n , 3 ) - myidy * jtot / nprocy ju = tree ( n , 4 ) + 1 - myidy * jtot / nprocy if ( iu < ib . or . il > ie . or . ju < jb . or . jl > je ) then cycle else if ( iu > ie ) iu = ie if ( il < ib ) il = ib if ( ju > je ) ju = je if ( jl < jb ) jl = jb do k = kl , ku do j = jl , ju do i = il , iu tr_v ( i , j , k ) = - cd * ladzf ( ntree_max - ( ku - k )) * vm ( i , j , k ) * & sqrt ( vm ( i , j , k ) ** 2 & + ( 0.25 * ( um ( i , j , k ) + um ( i + 1 , j , k ) + um ( i , j - 1 , k ) + um ( i + 1 , j - 1 , k ))) ** 2 & + ( 0.25 * ( wm ( i , j , k ) + wm ( i , j , k + 1 ) + wm ( i , j - 1 , k ) + wm ( i , j - 1 , k + 1 ))) ** 2 ) end do end do end do end if ! drag in x-direction il = tree ( n , 1 ) - myidx * itot / nprocx iu = tree ( n , 2 ) + 1 - myidx * itot / nprocx kl = tree ( n , 5 ) ku = tree ( n , 6 ) jl = tree ( n , 3 ) - myidy * jtot / nprocy ju = tree ( n , 4 ) - myidy * jtot / nprocy if ( iu < ib . or . il > ie . or . ju < jb . or . jl > je ) then cycle else if ( iu > ie ) iu = ie if ( il < ib ) il = ib if ( ju > je ) ju = je if ( jl < jb ) jl = jb do k = kl , ku do j = jl , ju do i = il , iu tr_u ( i , j , k ) = - cd * ladzf ( ntree_max - ( ku - k )) * um ( i , j , k ) * & sqrt ( um ( i , j , k ) ** 2 & + ( 0.25 * ( vm ( i , j , k ) + vm ( i , j + 1 , k ) + vm ( i - 1 , j , k ) + vm ( i - 1 , j + 1 , k ))) ** 2 & + ( 0.25 * ( wm ( i , j , k ) + wm ( i , j , k + 1 ) + wm ( i - 1 , j , k ) + wm ( i - 1 , j , k + 1 ))) ** 2 ) end do end do end do end if ! scalar volumetric sources/sinks ! Canopy EB if ( lmoist . and . ltempeq ) then il = tree ( n , 1 ) - myidx * itot / nprocx iu = tree ( n , 2 ) - myidx * itot / nprocx kl = tree ( n , 5 ) ku = tree ( n , 6 ) jl = tree ( n , 3 ) - myidy * jtot / nprocy ju = tree ( n , 4 ) - myidy * jtot / nprocy if ( iu < ib . or . il > ie . or . ju < jb . or . jl > je ) then cycle else if ( iu > ie ) iu = ie if ( il < ib ) il = ib if ( ju > je ) ju = je if ( jl < jb ) jl = jb do k = kl , ku do j = jl , ju do i = il , iu ! psychometrics ! saturation vapour pressure pressure e_sat = 61 0.8 * exp (( 1 7.27 * ( thlm ( i , j , k ) - 27 3.15 )) / ( thlm ( i , j , k ) - 3 5.85 )) ! water vapour partial pressure e_vap = ( qtm ( i , j , k ) * pref0 ) / ( 0.378 * qtm ( i , j , k ) + 0.622 ) ! qtcheck.m and https://earthscience.stackexchange.com/questions/2360/how-do-i-convert-specific-humidity-to-relative-humidity ! vapour pressure deficit D = max ( e_sat - e_vap , 0. ) ! output warning - cannot physically occur if ( e_sat < e_vap ) then write ( * , * ) 'D, e_sat, e_vap, thlm, qtm' , D , e_sat , e_vap , thlm ( i , j , k ), qtm ( i , j , k ) end if ! slope of the curve relating saturation vapour pressure to temperature s = ( 4098 * e_sat ) / (( thlm ( i , j , k ) - 3 5.85 ) ** 2 ) ! aerodynamic resistance r_a = 130 * sqrt ( lsize / ( sqrt (( 0.5 * ( um ( i , j , k ) + um ( i + 1 , j , k ))) ** 2 + ( 0.5 * ( vm ( i , j , k ) + vm ( i , j + 1 , k ))) ** 2 + ( 0.5 * ( wm ( i , j , k ) + wm ( i , j , k + 1 ))) ** 2 ))) ! decoupling factor omega = 1 / ( 1 + 2 * ( gam / ( s + 2 * gam )) * (( r_s ) / r_a ) ) ! latent heat qe = omega * ( s / ( s + 2 * gam )) * ( qa ( ntree_max - ( ku - k )) / ( dzf ( k ) * ladzf ( ntree_max - ( ku - k )))) + ( 1 - omega ) * ( 1 / ( gam * ( r_s ))) * rhoa * cp * D ! sensible heat qh = qa ( ntree_max - ( ku - k )) / ( dzf ( k ) * ladzf ( ntree_max - ( ku - k ))) - qe ! volumetric sinks/source of specific humidity and temp tr_qt ( i , j , k ) = ladzf ( ntree_max - ( ku - k )) * qe / ( rhoa * rlv ) tr_qtR ( i , j , k ) = ladzf ( ntree_max - ( ku - k )) * ( omega * ( s / ( s + 2 * gam )) * ( qa ( ntree_max - ( ku - k )) / ( dzf ( k ) * ladzf ( ntree_max - ( ku - k ))))) / ( rhoa * rlv ) tr_qtA ( i , j , k ) = ladzf ( ntree_max - ( ku - k )) * (( 1 - omega ) * ( 1 / ( gam * ( r_s ))) * rhoa * cp * D ) / ( rhoa * rlv ) tr_thl ( i , j , k ) = ladzf ( ntree_max - ( ku - k )) * qh / ( rhoa * cp ) tr_omega ( i , j , k ) = omega ! add to rhs qtp ( i , j , k ) = qtp ( i , j , k ) + tr_qt ( i , j , k ) !ladz(ntree_max-(ku-k))*qe/(rhoa*rlv) thlp ( i , j , k ) = thlp ( i , j , k ) + tr_thl ( i , j , k ) !ladz(ntree_max-(ku-k))*qh/(rhoa*cp) ! fill dummy variables for steady-state BCs VT_dum2 = VT_dum2 - tr_thl ( i , j , k ) * dzf ( k ) * dxf ( i ) * dy Vq_dum2 = Vq_dum2 - tr_qt ( i , j , k ) * dzf ( k ) * dxf ( i ) * dy end do end do end do ! fraction of total net radiation reaching the bottom of the tree Rq = Rn ( ntree_max + 1 - ( ku + 1 - kl )) / Qstar ! sensible heat flux from shaded surfaces shade = ( ( 1 - 0.7 ) * Rn ( ntree_max + 1 - ( ku + 1 - kl ) ) - 0.33 * Rq * dQdt + Rq * 38 ) / ( rhoa * cp ) ! dummy var for steady-state BC wTbot_dum2 = wTbot_dum2 - shade * ( xh ( iu + 1 ) - xh ( il )) * dy * ( ju - jl + 1 ) ! overwrite standard heat flux defined in modibm in shaded positions thlp ( il : iu , jl : ju , kb + 1 ) = thlp ( il : iu , jl : ju , kb + 1 ) + ( bctfz + shade ) * dzfi ( kb + 1 ) end if end if !lmoist and ltempeq ! scalar deposition if ( nsv > 0 ) then ! specific to infinite canyon study (tg3315 thesis - Chapter 5) if ( BCxs == 2 ) then ! no deposition effect from first or last tree to avoid interaction with BCs if ( n == 1 ) cycle if ( n == ntrees ) cycle end if il = tree ( n , 1 ) - myidx * itot / nprocx iu = tree ( n , 2 ) - myidx * itot / nprocx kl = tree ( n , 5 ) ku = tree ( n , 6 ) jl = tree ( n , 3 ) - myidy * jtot / nprocy ju = tree ( n , 4 ) - myidy * jtot / nprocy if ( iu < ib . or . il > ie . or . ju < jb . or . jl > je ) then cycle else if ( iu > ie ) iu = ie if ( il < ib ) il = ib if ( ju > je ) ju = je if ( jl < jb ) jl = jb do m = 1 , nsv ! define this for scalar variables that are deposited do k = kl , ku do j = jl , ju do i = il , iu tr_sv ( i , j , k , m ) = - svm ( i , j , k , m ) * ladzf ( ntree_max - ( ku - k )) * ud svp ( i , j , k , m ) = svp ( i , j , k , m ) + tr_sv ( i , j , k , m ) end do end do end do end do end if end if !nsv end do ! ntrees ! define these outside loop to avoid double counting cell faces wp ( ib : ie , jb : je , kb : ke ) = wp ( ib : ie , jb : je , kb : ke ) + tr_w ( ib : ie , jb : je , kb : ke ) vp ( ib : ie , jb : je , kb : ke ) = vp ( ib : ie , jb : je , kb : ke ) + tr_v ( ib : ie , jb : je , kb : ke ) up ( ib : ie , jb : je , kb : ke ) = up ( ib : ie , jb : je , kb : ke ) + tr_u ( ib : ie , jb : je , kb : ke ) ! steady-state BC calc. if ( lmoist . and . ltempeq ) then ! dummy vars - not all used? wTbot_dum3 = 0. wTbot_dum = 0. wTbot = 0. VT_dum3 = 0. Vq_dum3 = 0. VT_dum = 0. Vq_dum = 0. ! sum dummy variables assigned in main loop call MPI_ALLREDUCE ( wTbot_dum2 , wTbot_dum3 , 1 , MY_REAL , MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( VT_dum2 , VT_dum3 , 1 , MY_REAL , MPI_SUM , comm3d , mpierr ) call MPI_ALLREDUCE ( Vq_dum2 , Vq_dum3 , 1 , MY_REAL , MPI_SUM , comm3d , mpierr ) ! not necessary wTbot_dum = wTbot_dum3 Vq_dum = Vq_dum3 VT_dum = VT_dum3 ! total flux of temp from ground and roofs accounting for shading wTbot = wTbot_dum + (( xh ( ie + 1 ) - xh ( ib )) * jtot * dy - tr_A ) * bctfz ! temp flux at top equal to half of the total flux of heat (ground, roofs and canopies) - consistent with tg3315 thesis Chapter 4 - method iii wttop = 0.5 * ( wTbot + VT_dum ) / (( xh ( ie + 1 ) - xh ( ib )) * jtot * dy ) ! volumetric sink term throughout domain to account for the remaining heating - \"\" thlpcar = wttop / (( sum ( real ( IIcs ( kb + 1 : ke )) / rslabs ) / real ( kmax - 1. )) * ( zh ( ke + 1 ) - zh ( kb + 1 ))) ! top flux of qt equal to total from canopies - therefore uniform flux profile wqtop = ( Vq_dum ) / (( xh ( ie + 1 ) - xh ( ib )) * jtot * dy ) end if end subroutine trees end module modtrees","tags":"","url":"sourcefile/modtrees.f90.html"}]}