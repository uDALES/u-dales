{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"uDALES Docs","text":"<p>This is the documentation for uDALES, an open-source multi-physics microscale urban modelling tool, capable of performing large-eddy simulation (LES) of urban airflow, heat transfer, and pollutant dispersion. This documentation contains user's guides and general reference documentation.</p> <p>For a quick introduction and instructions on installing and running uDALES, see the \"Installation and First Run\" page: Installation and First Run.</p>"},{"location":"CONTRIBUTING/","title":"How to contribute","text":"<p>In general, you can contribute by reporting an issue or by directly contributing to the source code. For the latter, clone the repository, make your changes, and create a pull request (PR) with a clear description of your changes -- if you are unfamiliar with creating PRs, please see this guide first. Please also read the development notes before opening an issue or create a PR. For specific instructions on how to report a bug or how to submit a feature request, please see below:</p> <ul> <li>How to contribute</li> <li>Report a bug</li> <li>Request a new feature</li> </ul>"},{"location":"CONTRIBUTING/#report-a-bug","title":"Report a bug","text":"<p>Before creating bug reports, please check if similar issue have already been reported here. If none exist please create a new issue and include as many details as possible using the required template.</p>"},{"location":"CONTRIBUTING/#request-a-new-feature","title":"Request a new feature","text":"<p>Before creating a feature request, please check if a similar feature has been already asked here. If none exist please create a new feature request and include as many details as possible using the required template.</p>"},{"location":"DEVELOP/","title":"Development notes","text":""},{"location":"DEVELOP/#set-up","title":"Set up","text":"<p>Install all required packages for uDALES described in the prerequisites section, plus optionally Graphviz for generating graphs in the code viewer. E.g. installing all the required packages using Ubuntu's APT:</p> <pre><code>sudo apt update &amp;&amp; sudo apt install -y gfortran libopenmpi-dev openmpi-bin libnetcdf-dev libnetcdff-dev graphviz\n</code></pre> <p>Then, to set up the development environment for testing and generating the docs, download the latest version of Miniconda and install the required dependencies with:</p> <pre><code>conda env create -f environment.yml\n</code></pre> <p>Then activate with <code>conda activate udales</code>.</p>"},{"location":"DEVELOP/#installation","title":"Installation","text":"<p>To install uDALES on Linux, macOS, and WSL, use the following commands from the command prompt:</p> <pre><code>mkdir -p build/release\npushd build/release\ncmake ../..\nmake\n</code></pre> <p>To know more about build options, please see build/default options.</p>"},{"location":"DEVELOP/#running","title":"Running","text":"<p>A uDALES simulation needs to be executed from a directory containing all required input files. Examples of experiments and required inputs are in the <code>examples</code> directory. To run a uDALES simulation you need to specify the number of cpus <code>&lt;NCPU&gt;</code>, the path to the build file <code>&lt;BUILD&gt;</code> and the simulation configuration file <code>&lt;NAMOPTIONS&gt;</code> and execute the simulation with the following command:</p> <pre><code>mpiexec -n &lt;NCPU&gt; &lt;BUILD&gt; &lt;NAMOPTIONS&gt;\n</code></pre>"},{"location":"DEVELOP/#testing","title":"Testing","text":"<p>Please refer to Test docs.</p>"},{"location":"DEVELOP/#documentation","title":"Documentation","text":"<pre><code>mkdocs build --site-dir build/html\nford docs/udales-docs-software.md\n</code></pre>"},{"location":"DEVELOP/#examples-input-plots","title":"Examples input plots","text":"<p>To create domain plots of the examples, run the following from your command line (requires MATLAB):</p> <pre><code> matlab -nosplash -nodesktop -r \"cd('tools/examples'); plot_blocks('&lt;CASE_NUMBER&gt;'); quit\"\n</code></pre> <p>where <code>&lt;CASE_NUMBER&gt;</code> is e.g. <code>201</code>. Plots are then saved in their respective example folders.   </p>"},{"location":"DEVELOP/#examples-outputs-and-plots","title":"Examples outputs and plots","text":"<p>Run the following script to run and generate outputs for all example cases:</p> <pre><code>./tools/examples/run_examples.sh\n</code></pre> <p>Then, to create a sample plot for case <code>102</code> run the following from your command line (requires MATLAB):</p> <pre><code>matlab -nosplash -nodesktop -r \"cd('tools/examples'); plot_fielddump_slice('102','u','y',32,1); quit\"\n</code></pre>"},{"location":"DEVELOP/#versioning","title":"Versioning","text":"<p>This project uses semantic versioning.</p>"},{"location":"udales-2decomp/","title":"Parallelisation","text":"<p>Parallelisation of u-DALES 2.0 is achieved using the 2DECOMP&amp;FFT library. The 2DECOMP&amp;FFT library decomposes Cartesian domains using a 2-D pencil-based decomposition, assigning a pencil to each MPI rank. Operations on each pencil can then be performed in parallel. Users should ensure the 2-D decomposition grid factors the mesh exactly to ensure load balance. By doing so each pencil contains an equal number of grid points for an equal volume of work per MPI rank.</p> <p>Two communication patterns implemented by 2DECOMP&amp;FFT are used in u-DALES 2.0.</p>"},{"location":"udales-2decomp/#data-transposes","title":"Data transposes","text":"<p>Solving the Poisson problem using FFTs requires access to the full extent of an axis in each orientation. The 2DECOMP&amp;FFT library implements transpose operations from Z-&gt;Y, Y-&gt;X, X-&gt;Y and Y-&gt;Z pencil orientations allowing the solver to process each orientation in turn.</p>"},{"location":"udales-2decomp/#halo-exchanges","title":"Halo exchanges","text":"<p>The discretisation stencils in the transport equations require neighbour data. At pencil boundaries this requires exchanging data between neighbouring pencils. The 2DECOMP&amp;FFT library provides halo exchange subroutines to support such data exchange.</p>"},{"location":"udales-boundary-conditions/","title":"Boundary conditions","text":"<p>The boundary conditions for uDALES are specified under the <code>&amp;BC</code> header in <code>namoptions.inp</code>.</p>"},{"location":"udales-boundary-conditions/#momentum","title":"Momentum","text":""},{"location":"udales-boundary-conditions/#top","title":"Top","text":"<p>Determined by <code>BCtopm</code>. Possible values:</p> <ul> <li>1: free-slip, i.e. zero flux.</li> <li>2: no-slip, i.e. zero velocity.</li> <li>3: variable vertical velocity (necessary with inflow-outflow lateral boundary conditions).</li> </ul>"},{"location":"udales-boundary-conditions/#bottom","title":"Bottom","text":"<p>NB: only relevant if the bottom of the domain is not covered by floor facets. Determined by <code>BCbotm</code>. Possible values:</p> <ul> <li>1: free slip, i.e. zero flux.</li> <li>2: flux given by wall function involving temperature.</li> <li>3: flux given by neutral wall function.</li> </ul>"},{"location":"udales-boundary-conditions/#walls","title":"Walls","text":"<p>Determined by <code>iwallmom</code>. Possible values:</p> <ul> <li>1: free-slip, i.e. zero flux.</li> <li>2: flux given by wall function involving temperature.</li> <li>3: flux given by neutral wall function.</li> </ul>"},{"location":"udales-boundary-conditions/#x","title":"x","text":"<p>Determined by <code>BCxm</code>. Possible values:</p> <ul> <li>1: periodic</li> <li>2: inflow-outflow, fixed profile</li> <li>3: inflow-outflow, inflow given by time-varying profile from precursor simulation</li> </ul>"},{"location":"udales-boundary-conditions/#y","title":"y","text":"<p>Determined by <code>BCym</code>. Possible values:</p> <ul> <li>1: periodic</li> <li>2: inflow-outflow, fixed profile</li> </ul>"},{"location":"udales-boundary-conditions/#temperature","title":"Temperature","text":"<p>Only required when <code>ltempeq = .true.</code></p>"},{"location":"udales-boundary-conditions/#top_1","title":"Top","text":"<p>Determined by <code>BCtopT</code>. Possible values:</p> <ul> <li>1: constant flux given by <code>wttop</code>.</li> <li>2: constant temperature given by <code>thl_top</code>.</li> </ul>"},{"location":"udales-boundary-conditions/#bottom_1","title":"Bottom","text":"<p>Determined by <code>BCbotT</code>. Possible values:</p> <ul> <li>1: constant flux given by <code>wtsurf</code>.</li> <li>2: flux given by wall function. Temperature of ghost cells below floor facets given by <code>thls</code>.</li> </ul>"},{"location":"udales-boundary-conditions/#walls_1","title":"Walls","text":"<p>Determined by <code>iwalltemp</code>. Possible values:</p> <ul> <li>1: constant flux given by <code>bctfxm</code>/<code>bctfxp</code> for facets with normal in -/+ x-direction, <code>bctfym</code>/<code>bctfyp</code> for facets with normal in -/+ y-direction, and <code>bctfz</code> for facets with normal in +z direction.</li> <li>2: flux given by wall function.</li> </ul>"},{"location":"udales-boundary-conditions/#moisture","title":"Moisture","text":"<p>Determined by <code>iwallmoist</code>. Possible values:</p> <ul> <li>1: constant flux given by <code>bcqfxm</code>/<code>bcqfxp</code> for facets with normal in -/+ x-direction, <code>bcqfym</code>/<code>bctfyp</code> for facets with normal in -/+ y-direction, and <code>bcqfz</code> for facets with normal in +z direction.</li> <li>2: flux given by wall function.</li> </ul>"},{"location":"udales-boundary-conditions/#scalars","title":"Scalars","text":"<p>TBC</p>"},{"location":"udales-copy-inputs/","title":"Copying simulation input files","text":"<p>To set up a new simulation, <code>copy_inputs.sh</code> in <code>u-dales/tools/</code> is used to create a new simulation setup <code>new_exp_id</code> based on another simulation <code>old_exp_id</code>. All <code>exp_ids</code> are three digit integer numbers, e.g. 001, and are stored in directories of that name. Each experiment case directory must contain a config.sh file where appropriate paths for DA_EXPDIR (experiments directory), DA_WORKDIR (outputs directory), DA_TOOLSDIR (u-dales/tools directory) are set using export.</p> <p>Now to set-up a new experiment (here we use case <code>009</code>) based on a previous example (here we use case <code>001</code>), run:</p> <pre><code># We assume you are running the following commands from your\n# top-level project directory.\n\n# General syntax: copy_inputs.sh old_exp_id new_exp_id\nu-dales/tools/copy_inputs.sh experiments/001 009\n\n# To set up a new simulation starting from the restart files of another simulation\n# (\"warmstart\"), use the 'w' flag. E.g.: copy_inputs.sh old_exp_id new_exp_id w\nu-dales/tools/copy_inputs.sh experiments/001 009 w\n</code></pre>"},{"location":"udales-docs-software/","title":"Udales docs software","text":"<p>project: uDALES author: The uDALES Team project_github: https://github.com/uDALES/u-dales summary: TODO: github: https://github.com/uDALES src_dir: ../src output_dir: ../build/html/udales-docs-software media_dir: assets docmark: ! predocmark: !! docmark_alt: $$$ display:  public           private           protected source: true graph: true coloured_edges: true preprocess: false print_creation_date: true creation_date: %Y-%m-%d %H:%M %z md_extensions: markdown.extensions.toc                markdown.extensions.smarty</p>"},{"location":"udales-driver-simulations/","title":"Pre-cursor simulations","text":"<p>Precursor or driver simulations are used to provide realistic turbulent inflow boundary conditions for another simulation, typically referred to as the 'target' simulation. The options for running precursor and driven simulations are specified under the <code>&amp;DRIVER</code> header in namoptions.xxx. This provides two model functionalities:</p> <p>1) To run a precursor simulation where instantaneous y-z planes at a specified index in the x-direction (<code>iplane</code>) are written every <code>dtdriver</code> seconds to output files (named *driver*). 2) To run a driven simulation where the inlet y-z plane (at <code>i=ib-1</code> and <code>i=ib</code>) is determined by reading the *driver* files of a precursor simulation that has already been run.</p>"},{"location":"udales-driver-simulations/#running-precursor-simulations","title":"Running precursor simulations","text":"<p>Precursor simulations are indicated by first setting <code>idriver = 1</code> in namoptions.xxx. The set-up of the precursor simulation is then up to the users discretion. The other variables to specify are:</p> <ul> <li><code>tdriverstart</code> - specifies the number of seconds after which the *driver* files will start being written. If the precursor simulation is not a warm start then it is recommended to allow a sufficient amount of time for the flow field to develop to the desired state before starting to write to the *driver* files.</li> <li><code>dtdriver</code> specifies the timestep in seconds at which the y-z planes are written to the *driver* files. It is important to set this to be small (ideally <code>dtdriver = dt</code>) in order to reduce the requirement to interpolate these fields in the resulting driven simulation. However, depending on the case, this can be made larger with the advantage being a reduction in size of the *driver* files that are produced.</li> <li><code>iplane</code> is the index in the x-direction that you want to save the instantaneous y-z planes. For many cases the expected value is <code>iplane = ie</code> so that the outlet of the precursor simulation is saved.</li> <li><code>driverstore</code> is the number of timesteps that the user wants to write to the *driver* files. The total simulation time should therefore be equal or greater to <code>tdriverstart + (driverstore-1)*dtdriver</code> seconds to ensure that the writing process completes. The driven simulation based off this precursor will be limited to a maximum run time of <code>(driverstore-1)*dtdriver</code> seconds (unless multiple precursors are run using warm starts).</li> </ul> <p>Outputs:</p> <ul> <li>A file for each prognostic variable (e.g. <code>u0</code>, <code>v0</code>, <code>w0</code>, <code>thl0</code> (if <code>ltempeq = .true.</code>) etc.) for each processor.The file names follow 'var\"driver\\_\"nproc\".\"$expnr' where $var indicates the variable (NOTE: h is potential temperature under this convention). These files will hold the corresponding instantaneous y-z planes over the specified time period and are to be used to drive a driven simulation.</li> </ul>"},{"location":"udales-driver-simulations/#running-driven-simulations","title":"Running driven simulations","text":"<p>It is necessary to first have run a simulation following the above instructions. Driven simulations are initiated by setting <code>idriver = 2</code>. The following are guidelines for setting up the driven simulation:</p> <ul> <li>The driven simulation must have the same <code>jtot</code>, <code>ysize</code>, <code>kmax</code> and <code>zgrid.inp.xxx</code> as its corresponding precursor simulation.</li> <li>The driven simulation must use the same number of cores as the precursor simulation.</li> <li>It is not necessary to apply a forcing to the driven simulation due to the enforced inlet-outlet boundary conditions.</li> <li><code>BCxm = 3</code> is the current index to enforce the required inlet-outlet boundary conditions. Boundary conditions in the x-direction for other prognostic variables will be overwritten by this and therefore do not need to be set.</li> <li>The *driver* files from the precursor simulation must be copied from its output directory to the experiments directory of the driven simulation. For example, if the precursor is 001 and the driven simulation is 002 and you are working from the top uDALES directory: <code>cp outputs/001/*driver* experiments/002/</code>.</li> <li><code>driverstore</code> must be equal to or less than the number of timesteps saved in the *driver* files (equivalent value of <code>driverstore</code> in the precursor simulation).</li> <li><code>driverjobnr</code> must equal the job number of the corresponding precursor simulation. Following the above example: <code>driverjobnr = 001</code>.</li> <li><code>runtime</code> must equal <code>(driverstore-1)*dtdriver</code> seconds or less where <code>dtdriver</code> is from the precursor simulation. If this time limit is exceeded the simulation will be stopped as there will be no more data available to determine the inlet.</li> <li>NOTE: It is important that buildings are not positioned too close to the downwind edge of the domain. The vortices and wakes downwind in the nearfield of the buildings can cause errors alongside the convective outflow boundary condition. The necessary distance is case specific. If this distance is too small a typical error will be that high velocities are found at the domain edge and these lead to slow simulations and dt tending to nought.</li> </ul>"},{"location":"udales-example-simulations/","title":"Example simulations","text":""},{"location":"udales-example-simulations/#example-simulations","title":"Example simulations","text":"<p>uDALES can simulate a large variety of urban case studies. Here we showcase a few examples (List of examples) with different atmospheric stabilities and various setups (overview in Table 1) to help you get started. The setups are in the <code>namoptions</code> file of your simulation. To maximise the benefit of these examples it is advised that you have the <code>namoptions</code> file open for the relevant simulation as you work through the example documentation.</p> <p>Note that we limited the simulation time to just a few minutes for demonstration, if you are looking to conduct realistic simulations, you need a much longer simulation time. If you wish to run all examples automatically and plot inputs and outputs as shown in this guide, follow the instructions detailed in the  development notes instead.</p>"},{"location":"udales-example-simulations/#prerequisites","title":"Prerequisites","text":"<p>All examples below assume that you have installed uDALES as per our Installation and First Run.</p> <p>Set up the paths and variables for running the simulation, for example with the following:</p> <pre><code># We assume you are running the following commands from your\n# top-level project directory.\n\nexport DA_TOOLSDIR=$(pwd)/u-dales/tools # Directory of scripts\nexport DA_BUILD=$(pwd)/u-dales/build/release/u-dales # Build file\nexport NCPU=2 # Number of CPUs to use for a simulation\nexport DA_WORKDIR=$(pwd)/outputs # Output top-level directory\n</code></pre>"},{"location":"udales-example-simulations/#run","title":"Run","text":"<p>Example cases are located under <code>u-dales/examples</code>.</p> <p>All examples are run using the following command:</p> <pre><code># We assume you are running the following commands from your\n# top-level project directory.\n\n# General syntax: local_execute.sh exp_directory\n./u-dales/tools/local_execute.sh examples/001\n</code></pre>"},{"location":"udales-example-simulations/#customising-simulations","title":"Customising simulations","text":"<p>If you want to make any changes to the example simulations, e.g. changing the domain size, follow the set-up steps in the \"Installation and First Run\" guide to obtain a copy of the simulation setup and make the changes to your copy of the setup. You may need to run some pre-processing steps (see Pre-processing) before running the simulation. These cases are indicated as such in Table 1.</p>"},{"location":"udales-example-simulations/#main-simulation-set-up-options","title":"Main simulation set-up options","text":"<p>Below is a list of common setups and options for urban case studies. A complete list of all options available with uDALES can be found in the Configuration document.</p> <p>Table 1: Main setups of urban case studies and reference example simulation(s).</p> Type Setting Requires pre-processing Example simulation Domain size and resolution yes all Domain warmstart no 102 Morphology no buildings yes 001 Morphology infinite canyon builings yes 101 Morphology aligned cuboid buildings yes 002, 949 Morphology staggered cuboid buildings yes 102 Morphology pre-defined buildings yes 201, 950 Forcing pressure gradient yes 001 Forcing volume flow rate no 101, 102, 949 Forcing Coriolis and nudging yes 201 Forcing driving data no 950 Lateral momentum boundary conditions (BCs) periodic no 001, 002, 101, 102, 201, 949 Lateral momentum BCs driving data no 950 Passive scalar source point source no 102 Passive scalar source line source no 101 Lateral scalar BCs periodic no 101, 949 Lateral scalar BCs inflow-outflow no 102 Surface and top scalar BCs constant flux no 102 Surface and top scalar BCs isothermal no 101, 949 Surface and top scalar BCs energy balance yes 201 Output instantaneous fields no 001, 101, 102, 201, 949 Output time-averaged fields no 201, 950 Output space-averaged (along x,y) profiles no 002, 101, 102, 201, 501, 950"},{"location":"udales-example-simulations/#list-of-examples","title":"List of examples","text":"<ul> <li>Standard simulation setup</li> <li>Neutral simulations</li> <li>001<ul> <li>No buildings, bottom surface roughness</li> <li>Constant pressure gradient</li> <li>Output: instantaneous fields</li> </ul> </li> <li>002<ul> <li>Aligned cuboid buildings</li> <li>Output: space-time averaged profiles</li> </ul> </li> <li>Non-neutral simulations</li> <li>101<ul> <li>Infinite canyon buildings </li> <li>Volume flow rate forcing in x</li> <li>Temperature</li> <li>Isothermal BC for temperature</li> <li>Passive scalars line source</li> <li>Output: instantaneous fields for temperature and scalars</li> </ul> </li> <li> <p>102</p> <ul> <li>Prerequisites for warmstart simulation </li> <li>Volume flow rate forcing in x</li> <li>Constant thermal flux BC for temperature</li> <li>Passive scalars point source</li> <li>Scalar inflow-outflow BC</li> <li>Warmstart </li> </ul> </li> <li> <p>Energy balance simulation</p> </li> <li>201<ul> <li>Pre-defined buildings </li> <li>Output: time averaged fields</li> <li>Energy Balance</li> <li>Moisture</li> <li>Coriolis forcing and nudging</li> </ul> </li> <li>Driver simulation</li> <li>949<ul> <li>Driver/precursor simulation</li> </ul> </li> <li>950<ul> <li>Prerequisites simulation with external forcing </li> <li>Driven simulation</li> </ul> </li> </ul>"},{"location":"udales-example-simulations/#standard-simulation-setup","title":"Standard simulation setup","text":"<p>The below setups are required for any type of simulation.</p> <p>The experiment number, run time and number of pencils in x and y (the product of which is the number of cores to be used):</p> <pre><code>&amp;RUN\niexpnr       = 001\nruntime      = 11.\nnprocx       = 2\nnprocy       = 2\n</code></pre> <p>The simulation domain varies amongst the example simulations. An example is given:</p> <pre><code>&amp;DOMAIN\nimax         = 64\njtot         = 64\nktot         = 64\nxsize        = 64\nysize        = 64\n&amp;INPS\nzsize        = 64\n</code></pre> <p>We also set an initial profile for u-wind velocity (and other variables if they are used) of e.g. u = 2 m/s by</p> <pre><code>&amp;INPS\nu0           = 2.\n</code></pre> <p>and add some random perturbations to the initial field, such that turbulence develops faster:</p> <pre><code>randu        = 0.01\n</code></pre> <p>Changes in the domain and initial profiles require pre-processing.</p> <p>Further, we recommend running the simulations with adaptive time-stepping, the Fast-Fourier-Transformation algorithm in the poisson solver (this will become default in the future) and using the Vreman sub-grid model:</p> <pre><code>&amp;RUN\nladaptive    = .true.\n&amp;DYNAMICS\nipoiss       = 0\n&amp;NAMSUBGRID\nlvreman      = .true.\n</code></pre> <p>Further information on these parameters is in the Namoptions overview, and more on the required pre-processing steps is found in Pre-processing.</p>"},{"location":"udales-example-simulations/#neutral-simulations","title":"Neutral simulations","text":""},{"location":"udales-example-simulations/#001","title":"001","text":""},{"location":"udales-example-simulations/#no-buildings-bottom-surface-roughness","title":"No buildings, bottom surface roughness","text":"<p>This simulation does not contain any buildings. Therefore we need to set:</p> <pre><code>&amp;WALLS\nnfcts = 0\nlbottom = .true.\n</code></pre> <p>A rough surface at the bottom is simulated by setting the following parameters:</p> <pre><code>&amp;BC\nthls         = 288.\nz0           = 0.01\nz0h          = 0.000067\n</code></pre> <p>where <code>z0</code> is the roughness length for momentum. Note that even though this is a neutral simulation, all of these parameters need to be specified to reasonable values. The simulation uses periodic lateral boundary conditions by default.</p>"},{"location":"udales-example-simulations/#constant-pressure-gradient","title":"Constant pressure gradient","text":"<p>A constant pressure gradient in x is set by</p> <pre><code>&amp;INPS\ndpdx         = 0.0001\n</code></pre>"},{"location":"udales-example-simulations/#output-instantaneous-fields","title":"Output: instantaneous fields","text":"<p>The simulation output contains the 3D instantaneous fields of u, v, and w. The output is produced after every 10 seconds of simulation runtime. We specify this by setting:</p> <pre><code>&amp;OUTPUT\nlfielddump   = .true.\nfieldvars    = 'u0,v0,w0'\ntfielddump   = 10.\n</code></pre>"},{"location":"udales-example-simulations/#002","title":"002","text":"<p>This simulation has a similar setup to <code>001</code> and additionally contains buildings.</p>"},{"location":"udales-example-simulations/#aligned-cuboid-buildings","title":"Aligned cuboid buildings","text":"<p>The simulation contains aligned cube-shaped buildings.</p> <p>The IBM must be turned on if buildings are included:</p> <pre><code>&amp;RUN\nlibm         = .true.\n</code></pre> <p>The corresponding number of facets, solid points (for the U, V, W and scalar grids), fluid boundary points and facet sections are automatically updated in <code>WALLS</code>  by the preprocessing routine:</p> <pre><code>&amp;WALLS\nnfcts = 1024\nnsolpts_u = 17408\nnsolpts_v = 17408\nnsolpts_w = 20480\nnsolpts_c = 16384\nnbndpts_u = 8576\nnbndpts_v = 8576\nnbndpts_w = 8448\nnbndpts_c = 8448\nnfctsecs_u = 10815\nnfctsecs_v = 10811\nnfctsecs_w = 7168\nnfctsecs_c = 10720\n</code></pre>"},{"location":"udales-example-simulations/#output-space-time-averaged-profiles","title":"Output: space-time averaged profiles","text":"<p>The simulation output contains 1D space-averaged and space-time-averaged vertical profiles. The output is produced after every 10 seconds of simulation runtime and the time-average uses a sample time step of 1 second. We specify this by setting:</p> <pre><code>&amp;OUTPUT\nlxytdump     = .true.\ntstatsdump   = 10.\ntsample      = 1.\n</code></pre>"},{"location":"udales-example-simulations/#non-neutral-simulations","title":"Non-neutral simulations","text":""},{"location":"udales-example-simulations/#101","title":"101","text":""},{"location":"udales-example-simulations/#infinite-canyon-buildings","title":"Infinite canyon buildings","text":"<p>This simulation has \"infinite canyons\" along the y-axis as buildings.</p>"},{"location":"udales-example-simulations/#volume-flow-rate-forcing-in-x","title":"Volume flow rate forcing in x","text":"<p>The simulation is driven by a fixed volume-flow rate forcing, which prescribes the domain-average velocity of u = 1.5 m/s:</p> <pre><code>&amp;PHYSICS\nluvolflowr   = .true.\nuflowrate    = 1.5\n</code></pre>"},{"location":"udales-example-simulations/#temperature","title":"Temperature","text":"<p>The simulation also considers changes in temperature. We therefore need to set</p> <pre><code>&amp;PHYSICS\nlbuoyancy    = .true.\nltempeq      = .true.\n</code></pre> <p>set an initial temperature profile (using the surface temperature <code>thl0</code> and the default lapse rate)</p> <pre><code>&amp;INPS\nthl0         = 290.\n</code></pre> <p>and specify the advection scheme for temperature:</p> <pre><code>&amp;DYNAMICS\niadv_thl     = 2\n</code></pre>"},{"location":"udales-example-simulations/#isothermal-bc-for-temperature","title":"Isothermal BC for temperature","text":"<p>The temperature on the facets is set by the values in <code>Tfacinit.f90</code> (295 K in this case). These temperatures do not change as the energy balance is not used as a default (<code>lEB = .false.</code>). A fixed temperature at the the top of the domain (<code>thl_top</code>) is set by</p> <pre><code>&amp;BC\nthl_top      = 295.\nBCtopT       = 2\n</code></pre> <p>The temperature flux between the building walls and surrounding air is determined by wall functions:</p> <pre><code>&amp;WALLS\niwalltemp    = 2\n</code></pre>"},{"location":"udales-example-simulations/#passive-scalars-line-source","title":"Passive scalars line source","text":"<p>A passive scalar line source is set by</p> <pre><code>&amp;SCALARS\nnsv          = 1\nlscasrcl     = .true.\nnscasrcl     = 1\n</code></pre> <p>the exact properties of the line are set as follows:</p> <pre><code>&amp;INPS\nxSb          = 32\nySb          = 0\nzSb          = 1\nxSe          = 32\nySe          = 64\nzSe          = 1\nSSl          = 1\nsigSl        = 0.5\n</code></pre> <p>The scalar advection scheme is also set:</p> <pre><code>&amp;DYNAMICS\niadv_sv      = 7\n</code></pre>"},{"location":"udales-example-simulations/#output-instantaneous-fields-for-temperature-and-scalars","title":"Output: instantaneous fields for temperature and scalars","text":"<p>We added the temperature and scalar concentration to the instantaneous fields:</p> <pre><code>&amp;OUTPUT\nfieldvars    = 'u0,v0,w0,th,s1'\n</code></pre>"},{"location":"udales-example-simulations/#102","title":"102","text":"Domain 3D output <p>The basic setup of this simulation is similar to <code>101</code>.</p>"},{"location":"udales-example-simulations/#prerequisites-for-warmstart-simulation","title":"Prerequisites for warmstart simulation","text":"<p>The simulation is continued from a previous simulation with a similar setup. The restart files (<code>initd</code> and <code>inits</code> for scalars) containing all relevant field data are saved in the example directory.</p>"},{"location":"udales-example-simulations/#warmstart","title":"Warmstart","text":"<p>A warmstart simulation requires setting</p> <pre><code>&amp;RUN\nlwarmstart   = .true.\nstartfile    = 'initd00000267_xxx_xxx.102'\n</code></pre> <p>where the name of the <code>startfile</code> needs to match the name of the restart files (xxx instead of processor number).</p> <p>For a warmstart containing scalar concentration fields you need to additionally set</p>"},{"location":"udales-example-simulations/#volume-flow-rate-forcing-in-x_1","title":"Volume flow rate forcing in x","text":"<p>The simulation is driven by a fixed volume-flow rate forcing:</p> <pre><code>&amp;PHYSICS\nluvolflowr   = .true.\nuflowrate    = 1.5\n</code></pre>"},{"location":"udales-example-simulations/#constant-thermal-flux-bc-for-temperature","title":"Constant thermal flux BC for temperature","text":"<p>The temperature is determined by a constant thermal flux from the roads, building roofs and the top of the domain (<code>iwalltemp = 1</code> by default):</p> <pre><code>&amp;BC\nwtsurf       = 0.01\nwttop        = -0.01\nbctfz        = 0.01\n</code></pre>"},{"location":"udales-example-simulations/#passive-scalars-point-source","title":"Passive scalars point source","text":"<p>The simulation contains a scalar field with a scalar point source. The nature of the source is given by:</p> <pre><code>&amp;SCALARS\nnsv          = 1\nlscasrc      = .true.\nnscasrc      = 1\nlreadscal    = .true.\n</code></pre> <p>Here <code>lreadscal</code> is necessary as we are running a warmstart.</p> <p>The position, strength and standard deviation of emission of the source are set by:</p> <pre><code>&amp;INP\nxS           = 4\nyS           = 8\nzS           = 3\nSSp          = 1\nsigSp        = 0.5\n</code></pre>"},{"location":"udales-example-simulations/#scalar-inflow-outflow-bc","title":"Scalar inflow-outflow BC","text":"<p>The scalar concentration is not determined by periodic boundary conditions like momentum and temperature, but leaves the domain at the outflow plane:</p> <pre><code>&amp;BC\nBCxs         = 2\n</code></pre> <p>The inlet profile is determined by the profile found in <code>scalar.inp.102</code> (defaults to 0. if unspecified)</p>"},{"location":"udales-example-simulations/#energy-balance-simulation","title":"Energy balance simulation","text":""},{"location":"udales-example-simulations/#201","title":"201","text":""},{"location":"udales-example-simulations/#pre-defined-buildings","title":"Pre-defined buildings","text":"<p>The buildings are read in by the preprocessing from a user provided STL file.</p>"},{"location":"udales-example-simulations/#output-time-averaged-fields","title":"Output: time averaged fields","text":"<p>We add 3D output fields that are averaged in time:</p> <pre><code>&amp;OUTPUT\nltdump       = .true.\n</code></pre>"},{"location":"udales-example-simulations/#energy-balance","title":"Energy Balance","text":"<p>The simulations solves the surface energy balance.</p> <pre><code>&amp;ENERGYBALANCE\nlEB          = .true.\nlconstW      = .true.\nlwriteEBfiles = .true.\ndtEB         = 2.\nbldT         = 301.0\nwsoil        = 314.0\nwgrmax       = 451.0\nwwilt        = 172.0\nwfc          = 314.0\nskyLW        = 395.0\nGRLAI        = 2.1\nrsmin        = 200.0\nnfaclyrs     = 5 \n</code></pre> <p>For that we also need to use wall functions for temperature and moisture at the building facets:</p> <pre><code>&amp;WALLS\niwalltemp    = 2\niwallmoist   = 2\n</code></pre>"},{"location":"udales-example-simulations/#moisture","title":"Moisture","text":"<p>The energybalance contains a latent heat flux and therefore we need to solve the full wet thermodynamics including moisture:</p> <pre><code>&amp;PHYSICS\nlmoist       = .true.\n</code></pre> <p>The advection scheme for moisture is specified by:</p> <pre><code>&amp;DYNAMICS\niadv_qt      = 2\n</code></pre> <p>and domain top- values are chosen:</p> <pre><code>&amp;BC\nqt_top       = 0.0\n</code></pre>"},{"location":"udales-example-simulations/#coriolis-forcing-and-nudging","title":"Coriolis forcing and nudging","text":"<p>A coriolis force is specified:</p> <pre><code>&amp;PHYSICS\nlcoriol      = .true.\n</code></pre> <p>The geostrophic velocity is defined by default as a uniform profile of the initial velocity:</p> <pre><code>&amp;INPS\nu0           = 1.5\n</code></pre> <p>Nudging is applied in the top 64 cells of the domain with a relaxation timescale of 10800 seconds:</p> <pre><code>&amp;PHYSICS\nlnudge       = .true.\ntnudge       = 10800.\nnnudge       = 64\n</code></pre>"},{"location":"udales-example-simulations/#driver-simulation","title":"Driver simulation","text":""},{"location":"udales-example-simulations/#949","title":"949","text":"<p>This simulation is similar to <code>101</code> but does not contain any scalars. It is used as the precursor simulation for simulation <code>949</code>.</p>"},{"location":"udales-example-simulations/#driverprecursor-simulation","title":"Driver/precursor simulation","text":"<p>To save the output of a simulation into files that can be read by another simulation as driver-inputs, we set:</p> <pre><code>&amp;DRIVER\nidriver      = 1\ntdriverstart = 100.\ndtdriver     = 1.\ndriverstore  = 101\niplane       = 256\n</code></pre> <p><code>iplane</code> sets the index of the y-z plane we store (here this is equal to the outlet plane), and <code>(driverstore-1)*dtdriver</code> determines for how long you can run the driven simulation. The time when we start recording the planes should therefore be <code>tdriverstart</code> &lt;= <code>runtime</code> - <code>(driverstore-1)*dtdriver</code>. More information on these parameters is in the documentation on simulation setup.</p>"},{"location":"udales-example-simulations/#950","title":"950","text":""},{"location":"udales-example-simulations/#prerequisites-simulation-with-external-forcing","title":"Prerequisites simulation with external forcing","text":"<p>The driver input files are included in the driver_files folder inside the 950 example folder.</p>"},{"location":"udales-example-simulations/#driven-simulation","title":"Driven simulation","text":"<p>This simulation is forced by the data from the stored outlet plane of simulation <code>949</code>:</p> <pre><code>&amp;DRIVER\nidriver      = 2\ndriverjobnr  = 949\ndriverstore  = 101\n</code></pre> <p>The runtime of this simulation is restricted by the simulation time of the driver output, which is <code>(driverstore-1)*dtdriver</code> of the precursor simulation <code>949</code>. The maximum runtime we can set is therefore</p> <pre><code>runtime      = 100.\ndtmax        = 1.\n</code></pre> <p>and we want to set <code>dtmax</code> = <code>dtdriver</code> (<code>501</code>) to avoid interpolation of the driver snapshots.</p> <p>All boundary conditions (momentum, temperature) are set to inflow-outflow by:</p> <pre><code>&amp;BC\nBCxm         = 3\nBCtopm       = 3\n</code></pre>"},{"location":"udales-facets-tutorial/","title":"Working with uDALES facet data in MATLAB","text":"<p>In this tutorial we cover how to work with uDALES facet data. This pertains to all surface quanties, e.g. shear stress, surface pressure, surface energy balance terms and the temperature inside each of the facets.</p> <p>The <code>udbase</code> post-processing class reads in most important input parameters, and contains a number of methods to work with facet data:</p> <ul> <li>calculate_frontal_properties. This method calculates the skylines, frontal areas and blockage ratios in the x- and y-direction.</li> <li>plot_bulding_ids. This method displays a 2d map with the building ids of the domain.</li> <li>plot_2dmap. This method displays a 2d map with coloring and optional labels.</li> <li>plot_fac_type. This method displays the type of surface for each facet.</li> <li>assign_prop_to_fac. This method assigns a property of the facet type to each of the facets, so it can be used for calculation and visualisation</li> <li>plot_fac. This method displays a surface variable on the surface mesh.</li> <li>load_fac_momentum. This method loads instantaneous momentum surface data from <code>fac.expnr.nc</code>. The first index is the facet id and second index is time.</li> <li>load_fac_eb. This method loads instantaneous surface energy balance data from <code>facEB.expnr.nc</code>. The first index is the facet id and second index is time.</li> <li>load_seb. This method loads all instantaneous surface energy balance terms. The first index is the facet id and second index is time.</li> <li>load_fac_temperature. This method loads instantaneous facet temperature data <code>facT.expnr.nc</code>. The first index is the facet id, the second is the layer index and the third index is time.</li> <li>area_average_seb. This method calculates the area-averaged surface energy balance from the facet surface energy balances obtained using <code>load_seb</code>.</li> <li>area_average_fac. This method performs area-averaging over (a selection of) the facets. The facet index is assumed to be the first index of the array.</li> <li>convert_facvar_to_field. This method transfers a facet variable onto the grid, so it can be used for post-processing.</li> <li>convert_facflx_to_field. This method converts a facet variable to a density in a 3D field, so it can be used for post-processing (e.g. calculating distributed drag).</li> </ul> <p>The live matlab file of this tutorial can be found in the repository in the folder /docs/tutorial_mlx.</p>"},{"location":"udales-facets-tutorial/#initialising-udbase","title":"Initialising udbase","text":"<p>The starting point of this tutorial is that you have run a simulation and have merged the output files. If the simulations were performed on a HPC system, we assume that you have copied the output directory to your own workstation. Some of the netCDF (*.nc) files may be very large and you may only want to copy these if you plan to analyse the data.</p> <p>Note that the uDALES/tools/matlab path must be added via the Set Path button in order to use the udbase class. Alternatively, it can be added using the addpath function inside the script (done here).</p> <pre><code>% preamble\nclear variables\nclose all\n\n% add the uDALES matlab path\naddpath('path_to_udales\\tools\\matlab')\n\n% create an instance of the udbase class\nexpnr = 065;\nexpdir = 'path_to_experiments\\065';\n\nsim = udbase(expnr, expdir);\n</code></pre>"},{"location":"udales-facets-tutorial/#calculate_frontal_properties-calculate-skyline-blockage-ratio-and-frontal-areas","title":"calculate_frontal_properties: calculate skyline, blockage ratio and frontal areas","text":"<pre><code>help sim.calculate_frontal_properties;\n</code></pre> <pre><code>--- help for udbase/calculate_frontal_properties ---\n\n  A method to calculate the skyline, frontal areas and blockage\n  ratios in the x- and y-direction.\n\n  res = calculate_frontal_properties(OBJ) executes the method\n                                and returns a structure with\n                                the skyline, frontal areas and\n                                blockage ratios in x- and\n                                y-direction.\n  Example:\n    res = obj.calculate_frontal_properties();\n</code></pre> <p>This method calculates the frontal areas and blockage ratios in the x- and y-direction. Here, the frontal area represents the surface area projected summed over each individual building in the domain. In order to calculate the blockage ratio, we first calculate the skyline (see below in black) and determine the fraction of the image that is not occupied by fluid (white).</p> <pre><code>res = sim.calculate_frontal_properties();\n</code></pre> <pre><code>x-direction: frontal area = 368.0 m2, blockage ratio = 0.090\ny-direction: frontal area = 208.0 m2, blockage ratio = 0.051\n</code></pre> <pre><code>res\n</code></pre> <pre><code>res = struct with fields:\n    skylinex: [64x64 double]\n    skyliney: [64x64 double]\n         Afx: 368\n         Afy: 208\n         brx: 0.0898\n         bry: 0.0508\n</code></pre> <p>Let's plot the skyline in the x- and y-direction</p> <pre><code>figure\nsubplot(1,2,1)\npcolor(sim.yt, sim.zt, res.skylinex')\nshading flat\ncolormap(flipud(colormap('gray')))\nxlabel('y [m]','Interpreter','latex')\nylabel('z [m]','Interpreter','latex')\nax = gca;\nax.TickLabelInterpreter = 'latex';\naxis equal tight\ntitle('skyline in x-direction')\n\nsubplot(1,2,2)\npcolor(sim.xt, sim.zt, res.skyliney')\nshading flat\ncolormap(flipud(colormap('gray')))\nxlabel('x [m]','Interpreter','latex')\nylabel('z [m]','Interpreter','latex')\naxis equal tight\nax = gca;\nax.TickLabelInterpreter = 'latex';\ntitle('skyline in y-direction')\n</code></pre> <p></p>"},{"location":"udales-facets-tutorial/#plot_building_ids-display-the-building-ids-in-the-domain","title":"plot_building_ids: display the building ids in the domain","text":"<pre><code>help sim.plot_building_ids\n</code></pre> <pre><code>--- help for udbase/plot_building_ids ---\n\n  A method for plotting building IDs from above (x,y view) with distinct colors\n\n  plot_building_ids(OBJ) creates a top-view plot showing buildings\n  in different colors with building IDs at center of gravity\n\n  SEE ALSO: udgeom.splitBuildings, plot_outline, plot_2dmap\n</code></pre> <p>This method displays the ids of the individual buildings inside the domain, buildings are numbered from left-bottom to right-top.</p> <pre><code>figure\nsim.plot_building_ids()\n</code></pre> <pre><code>Extracting individual buildings from STL geometry...\nGround preprocessing: removing ground faces using deleteGround\nGround preprocessing: 694 faces after deleteGround (removed 1964 ground faces)\nGround preprocessing: direct mapping provided by deleteGround\n\nBuilding separation completed:\n  Buildings identified: 2 separate components\n  Total building faces: 694\n  Largest building: 580 faces\n  Smallest building: 114 faces\n  Average faces per building: 347.0\nCreating face-to-building mapping: 694 faces, 2 components\nMapping 694 processed building assignments back to 2658 original faces\nSuccessfully mapped 694 faces to buildings\n</code></pre> <pre><code>xlim([0 sim.xlen])\nylim([0 sim.ylen])\n</code></pre> <p></p>"},{"location":"udales-facets-tutorial/#plot_2dmap-display-2dmap","title":"plot_2dmap: display 2dmap","text":"<pre><code>help sim.plot_2dmap\n</code></pre> <pre><code>--- help for udbase/plot_2dmap ---\n\n  Plot a 2D map of buildings colored by a value per building.\n\n  plot_2dmap(OBJ, val)\n    val: numeric scalar or vector with length equal to number of buildings.\n\n  plot_2dmap(OBJ, val, labels)\n    labels: optional cell or string array with labels to display at\n          the centroid of each building. If provided it must\n          match the number of buildings.\n</code></pre> <p>This plot creates maps showing the 2d building outline, together with some text</p> <pre><code>% get individual building information from the udgeom instance, the\n% buildings ids are ordered according to their centroid.\n\nbuildings = sim.geom.get_buildings();\n\n% calculate the maximum height for each building\nids = cell(length(buildings), 1);\nhmax = zeros(size(buildings));\nfor i = 1:length(buildings)\n    bld = buildings{i};\n    hmax(i) = max(bld.Points(:,3));\n    ids{i} = num2str(i);\nend\n\n% plot the result\nfigure\nsim.plot_2dmap(hmax, ids)\ncolorbar\nxlim([0 sim.xlen])\nylim([0 sim.ylen])\ntitle('maximum building height')\n</code></pre> <p></p> <p>The function <code>format_surface_plot</code> applies a consistent layout to the surface plots. Its implementation</p>"},{"location":"udales-facets-tutorial/#plot_fac_type-display-surface-types","title":"plot_fac_type: display surface types","text":"<pre><code>help sim.plot_fac_type\n</code></pre> <pre><code>--- help for udbase/plot_fac_type ---\n\n  A method for plotting the different surface types used in a\n  geometry.\n\n  plot_fac_type(OBJ) plots the surface types for all buildings\n\n  plot_fac_type(OBJ, building_ids) plots the surface types only for\n  the specified building IDs (array of positive integers)\n\n  Examples:\n    % Plot surface types for all buildings\n    obj.plot_fac_type();\n\n    % Plot surface types only for specific buildings\n    obj.plot_fac_type([1, 5, 10]);\n</code></pre> <p>When working with a surface energy balance model, each facet will have a specific wall type with its own properties (albedo, emissivity, thickness etc). The wall types of the geometry can be conveniently displayed using the method <code>plot_fac_type</code>:</p> <pre><code>figure\nsim.plot_fac_type()\nformat_surface_plot('', 'SkipColorbar', true)\n</code></pre> <p></p> <p>The function <code>format_surface_plot</code> applies a consistent layout to the surface plots. Its implementation is given at the end of the tutorial.</p>"},{"location":"udales-facets-tutorial/#assign_prop_to_fac-assigning-wall-properties-to-facets","title":"assign_prop_to_fac: assigning wall properties to facets","text":"<pre><code>help sim.assign_prop_to_fac\n</code></pre> <pre><code>--- help for udbase/assign_prop_to_fac ---\n\n  Method for assigning properties of a material (stored in\n  factypes) to each facet for visualisation or calculation..\n\n  assign_prop_to_fac(OBJ, strprop) assigns the property strprop\n                                   to the appropriate facet.\n\n  Example (assign albedo to each facet):\n    obj = udbase(expnr);\n    al = obj.assign_prop_to_fac('al');\n</code></pre> <p>The wall type of each facet assigns properties to it which are stored in the <code>factypes</code> structure.</p> <pre><code>sim.factypes\n</code></pre> <pre><code>ans = struct with fields:\n      id: [9x1 double]\n    name: [9x1 string]\n     lGR: [9x1 double]\n      z0: [9x1 double]\n     z0h: [9x1 double]\n      al: [9x1 double]\n      em: [9x1 double]\n       d: [9x5 double]\n       C: [9x5 double]\n     lam: [9x6 double]\n</code></pre> <p>Description:</p> <ul> <li><code>id</code>: type identifier</li> <li><code>name</code>: type name</li> <li><code>lGR</code>: boolean that indicates whether or not there is evaporation on the facet</li> <li><code>z0</code>: [m] momentum roughness length for wall-function</li> <li><code>z0h</code>: [m] heat roughness length for wall-function</li> <li><code>al</code>: [-] surface albedo</li> <li><code>em</code>: [-] surface emissivity</li> <li><code>d</code>: [m] thickness of each layer inside the facet</li> <li><code>C</code>: [J/m3K] volumetric heat capacity of each layer inside the facet.</li> <li><code>lam</code>: [W/mK] thermal conductivity on each cell face inside the facet.</li> </ul> <p>In order to assign these properties to each facet, use the method <code>assign_prop_to_fac</code>. For example, to assign the albedo to each surface facet:</p> <pre><code>albs = sim.assign_prop_to_fac('al');\n</code></pre>"},{"location":"udales-facets-tutorial/#plot_fac-plot-facet-quantities","title":"plot_fac: plot facet quantities","text":"<pre><code>help sim.plot_fac\n</code></pre> <pre><code>--- help for udbase/plot_fac ---\n\n  A method for plotting a facet variable var as a 3D surface\n\n  plot_fac(OBJ, var) plots variable var for all facets\n\n  plot_fac(OBJ, var, building_ids) plots variable var only for\n  the specified building IDs (array of positive integers)\n\n  Examples:\n    % Plot net shortwave radiation for all buildings\n    obj.plot_fac(K);\n\n    % Plot only for specific buildings\n    obj.plot_fac(K, [1, 5, 10]);\n</code></pre> <p>We can now plot the albedo using the method <code>plot_fac</code>.</p> <pre><code>figure\nsim.plot_fac(albs)\nformat_surface_plot('$\\alpha$ [-]')\nclim([0, 0.5])\nxlim([0 sim.xlen])\nylim([0 sim.ylen])\n</code></pre> <p></p> <p>Note that we can also choose to plot only the information for building 1.</p> <pre><code>figure\nsim.plot_fac(albs, 1)\nformat_surface_plot('$\\alpha$ [-]')\nclim([0, 0.5])\nxlim([0 sim.xlen])\nylim([0 sim.ylen])\n</code></pre> <p></p> <p>... or for both buildings:</p> <pre><code>figure\nsim.plot_fac(albs, [1 2])\nformat_surface_plot('$\\alpha$ [-]')\nclim([0, 0.5])\nxlim([0 sim.xlen])\nylim([0 sim.ylen])\n</code></pre> <p></p>"},{"location":"udales-facets-tutorial/#load_fac_momentum-load-facet-pressure-and-shear-stresses","title":"load_fac_momentum: load facet pressure and shear stresses","text":"<pre><code>help sim.load_fac_momentum\n</code></pre> <pre><code>--- help for udbase/load_fac_momentum ---\n\n  A method to retrieve facet data for pressure and shear\n  information from the fac file.  \n\n  load_fac_momentum(OBJ) displays the variables in the file\n\n  load_fac_momentum(OBJ, svar) retrieves a variable from the file\n\n  Example (view contents of output):\n    obj = udbase(expnr);\n    obj.load_fac_momentum();\n</code></pre> <p>Surface information about shear and pressure can be obtained using the method <code>load_fac_momentum</code>. Calling it without parameters shows the data inside the file:</p> <pre><code>sim.load_fac_momentum;\n</code></pre> <pre><code>Contents of fac.065.nc:\n    Name               Description              Units      Size       Dimensions\n    _____    _______________________________    _____    _________    __________\n\n    cth      heat transfer coefficient (Ivo)             2658x1000    fct, time\n    fct      Facet number                                2658         fct\n    htc      heat transfer coefficient                   2658x1000    fct, time\n    pres     pressure                            Pa      2658x1000    fct, time\n    t        Time                                s       1000         time\n    tau_x    tau_x                               Pa      2658x1000    fct, time\n    tau_y    tau_y                               Pa      2658x1000    fct, time\n    tau_z    tau_z                               Pa      2658x1000    fct, time\n</code></pre> <p>Now we load the pressure data using the <code>load_fac_momentum</code> method and visualise it using the <code>plot_fac</code> method.</p> <pre><code>pres = sim.load_fac_momentum('pres');\n\nfigure\nsim.plot_fac(pres(:,end))\nformat_surface_plot('$p$ [m$^{2}$s$^{-2}$]')\n</code></pre> <p></p>"},{"location":"udales-facets-tutorial/#load_fac_eb-load-term-from-the-surface-energy-balance","title":"load_fac_eb: load term from the surface energy balance","text":"<pre><code>help sim.load_fac_eb\n</code></pre> <pre><code>--- help for udbase/load_fac_eb ---\n\n  A method to retrieve facet data of a surface energy balance\n  term from the facEB file.\n\n  load_fac_eb(OBJ) displays the variables in the file\n\n  load_fac_eb(OBJ, svar) retrieves a variable from the file\n\n  Example (view contents of output):\n    obj = udbase(expnr);\n    obj.load_fac_eb();\n</code></pre> <p>l<code>oad_fac_eb</code> is a low-level routine that reads individual variables from the surface energy balance file <code>facEB.expnr.nc</code>. It is recommended to use the method <code>load_seb</code> which loads all surface energy balance terms at the same time.</p> <p>The variables in <code>facEB.expnr.nc</code> are:</p> <pre><code>sim.load_fac_eb();\n</code></pre> <pre><code>Contents of facEB.065.nc:\n    Name        Description       Units       Size       Dimensions\n    _____    _________________    _____    __________    __________\n\n    LWin     Incoming longwave    W/m^2    2658x10020    fct, time\n    LWout    Outgoing longwave    W/m^2    2658x10020    fct, time\n    WGR      Water content        ?        2658x10020    fct, time\n    ef       Latent heat          W/m^2    2658x10020    fct, time\n    fct      Facet number                  2658          fct\n    hf       Sensible heat        W/m^2    2658x10020    fct, time\n    netsw    Net shortwave        W/m^2    2658x10020    fct, time\n    t        Time                 s        10020         time\n</code></pre> <p>Let's load and plot the net shortwave radiation at the end time</p> <pre><code>Kstar = sim.load_fac_eb('netsw');\n\nfigure\nsim.plot_fac(Kstar(:,end))\nformat_surface_plot('$K^*$ [Wm$^{-2}$]')\n</code></pre> <p></p>"},{"location":"udales-facets-tutorial/#load_seb-load-all-surface-energy-balance-terms","title":"load_seb: load all surface energy balance terms","text":"<pre><code>help sim.load_seb\n</code></pre> <pre><code>--- help for udbase/load_seb ---\n\n  A method to retrieve all surface energy balance terms on each\n  of the facets as a function of time.\n\n  load_seb(OBJ) loads the terms in the surface energy balance.\n\n  Example:\n    obj = udbase(expnr);\n    obj.load_seb();\n</code></pre> <p>the method <code>load_seb</code> loads all energy balance terms including surface temperature at once and is the preferred way of working with terms in the surface energy balance.</p> <pre><code>seb = sim.load_seb()\n</code></pre> <pre><code>seb = struct with fields:\n    Kstar: [2658x10020 single]\n    Lstar: [2658x10020 single]\n      Lin: [2658x10020 single]\n     Lout: [2658x10020 single]\n        H: [2658x10020 single]\n        E: [2658x10020 single]\n        G: [2658x10020 single]\n    Tsurf: [2658x10020 single]\n        t: [10020x1 single]\n</code></pre> <p>Let's plot all components of the surface energy balance at the last timestep</p> <pre><code>figure\nsubplot(3,2,1)\nsim.plot_fac(seb.Kstar(:,end))\nformat_surface_plot('$K^*$ [Wm$^{-2}$]')\nsubplot(3,2,2)\nsim.plot_fac(seb.Lstar(:,end))\nformat_surface_plot('$L^*$ [Wm$^{-2}$]')\nsubplot(3,2,3)\nsim.plot_fac(seb.H(:,end))\nformat_surface_plot('$H$ [Wm$^{-2}$]')\nsubplot(3,2,4)\nsim.plot_fac(seb.E(:,end))\nformat_surface_plot('$E$ [Wm$^{-2}$]')\nsubplot(3,2,5)\nsim.plot_fac(seb.G(:,end))\nformat_surface_plot('$G$ [Wm$^{-2}$]')\nsubplot(3,2,6)\nsim.plot_fac(seb.Tsurf(:,end))\nformat_surface_plot('$T_{surf}$ [K]')\n</code></pre> <p></p>"},{"location":"udales-facets-tutorial/#load_fac_temperature-load-temperatures-inside-facets","title":"load_fac_temperature: load temperatures inside facets","text":"<pre><code>help sim.load_fac_temperature\n</code></pre> <pre><code>--- help for udbase/load_fac_temperature ---\n\n  A method to retrieve temperature and temperature gradient\n  data from the facT file.\n\n  load_fac_temperature(OBJ) displays the variables in the file\n\n  load_fac_temperature(OBJ, svar) retrieves a variable from the file\n\n  Example (view contents of output):\n    obj = udbase(expnr);\n    obj.load_fac_temperature();\n</code></pre> <p>The following information is available about the temperature inside facets:</p> <pre><code>sim.load_fac_temperature();\n</code></pre> <pre><code>Contents of facT.065.nc:\n    Name         Description         Units        Size          Dimensions  \n    ____    _____________________    _____    ____________    ______________\n\n    T       Temperature               K       2658x6x10020    fct, lyr, time\n    dTdz    Temperature gradient      K/m     2658x6x10020    fct, lyr, time\n    fct     Facet number                      2658            fct\n    lyr     Number of wall layers             6               lyr\n    t       Time                      s       10020           time\n</code></pre> <p>This data can be used to explore what goes on inside each facet. As an example, let's plot the time-evolution of temperature inside facet 1:</p> <pre><code>% load time, temperature data and layer thicknesses\nt = sim.load_fac_temperature('t');\nT = sim.load_fac_temperature('T');\nd = sim.assign_prop_to_fac('d'); % retrieve facet layer thicknesses\n\nfacid = 1;\ntsel = t(1:1000:end);\nTsel = squeeze(T(facid, :, 1:1000:end));\nx = [0, cumsum(d(facid, :))]; % temperature is defined on cell faces\n\nfigure\nhold on\nleg = cell(size(tsel));\nfor n = 1:length(tsel)\n    plot(x, Tsel(:, n), 'LineWidth', 1)\n    leg{n} = ['$t=', num2str(tsel(n), '%8.0f'), '$ s'];\nend\nl = legend(leg);\nbox on\nl.Interpreter = 'latex';\nxlabel('$x$ [m]','Interpreter','latex')\nylabel('$T$ [K]','Interpreter','latex')\nax = gca;\nax.TickLabelInterpreter = 'latex';\ntitle('Temperature inside facet 1')\n</code></pre> <p></p>"},{"location":"udales-facets-tutorial/#area_average_seb-perform-area-averaging-of-the-surface-energy-balance-terms","title":"area_average_seb: perform area-averaging of the surface energy balance terms","text":"<pre><code>help sim.area_average_seb\n</code></pre> <pre><code>--- help for udbase/area_average_seb ---\n\n  A method for calculating the area-averaged surface energy\n  balance.\n\n  area_average_seb(OBJ, seb) averages the variables in seb over the\n  area.\n\n  Example:\n    obj = udbase(expnr);\n    seb = obj.load_seb()\n    seb_av = obj.area_average_seb(seb);\n</code></pre> <p>This method converts the facet-by-facet surface energy balance to an area-averaged surface energy balance.</p> <pre><code>seb_av = sim.area_average_seb(seb)\n</code></pre> <pre><code>seb_av = struct with fields:\n    Kstar: [461.2403 461.2403 461.2403 461.2403 461.2403 461.2403 461.2403 461.2403 461.2403 461.2403 461.2147 461.2147 461.2147 461.2147 461.2147 461.2147 461.2147 461.2147 461.2147 461.2147 461.2147 461.2147 461.2147 461.2147 \u2026 ] (1x10020 single)\n    Lstar: [-61.3138 -61.3469 -61.3852 -61.4188 -61.4530 -61.4909 -61.5253 -61.5605 -61.5961 -61.6331 -61.3138 -61.3469 -61.3852 -61.4188 -61.4530 -61.4909 -61.5252 -61.5604 -61.5961 -61.6331 -61.3138 -61.3469 -61.3852 -61.4188 \u2026 ] (1x10020 single)\n      Lin: [373.6797 373.6832 373.6863 373.6898 373.6931 373.6962 373.6998 373.7029 373.7063 373.7097 373.6797 373.6832 373.6863 373.6898 373.6931 373.6962 373.6998 373.7029 373.7063 373.7096 373.6797 373.6832 373.6863 373.6898 \u2026 ] (1x10020 single)\n     Lout: [434.9932 435.0301 435.0715 435.1083 435.1460 435.1872 435.2253 435.2637 435.3025 435.3427 434.9932 435.0299 435.0714 435.1081 435.1460 435.1872 435.2255 435.2637 435.3022 435.3427 434.9932 435.0299 435.0714 435.1081 \u2026 ] (1x10020 single)\n        H: [0.7807 3.6902 7.5545 10.5529 11.8296 11.1453 10.0029 9.9542 10.1124 10.3147 0.7807 3.6902 7.5545 10.5530 11.8298 11.1455 10.0029 9.9541 10.1123 10.3149 0.7807 3.6902 7.5545 10.5530 11.8298 11.1455 10.0029 9.9541 10.1123 \u2026 ] (1x10020 single)\n        E: [25.9738 16.7287 16.5153 16.3215 16.1434 15.9498 15.7488 15.5422 15.2622 15.0522 25.9738 16.7313 16.5179 16.3240 16.1458 15.9522 15.7511 15.5444 15.2642 15.0543 25.9738 16.7313 16.5179 16.3240 16.1458 15.9522 15.7511 \u2026 ] (1x10020 single)\n        G: [373.2034 379.5020 375.8164 372.9749 371.8422 372.6852 373.9917 374.2121 374.2988 374.2705 373.1778 379.4739 375.7881 372.9467 371.8143 372.6568 373.9637 374.1846 374.2715 374.2426 373.1778 379.4739 375.7881 372.9467 \u2026 ] (1x10020 single)\n        t: [10020x1 single]\n</code></pre> <p>Check that the surface energy balance terms sum to zero:</p> <pre><code>max(abs(seb_av.Kstar+seb_av.Lstar-seb_av.H-seb_av.E-seb_av.G))\n</code></pre> <pre><code>ans = single0.0313\n</code></pre> <p>This value is very small compared to the mean incoming short-wave radiation on the facets (~400 W/m2) and we therefore conclude that the surface energy balance closes. We now create a plot of the area-averaged surface energy balance.</p> <pre><code>figure()\nhold on\nplot(seb_av.t,seb_av.Kstar, seb_av.t,seb_av.Lstar, seb_av.t,seb_av.H, ...\n     seb_av.t,seb_av.E, seb_av.t,seb_av.G, 'LineWidth',1);\nxlim([0,seb_av.t(end)])\nl = legend('$K^*$','$L^*$','$H$','$E$','$G$');\nbox on\nl.Interpreter = 'latex';\nxlabel('$t$ [s]','Interpreter','latex')\nylabel('$\\langle F \\rangle_s$ [Wm$^{-2}$]','Interpreter','latex')\nax = gca;\nax.TickLabelInterpreter = 'latex';\ntitle('Area-averaged surface energy balance')\n</code></pre> <p></p> <p>Note that this is an average over the surface. In order to obtain the surface energy balances typically used in meteorology, we will need to project this onto a flat ground using a factor f=A_{3D} /A_{2D}, where A_{3D} is the total surface area and A_{2D} is the projected surface area (height x width of the domain).</p> <pre><code>% Define a factor f = A3D/A2D.\nf = sum(sim.facs.area)/(sim.xlen*sim.ylen);\n\n% Upon multiplying the area-averaged SEB with f, the SEB represents a\n% projected-area-averaged SEB term as typically presented in meteorological\n% applications.  \n\nfigure()\nhold on\nplot(seb_av.t,f*seb_av.Kstar, seb_av.t,f*seb_av.Lstar, seb_av.t,f*seb_av.H, ...\n     seb_av.t,f*seb_av.E, seb_av.t,f*seb_av.G, 'LineWidth',1);\nxlim([0,seb_av.t(end)])\nl = legend('$K^*$','$L^*$','$H$','$E$','$G$');\nbox on\nl.Interpreter = 'latex';\nxlabel('$t$ [s]','Interpreter','latex')\nylabel('$F$ [Wm$^{-2}$]','Interpreter','latex')\nax = gca;\nax.TickLabelInterpreter = 'latex';\ntitle('Standard surface energy balance')\n</code></pre> <p></p>"},{"location":"udales-facets-tutorial/#area_average_fac-area-averaging-over-facet-data","title":"area_average_fac: area-averaging over facet data","text":"<pre><code>help sim.area_average_fac;\n</code></pre> <pre><code>--- help for udbase/area_average_fac ---\n\n  A method for area-averaging a facet quantity, either over all\n  facets or over a selection.\n\n  area_average_fac(OBJ, var) area-averages variable var over\n  all facets.\n\n  area_average_fac(OBJ, var, sel) area-averages variable var\n  over the facet indices in sel\n\n  Example:\n    K_av = obj.area_average_fac(K);\n</code></pre> <p>This method performs area-averaging, either over all facets or over a selection of facets.</p> <p>Below we provide a non-trivial example on how to this method can be used to obtain a surface energy balance for the sidewalls in the domain. The sidewalls will be selected by using that the z-component of the surface normal has to be zero:</p> <pre><code>% Select side walls\nnorms = sim.geom.stl.faceNormal;\nfac_ids = find(abs(norms(:, 3)) &lt; 1e-6);\n\n% a quick visual check\nI = zeros(size(sim.facs.area));\nI(fac_ids) = 1;\n\nfigure\nsim.plot_fac(I)\nformat_surface_plot('')\n</code></pre> <p></p> <p>This looks correct. We can now calculate and plot the area-averaged surface energy balance on the side-walls.</p> <pre><code>Kav_side = sim.area_average_fac(seb.Kstar, fac_ids);\nLav_side = sim.area_average_fac(seb.Lstar, fac_ids);\nHav_side = sim.area_average_fac(seb.H, fac_ids);\nEav_side = sim.area_average_fac(seb.E, fac_ids);\nGav_side = sim.area_average_fac(seb.G, fac_ids);\n\nfigure()\nhold on\nplot(seb.t,Kav_side, seb.t,Lav_side, seb.t,Hav_side, ...\n     seb.t,Eav_side, seb.t,Gav_side, 'LineWidth',1);\nxlim([0,seb_av.t(end)])\nl = legend('$K^*$','$L^*$','$H$','$E$','$G$');\nbox on\nl.Interpreter = 'latex';\nxlabel('$t$ [s]','Interpreter','latex')\nylabel('$\\langle F \\rangle_s$ [Wm$^{-2}$]','Interpreter','latex')\nax = gca;\nax.TickLabelInterpreter = 'latex';\ntitle('Area-averaged surface energy balance for sidewalls')\n</code></pre> <p></p> <pre><code>% average over entire time-range, merge short-term time average to\n% long-term\n% see utility_tutorial for functions merge_stat_var and so on\n[Havt, ~] = merge_stat(seb.H, zeros(size(seb.H)), length(seb.t));\n\nfigure\nsubplot(1,2,1)\nsim.plot_fac(Havt)\nformat_surface_plot('$H$ [Wm$^{-2}$]')\ncolorbar off\nsubplot(1,2,2)\nsim.plot_fac(Havt)\nformat_surface_plot('$H$ [Wm$^{-2}$]')\ncolorbar off\n</code></pre> <p></p>"},{"location":"udales-facets-tutorial/#convert_facvar_to_field-convert-facet-data-to-grid","title":"convert_facvar_to_field: convert facet data to grid","text":"<pre><code>help sim.convert_facvar_to_field\n</code></pre> <pre><code>--- help for udbase/convert_facvar_to_field ---\n\n  Method for transferring a facet variable onto the grid.\n\n  Inputs:\n    var:     facet variable (e.g. from load_fac_eb, load_fac_temperature, etc)\n    facsec:  facet section structure (e.g. obj.facsec.u)\n    building_ids (optional): array of building IDs to include. If not\n                             specified, all buildings are included.\n\n  Outputs:\n    fld:     variable on the grid (itot x jtot x ktot)\n\n  The facsec and dz inputs are required since the routine does not know where % on the staggered grid the variable is located.\n\n  convert_facvar_to_field(OBJ, var, facsec) transfers a variable onto the grid.\n\n  convert_facvar_to_field(OBJ, var, facsec, building_ids) converts only\n                                 facets from the specified building IDs.\n\n  Examples:\n    % Convert all facets\n    fld = obj.convert_facvar_to_field(var, sim.facsec.c);\n\n    % Convert only specific buildings\n    fld = obj.convert_facvar_to_field(var, sim.facsec.c, [1, 5, 10]);\n</code></pre> <p>This function assigns facet data to the grid, which is useful for some averaging and visualisation methods. For example, we can show the time-averaged surface temperature for buildings 1 and 2 and visualise the associated 3D grid locations:</p> <pre><code>Tsav   = merge_stat(squeeze(T(:,1,:)), zeros(size(squeeze(T(:,1,:)))), length(seb.t));\nTsgrid = sim.convert_facvar_to_field(Tsav,sim.facsec.c, [1 2]);\n\n% Get the (x, y, z) coordinates of non-zero elements\n[i, j, k] = ind2sub(size(Tsgrid), find(abs(Tsgrid) &gt; 0));\nx = sim.xt(i); y = sim.yt(j); z = sim.zt(k);\n\n% Get the corresponding values\nvalues = Tsgrid(abs(Tsgrid) &gt; 0);\n\n% Plot the data using scatter3\nfigure;\nscatter3(x, y, z, 24, values, 'filled');\nformat_surface_plot('$T_s$ [K]');\n</code></pre> <p></p>"},{"location":"udales-facets-tutorial/#convert_facflx_to_field-convert-facet-data-to-3d-density-field","title":"convert_facflx_to_field: convert facet data to 3D density field","text":"<pre><code>help sim.convert_facflx_to_field\n</code></pre> <pre><code>--- help for udbase/convert_facflx_to_field ---\n\n  Method for converting a facet variable to a density in a 3D\n  field.\n\n  Inputs:\n    var:     facet flux variable (e.g. from load_fac_eb, load_fac_temperature, etc)\n    facsec:  facet section structure (e.g. obj.facsec.u)\n    dz:      vertical grid spacing at cell centers (obj.dzt)\n    building_ids (optional): array of building IDs to include. If not\n                             specified, all buildings are included.\n\n  Outputs:\n    fld:     3D field density (itot x jtot x ktot)\n\n  The facsec and dz inputs are required since the routine does not know where % on the staggered grid the variable is located.\n\n  convert_facflx_to_field(OBJ, var, facsec, dz) converts the facet variable var  \n                                 to a 3D field density for all facets.\n\n  convert_facflx_to_field(OBJ, var, facsec, dz, building_ids) converts only\n                                 facets from the specified building IDs.\n\n  Examples:\n    % Convert all facets\n    fld = obj.convert_facflx_to_field(var, sim.facsec.c, sim.dzt);\n\n    % Convert only specific buildings\n    fld = obj.convert_facflx_to_field(var, sim.facsec.c, sim.dzt, [1, 5, 10]);\n</code></pre> <p>This function assigns facet data to a density in a 3D field, which is useful for assessing plane-average distributed stresses [1] as well as the multi-scale analysis proposed by Van Reeuwijk and Huang [2]. For example, we can convert the time-averaged heat flux Havt to a 3d density field as follows.</p> <pre><code>rhoH = sim.convert_facflx_to_field(Havt,sim.facsec.c,sim.dzt);\n\n% let's check whether the integrals of the 2D and 3D fields match:\ns = 0;\nfor k = 1:size(rhoH, 3)\n    s = s + sum(sum(rhoH(:,:,k)*sim.dx*sim.dy*sim.dzt(k)));\nend\n\n% calculate the relative error\nabs(s - sum(Havt .* sim.facs.area)) / s\n</code></pre> <pre><code>ans = single9.4734e-08\n</code></pre> <p>The relative error is extremely small which shows that the total amount of heat added to the domain is equivalent in both cases. Let's visualise the density field:</p> <pre><code>% Get the (x, y, z) coordinates of non-zero elements\n[i, j, k] = ind2sub(size(rhoH), find(abs(rhoH) &gt; 0));\nx = sim.xt(i); y = sim.yt(j); z = sim.zt(k);\n\n% Get the corresponding values\nvalues = rhoH(abs(rhoH) &gt; 0);\n\n% Plot the data using scatter3\nfigure;\nscatter3(x, y, z, 24, values, 'filled');\nformat_surface_plot('$\\rho_{H}$ [Wm$^{-3}$]');\n</code></pre> <p></p> <p>Here, we note that it is a coincidence that the values of the sensible heat flux density \\rho_{H\\;} are similar to those of the heat flux \\bar{H\\;} itself, despite their units being different.</p> <p>We can also select specific buildings:</p> <pre><code>rhoH = sim.convert_facflx_to_field(Havt,sim.facsec.c,sim.dzt, [1, 2]);\n% Get the (x, y, z) coordinates of non-zero elements\n[i, j, k] = ind2sub(size(rhoH), find(abs(rhoH) &gt; 0));\nx = sim.xt(i); y = sim.yt(j); z = sim.zt(k);\n\n% Get the corresponding values\nvalues = rhoH(abs(rhoH) &gt; 0);\n\n% Plot the data using scatter3\nfigure;\nscatter3(x, y, z, 24, values, 'filled');\nformat_surface_plot('$\\rho_{H}$ [Wm$^{-3}$]');\n</code></pre> <p></p> <p>To calculate the horizontally-average heat flux density, we can simply average over the horizontal directions.</p> <pre><code>rhoH = sim.convert_facflx_to_field(Havt,sim.facsec.c,sim.dzt);\nfH = squeeze(mean(mean(rhoH, 1), 2));\nfigure\nplot(fH, sim.zt, 'LineWidth',1);\nbox on\nylabel('$z$ [m]','Interpreter','latex')\nxlabel('$f_H$ [Wm$^{-3}$]','Interpreter','latex')\nax = gca;\nax.TickLabelInterpreter = 'latex';\ntitle('Distributed heat flux')\n</code></pre> <p></p>"},{"location":"udales-facets-tutorial/#function-to-format-surface-plots","title":"Function to format surface plots","text":"<p>This auxiliary function is used to ensure a consistent layout of all surface plots in this tutorial.</p> <pre><code>function format_surface_plot(strvar, varargin)\n    % Parse optional parameters\n    p = inputParser;\n    addParameter(p, 'SkipColorbar', false, @islogical);\n    parse(p, varargin{:});\n\n    % Apply standard formatting\n    view(-25,30)\n    xlabel('$x$ [m]','Interpreter','latex')\n    ylabel('$y$ [m]', 'Interpreter','latex')\n    zlabel('$z$ [m]','Interpreter','latex')\n    ax = gca;\n    ax.TickLabelInterpreter = 'latex';\n    axis equal\n\n    % Only create/modify colorbar if not skipped\n    if ~p.Results.SkipColorbar\n        c = colorbar;\n        c.Label.String = strvar;\n        c.Label.Interpreter = 'latex';\n        c.TickLabelInterpreter = 'latex';\n    end\nend\n</code></pre>"},{"location":"udales-facets-tutorial/#references","title":"References","text":"<p>[1] Suetzl BS, Rooney GG,  van Reeuwijk M (2020). Drag Distribution in Idealized Heterogeneous Urban Environments. Bound-Lay. Met. 178, 225-248.</p> <p>[2] Maarten van Reeuwijk, Jingzi Huang (2025) Multi-scale Analysis of Flow over Heterogeneous Urban Environments, Bound-Lay. Met. 191, 47.</p>"},{"location":"udales-fields-tutorial/","title":"Working with uDALES field data in MATLAB","text":"<p>This tutorial describes how to read and process field data output of the LES code uDALES using MATLAB. In addition, it describes some important concepts, such as the grid layout, variable locations and averaging procedures.</p> <p>The <code>udbase</code> post-processing class reads in most important input parameters, and contains a number of methods to load field data:</p> <ul> <li>load_stat_xyt. This method load the 1D slab- and time-averaged statistics from the file <code>xytdump.expnr.nc</code>. Several time-intervals may be present in the data.</li> <li>load_stat_t. This method loads the 3D time-averaged statistics from the file <code>tdump.expnr.nc</code>. Several time-intervals may be present in the data.</li> <li>load_stat_tree. This method loads the 3D time-averaged statistics of the tree source terms from the file <code>treedump.expnr.nc</code>. This method works exactly the same way as <code>load_stat_t</code>.</li> <li>load_field. This method loads instantaneous 3D data from the file <code>fielddump.expnr.nc</code>. Several output times may be present in the data.</li> <li>load_slice. This method loads instantaneous 2D slices of instantaneous 3D data from the file <code>Xslicedump.expnr.nc</code>. Several output times may be present in the data.</li> <li>plot_trees. This method plots tree patches.</li> </ul> <p>The live matlab file of this tutorial can be found in the repository in the folder /docs/tutorial_mlx.</p>"},{"location":"udales-fields-tutorial/#initialising-udbase","title":"Initialising udbase","text":"<p>The starting point of this tutorial is that you have run a simulation and have merged the output files. If the simulations were performed on a HPC system, we assume that you have copied the output directory to your own workstation. Some of the netCDF (*.nc) files may be very large and you may only want to copy these if you plan to analyse the data.</p> <p>Note that the uDALES/tools/matlab path must be added via the Set Path button in order to use the udbase class. Alternatively, it can be added using the addpath function inside the script (done here).</p> <pre><code>% preamble\nclear variables\nclose all\n\n% add the uDALES matlab path\naddpath('path_to_udales\\tools\\matlab')\n\n% create an instance of the udbase class\nexpnr = 110;\nexpdir = 'path_to_experiments\\110';\nsim = udbase(expnr, expdir);\n</code></pre> <pre><code>Warning: prof.inp.110 not found. Assuming equidistant grid.\n</code></pre>"},{"location":"udales-fields-tutorial/#udales-grid-layout","title":"uDALES grid layout","text":"<p>uDALES uses a grid that is staggered, which means that not all variables are defined at the same location on the grid. Staggering is computationally advantageous [1], but requires care with plotting, as it is imporant to plot variables in their correct location. uDALES' grid layout is as follows.</p> <pre><code>% 2D view of staggered grid arrangement\n% (x-z direction; grid layout in other directions is identical)\n%\n%                           w(i,j,k+1)\n%                               ^\n% zm(k+1) --            --------|--------\n%                       |               |\n%                       |   c(i,j,k)    |\n%   zt(k) --  u(i,j,k) ---&gt;     o      ---&gt; u(i+1,j,k)\n%                       |               |\n%                       |       ^       |\n%   zm(k) --            --------|--------\n%                           w(i,j,k)\n%\n%                       |       |       |\n%                     xm(i)   xt(i)   xm(i+1)\n%\n%   Coordinate positions (assuming z-grid is equidistant)\n%   xm(i) = (i-1) * dx;     xt(i) = (i-1/2) * dx\n%   ym(j) = (j-1) * dy;     yt(j) = (j-1/2) * dy\n%   zm(k) = (k-1) * dz;     zt(k) = (k-1/2) * dz\n%\n%   Grid increments:\n%   dzt(k) = zm(k+1) - zm(k)\n%   dzm(k) = zt(k) - zt(k-1)\n%\n%   Note that z does not have to be equidistant.\n</code></pre> <p>There are six arrays for the coordinates:</p> <ul> <li><code>xm.</code> x-coordinate of cell edges</li> <li><code>xt.</code> x-coordinate of cell centres</li> <li><code>ym.</code> y-coordinate of cell edges</li> <li><code>yt.</code> y-coordinate of cell centres</li> <li><code>zm.</code> z-coordinate of cell edges</li> <li><code>zt.</code> z-coordinate of cell centres</li> </ul> <p>The field variables are defined as follows</p> <ul> <li><code>u(i,j,k)</code> is the u-velocity at location <code>(xm(i),yt(j),zt(k))</code></li> <li><code>v(i,j,k)</code> is the v-velocity at location <code>(xt(i),ym(j),zt(k))</code></li> <li><code>w(i,j,k)</code> is the w-velocity at location <code>(xt(i),yt(j),zm(k))</code></li> <li><code>c(i,j,k)</code> is a scalar quantity at location <code>(xt(i),yt(j),zt(k))</code> </li> </ul> <p>Scalars (potential temperature, specific humidity, pollutants) are always defined in the cell-centre. Fluxes are typically defined on the cell edges.</p> <p>You can always look up where the variables are defined from the output variable information using the load.. methods.</p>"},{"location":"udales-fields-tutorial/#averages-used-in-udales-output","title":"Averages used in uDALES output","text":"<p>Many of the outputs of uDALES have been averaged in some manner. This is advantageous as these are often the quantities we are interested in, and also require much less diskspace and memory to process.</p> <p>The Reynolds decomposition is used to decompose variables into mean quantities and their fluctuations [2]:</p> <p>\\varphi \\left(x,y,z,t\\right)=\\bar{\\varphi \\;} \\left(x,y,z\\right)+\\varphi {\\;}^{\\prime } \\left(x,y,z,t\\right),</p> <p>where the overbar denotes time-averaging. The time-averaged data is contained in the <code>tdump.expnr.nc</code> file.</p> <p>Often, we are interested in the quantities that are additionally averaged in the horizontal plane. This is often referred to as a slab average.  In this case it is common to further decompose the time-averaged quantity \\bar{\\varphi} into a spatial average \\langle \\bar{\\varphi} \\rangle \\left(z\\right) (i.e., average over the horizontal surface)  and its spatial variation \\bar{\\varphi} \\textrm{\"}\\left(x,y,z\\right)=\\bar{\\varphi} \\left(x,y,z\\right)-\\langle \\bar{\\varphi} \\rangle \\left(z\\right). Upon substituting this expression into the equation above, we obtain the triple decomposition [3]:</p> <p>\\varphi \\left(x,y,z,t\\right)=\\langle \\bar{\\varphi} \\rangle \\left(z\\right)+\\bar{\\varphi} \\textrm{\"}\\left(x,y,z\\right)\\;+\\varphi^{\\prime } \\left(x,y,z,t\\right).</p> <p>Here, \\langle \\bar{\\varphi \\;} \\rangle is an intrinsic average, defined as [3]</p> <p>$$ \\langle \\bar{\\varphi} \\rangle \\;\\left(z\\right)=\\frac{1}{A_f }\\int_{\\Omega_{f\\;} } \\varphi \\;\\mathrm{dA} $$</p> <p>where A_f \\left(z\\right) is the area occupied by fluid and \\Omega_f is the horizontal surface that is occupied by the fluid. The quantity \\langle \\bar{\\varphi} \\rangle represents the average value of \\bar{\\varphi} inside the fluid between the buildings. Another commonly used quantity is the comprehensive average \\langle \\bar{\\varphi} \\rangle_C, which is defined as</p> <p>$$ \\langle \\bar{\\varphi} \\rangle_C \\left(z\\right)=\\frac{1}{A}\\int_{\\Omega_{f\\;} } \\varphi \\;\\mathrm{dA}=\\frac{A_f }{A}\\langle \\bar{\\varphi} \\rangle \\left(z\\right) $$</p> <p>where A is the total surface area. In many cases, it is more convenient to work with comprehensive averages than intrinsic averages, particularly when considering averaged budgets of momentum, temperature etc [3]. To convert the intrinsic-average output from uDALES into a comprehensive average, simply multiply the intrinsic average by A_f /A as shown above. Time and intrinsically-averaged data is contained in the <code>xytdump.expnr.nc</code> file.</p>"},{"location":"udales-fields-tutorial/#load_stat_xyt-loading-time-and-slab-averaged-data","title":"load_stat_xyt: loading time- and slab-averaged data","text":"<pre><code>help sim.load_stat_xyt\n</code></pre> <pre><code>--- help for udbase/load_stat_xyt ---\n\n  A method to retrieve plane- and time-averaged 1D statistics\n  information from the xytdump file.  \n\n  load_stat_xyt(OBJ) displays the variables in the xytdump file\n\n  load_stat_xyt(OBJ, svar) retrieves a variable from the xytdump file\n\n  Example (view contents of output):\n    obj = udbase(expnr);\n    obj.load_stat_xyt();\n</code></pre> <p>This method loads a single output variable <code>var</code> at a time. In order to understand which variables are present in the output file, call the method without input arguments.</p> <pre><code>sim.load_stat_xyt();\n</code></pre> <pre><code>Contents of xytdump.110.nc:\n       Name                     Description                  Units     Size     Dimensions\n    ___________    _____________________________________    _______    _____    __________\n\n    pxyt           Pressure                                 kgm/s^2    256x3     zt, time\n    qtxyt          Moisture                                 kg/kg      256x3     zt, time\n    thlpthlptxy    Temp. variance                           K^2        256x3     zt, time\n    thlsgsxyt      SGS heat flux                            K m/s      256x3     zm, time\n    thlxyt         Temperature                              K          256x3     zt, time\n    time           Time                                     s          3         time\n    tketxyc        tke                                      m^2/s^2    256x3     zt, time\n    upuptxyc       u variance                               m^2/s^2    256x3     zt, time\n    upvpxyt        Turbulent mom. flux                      m^2/s^2    256x3     zm, time\n    upwpxyt        Turbulent mom. flux                      m^2/s^2    256x3     zm, time\n    usgsxyt        SGS mom. flux                            m^2/s^2    256x3     zm, time\n    uvxyt          Kinematic mom. flux                      m^2/s^2    256x3     zm, time\n    uwxyt          Kinematic mom. flux                      m^2/s^2    256x3     zm, time\n    uxyt           Streamwise velocity                      m/s        256x3     zt, time\n    vpvptxyc       v variance                               m^2/s^2    256x3     zt, time\n    vpwpxyt        Turbulent mom. flux                      m^2/s^2    256x3     zm, time\n    vsgsxyt        SGS mom. flux                            K m/s      256x3     zm, time\n    vwxyt          Kinematic mom. flux                      m^2/s^2    256x3     zm, time\n    vxyt           Spanwise velocity                        m/s        256x3     zt, time\n    wpthlpxyt      Turbulent heat flux                      K m/s      256x3     zm, time\n    wpwptxyc       w variance                               m^2/s^2    256x3     zt, time\n    wthlxyt        Kinematic heat flux                      K m/s      256x3     zm, time\n    wwxyt          Kinematic mom. flux                      m^2/s^2    256x3     zm, time\n    wxyt           Vertical velocity                        m/s        256x3     zm, time\n    zm             Vertical displacement of cell edges      m          256       zm\n    zt             Vertical displacement of cell centers    m          256       zt\n</code></pre> <p>Before showing how to display the data, we note that the variable <code>'time'</code> has a size <code>1</code> \\times <code>3</code>. Let's load the data to see what is inside.</p> <pre><code>txyt = sim.load_stat_xyt('time')\n</code></pre> <pre><code>txyt = 3x1 single column vector\n1.0e+03\n2.0001\n4.0001\n6.0001\n</code></pre> <p>There are three times at which output has been generated. This can be understood by considering the input parameter values</p> <pre><code>sim.tstatsdump\n</code></pre> <pre><code>ans = 2000\n</code></pre> <pre><code>sim.runtime\n</code></pre> <pre><code>ans = 6002\n</code></pre> <p>Therefore, the entire runtime is divided into 3 time intervals, in each of which the time average is taken.</p> <p>The vertical coordinate z and mean streamwise velocity \\langle \\bar{u} \\rangle can be loaded as:</p> <pre><code>zm   = sim.load_stat_xyt('zm');\nuxyt = sim.load_stat_xyt('uxyt');\n</code></pre> <p>Since \\langle \\bar{u} \\rangle is the streamwise velocity, it is defined in the vertical cell-center and should thus be plotted against <code>zm</code>. We plot \\langle \\bar{u} \\rangle for each averaging time interval below.</p> <pre><code>tstart = 0;\nleg = cell(size(txyt)); % create a cell array to store each of the legend entries\nfigure\nhold on\nfor n = 1:length(txyt)\n    plot(uxyt(:, n), zm, 'Linewidth', 1);\n    leg{n} = ['$t=', num2str(tstart, '%8.0f'), '-', num2str(txyt(n), '%8.0f'), '$s'];\n    tstart = txyt(n);\nend\nhold off\nbox on\nylabel ('$z$ [m]', 'Interpreter', 'latex')\nxlabel ('$\\langle \\overline{u} \\rangle$ [m/s]', 'Interpreter', 'latex')\nlegend(leg, 'Location','northwest', 'Interpreter', 'latex')\n</code></pre> <p></p> <p>As can be seen, during the first time-interval, the flow is substantially slower than in the other two intervals, suggesting an initial transient. Although the profiles for last two time-intervals are close, they are not identical showing that either the flow has not equilibriated entirely, or the chosen averaging time-interval was too small, or both.</p> <p>Using the continuity equation it can be shown that for period domains \\langle \\bar{w} \\rangle =0, which also implies that \\langle \\bar{w} \\textrm{\"}\\rangle =0. This means that the dispersive momentum flux \\langle \\bar{u\\;} \\textrm{\"}\\bar{w\\;} \\textrm{\"}\\rangle is equal to \\langle \\bar{\\;u} \\;\\bar{\\;w} \\rangle. Thus, we can load the mean turbulent horizontal momentum flux \\langle \\bar{u^{\\prime } w^{\\prime } } \\rangle and dispersive flux \\langle \\bar{u\\;} \\textrm{\"}\\bar{w\\;} \\textrm{\"}\\rangle can be loaded as:</p> <pre><code>zt      = sim.load_stat_xyt('zt');      % location of vertical fluxes of horizontal momentum\nupwpxyt = sim.load_stat_xyt('upwpxyt'); % turbulence fluxes (p indicates prime)\nuwxyt   = sim.load_stat_xyt('uwxyt');   % dispersive fluxes\n</code></pre> <p>Note that these terms should be plotted against against <code>zt</code> (cell center) since they represent the vertical exchange of horizontal momentum. Again, we plot the averages for each time interval (now we can do this more compactly as we do not need to create the legend entries):</p> <pre><code>figure\nsubplot(1,3,1);\nplot(upwpxyt, zt, 'LineWidth',1);\nxlabel ('$\\langle \\overline{u^\\prime w^\\prime} \\rangle$ [m$^2$/s$^2$]', ...\n    'Interpreter', 'latex')\nylabel ('$z$ [m]', 'Interpreter', 'latex')\nxlim([-0.5 0])\n\nsubplot(1,3,2);\nplot(uwxyt, zt, 'LineWidth',1);\nxlabel (['$\\langle \\overline{u}^{\\prime\\prime} \\overline{w}^{\\prime\\prime} \\rangle$' ...\n    ' [m$^2$/s$^2$]'], 'Interpreter', 'latex')\nxlim([-0.5 0])\n\nsubplot(1,3,3);\nplot(uwxyt+upwpxyt, zt, 'LineWidth',1);\nxlabel (['$\\langle \\overline{u^\\prime w^\\prime} \\rangle+\\langle \\overline{u}^{\\prime\\prime} \\overline{w}^{\\prime\\prime} \\rangle$' ...\n    ' [m$^2$/s$^2$]'], 'Interpreter', 'latex')\nxlim([-0.5 0])\nlegend(leg, 'Location','northwest', 'Interpreter', 'latex')\n</code></pre> <p></p> <p>To interpret this data, it is easiest to start with the right-most figure which plots the sum of the dispersive and turbulent fluxes. In a steady state (and for a simulation with a constant pressure gradient of average velocity), we expect this quantity to form a straight line, which is the case for the last two time-intervals. The data are also nearly collapsing for the last two time-intervals, once more suggesting that these flows are close to a statistical steady state.</p> <p>The turbulent and dispersive fluxes show substantial variation for all three curves, showing that much longer averaging is needed to obtain reliable statistics for these quantities [4].</p>"},{"location":"udales-fields-tutorial/#load_stat_t-loading-time-averaged-data","title":"load_stat_t: loading time-averaged data","text":"<pre><code>help sim.load_stat_t\n</code></pre> <pre><code>--- help for udbase/load_stat_t ---\n\n  A method to retrieve time-averaged statistics from the tdump file\n\n  load_stat_t(OBJ) displays the variables in the tdump file\n\n  load_stat_t(OBJ, svar) retrieves a variable from the tdump file\n\n  Example (view contents of output):\n    obj = udbase(expnr);\n    obj.load_stat_t();\n</code></pre> <p>The time-averaged field data is stored in the <code>tdump.expnr.nc</code> file. The variables it contains can be listed as:</p> <pre><code>sim.load_stat_t();\n</code></pre> <pre><code>Contents of tdump.110.nc:\n       Name                      Description                    Units         Size            Dimensions\n    ___________    ________________________________________    _______    _____________    ________________\n\n    PSS            PSS defect                                  gm/s       128x128x256x3    xt, yt, zt, time\n    pt             Pressure                                    kgm/s^2    128x128x256x3    xt, yt, zt, time\n    qtt            Moisture                                    kg/kg      128x128x256x3    xt, yt, zt, time\n    sca1psca1pt    Concentration variance 1                    g^2/m^6    128x128x256x3    xt, yt, zt, time\n    sca1t          Concentration field 1                       g/m^3      128x128x256x3    xt, yt, zt, time\n    sca2psca2pt    Concentration variance 2                    g^2/m^6    128x128x256x3    xt, yt, zt, time\n    sca2t          Concentration field 2                       g/m^3      128x128x256x3    xt, yt, zt, time\n    sca3psca3pt    Concentration variance 3                    g^2/m^6    128x128x256x3    xt, yt, zt, time\n    sca3t          Concentration field 3                       g/m^3      128x128x256x3    xt, yt, zt, time\n    sca4psca4pt    Concentration variance 4                    g^2/m^6    128x128x256x3    xt, yt, zt, time\n    sca4t          Concentration field 4                       g/m^3      128x128x256x3    xt, yt, zt, time\n    sv1sgs         SGS flux 1                                  gm/s       128x128x256x3    xt, yt, zm, time\n    sv2sgs         SGS flux 2                                  gm/s       128x128x256x3    xt, yt, zm, time\n    sv3sgs         SGS flux 3                                  gm/s       128x128x256x3    xt, yt, zm, time\n    sv4sgs         SGS flux 4                                  gm/s       128x128x256x3    xt, yt, zm, time\n    thlpthlpt      Temperature variance                        K^2        128x128x256x3    xt, yt, zt, time\n    thlt           Temperature                                 K          128x128x256x3    xt, yt, zt, time\n    time           Time                                        s          3                time\n    tketc          TKE                                         m^2/s^2    128x128x256x3    xt, yt, zt, time\n    upuptc         u variance                                  m^2/s^2    128x128x256x3    xt, yt, zt, time\n    upvpt          Turbulent momentum flux                     m^2/s^2    128x128x256x3    xm, ym, zt, time\n    upwpt          Turbulent momentum flux                     m^2/s^2    128x128x256x3    xm, yt, zm, time\n    ut             Streamwise velocity                         m/s        128x128x256x3    xm, yt, zt, time\n    vpvptc         v variance                                  m^2/s^2    128x128x256x3    xt, yt, zt, time\n    vpwpt          Turbulent momentum flux                     m^2/s^2    128x128x256x3    xt, ym, zm, time\n    vt             Spanwise velocity                           m/s        128x128x256x3    xt, ym, zt, time\n    wpsca1pt       Turbulent flux 1                            gm/s       128x128x256x3    xt, yt, zm, time\n    wpsca2pt       Turbulent flux 2                            gm/s       128x128x256x3    xt, yt, zm, time\n    wpsca3pt       Turbulent flux 3                            gm/s       128x128x256x3    xt, yt, zm, time\n    wpsca4pt       Turbulent flux 4                            gm/s       128x128x256x3    xt, yt, zm, time\n    wpthlpt        Turbulent heat flux                         K m/s      128x128x256x3    xt, yt, zm, time\n    wpwptc         w variance                                  m^2/s^2    128x128x256x3    xt, yt, zt, time\n    wt             Vertical velocity                           m/s        128x128x256x3    xt, yt, zm, time\n    xm             West-East displacement of cell edges        m          128              xm\n    xt             West-East displacement of cell centers      m          128              xt\n    ym             South-North displacement of cell edges      m          128              ym\n    yt             South-North displacement of cell centers    m          128              yt\n    zm             Vertical displacement of cell edges         m          256              zm\n    zt             Vertical displacement of cell centers       m          256              zt\n</code></pre> <p>We load the time-averaged streamwise velocity field u, and the coordinates it relates to. Note that the appropriate coordinate arrays are listed in the 'Dimensions' column above.</p> <pre><code>ut = sim.load_stat_t('ut');\ntt = sim.load_stat_t('time');\nxm = sim.load_stat_t('xm'); % we are interested in plotting u  \nyt = sim.load_stat_t('yt');\nzt = sim.load_stat_t('zt');\n</code></pre> <p>We plot a horizontal slice at the mean building height <code>z=10m</code>, choosing to use the statistics of the last time-interval</p> <pre><code>% find the k-index closest to z=10 m\nzloc = 10;\nk = find(abs(zt - zloc) == min(abs(zt - zloc)), 1);\n\n% choose last time interval\nn = length(tt);\n\nfigure\npcolor(xm, yt, squeeze(ut(:,:,k,n))');\nshading flat; axis equal tight; colorbar\nxlabel('$x$ [m]', 'Interpreter','latex')\nylabel('$y$ [m]', 'Interpreter','latex')\ntitle(['$\\overline u(x, y, z=', num2str(zt(k), '%8.1f'), 'm)$; no NaNs'], 'Interpreter','latex')\n</code></pre> <p></p> <p>You can see that where the buildings are, the velocity is zero. However, since this is a solid domain, you will want to remove these from the plot. You can use the arrays  <code>Su, Sv, Sw</code> and <code>Sc</code> in the sim object for this, which are 3D boolean matrices that indicate the cells contain buildings as true. There are four different arrays since the grid is staggered. We are dealing with the u-velocity, so will use the array <code>Su</code>. In order to do so, we can simply set the cells that contain solid elements to <code>NaN</code>.</p> <pre><code>curut = ut(:,:,:,n);\ncurut(sim.Su) = NaN;\n\nfigure\npcolor(xm, yt, squeeze(curut(:,:,k))');\nshading flat; axis equal tight; colorbar\nxlabel('$x$ [m]', 'Interpreter','latex')\nylabel('$y$ [m]', 'Interpreter','latex')\ntitle(['$\\overline u(x, y, z=', num2str(zt(k), '%8.1f'), 'm)$'], 'Interpreter','latex')\n</code></pre> <p></p> <p>Similarly, we can plot a vertical slice in the middle of the y-domain as follows.</p> <pre><code>j = sim.jtot/2+1; % select the index in the middle of the domain span\n\nfigure\npcolor(xm, zt, squeeze(curut(:,j,:))');\nshading flat; axis equal tight; colorbar\nxlabel('$x$ [m]', 'Interpreter','latex')\nylabel('$z$ [m]', 'Interpreter','latex')\ntitle(['$\\overline u(x, y=', num2str(yt(j), '%8.1f'), 'm, z)$'], 'Interpreter','latex')\n</code></pre> <p></p>"},{"location":"udales-fields-tutorial/#load_field-loading-instantaneous-3d-data","title":"load_field: loading instantaneous 3D data","text":"<pre><code>help sim.load_field\n</code></pre> <pre><code>--- help for udbase/load_field ---\n\n   A method to retrieve instantaneous 3D data from from the fielddump file.\n\n   load_field(OBJ) displays the variables in the fielddump file\n\n   load_field(OBJ, svar) retrieves variable svar from the fielddump file\n\n   Example (view contents of output):\n     obj = udbase(expnr);\n     obj.load_field();\n</code></pre> <p>The instantaneous field data is stored in the field<code>dump.expnr.nc</code> file, again, the variables it contains can be listed as:</p> <pre><code>sim.load_field();\n</code></pre> <pre><code>Contents of fielddump.110.nc:\n    Name                  Description                   Units        Size            Dimensions\n    ____    ________________________________________    _____    _____________    ________________\n\n    time    Time                                         s       3                time\n    u       West-East velocity                           m/s     128x128x256x3    xm, yt, zt, time\n    v       South-North velocity                         m/s     128x128x256x3    xt, ym, zt, time\n    w       Vertical velocity                            m/s     128x128x256x3    xt, yt, zm, time\n    xm      West-East displacement of cell edges         m       128              xm\n    xt      West-East displacement of cell centers       m       128              xt\n    ym      South-North displacement of cell edges       m       128              ym\n    yt      South-North displacement of cell centers     m       128              yt\n    zm      Vertical displacement of cell edges          m       256              zm\n    zt      Vertical displacement of cell centers        m       256              zt\n</code></pre> <p>The variable <code>time</code> contains the times at which output is written. Let's load the data to see which times these are</p> <pre><code>t = sim.load_field('time')\n</code></pre> <pre><code>t = 3x1 single column vector\n1.0e+03\n2.0000\n4.0000\n6.0000\n</code></pre> <p>These times can be understood by noticing that the output interval requested in the input file is</p> <pre><code>sim.tfielddump\n</code></pre> <pre><code>ans = 2000\n</code></pre> <p>We load the data, once more using the horizontal velocity</p> <pre><code>u  = sim.load_field('u');\nxm = sim.load_field('xm');\nyt = sim.load_field('yt');\nzt = sim.load_field('zt');\n</code></pre> <p>We plot the instantaneous horizontal velocity at the same locations as in the previous section using the last output time</p> <pre><code>n = length(t); % choose last output time\n\n% set the u-value inside buildings to NaN\ncuru = u(:,:,:,n);\ncuru(sim.Su) = NaN;\n\nfigure\npcolor(xm, yt, squeeze(curu(:,:,k))');\nshading flat; axis equal tight; colorbar\nxlabel('$x$ [m]', 'Interpreter','latex')\nylabel('$y$ [m]', 'Interpreter','latex')\ntitle(['$u(x, y, z=', num2str(zt(k), '%8.1f'), 'm, t=', num2str(t(n), '%8.0f'),'s)$'], 'Interpreter','latex')\n</code></pre> <p></p> <pre><code>figure\npcolor(xm, zt, squeeze(curu(:,j,:))');\nshading flat; axis equal tight; colorbar\nxlabel('$x$ [m]', 'Interpreter','latex')\nylabel('$y$ [m]', 'Interpreter','latex')\ntitle(['$u(x, y, z=', num2str(zt(k), '%8.1f'), 'm, t=', num2str(t(n), '%8.0f'),'s)$'], 'Interpreter','latex')\n</code></pre> <p></p>"},{"location":"udales-fields-tutorial/#load_slice-loading-instantaneous-2d-slice-data","title":"load_slice: loading instantaneous 2D slice data","text":"<pre><code>help sim.load_slice\n</code></pre> <pre><code>--- help for udbase/load_slice ---\n\n  A method to retrieve instantaneous 2D slices from from the slicedump file.\n\n  load_slice(obj) displays information, option chooses plane.\n\n  load_slice(obj, ...)\n\n  Example (view contents of output of horizontal slice):\n     obj = udbase(expnr);\n     obj.load_slice('k');\n</code></pre> <p>The instantaneous slice data is stored in the <code>Xslicedump.expnr.nc</code> file. This file contains particular slices of the 3D instantaneous data, which makes this data particularly suitable for creating animations since the output frequency can be much higher than for 3D fields as the filesize will remain much more manageable.</p> <p>uDALES is capable of outputting slices along the <code>x</code>, <code>y</code> or <code>z</code>-direction. In this particular simulation, we requested to output horizontal slices (fixed height in vertical direction using an index <code>kslice</code>, e.g., <code>zm(kslice)</code>) using the input parameter:</p> <pre><code>sim.lkslicedump\n</code></pre> <pre><code>ans = 1\n</code></pre> <p>at index</p> <pre><code>sim.kslice\n</code></pre> <pre><code>ans = 21\n</code></pre> <p>and output instantaneous slices at time-intervals</p> <pre><code>sim.tsample\n</code></pre> <pre><code>ans = 3\n</code></pre> <p>The first argument to the load_slice method is the slice direction:</p> <ul> <li>'<code>i</code>': vertical slices taken at fixed <code>x</code>. Outputs data that is a function of <code>y,z</code> and <code>t</code>.</li> <li>'<code>j</code>': vertical slices taken at fixed <code>y</code>. Outputs data that is a function of <code>x,z</code> and <code>t</code>.</li> <li>'<code>k</code>': horizontal slices taken at fixed <code>z</code>. Outputs data that is a function of <code>x,y</code> and <code>t</code>.</li> </ul> <p>To list all the variables stored in <code>kslicedump.expnr.nc</code>, we use</p> <pre><code>sim.load_slice('k');\n</code></pre> <pre><code>Contents of kslicedump.110.nc:\n       Name                     Description                   Units        Size         Dimensions\n    __________    ________________________________________    _____    ____________    ____________\n\n    qt_kslice     Specific humidity at kslice                   -      128x128x1979    xt, yt, time\n    thl_kslice    Potential temperature at kslice               -      128x128x1979    xt, yt, time\n    time          Time                                          s      1979            time\n    u_kslice      Streamwise velocity at kslice                 -      128x128x1979    xm, yt, time\n    v_kslice      Spanwise velocity at kslice                   -      128x8x1979      xt, ym, time\n    w_kslice      Vertical velocity at kslice                   -      128x128x1979    xt, yt, time\n    xm            West-East displacement of cell edges          m      128             xm\n    xt            West-East displacement of cell centers        m      128             xt\n    yt            South-North displacement of cell centers      m      128             yt\n</code></pre> <p>This horizontal slice is at <code>z = zm(sim.kslice)</code> or <code>z = zt(sim.kslice)</code>, depending on the variable.</p> <p>To load the data, we specify the variables we wish to load:</p> <pre><code>xm = sim.load_slice('k', 'xm');\nyt = sim.load_slice('k', 'yt');\nuk = sim.load_slice('k', 'u_kslice');\nt  = sim.load_slice('k', 'time');\n</code></pre> <p>We plot this horizontal slice of the instantaneous velocity at the last output time:</p> <pre><code>n = length(t); % choose the last time-step\n\n% Replace the data at building locations with NaNs\ncuru = squeeze(uk(:,:,n));\ncuru(squeeze(sim.Su(:,:,sim.kslice))) = NaN;\n\n% note that the squeeze command is not formally needed here, but they will\n% be needed when considering i and j slices.\n\n% plot the data\nfigure\npcolor(xm, yt, curu');\nshading flat; axis equal tight;\nxlabel('$x$ [m]', 'Interpreter','latex')\nylabel('$y$ [m]', 'Interpreter','latex')\ncolorbar\ntitle(['$u(x,y,z=', num2str(zm(sim.kslice), '%8.1f'), 'm, t=', num2str(t(n), '%8.0f'), 's)$'], 'Interpreter','latex')\n</code></pre> <p></p>"},{"location":"udales-fields-tutorial/#load_stat_tree-and-plot_tree-loading-and-plotting-tree-data","title":"load_stat_tree and plot_tree: loading and plotting tree data","text":"<p>We next switch to a tree simulation to show the tree functions example</p> <pre><code>clear variables;\nexpnr = 525;\nexpdir = 'path_to_experiments\\525';\n\nsim = udbase(expnr, expdir);\n</code></pre> <pre><code>Warning: One or more solid_(u,v,w,c).525 files not found.\n</code></pre> <p>The trees patches can be plotted using</p> <pre><code>sim.plot_trees;\n</code></pre> <p></p> <p>The time-averaged tree source data is stored in the <code>treedump.expnr.nc</code> file. The variables it contains can be listed as:</p> <pre><code>help sim.load_stat_tree\n</code></pre> <pre><code>--- help for udbase/load_stat_tree ---\n\n  A method to retrieve time-averaged statistics of the tree\n  source terms from the treedump file\n\n  load_stat_tree(OBJ) displays the variables in the treedump file\n\n  load_stat_tree(OBJ, svar) retrieves a variable from the treedump file\n\n  Example (view contents of output):\n    obj = udbase(expnr);\n    obj.load_stat_tree();\n</code></pre> <pre><code>sim.load_stat_tree();\n</code></pre> <pre><code>Contents of treedump.525.nc:\n      Name                    Description                    Units         Size           Dimensions\n    ________    ________________________________________    _______    ____________    ________________\n\n    time        Time                                        s          4               time\n    tr_omega    Decoupling factor                           -          512x256x64x4    xt, yt, zt, time\n    tr_qt       Moisture source sink                        1/s        512x256x64x4    xt, yt, zt, time\n    tr_qtA      Moisture source sink                        1/s        512x256x64x4    xt, yt, zt, time\n    tr_qtR      Moisture source sink                        1/s        512x256x64x4    xt, yt, zt, time\n    tr_sv1      Scalar source sink                          kg/m^3s    512x256x64x4    xt, yt, zt, time\n    tr_sv2      Scalar source sink                          kg/m^3s    512x256x64x4    xt, yt, zt, time\n    tr_thl      Temp source/ sink                           K/s        512x256x64x4    xt, yt, zt, time\n    tr_u        Drag in x                                   m/s^2      512x256x64x4    xt, yt, zt, time\n    tr_v        Drag in y                                   m/s^2      512x256x64x4    xt, yt, zt, time\n    tr_w        Drag in z                                   m/s^2      512x256x64x4    xt, yt, zm, time\n    xt          West-East displacement of cell centers      m          512             xt\n    yt          South-North displacement of cell centers    m          256             yt\n    zm          Vertical displacement of cell edges         m          64              zm\n    zt          Vertical displacement of cell centers       m          64              zt\n</code></pre>"},{"location":"udales-fields-tutorial/#references","title":"References","text":"<p>[1] Ferziger JH, Peric M (1999) Computational methods for fluid dynamics (3<sup>rd</sup> ed.). Springer.</p> <p>[2] Oke TR, Mills G, Christen A, Voogt JA (2017) Urban Climates. Cambridge University Press.</p> <p>[3] Schmid M, Lawrence GA, Parlange MB, Giometto MG (2019) Volume averaging for urban canopies. Bound-Lay. Met. 173, 349-372.</p> <p>[4] Suetzl BS, Rooney GG,  van Reeuwijk M (2020) Drag Distribution in Idealized Heterogeneous Urban Environments. Bound-Lay. Met. 178,225-248.</p>"},{"location":"udales-geometry-tutorial/","title":"uDALES urban surface creation","text":"<p>uDALES supports several manners to create urban surfaces. It is possible to run uDALES without specifying an urban surface, in which case a flat terrain is assumed. In most cases however, an urban surface will be specified. uDALES contains a number of functions in the udgeom package that aid geometry generation:</p> <ul> <li>udgeom.createFlatSurface. This function creates a flat surface. The main reason for using this function is to be able to discretise the surface in as many facets as possible in case heterogeneous boundary conditions are required.</li> <li>udgeom.createCanyons. This function creates one-dimensional street canyons.</li> <li>udgeom.createCubes. This function creates cubes, either a single one or an array of cubes.</li> <li>udgeom.createRealistic. This function creates a realistic urban surface based on an stl file that contains the buildings. The function adds the ground surface.</li> </ul> <p>The live matlab file of this tutorial can be found in the repository in the folder /docs/tutorial_mlx.</p>"},{"location":"udales-geometry-tutorial/#initialising-udbase","title":"Initialising udbase","text":"<p>Note that the uDALES/tools/matlab path must be added via the Set Path button in order to use the udgeom package. Alternatively, it can be added using the addpath function inside the script (done here).</p> <pre><code>% preamble\nclear variables\nclose all\n\n% add the uDALES matlab path\naddpath('path_to_udales\\tools\\matlab')\n</code></pre>"},{"location":"udales-geometry-tutorial/#the-udgeom-class","title":"The udgeom class","text":"<p>The udgeom class contains the uDALES urban surface. It is the output of the geomety creation routines mentioned above. The class can load STL files, display the geometry and save to STL files as shown below.</p> <pre><code>help udgeom.udgeom\n</code></pre> <pre><code>  udgeom Geometry class for uDALES\n     The udgeom class contains the triangulated surface.\n\n    Documentation for udgeom.udgeom\n</code></pre> <pre><code>geom = udgeom.udgeom();    % create udgeom instance.\nmethods(geom);             % show the methods the class contains\n</code></pre> <pre><code>Methods for class udgeom.udgeom:\n\ncalculate_outline2d       chcpath                   get_building_outlines     get_buildings             get_face_to_building_map  get_outline               gohome                    gopath                    load                      save                      show                      show_outline              udgeom\n\nMethods of udgeom.udgeom inherited from handle.\n</code></pre> <p>These methods can be used as follows</p> <pre><code>help geom.load\n</code></pre> <pre><code>--- help for udgeom.udgeom/load ---\n\n  load an STL file.\n\n  example:\n    obj.load(obj, filename)\n</code></pre> <pre><code>help geom.save\n</code></pre> <pre><code>--- help for udgeom.udgeom/save ---\n\n  save an STL file.\n\n  example:\n    obj.save(obj, filename)\n</code></pre> <pre><code>help geom.show\n</code></pre> <pre><code>--- help for udgeom.udgeom/show ---\n\n  plot the geometry\n\n  show(obj, colorbuildings)\n        colorbuildings (optional): boolean parameter on whether\n                                   to colour buildings. This\n                                   parameter is true by default.\n                                   Needs to be set to false for\n                                   large geometries.\n\n  examples:\n    obj.show();\n    obj.show(false);\n</code></pre> <p>Here is a simple example on how to use this class:</p> <pre><code>geom.load('uDALES.stl')    % load an STL file from the current directory (can be changed in constructor)\ngeom.show();               % show the geometry\nxlabel('x [m]');\nylabel('y [m]')\n</code></pre> <p></p> <p>Another way is to show the outline.</p> <pre><code>help geom.show_outline\n</code></pre> <pre><code>--- help for udgeom.udgeom/show_outline ---\n\n  Plot the geometry outline edges\n\n  show_outline(obj) plots the precomputed outline edges of the geometry\n  show_outline(obj, angle_threshold) recalculates outline with custom threshold\n\n  Parameters:\n    angle_threshold (optional): Angle threshold in degrees for edge detection\n                               If not provided, uses precomputed outline\n\n  Examples:\n    obj.show_outline();     % Use precomputed outline\n    obj.show_outline(30);   % Recalculate with 30\u252c\u2591 threshold\n</code></pre> <p>Here is a simple example on how to use this method:</p> <pre><code>geom.show_outline();               % show the geometry outline\nxlabel('x [m]');\nylabel('y [m]')\n</code></pre> <p></p>"},{"location":"udales-geometry-tutorial/#udgeomcreateflatsurface","title":"udgeom.createFlatSurface","text":"<p>This function creates flat surfaces</p> <pre><code>help udgeom.createFlatSurface\n</code></pre> <pre><code>  createFlatSurface    creates flat surface consisting of triangular facets\n\n     geom = createFlatSurface(xsize, ysize, edgelength) returns a geom\n     instance that can be saved to an stl file.\n         xsize:  length of the domain in x-direction\n         ysize:  length of the domain in y-direction\n         edgelength: the length of individual facets. Best taken as xsize\n         (or ysize) divided by an integer number.\n</code></pre> <p>See below for an example how to use this function.</p> <pre><code>% domain size\nxsize = 96;           % [m]\nysize = xsize;        % [m]\nedgelength = xsize/8; % [m]\n\ngeom = udgeom.createFlatSurface(xsize, ysize, edgelength);\ngeom.show;\nxlabel('x [m]');\nylabel('y [m]')\n</code></pre> <p></p>"},{"location":"udales-geometry-tutorial/#udgeomcreatecanyons","title":"udgeom.createCanyons","text":"<p>This function creates one-dimensional street canyons</p> <pre><code>help udgeom.createCanyons\n</code></pre> <pre><code>  createCanyons    creates one-dimensional street canyons\n\n     geom = createCanyons(xsize, ysize, B, W, H, shift, edgelength) returns\n     a geom instance that can be saved to an stl file.\n         xsize:      length of the domain in x-direction\n         ysize:      length of the domain in y-direction\n         B:          building width\n         W:          street width\n         H:          building height\n         shift:      shifts the canyons to the right in the x-direction\n         edgelength: the length of individual facets. Best taken as xsize\n                     (or ysize) divided by an integer number.\n         rotate90:   boolean that allows one to rotate the domain once it\n                     has been generated. Set this parameter to false under\n                     normal conditions.\n</code></pre> <p>See below for an example how to use this function.</p> <pre><code>% domain size\nxsize = 96;       % domain size in x-direction\nysize = 96;       % domain size in y-direction\n\n% canyon properties\nB = 12;           % building width\nH = 16;           % building height\nW = 12;           % street width\nshift = 20;       % make the canyons start a distance from the west-boundary of the domain.\n                  % Note this makes the domain larger in the x-direction.\nedgelength = 6;   % facet size\nrotate90 = false; % default value\n\ngeom = udgeom.createCanyons(xsize, ysize, B, W, H, shift, edgelength, rotate90);\ngeom.show;\nxlabel('x [m]');\nylabel('y [m]')\n</code></pre> <p></p>"},{"location":"udales-geometry-tutorial/#udgeomcreatecubes","title":"udgeom.createCubes","text":"<p>This function creates cubes, either a single one or an array of cubes.</p> <pre><code>help udgeom.createCubes\n</code></pre> <pre><code>  createCubes    creates cubes, either a single one or an array of cubes.\n\n     geom = createCubes(xsize, ysize, Hx, Hy, Hz, Cx, Cy, geom_option, edgelength)\n     returns a geom instance that can be saved to an stl file.\n         xsize:       length of the domain in x-direction\n         ysize:       length of the domain in y-direction\n         Hx:          cube x-length\n         Hy:          cube y-length\n         Hz:          cube height\n         Cx:          cube spacing in x-direction\n         Cy:          cube spacing in y-direction\n         geom_option: the type of geometry to create:\n                                 'S': single cube\n                                'AC': aligned cubes\n                                'SC': staggered cubes\n         edgelength: the length of individual facets. Best taken as xsize\n                     (or ysize) divided by an integer number.\n</code></pre> <p>See below for an example how to use this function.</p> <pre><code>% domain size\nxsize = 96;\nysize = 96;\n\n% cube length in each direction\nHx = 16;\nHy = 16;\nHz = 16;\n\n% canyon length in each direction\nCx = 8;\nCy = 8;\n\n% geometry type\n%     S: single cube\n%    AC: aligned cubes\n%    SC: staggered cubes\n\ngeom_type = 'SC';\n\nedgelength = 8;\n\ngeom = udgeom.createCubes(xsize, ysize, Hx, Hy, Hz, Cx, Cy, geom_type, edgelength);\ngeom.show;\nxlabel('x [m]');\nylabel('y [m]')\n</code></pre>"},{"location":"udales-geometry-tutorial/#udgeomcreaterealistic","title":"udgeom.createRealistic","text":"<p>This function creates a realistic urban surface based on an stl file that contains the buildings. The function adds the ground surface.</p> <pre><code>help udgeom.createRealistic\n</code></pre> <pre><code>  createRealistic    creates a realistic urban surface based on an stl file\n                     that contains the buildings. The function adds the\n                     ground surface.  \n\n     geom = createRealistic(stlfile, xsize, ysize, shift, edgelength)\n     returns a geom instance that can be saved to an stl file.\n         stlfile:    the STL file that contains the buildings (NOT the\n                     ground)\n         xsize:      length of the new domain in x-direction\n         ysize:      length of the new domain in y-direction\n         shift:      array that shifts the geometry. shift[1], shift[2] and\n                     shift[3] represent, respectively, the shift in x-, y-\n                     and z-direction.\n         edgelength: the length of individual facets. Best taken as xsize\n                     (or ysize) divided by an integer number.\n</code></pre> <p>See below for an example how to use this function.</p> <pre><code>% stl file containing buildings only\nstlfile = 'uDALES.stl';\n\n% original domain size\nxsize_og = 256;\nysize_og = 128;\n\n% example translation to make domain larger in x direction\nshift = [20 0 0];\n\n% ground facet size\nedgelength = 16;\n\ngeom = udgeom.createRealistic(stlfile, xsize_og, ysize_og, shift, edgelength);\ngeom.show;\nxlabel('x [m]');\nylabel('y [m]')\n</code></pre>"},{"location":"udales-how-to-cite/","title":"How to cite","text":"<p>When using uDALES or data generated by uDALES please cite:</p> <p>Owens et al. (2024). A conservative immersed boundary method for the multi-physics urban large-eddy simulation model uDALES v2.0. Geophys. Mod. Dev. 16:6277-6300, https://doi.org/10.5194/gmd-17-6277-2024</p> <p>Suter el al. (2022), uDALES 1.0: a large-eddy-simulation model for urban environments. Geophys. Mod. Dev. 15, 5309\u20135335, https://doi.org/10.5194/gmd-15-5309-2022</p> <pre><code>@Article{Owens2024,\nAUTHOR = {Owens, S. O. and Majumdar, D. and Wilson, C. E. and Bartholomew, P. and van Reeuwijk, M.},\nTITLE = {A conservative immersed boundary method for the multi-physics urban large-eddy simulation model uDALES v2.0},\nJOURNAL = {Geoscientific Model Development},\nVOLUME = {17},\nYEAR = {2024},\nNUMBER = {16},\nPAGES = {6277--6300},\nURL = {https://gmd.copernicus.org/articles/17/6277/2024/},\nDOI = {10.5194/gmd-17-6277-2024}\n}\n\n@Article{Suter2022,\nAUTHOR = {Suter, I. and Grylls, T. and S\\\"utzl, B. S. and Owens, S. O. and Wilson, C. E. and van Reeuwijk, M.},\nTITLE = {uDALES 1.0: a large-eddy simulation model for urban environments},\nJOURNAL = {Geoscientific Model Development},\nVOLUME = {15},\nYEAR = {2022},\nNUMBER = {13},\nPAGES = {5309--5335},\nURL = {https://gmd.copernicus.org/articles/15/5309/2022/},\nDOI = {10.5194/gmd-15-5309-2022}\n}\n</code></pre> <p>If you are looking to also cite a specific version of the software, you can find corresponding version-specific DOIs on Zenodo.</p>"},{"location":"udales-installation/","title":"Installation","text":"<p>Getting started with uDALES to set up your own experiments is straightforward. This page goes through the steps required to install uDALES and to set-up the directory structure. Results are output in netCDF format, for a quick inspection you can use GUI tools such as Panoply or ncview. To learn more about pre- and post-processing steps see the what's next section.</p> <p>If you have Singularity available on your system, you can use the provided scripts under <code>tools/singularity</code> to build and run uDALES cases locally or on HPC environments. See Singularity for instructions; otherwise, see the next section.</p>"},{"location":"udales-installation/#prerequisites","title":"Prerequisites","text":""},{"location":"udales-installation/#udales","title":"uDALES","text":"<p>uDALES is supported to run on Linux, macOS and Windows Subsystem for Linux (WSL). Please ensure that the latest version of the following libraries and software are available on your system:</p> <ul> <li>CMake &gt;= 3.9.</li> <li>NetCDF-Fortran &gt;= 4.</li> <li>GNU &gt;= 9, Intel, or Cray Fortran compiler.</li> <li>A recent version of MPICH or Open-MPI.</li> <li>FFTW</li> </ul>"},{"location":"udales-installation/#project-setup","title":"Project setup","text":"<p>To set up a project template for uDALES with a generic folder structure that you can later use to set up your own experiments, you will need:</p> <ul> <li>Git &gt;= 2.</li> <li>A GitHub account. (optional)</li> <li>Python &gt;= 3.6.</li> </ul>"},{"location":"udales-installation/#pre-processing","title":"Pre-processing","text":"<p>When you create your own experiments, the input data needs to be processed before the simulation can be performed. For this reason, uDALES has a suite of pre-processing routines written in several languages including MATLAB. For information on how perform the pre-processing, see pre-processing.</p> <ul> <li>MATLAB &gt;= R2017b</li> </ul>"},{"location":"udales-installation/#post-processing","title":"Post-processing","text":"<p>The uDALES output data are stored in netCDF files. However, as the code is parallel, these need to be merged before they can be conveniently visualised an processed using Python, MATLAB or other languages. The merging is performed with the NCO package:</p> <ul> <li>netCDF Operators (NCO).</li> </ul> <p>On local systems, these software and libraries (except MATLAB) should be available from your system's package manager (e.g. APT, yum, Homebrew, etc.) and examples on how to install all the required libraries for Linux/WSL and macOS are given below.</p> <p>On high performance computing (HPC) clusters, these software and libraries should have already been installed. Please refer to the specific documentation to load the above software and libraries. Alternatively, you can install all the required packages easily after installing Linuxbrew and using the instructions for macOS.</p>"},{"location":"udales-installation/#linuxwsl-ubuntu","title":"Linux/WSL (Ubuntu)","text":"<pre><code>sudo apt-get update &amp;&amp; sudo apt-get upgrade -y\nsudo apt-get install -y git cmake gfortran libomp-dev libopenmpi-dev openmpi-bin libnetcdf-dev libnetcdff-dev nco python3 python3-pip libfftw3-dev\n</code></pre>"},{"location":"udales-installation/#macos","title":"macOS","text":"<p>On macOS, use Homebrew to install the required libraries. If you do not have Homebrew installed on your system, install it from the Homebrew installation page then, to install all the required dependencies, including support for MPI, run the following commands from your terminal prompt:</p> <pre><code>brew update\nbrew install git cmake gcc netcdf netcdf-fortran mpich nco python3 fftw\n</code></pre>"},{"location":"udales-installation/#repository-set-up","title":"Repository set-up","text":"<p>Create a top-level directory, for example called \"uDALES\":</p> <pre><code>mkdir uDALES\n</code></pre> <p>Clone the u-dales repository into the top-level directory:</p> <pre><code>cd uDALES\ngit clone --recurse-submodules https://github.com/uDALES/u-dales.git\n</code></pre> <p>Create directories for experiment set-ups and output data:</p> <pre><code>mkdir experiments outputs\n</code></pre> <p>such that your directory tree resembles the following:</p> <pre><code>.\nmyproject\n\u2502\n\u251c\u2500\u2500 experiments # Configuration files grouped by experiment number.\n\u2502   \u2514\u2500\u2500 &lt;N&gt;     # Any configurations files needed by uDALES to run experiment &lt;N&gt; a three digit integer number.\n\u2502   \u2514\u2500\u2500 ...\n\u2502\n\u251c\u2500\u2500 outputs     # Additional or specialized tools other then the ones included with uDALES.\n\u2502   \u2514\u2500\u2500 &lt;N&gt;     # Output from experiment &lt;N&gt;.\n\u2502   \u2514\u2500\u2500 ...\n\u2502\n\u2514\u2500\u2500 u-dales     # uDALES model development repository (submodule).\n\u2502   \u2514\u2500\u2500 2decomp-fft\n\u2502   \u2514\u2500\u2500 ...\n\u2502   \u2514\u2500\u2500 src\n\u2502   \u2514\u2500\u2500 ...\n\u2502   \u2514\u2500\u2500 tools\n\u2502   \u2514\u2500\u2500 ...\n</code></pre> <p>In the next steps we will assume your current working directory is the top-level project directory.</p>"},{"location":"udales-installation/#build-on-common-systems","title":"Build on common systems","text":"<p>To compile uDALES (in release mode) on common/local uvuntu or mac systems using helper script, run:</p> <pre><code># We assume you are running the following commands from the u-dales directory\ntools/build_executable.sh common release\n</code></pre> <p>OR, you can do it manually. On standard systems and configurations, you can build uDALES with the following commands:</p> <pre><code># We assume you are running the following commands from your\n# top-level project directory.\n\nmkdir -p u-dales/build/release # in case you want to later create a build/debug\npushd u-dales/build/release\ncmake -LA ../..\nmake\npopd\n</code></pre> <p>You can compile in parallel mode by passing Make the <code>j</code> flag followed by the number of CPU cores to use. For example, to compile with 2 cores do <code>make -j2</code>.</p>"},{"location":"udales-installation/#build-on-hpcs","title":"Build on HPCs","text":"<p>To compile uDALES (in release mode) on the ICL HPC cluster run:</p> <pre><code># We assume you are running the following commands from the u-dales directory\ntools/build_executable.sh icl release\n</code></pre> <p>To compile uDALES (in release mode) on ARCHER2, use:</p> <pre><code># We assume you are running the following commands from the u-dales directory\ntools/build_executable.sh archer release\n</code></pre> <p>Information for developers: if you are a High Performance Cluster (HPC) user you are likely using the Environment Modules package for the dynamic modification of the user's environment via modulefiles and therefore you may need to hint CMake the PATH to netCDF (see below how).</p> <p>Here we show how to compile uDALES using the HPC at ICL as an example, therefore please note that the specific names/versions installed on your system may be different.</p> <pre><code>module list # list currently enabled modules -- should be empty!\nmodule avail # list available modules\n</code></pre> <pre><code># This is an example, please check with the previous command for the exact name of the\n# modules available on your system. This will load netCDF compiled with Intel Suite\n# 2020.2 and add the correct version of icc and ifort to the PATH.\nmodule load intel-suite/2020.2 mpi/intel-2019.8.254 cmake/3.18.2 git/2.14.3\n</code></pre> <p>Then, to build the uDALES executable, run the following commands:</p> <pre><code># We assume you are running the following commands from your\n# top-level project directory.\n\nmkdir -p u-dales/build/release\npushd u-dales/build/release\nFC=mpiifort cmake -DNETCDF_DIR=/apps/netcdf/4.4.1-c -DNETCDF_FORTRAN_DIR=/apps/netcdf/4.4.4-fortran -LA ../..\nmake\npopd\n</code></pre> <p>where <code>NETCDF_DIR</code> and <code>NETCDF_FORTRAN_DIR</code> indicates the absolute path to your netCDF-C and netCDF-Fortran installation directories. Here, we use the utilities <code>nc-config</code> and <code>nf-config</code> to hint CMake the location of netCDF, but you can simply pass the absolute path to the netCDF-C and netCDF-Fortran manually instead. You can compile in parallel mode by passing Make the <code>j</code> flag followed by the number of CPU cores to use. For example, to compile with 2 cores do <code>make -j2</code>.</p>"},{"location":"udales-installation/#build-defaultsoptions","title":"Build defaults/options","text":"<p>By default uDALES will compile in <code>Release</code> mode. You can change this by specifying the option (or flag) at configure time. The general syntax for specifying an option in CMake is <code>-D&lt;flag_name&gt;=&lt;flag_value&gt;</code> where <code>&lt;flag_name&gt;</code> is the option/flag name and <code>&lt;flag_value&gt;</code> is the option/flag value. The following options can be specified when configuring uDALES:</p> Name Options Default Description <code>CMAKE_BUILD_TYPE</code> <code>Release</code>, <code>Debug</code> <code>Release</code> Whether to optimise/build with debug flags <code>NETCDF4_DIR</code> <code>&lt;path&gt;</code> - Path to netCDF-C installation directory <code>NETCDF_FORTRAN_DIR</code> <code>&lt;path&gt;</code> - Path to netCDF-Fortran installation directory <code>SKIP_UPDATE_EXTERNAL_PROJECTS</code> <code>ON</code>, <code>OFF</code> <code>OFF</code> Whether to skip updating external projects"},{"location":"udales-installation/#singularity","title":"Singularity","text":"<p>If you are looking for information on how to install or use Singularity on your system, please refer to the Singularity documentation. The use of Singularity is undoubtedly the easiest way to build and run cases in uDALES as all dependencies are provided and uDALES will compile out of the box. Furthermore, users wishing to achieve a reasonable level of scientific reproducibility may archive software, tools, and data with their Singularity image containing OS and external libraries to an open access repository (e.g. Meyer et al., 2020).</p> <p>First clone the uDALES repository with:</p> <pre><code>git clone https://github.com/uDALES/u-dales.git\n</code></pre> <p>Then, to build and download the Singularity image use:</p> <pre><code>singularity build --remote tools/singularity/image.sif tools/singularity/image.def\n</code></pre> <p>then, to install uDALES use:</p> <pre><code># udales_build.sh &lt;NPROC&gt; [Debug, Release]\n./tools/singularity/udales_build.sh 2 Release\n</code></pre> <p>Finally, to run an example case use:</p> <pre><code># udales_run.sh &lt;NPROC&gt; &lt;BUILD_TYPE&gt; &lt;PATH_TO_CASE&gt; &lt;NAMELIST&gt;\n./tools/singularity/udales_run.sh 2 Release examples/001 namoptions.001\n</code></pre> <p>If you are looking to run the build and run commands on HPC, we have provided a sample script under <code>tools/singularity/udales_pbs_submit.sh</code>, you can modify and run it with <code>qsub tools/singularity/udales_pbs_submit.sh</code>.</p>"},{"location":"udales-installation/#whats-next","title":"What's next?","text":"<p>This simple guide is meant to allow you to get started based on an existing example. We set up several example simulations to get you started. To learn more about pre- and post-processing steps in uDALES, please see the pre-processing and post-processing pages.</p>"},{"location":"udales-namoptions-overview/","title":"Input parameters","text":"<p>Below we specify the input parameters in the <code>namoptions</code> file of your experiment.</p>"},{"location":"udales-namoptions-overview/#namelist-run","title":"Namelist RUN","text":"Name Default Possible values Description Unit iexpnr 000 Three digit integer. Experiment case number - lwarmstart .false. .true. or .false. If .true. simulation reads in restart file to initialize fields. - startfile '' 'initd00001234_xxx_xxx.000' Name of restart file, the last three digits should match iexpnr. - runtime 300 &gt; 0 Simulation time. [s] trestart 10000. 0 &lt; trestart &lt; runtime Time at which restart files are written, trestart &gt; runtime will prevent restart files being written. [s] dtmax 20 &gt; 0 Maximum allowed numerical integration timestep. [s] ladaptive .false. .true. or .false. Switch for adaptive time-stepping, .true. recommended. - courant 1.1 1 &lt;= courant &lt;=2 Courant number, default sets it to 1.5 or 1.1 (if Kappa or upwind scheme is used). - lrandomize .true. .true. or .false. Switch that determines whether initial field is randomised. - irandom 43 <code>INTEGER</code> &gt; 0 Seed for random number generation. - randu 0.01 <code>REAL</code> &gt; 0 Amplitude of velocity field randomisation. [m/s] libm .true. .true. or .false. Switch that determines whether the Immersed Boundary Method is turned on. - lles .true. .true. or .false. Switch that determines whether the subgrid model is turned on or constant ekm and ekh are used (DNS). - nprocx - <code>INTEGER</code> &gt; 0 Number of pencils in the x-direction (see 2decomp documentation [https://2decomp-fft.github.io/]), must be a divisor of itot. - nprocy - <code>INTEGER</code> &gt; 0 Number of pencils in the y-direction (see 2decomp documentation [https://2decomp-fft.github.io/]), must be a divisor of jtot and ktot. -"},{"location":"udales-namoptions-overview/#namelist-domain","title":"Namelist DOMAIN","text":"Name Default Possible values Description Unit itot 96 <code>INTEGER</code> &gt; 0 Number of points in x-direction. - jtot 96 <code>INTEGER</code> &gt; 0 Number of points in y-direction. - ktot 96 <code>INTEGER</code> &gt; 0 Number of points in z-direction. - xlen -1 <code>REAL</code> &gt; 0 Domain size in x-direction. - ylen -1 <code>REAL</code> &gt; 0 Domain size in x-direction. -"},{"location":"udales-namoptions-overview/#namelist-physics","title":"Namelist PHYSICS","text":"Name Default Possible values Description Unit ps 101325 <code>REAL</code> &gt; 0 Air pressure at surface, recommend using standard pressure. [Pa] igrw_damp 0 0, 1, 2, 3 Integer switch to enable gravity wave damping. - ltempeq .false. .true. or .false. Switch for solving temperature equation. - lbuoyancy .false. .true. or .false. Switch for buoyancy force in temperature equation. - lmoist .false. .true. or .false. Switch for solving moisture equation. - lcoriol .false. .true. or .false. Switch for inluding the Coriolis force. - luoutflowr .false. .true. or .false. Switch that determines whether u-velocity is corrected to get a fixed outflow rate. Only functional when x-direction is not parellelised. lvoutflowr .false. .true. or .false. Switch that determines whether u-velocity is corrected to get a fixed outflow rate. Only functional when y-direction is not parellelised. luvolflowr .false. .true. or .false. Switch that determines whether u-velocity is corrected to get a fixed volume flow rate. - lvvolflowr .false. .true. or .false. Switch that determines whether u-velocity is corrected to get a fixed volume flow rate. - luflowr .false. .true. or .false. Switch that determines whether u-velocity is corrected to get a fixed flow velocity. - lvflowr .false. .true. or .false. Switch that determines whether v-velocity is corrected to get a fixed flow velocity. - uflowrate 1. <code>REAL</code> U-velocity flow rate for out- or volume-flow forcing. [m/s] vflowrate 1. <code>REAL</code> V-velocity flow rate out- or volume-flow forcing. [m/s] lprofforc .false. .true. or .false. Switch for nudging flow to a profile (forcing). - lnudge .false. .true. or .false. Switch for nudging flow to profiles (in <code>prof.inp.xxx</code>). - nnudge 0 <code>INTEGER</code> Number of points from bottom to nudge. - tnudge 60. <code>REAL</code> Time scale for nudging - ltimedepsurf .false. .true. or .false. Switch for time-dependent surface heat flux (<code>bctfz</code> etc - see BC section). - ntimedepsurf 0 <code>REAL</code> Number of time-dependent surface heat fluxes in file <code>timedepsurf.inp.xxx</code>. - ltimedepnudge .false. .true. or .false. Switch for time-dependent profiles. When <code>lnudge = .true.</code>, then this switch causes the nudging profile to vary in time. If using inflow-outflow boundary conditions with inflow given by profile (<code>BCxm/BCxT/BCxq = 2</code>), then the inflow profile varies in time. - ntimedepnudge 0 <code>REAL</code> Number of time-dependent nudging profiles in file <code>timedepnudge.inp.xxx</code>. - ltimedepsw .false. .true. or .false. Time-dependent shortwave radiation on facets - ntimedepsw 0 <code>REAL</code> Number of time-dependent shortwave radiative fluxes in file <code>timedepsw.inp.xxx</code>. - ltimedeplw .false. .true. or .false. Time-dependent longwave radiation on facets. - ntimedeplw 0 <code>REAL</code> Number of time-dependent shortwave radiative fluxes in file <code>timedeplw.inp.xxx</code>. -"},{"location":"udales-namoptions-overview/#namelist-dynamics","title":"Namelist DYNAMICS","text":"<p>Possible advection schemes:</p> <p>1 = 1<sup>st</sup> order upwind scheme</p> <p>2 = 2<sup>nd</sup> order central difference scheme</p> <p>7 = Kappa (flux limited) scheme. This scheme can only be applied to passive scalars.</p> Name Default Possible values Description Unit lqlnr .false. .true. or .false. Logical for calculation of liquid water concentration. - ipoiss 0 0 Poisson solver. 0 = using 2D Fast Fourier Transform. - iadv_mom 2 2 Advection scheme for momentum. - iadv_tke 2 2 Advection scheme for TKE. Only used if <code>loneeqn = True</code>. - iadv_thl 2 2 Advection scheme for temperature. - iadv_qt 2 2 Advection scheme for moisture. - iadv_sv 7 1, 2, 7 Advection scheme for scalars. -"},{"location":"udales-namoptions-overview/#namelist-bc","title":"Namelist BC","text":"<p>Switches for boundary conditions: momentum (m), temperature (T), humidity (q) and scalars (s).</p> <p>Lateral BCs (BCx, BCy): 1 = periodic, 2 in/outflow conditions, inflow given by profile (usually constant), 3: in/outflow conditions, inflow given by precursor simulation.</p> <p>BCs at the top (BCtop): 1 = freeslip, 2 = noslip, 3 = should be used with inflow/outflow conditions.</p> <p>BCs at the bottom (BCbot; only effective if not covered with ground facets): 1 = flux, 2 = wall function, 3 = neutral wall function.</p> Name Default Possible values Description Unit BCxm 1 1,2,3 Domain boundary condition for momentum in x. - BCxT 1 1,2,3 Domain boundary condition for temperature in x. - BCxq 1 1,2,3 Domain boundary condition for humidity in x. - BCxs 1 1,2,3 Domain boundary condition for scalars in x. - BCym 1 1,2 Domain boundary condition for momentum in y. - BCyT 1 1,2 Domain boundary condition for temperature in y. - BCyq 1 1,2 Domain boundary condition for humidity in y. - BCys 1 1,2 Domain boundary condition for scalars in y. - BCtopm 1 1,2,3 Boundary condition for momentum at domain top. - BCtopT 1 1,2 Boundary condition for temperature at domain top. - BCtopq 1 1,2 Boundary condition for humidity at domain top. - BCtops 1 1,2 Boundary condition for scalars at domain top. - bctfxm 0 <code>REAL</code> Temperature flux on facets with surface normal in -x direction. [Km/s] bctfxp 0 <code>REAL</code> Temperature flux on facets with surface normal in +x direction. [Km/s] bctfym 0 <code>REAL</code> Temperature flux on facets with surface normal in -y direction. [Km/s] bctfyp 0 <code>REAL</code> Temperature flux on facets with surface normal in +y direction. [Km/s] bctfz 0 <code>REAL</code> Temperature flux on facets with surface normal in +z direction. [Km/s] bcqfxm 0 <code>REAL</code> Moisture flux on facets with surface normal in -x direction. [m/s] bcqfxp 0 <code>REAL</code> Moisture flux on facets with surface normal in +x direction. [m/s] bcqfym 0 <code>REAL</code> Moisture flux on facets with surface normal in -y direction. [m/s] bcqfyp 0 <code>REAL</code> Moisture flux on facets with surface normal in +y direction. [m/s] bcqfz 0 <code>REAL</code> Moisture flux on facets with surface normal in +z direction. [m/s] thl_top -1. <code>REAL</code> &gt;= 0 Temperature at the top boundary. [K] qt_top -1. <code>REAL</code> &gt;= 0 Humidity at the top boundary. [kg/kg] wttop 0. <code>REAL</code> Temperature flux at the top boundary. [Km/s] BCbotm 2 1,2,3 Boundary condition for momentum at domain bottom (if <code>lbottom = .true.</code>). - BCbotT 1 1,2 Boundary condition for temperature at domain bottom (if <code>lbottom = .true.</code>). - BCbotq 1 1 Boundary condition for humidity at domain bottom (if <code>lbottom = .true.</code>). - BCbots 1 1 Boundary condition for scalars at domain bottom (if <code>lbottom = .true.</code>). - wtsurf -1. <code>REAL</code> Temperature flux at domain bottom (if <code>lbottom = .true.</code>). [Km/s] wqsurf -1. <code>REAL</code> Moisture flux at domain bottom (if <code>lbottom = .true.</code>). [m/s] thls -1. <code>REAL</code> Temperature at domain bottom (if <code>lbottom = .true.</code>). [K] qts -1. <code>REAL</code> Moisture at domain bottom (if <code>lbottom = .true.</code>). Used in modthermodynamics to get a BC for the moisture profile. [kg/kg] z0 -1. <code>REAL</code> Momentum roughness length of the domain bottom (if <code>lbottom = .true.</code>). [m] z0h -1. <code>REAL</code> Heat roughness length of the domain bottom (if <code>lbottom = .true.</code>). [m]"},{"location":"udales-namoptions-overview/#namelist-namsubgrid","title":"Namelist NAMSUBGRID","text":"Name Default Possible values Description Unit lvreman .true. .true. or .false. Switch for Vreman (2004) sub-grid scheme. - <p>| cf | 2.5 | <code>REAL</code> &gt; 0 | Filter constant. | - | | cn | 0.76 | <code>REAL</code> &gt; 0 | Subfilter scale parameter. | - | | Rigc | 0.25 | <code>REAL</code> &gt; 0 | Critical Richardson number. | - |</p>"},{"location":"udales-namoptions-overview/#namelist-walls","title":"Namelist WALLS","text":"<p>1 = fixed flux</p> <p>2 = flux determined by wall function involving temperature</p> <p>3 = flux determined by neutral wall function (set automatically if <code>ltempeq = .false.</code>)</p> Name Default Possible values Description Unit nblocks 0 <code>INTEGER</code> Number of blocks specified in <code>blocks.inp</code>. - nfcts -1 <code>INTEGER</code> Number of facets specified in <code>facets.inp</code>. - iwallmom 2 1, 2, 3 (1 means zero flux) Building wall momentum flux. - iwalltemp 1 1, 2 Building wall temperature flux. - iwallmoist 1 1, 2 Building wall moisture flux. - iwallscal 1 1, 2 Building wall scalar flux - lbottom .false. .true., .false. Switch for using wall function as bottom BC. Used only if no ground facets. - nsolpts_u 0 <code>INTEGER</code> Number of solid points on u-grid. - nsolpts_v 0 <code>INTEGER</code> Number of solid points on v-grid. - nsolpts_w 0 <code>INTEGER</code> Number of solid points on w-grid. - nsolpts_c 0 <code>INTEGER</code> Number of solid points on c-grid. - nbndpts_u 0 <code>INTEGER</code> Number of fluid boundary points on u-grid. - nbndpts_v 0 <code>INTEGER</code> Number of fluid boundary points on v-grid. - nbndpts_w 0 <code>INTEGER</code> Number of fluid boundary points on w-grid. - nbndpts_c 0 <code>INTEGER</code> Number of fluid boundary points on c-grid. - nfctsecs_u 0 <code>INTEGER</code> Number of facet sections on u-grid. - nfctsecs_v 0 <code>INTEGER</code> Number of facet sections on v-grid. - nfctsecs_w 0 <code>INTEGER</code> Number of facet sections on w-grid. - nfctsecs_c 0 <code>INTEGER</code> Number of facet sections on c-grid. - lnorec .false. .true. or .false. Switch for not using reconstruction. -"},{"location":"udales-namoptions-overview/#namelist-energybalance","title":"Namelist ENERGYBALANCE","text":"Name Default Possible values Description Unit lEB .false. .true. or .false. Switch for using the facet energy balance. - lwriteEBfiles .false. .true., .false. Switch for writing facet temperatures and energy budget to file. - lconstW .false. .true. or .false. Switch whether soil moisture is assumed as constant in time (.true.) or the evaporated water is from the soil (.false.). - dtEB 10. <code>REAL</code> Time interval between calculations of facet energy balance. s bldT 0. <code>REAL</code> Internal temperature of the buildings. [K] flrT 0. <code>REAL</code> Internal temperature of the ground. [K] wsoil 0. <code>REAL</code> Water content of soil. [kg/m3] wgrmax 450. <code>REAL</code> Maximum water content. [kg/m3] wwilt 171. <code>REAL</code> Water content at wilting point. [kg/m3] wfc 313. <code>REAL</code> Water content at field capacity. [kg/m3] skyLW 0. <code>REAL</code> Long-wave radiation from the sky. [W/m2] GRLAI 2. <code>REAL</code> Leaf area index of a green roof. [m2/m2] rsmin 110. <code>REAL</code> Minimum resistance of soil/plant. [s/m] nfaclyrs 3 <code>INTEGER</code> Number of layers making up each facet (nwalllayers in uDALES v1). - lvfsparse .false. .true. or .false. Switch for view factors in sparse (text) format. - nnz 0 <code>INTEGER</code> Number of non-zero view factors (only used with sparse view factor format. - lperiodicEBcorr .false. .true. or .false. Switch for preventing over-heating and moisture saturation in periodic simualtions. - sinkbase 0 <code>INTEGER</code> &gt; 0 k index above which the periodicEBcorr sink is applied (should be above height of tallest building). - fraction 0 <code>REAL</code> &gt; 0 Ratio of domain height to uncapped boundary layer height. -"},{"location":"udales-namoptions-overview/#namelist-scalars","title":"Namelist SCALARS","text":"Name Default Possible values Description Unit nsv 0 <code>INTEGER</code> &gt; 0 Number of passive scalars. - lreadscal .false. .true., .false. Switch for reading scalar pollutant field (warm start). Deprecated, will be removed in the future. - lscasrcr .false. .true., .false. Switch for 2-D network of point sources at lowest level as defined in scals.inp.xxx. - lscasrcl .false. .true., .false. Switch for passive scalar line source when using canyon geometry. - lscasrc .false. .true., .false. Switch for passive scalar point source defined by xS,yS,zS,SS,sigS. -"},{"location":"udales-namoptions-overview/#namelist-driver","title":"Namelist DRIVER","text":"Name Default Possible values Description Unit idriver 0 0, 1, 2 Options for running precursor driver simulations where *driver* files will be written (<code>= 1</code>) and reading a completed driver simulation as the inlet to a simulation (<code>= 2</code>). Default (<code>= 0</code>) will do neither. - tdriverstart 0. <code>REAL</code> Time at which *driver* files start being written. In use for <code>idriver = 1</code>. s dtdriver 0. <code>REAL</code> Timestep at which *driver* file planes are written. In use for <code>idriver = 1</code>. s iplane - <code>INTEGER</code> Index of the position on the x-axis of the plane that will be written to *driver* files. In use for <code>idriver = 1</code>. driverstore 0. <code>INTEGER</code> Number of timesteps (<code>idriver = 1</code>) to be written to *driver* files or (<code>idriver = 2</code>) contained in *driver* files to be read. - driverjobnr - - Job number of the *driver* files to be read. These files should be copied into the experiments folder of the driven simulation. In use for <code>idriver = 2</code>. - lsdriver .false. .true., .false. Switch for reading scalar driver files. In use for <code>idriver = 2</code>. -"},{"location":"udales-namoptions-overview/#namelist-output","title":"Namelist OUTPUT","text":"Name Default Possible values Description Unit lfielddump .false. .true. or .false. Switch for instantaneous field output. - tfielddump 10000. Output time for fields. [s] fieldvars '' Any of the given labels, several are seperated by a comma: u0,v0,w0,th,ql,qt,p0,s1,s2,s3,s4,s5 Variable names of fields. - tsample 5. <code>REAL</code> Sample time for statistics. [s] tstatsdump 10000. <code>REAL</code> Output time for statistics. [s] tstatstart 0. <code>REAL</code> Time from which statistics computation or data sampling starts. [s] ltdump .false. .true. or .false. Switch to output time-averaged statistics. - lydump .false. .true. or .false. Switch to output y-averaged statistics. Only functional if x-direction is not parallelised. - lytdump .false. .true. or .false. Switch to output y- and time- averaged statistics. Only functional if x-direction is not parallelised. - lxydump .false. .true. or .false. Switch to output x- and y- averaged statistics. - lxytdump .false. .true. or .false. Switch to output x-, y- and time-averaged statistics. - lslicedump .false. .true. or .false. Switch to output slices in the xy-plane. -"},{"location":"udales-namoptions-overview/#namelist-inps","title":"Namelist INPS","text":"Name Default Possible values Description Unit zsize - - Size of domain in z direction. [m] lzstretch false true or false Switch for stretched z grid. - lstretchexp false true or false Switch for z grid stretched using exp function. - lstretchtanh false true or false Switch for z grid stretched using tanh function. - lstretch2tanh false true or false Switch for z grid stretched using 2tanh function. - stretchconst 0.01 - Stretch constant. - u0 0 - Initial u-velocity. Also applied as geostrophic term where applicable. [m/s] v0 0 - Initial v-velocity. Also applied as geostrophic term where applicable. [m/s] dpdx 0 - Pressure gradient in x direction. [Pa/m] dpdy 0 - Pressure gradient in y direction. [Pa/m] thl0 288 - Temperature at z = 0. - qt0 0 - Specific humidity at z = 0. - lapse 0 - Lapse rate. [K/m] w_s 0 - Subsidence. - R 0 - Radiative forcing. [W/m^2] xS 0 <code>REAL</code> Position of scalar point source in x. [m] yS 0 <code>REAL</code> Position of scalar point source in y. [m] zS 0 <code>REAL</code> Position of scalar point source in z. [m] SSp 0. <code>REAL</code> Strength of scalar point source. [g/s] sigSp 0. <code>REAL</code> Standard deviation of scalar point source. [m] xSb 0 <code>REAL</code> Start of scalar line source in x. [m] ySb 0 <code>REAL</code> Start of scalar line source in y. [m] zSb 0 <code>REAL</code> Start of scalar line source in z. [m] xSe 0 <code>REAL</code> End of scalar line source in x. [m] ySe 0 <code>REAL</code> End of scalar line source in y. [m] zSe 0 <code>REAL</code> End of scalar line source in z. [m] SSl 0. <code>REAL</code> Strength of scalar line source. [g/ms] sigSl 0. <code>REAL</code> Standard deviation of scalar line source. [m] NOb 0 - Initial concentration of NO. - NO2b 0 - Initial concentration of NO2. - O3b 0 - Initial concentration of O3. - stl_file - <code>STRING</code> Name of STL file defining the geometry. - read_types false true or false Switch for reading facet types from file. Default: false (all facets are set to type 1). - types_path - <code>STRING</code> Name of types file. - facT 288 <code>REAL</code> &gt; 0 If <code>iwallmom = 2</code> or  <code>iwalltemp = 2</code> then this sets the facet temperature, or if <code>lEB = .true.</code> it is the initial facet temperature [K] ifacsec 1 1 or 2 Option for facet section calculation. 1: Fortran (default, fast), 2: MATLAB (useful for debugging - ishortwave 1 1  or 2 Option for shortwave radiation calculation,  1  uses Fortran and is faster, 2 uses MATLAB and useful for debugging. - isolar 1 1 , 2, 3 Option for solar radiation, 1 uses custom values, 2 uses lattitude and lonigtude, 3 uses weather file. - view3d_out 0 0 , 1 , 2 Output format for View3D, 0 is text, 2 is binary, 2 is sparse. - maxD Inf <code>REAL</code> &gt; 0 Maximum distance to check view factors, otherwise they are zero. - xazimuth 90 <code>REAL</code> The azimuthal angle of the x-axis (with respect to North). [degrees] solarazimuth 135 <code>REAL</code> Solar azimuth, used if isolar = 1. [degrees] solarzenith 28.4066 <code>REAL</code> Solar zenith, used if isolar = 1 . [degrees] I 800 <code>REAL</code> &gt; 0 Shortwave direct normal irradiance (DNI), used if isolar = 1. W/m^2 Dsky 418.8041 <code>REAL</code> &gt; 0 Diffuse sky irradiance, used if isolar = 1. W/m^2 year - <code>INTEGER</code> Year. - month - 1 &lt;= <code>INTEGER</code> &lt;= 12 Month (where 6 corresponds to June), if isoloar = 2 or 3. - day - 1 &lt;= <code>INTEGER</code> &lt;= 31 Day, if isloar = 2 or 3. - hour 6 0 &lt;= <code>INTEGER</code> &lt;= 23 Hour (0 for midnight, 23 for 11pm), if isloar = 2 or 3. [hours] minute 0 0 &lt;= <code>INTEGER</code> &lt;= 59 Minute, if isloar = 2 or 3. [mins] second 0 0 &lt;= <code>INTEGER</code> &lt;= 59 Second, if isloar = 2 or 3. [s] longitude -0.13 <code>REAL</code> Longitude, if isloar = 2. [degrees] latitude 51.5 <code>REAL</code> Latitude, if isloar = 2. [degrees] timezone 0 - Timezone, if isloar = 2. - elevation 0 <code>REAL</code> Elevation, if isloar = 2. - weatherfname - <code>STRING</code> File containing weather data, if isolar = 3. -"},{"location":"udales-namoptions-overview/#namelist-chemistry","title":"Namelist CHEMISTRY","text":"Name Default Possible values Description Unit lchem .false. .true., .false. Switch for basic chemistry. - k1 0. Rate constant (O3 + NO -&gt; NO2 + 02 ). Chemistry model parameter. JNO2 0. NO2 photolysis rate. Chemistry model parameter."},{"location":"udales-namoptions-overview/#namelist-heatpump","title":"Namelist HEATPUMP","text":"Name Default Possible values Description Unit lheatpump .false. .true. or .false. Switch for basic heat pump. lfan_hp .true. .true. or .false. Switch for heat pump fan on/off. nhppoints 0 <code>INTEGER</code> Number of heat pump grid points. Q_dot_hp 0. <code>REAL</code> Total volume flux emission from the heat pump in vertical direction. [m^3/s] QH_dot_hp 0. <code>REAL</code> Rate of total heat extracted from the ambient air by the heat pump. [W]"},{"location":"udales-post-processing/","title":"Post-processing","text":"<p>uDALES saves the outputs as NetCDF files. If a simulation is run on several processors, each processor writes independent output files. The scripts <code>nco_concatenate_field_x.sh</code> and <code>nco_concatenate_field_y.sh</code> in the <code>tools</code> directory can be used together to gather these output files into a single file. The wrapper script <code>gather_outputs.sh</code> does this automatically for all output fields of the simulation. The script is automatically called after a simulation run when using <code>local_execute.sh</code> for executing your simulation. However on Imperial HPC or ARCHER2, the file gathering process should be executed seperately using <code>hpc_gather.sh</code> or <code>archer_gather.sh</code> respectively, once the main simulation completes.</p> <p>If you have separate output files of a continuous simulation, e.g. because one simulation is the warmstart of the other simulation, you can append these output files into a single file using the script <code>append_outputs.sh</code>.</p>"},{"location":"udales-post-processing/#gather-output-fields","title":"Gather output fields","text":"<p>To gather the output files of serveral processors from your simulation to a single file, use:</p> <pre><code># We assume you are running the following commands from your\n# top-level project directory.\n\n# General syntax: gather_outputs.sh &lt;path-to-exp-outputs&gt;\n./u-dales/tools/gather_outputs.sh outputs/009\n</code></pre> <p>In the above command, replace 009 with the number of your simulation. </p> <p>When on Imperial HPC, one should carry out the gather operation on a compute node using the wrapper script <code>hpc_gather.sh</code> as below,</p> <p><pre><code># We assume you are running the following commands from your\n# top-level project directory.\n\n./u-dales/tools/hpc_gather.sh experiments/009\n</code></pre> Note in the above command <code>path-to-exp</code> is passed as an input argument instead of <code>path-to-exp-outputs</code>. The hpc_gather.sh script will identify the output work directory from the <code>config.sh</code> file available in the experiment directory.</p> <p>When on the ARCHER2 cluster, one should use the wrapper script <code>archer_gather.sh</code>. In this case, one should pass <code>path-to-exp-outputs</code> as the input argument as below,</p> <pre><code># We assume you are running the following commands from your\n# top-level project directory.\n\n./u-dales/tools/archer_gather.sh outputs/009\n</code></pre>"},{"location":"udales-post-processing/#append-two-output-files","title":"Append two output files","text":"<p>We assume that simulation 1 was run before simulation 2, i.e. the time steps of simulation 1 are all before simulation 2. To append the output files of simulation 1 (009) to simulation 2 (010), use:</p> <pre><code># We assume you are running the following commands from your\n# top-level project directory.\n\n# General syntax: append_outputs.sh &lt;path-to-simulation-1-outputs&gt; &lt;path-to-simulation-2-outputs&gt;\n./u-dales/tools/append_outputs.sh outputs/009 outputs/010\n</code></pre> <p>Replace 009 and 010 with the numbers of your simulations.</p>"},{"location":"udales-post-processing/#different-output-files-explained","title":"Different output files explained","text":"<p>The output files generated depend on the parameters specified under <code>&amp;OUPUT</code> in the <code>namoptions</code> file of your simulation (see Configuration for details), and the name of the output file(s) matches the name of that switch, e.g. if <code>lxytdump</code> is selected for experiment <code>009</code> then there will be an output file called <code>xytdump.009.nc</code>. If <code>lfielddump</code> is selected, note that there will be a <code>fielddump.xxx.009.nc</code> file for each cpu.</p>"},{"location":"udales-post-processing/#reading-output-files","title":"Reading output files","text":"<p>These output files are in netcdf format, and so it is possible to obtain a description of any particular file using the command <code>ncdisp('&lt;top-level-directory&gt;/outputs/009/xytdump.009.nc')</code> in Matlab. To read a variable, one can use e.g. <code>u = ncread(&lt;top-level-directory&gt;/outputs/009/xytdump.009.nc', 'uxyt')</code></p>"},{"location":"udales-pre-processing/","title":"uDALES preprocessing","text":"<p>In order to perform a simulation with uDALES, the input data needs to be processed, which creates a number of input files that will be read by the uDALES simulation. This can be done from the command line using the shell script <code>write_inputs.sh</code>, which is a wrapper around the MATLAB script <code>write_inputs.m</code>. For more info about the functions see the Developer's guide. The script requires several variables in order to be execute without errors. Three main files required inside the experiment case directory are</p> <ol> <li>an appropriately set namoptions.001 (assumming 001 is the case directory name) file,</li> <li>an STL file of the  building geometry (except for few special cases)</li> <li>the config.sh file.</li> </ol> <p>Below is an example setup for copying and pasting. You need to specify these parameters in a <code>config.sh</code> file within the example directory, which is then read by the scripts.</p> <pre><code># We assume you are running the following commands from your\n# top-level project directory.\n\nexport DA_TOOLSDIR=$(pwd)/u-dales/tools # Directory of the scripts\nexport DA_EXPDIR=$(pwd)/experiments #  The top-level directory of the simulation setups\n</code></pre> <p>Before running the preprocessing, one must build the View3D submodule. This is a one time task and should be done as soon as you clone u-dales from GitHub.</p> <pre><code># We assume you are running the following commands from the u-dales directory.\n\n# To build on local/common ubuntu or mac systems\n./tools/build_preprocessing.sh common\n\n# To build on ICL HPC\n./tools/build_preprocessing.sh icl\n</code></pre> <p>Then, to start the pre-processing, run:</p> <p>For local ubuntu or mac</p> <pre><code># We assume you are running the following commands from your\n# top-level project directory.\n\n# General syntax: write_inputs.sh exp_id\n./u-dales/tools/write_inputs.sh experiments/001\n</code></pre> <p>For ICL HPC</p> <pre><code># We assume you are running the following commands from your\n# top-level project directory.\n\n# General syntax: write_inputs.sh esperiments/exp_id run_node_type\n\n# To run preprocessing on HPC log in node (not recomended)\n./u-dales/tools/write_inputs.sh experiments/001 l\n\n# To run preprocessing on HPC compute node (recomended)\n./u-dales/tools/write_inputs.sh experiments/001 c\n</code></pre> <p>In above example commands, replace 001 with the number of your example.</p> <p>Note: After editing or creating a <code>namoptions.###</code> file (use an existing template where possible), run <code>write_inputs.sh</code> to generate or update geometry-related input files such as <code>facets.inp</code> and <code>factypes.inp</code>. If your setup requires generating geometry from STL files during pre-processing, set the <code>gen_geom</code> parameter in the <code>namoptions</code> file so the pre-processor will build geometry from the provided STL.</p>"},{"location":"udales-pre-processing/#input-files","title":"Input files","text":"<p>uDALES requires a number of input files, all suffixed by the experiment number, which is omitted in the following documentation. The <code>namoptions.inp</code> file contains a list of parameters for uDALES and the pre-processing routines, and the pre-processing is intended to run using solely this file (with some exceptions). The input files are:</p> <ul> <li><code>prof.inp</code>: initial profiles of flow variables (described in DALES documentation).</li> <li><code>lscale.inp</code>: large-scale forcings (described in DALES documentation).</li> <li><code>facets.inp</code>: column of facet types and three columns (x,y,z) of surface normal components (nfcts x 4).</li> <li><code>Tfacinit.inp</code>: list of initial facet temperatures (nfcts x 1).</li> <li><code>factypes.inp</code>: a description of the properties of different types of facet (described below). This is copied to the experiment directory automatically. Each row describes a wall type, with the first 6 columns being: wall type id, a boolean for whether it is a 'green' facet or not, momentum roughness length, heat roughness length, albedo, and emissivity. Assuming that each facet is composed of 3 layers, the next 3 columns give the thickness of each, the next 3 give the volumetric heat capacity, the next 3 give the heat conductivity, and the final 4 give the thermal diffusivity at each interface between the layers.</li> <li><code>scalar.inp</code>: if using scalars, the initial scalar profiles.</li> <li><code>timedepnudge.inp</code>: if using time-dependent nudging (described in DALES documentation).</li> <li><code>timedepsurf.inp</code>: if using time-dependent surface fluxes (described in DALES documentation).</li> </ul> <p>With the IBM, the following additional files are required:</p> <ul> <li><code>solid_u.txt</code>: Indices of solid points on u-grid (nsolpts_u x 3).</li> <li><code>solid_v.txt</code>: Indices of solid points on v-grid (nsolpts_v x 3).</li> <li><code>solid_w.txt</code>: Indices of solid points on w-grid (nsolpts_w x 3).</li> <li><code>solid_c.txt</code>: Indices of solid points on c-grid (nsolpts_c x 3).</li> <li><code>fluid_boundary_u.txt</code>: Indices of fluid boundary points on u-grid (nbndpts_u x 3).</li> <li><code>fluid_boundary_v.txt</code>: Indices of fluid boundary points on v-grid (nbndpts_v x 3).</li> <li><code>fluid_boundary_w.txt</code>: Indices of fluid boundary points on w-grid (nbndpts_w x 3).</li> <li><code>fluid_boundary_c.txt</code>: Indices of fluid boundary points on c-grid (nbndpts_c x 3).</li> <li><code>facet_sections_u.txt</code>: Indices of facet sections on u-grid (nfctsecs_u x 3).</li> <li><code>facet_sections_v.txt</code>: Indices of facet sections on v-grid (nfctsecs_v x 3).</li> <li><code>facet_sections_w.txt</code>: Indices of facet sections on w-grid (nfctsecs_w x 3).</li> <li><code>facet_sections_c.txt</code>: Indices of facet sections on c-grid (nfctsecs_c x 3).</li> </ul> <p>With the SEB, the following additional files are required:</p> <ul> <li><code>facetarea.inp</code>: list of areas of facets (nfcts x 1).</li> <li><code>vf.nc.inp</code> or <code>vfsparse.inp</code>: view factors stored in netcdf or sparse format respectively.</li> <li><code>svf.inp</code>: list of sky view factors of facets (nfcts x 1).</li> <li><code>netsw.inp</code>: list of net shortwave radiation on facets (nfcts x 1). If using time-dependent radiation on facets:</li> <li><code>timedepsw.inp</code>: shortwave - row of times (1 x ntimedepsw) followed by array of values (nfcts x ntimedepsw).</li> <li><code>timedeplw.inp</code>: longwave - columns for times and values (ntimedeplw x 2). This currently must be generated by a separate user-defined script.</li> </ul>"},{"location":"udales-pre-processing/#developers-guide","title":"Developer's guide","text":"<p>The <code>u-dales/tools/preprocessing.m</code> matlab class contains the functionality for preprocessing. The constructor reads the parameters in <code>namoptions</code> and stores them as member variables, and defines default variables for those not specified. These are then used in the member functions. In these member functions, additional data structures are also stored as member variables, including those used repeatedly and those eventually written to files, so that one can easily view and manipulate them using the matlab IDE.</p> <p>The <code>u-dales/tools/write_inputs.m</code> matlab script calls member functions of <code>preprocessing.m</code> in order to write the basic input files (those not relating to the IBM or SEB), followed by routines located in the <code>IBM</code> and <code>SEB</code> directories within the uDALES tools directory. It is intended to be as short and readable as possible, with the goal being that a developer can edit for a particular purpose. It will work simply as a normal script using the matlab IDE, but when doing this, ensure that <code>DA_EXPDIR = &lt;top level directory&gt;/experiments/</code> and <code>DA_TOOLSDIR = &lt;top level directory&gt;/u-dales/tools/</code> are defined.</p> <p>The <code>u-dales/tools/write_inputs.sh</code> shell script acts as a wrapper around <code>write_inputs.m</code>. Before running the matlab script, it will run the shell script <code>config.sh</code> located in the experiment directory, which defines environmental variables <code>DA_EXPDIR</code> and <code>DA_TOOLSDIR</code>. After running the script, it will also write the correct number of facets to <code>namoptions</code>. It is intended to be run from the top level project directory.</p> <p>Some parameters used by uDALES are used in the pre-processing. They are the following:</p>"},{"location":"udales-pre-processing/#run","title":"<code>&amp;RUN</code>","text":"<ul> <li><code>runtime</code>: Length of simulation period (in seconds). This is used with time-varying solar position (see below).</li> </ul>"},{"location":"udales-pre-processing/#domain","title":"<code>&amp;DOMAIN</code>","text":"<ul> <li><code>itot</code>: number of cells in x-direction. Default: 64.</li> <li><code>jtot</code>: number of cells in y-direction. Default: 64.</li> <li><code>ktot</code>: number of cells in z-direction. Default: 96.</li> <li><code>xlen</code>: domain size in x-direction (metres).</li> <li><code>ylen</code>: domain size in y-direction (metres).</li> </ul>"},{"location":"udales-pre-processing/#walls","title":"<code>&amp;WALLS</code>","text":"<p>This section describes the parameters used by the IBM.</p> <ul> <li><code>iwallmom</code>: Momentum flux boundary condition - 1:zero flux, 2: non-neutral wall function, 3: neutral wall function.</li> <li><code>iwalltemp</code>: Temperature flux boundary condition - 1: constant flux, 2: wall function. If either of these are true, then <code>Tfacinit.inp.xxx</code> is written using the value of <code>facT</code>.</li> </ul> <p>The following parameters are not used, but instead generated by the pre-processing routines and written to the file <code>info.txt</code> by the pre-processing script. They must be added to namoptions manually.</p> <ul> <li><code>nfcts</code>: number of facets. If using <code>write_inputs.sh</code> (see below), this will write its value into namoptions. Equal to the number of (non-header) lines in <code>facets.inp.xxx</code>.</li> <li><code>nsolpts_u</code>: number of solid points on the u-grid. Equal to the number of (non-header) lines in <code>solid_u.txt</code>.</li> <li><code>nsolpts_v</code>: number of solid points on the v-grid. Equal to the number of (non-header) lines in <code>solid_v.txt</code>.</li> <li><code>nsolpts_w</code>: number of solid points on the w-grid. Equal to the number of (non-header) lines in <code>solid_w.txt</code>.</li> <li><code>nsolpts_c</code>: number of solid points on the c-grid. Equal to the number of (non-header) lines in <code>solid_c.txt</code>.</li> <li><code>nsndpts_u</code>: number of fluid boundary points on the u-grid. Equal to the number of (non-header) lines in <code>fluid_boundary_u.txt</code>.</li> <li><code>nsndpts_v</code>: number of fluid boundary points on the v-grid. Equal to the number of (non-header) lines in <code>fluid_boundary_v.txt</code>.</li> <li><code>nsndpts_w</code>: number of fluid boundary points on the w-grid. Equal to the number of (non-header) lines in <code>fluid_boundary_w.txt</code>.</li> <li><code>nsndpts_c</code>: number of fluid boundary points on the c-grid. Equal to the number of (non-header) lines in <code>fluid_boundary_c.txt</code>.</li> <li><code>nfctsecs_u</code>: number of facet sections on the u-grid. Equal to the number of (non-header) lines in <code>facet_sections_u.txt</code>.</li> <li><code>nfctsecs_v</code>: number of facet sections on the v-grid. Equal to the number of (non-header) lines in <code>facet_sections_v.txt</code>.</li> <li><code>nfctsecs_w</code>: number of facet sections on the w-grid. Equal to the number of (non-header) lines in <code>facet_sections_w.txt</code>.</li> <li><code>nfctsecs_c</code>: number of facet sections on the c-grid. Equal to the number of (non-header) lines in <code>facet_sections_c.txt</code>.</li> </ul>"},{"location":"udales-pre-processing/#physics","title":"<code>&amp;PHYSICS</code>","text":"<ul> <li><code>luoutflowr</code>: switch that determines whether u-velocity is corrected to get a fixed outflow rate Default: false.</li> <li><code>lvoutflowr</code>: switch that determines whether v-velocity is corrected to get a fixed outflow rate. Default: false.</li> <li><code>luvolflowr</code>: switch that determines whether u-velocity is corrected to get a fixed volume flow rate. Default: false.</li> <li><code>lvvolflowr</code>: switch that determines whether v-velocity is corrected to get a fixed volume flow rate. Default: false.</li> <li><code>lcoriol</code>: switch for coriolis force. Default: false.</li> <li><code>lprofforc</code>: switch for nudging flow to a profile. Default: false.</li> </ul> <p>Note only one forcing should be specified, i.e. one of <code>luoutflowr</code>/<code>lvoutflowr</code>,<code>luvolflowr</code>/<code>lvvolflowr</code>, <code>lprofforc</code>, or <code>lcoriol</code>.</p>"},{"location":"udales-pre-processing/#energybalance","title":"<code>&amp;ENERGYBALANCE</code>","text":"<ul> <li><code>lEB</code>: switch for energy balance. Default: false.</li> <li><code>lvfsparse</code>: switch for view factors in sparse (text) format.</li> <li><code>nnz</code>: number of non-zero view factors when using sparse format - this needs to be written to namoptions after pre-processing.</li> <li><code>dtEB</code>: surface energy balance timestep.</li> </ul>"},{"location":"udales-pre-processing/#chemistry","title":"<code>&amp;CHEMISTRY</code>","text":"<ul> <li><code>lchem</code>: switch for chemistry.</li> </ul>"},{"location":"udales-pre-processing/#scalars","title":"<code>&amp;SCALARS</code>","text":"<ul> <li><code>nsv</code>: number of scalar variables. Default: 0. Note that <code>nsv &gt; 0</code> is not yet supported in the pre-processing.</li> </ul>"},{"location":"udales-pre-processing/#inps","title":"<code>&amp;INPS</code>","text":"<p>The parameters under the <code>&amp;INPS</code> header are used only in the pre-processing.</p> <ul> <li><code>zsize</code>: size of domain in z direction (metres).</li> <li><code>lzstretch</code>: switch for stretched z grid. Default: false.</li> <li><code>lstretchexp</code>: switch for z grid stretched using exp function. Default: false.</li> <li><code>lstretchtanh</code>: switch for z grid stretched using tanh function. Default: false.</li> <li><code>lstretch2tanh</code>: switch for z grid stretched using 2tanh function. Default: false.</li> <li><code>stretchconst</code>: stretch constant. Default: 0.01.</li> <li><code>u0</code>: initial u-velocity (m/s). Also applied as geostrophic term where applicable. Default: 0.</li> <li><code>v0</code>: initial v-velocity (m/s). Also applied as geostrophic term where applicable. Default: 0.</li> <li><code>dpdx</code>: pressure gradient in x direction (Pa/m). Default: 0.</li> <li><code>dpdy</code>: pressure gradient in y direction (Pa/m). Default: 0.</li> <li><code>thl0</code>: temperature at z = 0. Default: 288.</li> <li><code>qt0</code>: specific humidity at z = 0. Default: 0.</li> <li><code>lapse</code>: lapse rate (K/m). Default: 0.</li> <li><code>w_s</code>: subsidence. Default: 0.</li> <li><code>R</code>: radiative forcing (W/m^2). Default: 0.</li> <li><code>NOb</code>: initial concentration of NO. Default: 0.</li> <li><code>NO2b</code>: initial concentration of NO2b. Default: 0.</li> <li><code>O3b</code>: initial concentration of O3b. Default: 0.</li> </ul> <p>The following parameters are related to the immersed boundary method.</p> <ul> <li><code>stl_file</code>: Name of STL file defining the geometry.</li> <li><code>read_types</code>: Switch for reading facet types from file. Default: false (all facets are set to type 1).</li> <li><code>types_path</code>: Name of types file.</li> <li><code>facT</code>: if <code>iwallmom = 2</code> or  <code>iwalltemp = 2</code> then (constant) facet temperature, or if <code>lEB = .true.</code> then initial facet temperature. Default: 288.</li> <li><code>isolid_bound</code>: Option for classification of solid/fluid points, including boundary points. 1: In-house Fortran routine (default, fast), 2: equivalent MATLAB routine (useful for debugging), 3: inpolyhedron (MATLAB; provided for when option 1 &amp; 2 are not producing expected results): https://www.mathworks.com/matlabcentral/fileexchange/37856-inpolyhedron-are-points-inside-a-triangulated-volume.</li> <li><code>ifacsec</code>: Option for facet section calculation. 1: Fortran (default, fast), 2: MATLAB (useful for debugging).</li> </ul> <p>If using the energy balance, the following parameters can also be specified.</p> <ul> <li><code>ishortwave</code>: Option for shortwave radiation calculation. 1: Fortran (default, fast), 2:  MATLAB (useful for debugging).</li> <li><code>isolar</code>: Option for solar radiation (see below for futher detail). 1: custom (default), 2: from latitude &amp; longitude, 3: from weather file.</li> <li><code>view3d_out</code>: Output format for View3D: 0: text, 1: binary, 2: sparse (text). Default: 0.</li> <li><code>maxD</code>: Maximum distance to check view factors, otherwise they are zero. Default: Inf.</li> <li><code>xazimuth</code>: the azimuthal angle of the x-axis (with respect to North). Default : 90 degrees, i.e. East.</li> </ul> <p>If <code>isolar = 1</code>, then the solar radiation is determined by:</p> <ul> <li><code>solarazimuth</code>: solar azimuth (degrees). Default: 135. (solaz in uDALES v1).</li> <li><code>solarzenith</code>: solar zenith (degrees). Default: 28.4066. (Z in uDALES v1).</li> <li><code>I</code>: direct normal irradiance (DNI) (W/m^2). Default: 800.</li> <li><code>Dsky</code>: diffuse sky irradiance (W/m^2). Default: 418.8041. (Dsk in uDALES v1).</li> </ul> <p>If <code>isolar = 2</code>, then the solar position is calculated according to the NOAA solar position algorithm, and <code>I</code> and <code>Dsky</code> are determined by the ASHRAE clear-sky model, and the spacetime location is specified by:</p> <ul> <li><code>year</code>, e.g. 2023.</li> <li><code>month</code>, where e.g. 6 corresponds to June.</li> <li><code>day</code>, e.g. 21.</li> <li><code>hour</code>, where e.g. 0 corresponds to midnight and 23 corresponds to 11pm. Default: 6.</li> <li><code>minute</code>. Default: 0.</li> <li><code>second</code>. Default: 0.</li> <li><code>longitude</code>. Default: -0.13.</li> <li><code>latitude</code>. Default: 51.5.</li> <li><code>timezone</code>. Default: 0.</li> <li><code>elevation</code>. Default: 0.</li> </ul> <p>If <code>isolar = 3</code>, then the parameters are specified in a file containing weather data for a given year.</p> <ul> <li><code>weatherfname</code>: file name.</li> <li><code>month</code></li> <li><code>day</code></li> <li><code>hour</code>. Default: 0.</li> </ul> <p>The solar parameters can also be varied in time using the <code>ltimedepsw</code> switch. This occurs on a timescale <code>dtSP</code>, which is equal to <code>dtEB</code> by default.</p>"},{"location":"udales-pub-list/","title":"Publication list","text":"<p>uDALES was used in the following publications <sup>1</sup><sup>2</sup><sup>3</sup><sup>4</sup><sup>5</sup><sup>6</sup><sup>7</sup><sup>8</sup><sup>9</sup><sup>10</sup><sup>11</sup><sup>12</sup>.</p> <ol> <li> <p>S. Owens, O. Beckett, A. Acred, and M. van Reeuwijk. Large-eddy simulation of a diurnal cycle in a coastal urban environment. Building and Environment, (awaiting publication). URL: https://dx.doi.org/10.2139/ssrn.5125973.\u00a0\u21a9</p> </li> <li> <p>Dipanjan Majumdar, Giulio Vita, Rubina Ramponi, Nina Glover, and Maarten van Reeuwijk. The drag length is key to quantifying tree canopy drag. Journal of Wind Engineering and Industrial Aerodynamics, 261:106084, 2025. doi:https://doi.org/10.1016/j.jweia.2025.106084.\u00a0\u21a9</p> </li> <li> <p>S. O. Owens, D. Majumdar, C. E. Wilson, P. Bartholomew, and M. van Reeuwijk. A conservative immersed boundary method for the multi-physics urban large-eddy simulation model uDALES v2.0. Geosc. Mod. Dev., 17(16):6277\u20136300, 2024. doi:10.5194/gmd-17-6277-2024.\u00a0\u21a9</p> </li> <li> <p>Tom Grylls and Maarten van Reeuwijk. How trees affect urban air quality: it depends on the source. Atmos. Env., 290:119275, 2022. doi:10.1016/j.atmosenv.2022.119275.\u00a0\u21a9</p> </li> <li> <p>I. Suter, T. Grylls, B. S. S\u00fctzl, S. O. Owens, C. E. Wilson, and M. van Reeuwijk. uDALES 1.0: a large-eddy simulation model for urban environments. Geosc. Mod. Dev., 15(13):5309\u20135335, 2022. doi:10.5194/gmd-15-5309-2022.\u00a0\u21a9</p> </li> <li> <p>H.D. Lim, D. Hertwig, T. Grylls, H. Gough, M. van Reeuwijk, C.S.E. Grimmond, and C. Vanderwel. Drag distribution in idealized heterogeneous urban environments. Exp. Fluids, 63:92, 2022. doi:10.1007/s00348-022-03439-0.\u00a0\u21a9</p> </li> <li> <p>B.S. Suetzl, G.G. Rooney, A. Finnenkoeter, S. Bohnenstengel, C.S. Grimmond, and M. Van Reeuwijk. Distributed urban drag parameterization for sub-kilometre scale numerical weather prediction. Q. J. Roy. Met. Soc., 147:3940\u20133956, 2021. doi:10.1002/qj.4162.\u00a0\u21a9</p> </li> <li> <p>T. Grylls, I. Suter, B.S. Suetzl, S. Owens, D. Meyer, and M. van Reeuwijk. Udales: large-eddy-simulation software for urban flow, dispersion, and microclimate modelling. J. Open Source Softw., 6(63):3055, 2021. doi:10.21105/joss.03055.\u00a0\u21a9</p> </li> <li> <p>T. Grylls and M. Van Reeuwijk. Tree model with drag, transpiration, shading and deposition: identification of cooling regimes and large-eddy simulation. J. Agricul. Forestry Meteo., 298\u2013299:108288, 2021. doi:10.1016/j.agrformet.2020.108288.\u00a0\u21a9</p> </li> <li> <p>B.S. Suetzl, G.G. Rooney, and M. van Reeuwijk. Drag distribution in idealized heterogeneous urban environments. Bound.-Lay. Met., 178:225\u2013248, 2020. doi:10.1007/s10546-020-00567-0.\u00a0\u21a9</p> </li> <li> <p>T. Grylls, I. Suter, and M. van Reeuwijk. Steady-state large-eddy simulations of convective and stable urban boundary layers. Bound.-Lay. Met., 175(3):309\u2013341, 2020. doi:10.1007/s10546-020-00508-x.\u00a0\u21a9</p> </li> <li> <p>T. Grylls, C.M.A. Le Cornec, P. Salizzoni, L. Soulhac, M.E.J. Stettler, and M. van Reeuwijk. Evaluation of an operational air quality model using large-eddy simulation. Atmos. Env. X, 3:100041, 2019. doi:10.1016/j.aeaoa.2019.100041.\u00a0\u21a9</p> </li> </ol>"},{"location":"udales-simulation-setup/","title":"Running uDALES","text":""},{"location":"udales-simulation-setup/#running-udales","title":"Running uDALES","text":"<p>The scripts <code>local_execute.sh</code> (for local machines), <code>hpc_execute.sh</code> (for ICL cluster) and <code>archer_execute.sh</code> (for ARCHER2) in <code>u-dales/tools</code> are used as wrappers to run simulations. These scripts contain several helpers to run the simulations and merge outputs (see Post-processing for more info) from several CPUs into a single file.</p> <p>The scripts require several variables to be set up. Below is an example setup for copying and pasting. You can also specify these parameters in a <code>config.sh</code> file within the example directory, which is then read by the scripts. We recommend keeping a <code>config.sh</code> in each example case directory with the appropriate variable setting. The simulation workflow consists of three stages:</p> <ol> <li>Pre-processing: create or update input files with <code>write_input.sh</code> (calls <code>write_input.m</code>) or other pre-processing tools.</li> <li>Execution: launch the solver using <code>local_execute.sh</code> (for desktop) or <code>hpc_execute.sh</code> (for clusters).</li> <li>Post-processing: merge and analyse output files using <code>gather_outputs.sh</code> or other scripts.</li> </ol> <p>Example cases shipped with uDALES are located under <code>u-dales/examples/</code> and are suitable for testing an installation.</p> <p>Note that you need to choose the number of CPUs you are using to run the simulation such that the product of <code>nprocx</code> and <code>nprocy</code> (in the <code>namoptions</code> input file) is equal to the total number of CPU asked, i.e., <code>nprocx * nprocy = NCPU</code> for local machines, and <code>nprocx * nprocy = NNODE * NCPU</code> for ICL HPC or ARCHER2 clusters.</p>"},{"location":"udales-simulation-setup/#run-on-common-systems","title":"Run on common systems","text":"<pre><code># Contents of the config.sh file\n# We assume you are running the following commands from your\n# top-level project directory.\n\nexport DA_EXPDIR=$(pwd)/experiments                     # Experiments top-level directory\nexport DA_TOOLSDIR=$(pwd)/u-dales/tools                 # Directory of scripts\nexport DA_BUILD=$(pwd)/u-dales/build/release/u-dales    # Build file\nexport DA_WORKDIR=$(pwd)/outputs                        # Output top-level directory\nexport NCPU=8                                           # Number of CPUs to use for a simulation\n\n# It is recommended to write the full path instead of using $(pwd) in config.sh file\n</code></pre> <p>Then, to start the simulation, run:</p> <pre><code># We assume you are running the following commands from your\n# top-level project directory.\n\n# General syntax: local_execute.sh exp_directory\n./u-dales/tools/local_execute.sh experiments/009\n</code></pre>"},{"location":"udales-simulation-setup/#run-on-icl-cluster","title":"Run on ICL cluster","text":"<pre><code># Contents of the config.sh file\n# We assume you are running the following commands from your\n# top-level project directory.\n\nexport DA_EXPDIR=$(pwd)/experiments                     # Experiments top-level directory\nexport DA_TOOLSDIR=$(pwd)/u-dales/tools                 # Directory of scripts\nexport DA_BUILD=$(pwd)/u-dales/build/release/u-dales    # Build file\nexport DA_WORKDIR=$EPHEMERAL                            # Output top-level directory\nexport NCPU=128                                         # Number of CPUs to use for a simulation\nexport NNODE=1                                          # Number of nodes to use for a simulation\nexport WALLTIME=\"00:30:00\"                              # Maximum runtime for simulation in hours:minutes:seconds\nexport MEM=\"128gb\"                                      # Memory request per node\n\n# It is recommended to write the full path instead of using $(pwd) in config.sh file\n</code></pre> <p>For guidance on how to set the parameters on HPC, have a look at Job sizing guidance. Then, to start the simulation, run:</p> <pre><code># We assume you are running the following commands from your\n# top-level project directory.\n\n# General syntax: hpc_execute.sh exp_directory\n./u-dales/tools/hpc_execute.sh experiments/009\n</code></pre>"},{"location":"udales-simulation-setup/#run-on-archer2","title":"Run on ARCHER2","text":"<pre><code># Contents of the config.sh file\n# We assume you are running the following commands from your\n# top-level project directory.\n\nexport DA_EXPDIR=/work/account/account/username/top_level_project_directory/experiments                     # Experiments top-level directory\nexport DA_TOOLSDIR=/work/account/account/username/top_level_project_directory/u-dales/tools                 # Directory of scripts\nexport DA_BUILD=/work/account/account/username/top_level_project_directory/u-dales/build/release/u-dales    # Build file\nexport DA_WORKDIR=/work/account/account/username/top_level_project_directory/outputs                        # Output top-level directory\nexport NCPU=128                                                                                             # Number of CPUs to use for a simulation\nexport NNODE=1                                                                                              # Number of nodes to use for a simulation\nexport WALLTIME=\"24:00:00\"                                                                  # Maximum runtime for simulation in hours:minutes:seconds\nexport MEM=\"256gb\"                                                                          # Memory request per node\nexport QOS=\"standard\"                                                                       # Queue\n</code></pre> <p>For guidance on how to set the parameters on ARCHER2, have a look at the ARCHER2 documentation. In particular, make sure to edit the <code>archer_execute.sh</code> script (the line <code>#SBATCH --account=n02-ASSURE</code>) and set the account corresponds to one you use. Then, to start the simulation, run:</p> <pre><code># We assume you are running the following commands from your\n# top-level project directory.\n\n# General syntax: hpc_execute.sh exp_directory\nbash ./u-dales/tools/archer_execute.sh experiments/009\n</code></pre>"},{"location":"udales-udbase-tutorial/","title":"Introduction to uDALES post-processing with MATLAB","text":"<p>This tutorial describes how to read and process facet data of the LES code uDALES using MATLAB. This tutorial introduces the <code>udbase</code> post-processing class. There are separate tutorials for processing field files and facet files.</p> <p>The <code>udbase</code> post-processing class reads in most important input parameters, and contains a number of methods to load field and facet data.</p> <p>Field data:</p> <ul> <li>load_stat_xyt. This method load the 1D slab- and time-averaged statistics from the file <code>xytdump.expnr.nc</code>. Several time-intervals may be present in the data.</li> <li>load_stat_t. This method loads the 3D time-averaged statistics from the file <code>tdump.expnr.nc</code>. Several time-intervals may be present in the data.</li> <li>load_stat_tree. This method loads the 3D time-averaged statistics of the tree source terms from the file <code>treedump.expnr.nc</code>. This method works exactly the same way as <code>load\\\\_stat\\\\_t</code>.</li> <li>load_field. This method loads instantaneous 3D data from the file <code>fielddump.expnr.nc</code>. Several output times may be present in the data.</li> <li>load_slice. This method loads instantaneous 2D slices of instantaneous 3D data from the file <code>Xslicedump.expnr.nc</code>. Several output times may be present in the data.</li> </ul> <p>Facet data:</p> <ul> <li>calculate_frontal_properties. This method calculates the skylines, frontal areas and blockage ratios in the x- and y-direction.</li> <li>plot_fac_type. This method displays the type of surface for each facet.</li> <li>assign_prop_to_fac. This method assigns a property of the facet type to each of the facets, so it can be used for calculation and visualisation</li> <li>plot_fac. This method displays a surface variable on the mesh.</li> <li>load_fac_momentum. This method loads instantaneous momentum surface data from <code>fac.expnr.nc</code>. The first index is the facet id and second index is time.</li> <li>load_fac_eb. This method loads instantaneous surface energy balance data from <code>facEB.expnr.nc</code>. The first index is the facet id and second index is time.</li> <li>load_seb. This method loads all instantaneous surface energy balance terms. The first index is the facet id and second index is time.</li> <li>load_fac_temperature. This method loads instantaneous facet temperature data <code>facT.expnr.nc</code>. The first index is the facet id, the second is the layer index and the third index is time.</li> <li>area_average_seb. This method calculates the area-averaged surface energy balance from the facet surface energy balances obtained using <code>load_seb</code>.</li> <li>area_average_fac. This method performs area-averaging over (a selection of) the facets. The facet index is assumed to be the first index of the array.</li> <li>plot_trees. This method volumetric tree blocks along with the STL geometry.</li> <li>convert_facflx_to_field. This method converts a facet variable to a density in a 3D field, so it can be used for post-processing (e.g. calculating distributed drag).</li> <li>convert_facvar_to_field. This method assigns facet variables to the 3D grid, so it can be used for post-processing (e.g. averaging over y).</li> </ul> <p>The live matlab file of this tutorial can be found in the repository in the folder /docs/tutorial_mlx.</p>"},{"location":"udales-udbase-tutorial/#initialising-udbase","title":"Initialising udbase","text":"<p>The starting point of this tutorial is that you have run a simulation and have merged the output files. If the simulations were performed on a HPC system, we assume that you have copied the output directory to your own workstation. Some of the netCDF (*.nc) files may be very large and you may only want to copy these if you plan to analyse the data.</p> <p>The uDALES postprocessing class is called <code>udbase</code>. Typically, you will create a post-processing script in the output directory on your workstation, but it is also possible to have the output directory located in another directory. This is particularly useful if you are comparing several different simulations at the same time. Here, we will show how to use data from simulation 065 (<code>expnr=065)</code> that is located in a different directory from the one you are working in.</p> <p>Note that the uDALES/tools/matlab path must be added via the Set Path button in order to use the udbase class. Alternatively, it can be added using the addpath function inside the script (done here).</p> <pre><code>% preamble\nclear variables\nclose all\n\n% add the uDALES matlab path\naddpath('path_to_udales\\tools\\matlab')\n\n% create an instance of the udbase class\nexpnr = 065;\nexpdir = 'path_to_experiments\\065';\n\nsim = udbase(expnr, expdir);\n</code></pre> <p>The constructor can have a number of input parameters:</p> <pre><code>help udbase.udbase\n</code></pre> <pre><code>  Class constructor.\n\n  udbase(expnr, dapath, load_preprocdata)\n     expnr:                       experiment number\n     dapath (optional):           path to the experiment\n\n  Example:\n    obj = udbase(expnr, '/path/experiments/../100');\n\n    Documentation for udbase/udbase\n</code></pre> <p>The constructor of the <code>udbase</code> class reads in the following files:</p> <ul> <li><code>namoptions.expnr. C</code>ontains the simulation input parameters.</li> <li><code>xxx.stl.</code> Contains the urban geometry used for the simulation [optional].  </li> </ul> <p>Provided that <code>load_preprocdata</code> is not set to false, the constructor of the <code>udbase</code> class additionally reads the following files:</p> <ul> <li><code>solid_(u,v,w,c).txt.</code> Contains the indices of the (u,v,w,c)-volumes occupied by buildings.</li> <li><code>facets.inp</code>. Contains information about the facet wall type and surface normal.</li> <li><code>factypes.inp</code>. Contains information about the properties of the wall types.</li> <li><code>facetarea.inp</code>. Contains information about the facet areas.</li> <li><code>fluid_boundary_(u,v,w,c).txt</code>. Contains information about the fluid cells associated with facet sections.</li> <li><code>facet_sections_(u,v,w,c).txt</code>. Information about facet section area, distance and flux point.</li> </ul>"},{"location":"udales-udbase-tutorial/#accessing-simulation-properties","title":"Accessing simulation properties","text":"<p>To view all simulation input parameters, simply type</p> <pre><code>sim\n</code></pre> <pre><code>sim =\n  udbase with properties:\n\n              expnr: '065'\n               geom: [1x1 udgeom.udgeom]\n                 xm: [64x1 double]\n                 ym: [64x1 double]\n                 zm: [64x1 double]\n                 xt: [64x1 double]\n                 yt: [64x1 double]\n                 zt: [64x1 double]\n                 dx: 1\n                 dy: 1\n                dzm: [64x1 double]\n                dzt: [64x1 double]\n                 Su: [64x64x64 logical]\n                 Sv: [64x64x64 logical]\n                 Sw: [64x64x64 logical]\n                 Sc: [64x64x64 logical]\n               facs: [1x1 struct]\n           factypes: [1x1 struct]\n             facsec: [1x1 struct]\n              trees: []\n         stl_ground: 1\n               ktot: 64\n          fieldvars: ''v0,th,qt,u0,w0''\n           lBImin_w: 0\n         iwallmoist: 2\n          nbndpts_c: 5164\n          lbuoyancy: 1\n           lBImin_c: 0\n          nsolpts_c: 3488\n           iadv_thl: 2\n         nfctsecs_c: 7940\n          nbndpts_v: 5208\n               thl0: 301\n              rsmin: 200\n             iexpnr: 65\n              skyLW: 395\n                z0h: 6.7000e-05\n             wgrmax: 451\n              dtfac: 10\n           lxytdump: 1\n         tstatsdump: 5\n                 z0: 0.0100\n          lvfsparse: 1\n       solarazimuth: 135\n               flrT: 298\n             wtsurf: 0\n         nfctsecs_w: 2817\n             ltdump: 0\n         lfielddump: 0\n                  I: 814\n               ylen: 64\n         tfielddump: 11\n               itot: 64\n         nfctsecs_u: 11214\n                 u0: 2\n          uflowrate: 5\n               jtot: 64\n             min_vf: 0.0100\n              zsize: 64\n                nnz: 909975\n               xlen: 64\n               libm: 1\n           lBImin_v: 0\n           nfaclyrs: 5\n          nsolpts_v: 3696\n        solarzenith: 45\n           fraction: 0.5000\n              nfcts: 2658\n          igrw_damp: 0\n            tsample: 1\n          nsolpts_u: 3856\n    lperiodicEBcorr: 1\n             wqsurf: 0\n               maxD: 64\n                qt0: 0.0100\n            iadv_qt: 2\n             nprocx: 8\n           stl_file: 'geom.065.stl'\n              randu: 0.0100\n              lflat: 1\n              dtmax: 5\n           trestart: 51000\n       diag_neighbs: 0\n             nprocy: 4\n            irandom: 43\n           lBImin_u: 0\n          nbndpts_u: 5208\n             lmoist: 1\n            ltempeq: 1\n         lrandomize: 1\n               Dsky: 107.2000\n              GRLAI: 2.1000\n          nsolpts_w: 7584\n             ipoiss: 0\n          ladaptive: 1\n               dtEB: 1\n         nfctsecs_v: 12010\n         luvolflowr: 1\n         lvoutflowr: 0\n                wfc: 314\n          vflowrate: 0\n      lwriteEBfiles: 1\n                 ps: 101300\n            runtime: 10000\n               facT: 301\n           sinkbase: 32\n          iwalltemp: 2\n               bldT: 298\n            lconstW: 1\n          lwritefac: 1\n            lvreman: 1\n              wsoil: 250\n                lEB: 1\n              wwilt: 172\n          nbndpts_w: 5164\n</code></pre> <p>For a complete list of parameters and their meaning, please consult the pre-processing documentation. Some commonly used parameters are</p> <ul> <li><code>xlen</code>, <code>ylen</code> and <code>zsize</code> that represent the domain size</li> <li><code>itot</code>, <code>jtot</code> and <code>ktot</code> that represent the total number of grid cells</li> </ul> <p>To access a parameter directly, use the syntax <code>object.prop</code>. To access the domain length in x-direction, use</p> <pre><code>sim.xlen\n</code></pre> <pre><code>ans = 64\n</code></pre> <p>The geometry stored in the STL file, if present, has been also loaded, which can be visualised using the method below. This method will produce an error if STL file does not exist or been loaded.</p> <pre><code>sim.geom.show();\n</code></pre> <p></p> <p>This shows all individual faces. Use <code>show_outline</code> to see the building outlines.</p> <pre><code>sim.geom.show_outline();\n</code></pre> <p></p>"},{"location":"udales-utility-tutorial/","title":"Using uDALES utilities in MATLAB","text":"<p>This tutorial demonstrates how to use the uDALES MATLAB utilities for post-processing simulation data. It covers 1) time-averaging; 2) merging short-term time-averaged data to long-term averages, and 3) coarse-graining fields for Spatial filtering (coarse-graining method). The utility functions include:</p> <ul> <li>time_average. This routine calculates the time-average of a quantity (assumes time is in the last index of the variable).</li> <li>merge_stat. This routine merges the short-term time average and (co)variance into long-term averages and associated (co)variance.</li> <li>coarsegrain_field. This routine allows you to coarse-grain a field using a planar filter in the x-y plane using a fixed lengthscale [1].</li> </ul>"},{"location":"udales-utility-tutorial/#time_average-time-averaged-mean-and-variance-of-instantaneous-data","title":"time_average: time-averaged mean and variance of instantaneous data","text":"<p><code>time_average</code> function returns the mean and variance of time-series data (fields, facets, timeseries, ...). The method assumes that time is the last array index.</p> <pre><code>help time_average\n</code></pre> <pre><code>  time_average  Time-average variables over all available time intervals\n\n    [Xmean, var] = time_average(X)\n        Compute the time-averaged mean and variance of X over the full\n        time record (time is assumed to be the last dimension).\n\n    [Xmean, Ymean, cov] = time_average(X, Y)\n        Compute the time-averaged means of X and Y and their covariance\n        over the full time record.\n\n  Inputs:\n    X   - First variable time series. The final array dimension is assumed\n          to be time (e.g. size(X) = [..., Nt]).\n    Y   - Second variable time series (same shape as X) [optional]\n\n  Outputs:\n    For single variable (1 input):\n      Xmean - Time-averaged X over the full record\n      var   - Time-averaged variance over the full record\n\n    For two variables (2 inputs):\n      Xmean - Time-averaged X over the full record\n      Ymean - Time-averaged Y over the full record\n      cov   - Time-averaged covariance over the full record\n\n  Examples:\n    [X_avg, X_var] = time_average(X);\n    [X_avg, Y_avg, XY_cov] = time_average(X, Y);\n</code></pre> <p>For example, let's load instantaneous pressure data for facets:</p> <pre><code>% preamble\nclear variables\nclose all\n\n% add the uDALES matlab path\naddpath('path_to_udales\\tools\\matlab')\n\n% create an instance of the udbase class\nexpnr = 065;  % Experiment number\nexpdir = 'path_to_experiments\\065';\nsim = udbase(expnr, expdir);\n\np = sim.load_fac_momentum('pres');\nt = sim.load_fac_momentum('t');\n</code></pre> <p>Now, let's calculate pressure mean and variance</p> <pre><code>[pav, pvar] = time_average(p);\n</code></pre> <p>Plot the time-series of p together with the mean and the 95% confidence interval</p> <pre><code>figure\nplot(t, p(1,:), t, ones(size(t)) *pav(1),'k-'); hold on\nplot(t, ones(size(t)) *(pav(1)+ 2* sqrt(pvar(1))), 'k--', t, ones(size(t)) *(pav(1)- 2* sqrt(pvar(1))), 'k--')\nlegend('p(t)', 'time-averaged p','two-sigma level of p')\nxlabel 'time'; ylabel 'pressure';\n</code></pre> <p></p> <p>The function can also be used to calculated the time average and covariance of two variables. For example, let's calculate the covariance of the facet pressure and x-component shear stress \\overline{p^{\\prime } \\tau_x^{\\prime } }:</p> <pre><code>taux = sim.load_fac_momentum('tau_x');\n[pbar, tauxbar, ptauxbar] = time_average(p, taux);\n\n% check output for the first facet\nfprintf('The time-averaged pressure pbar=%.3f m2/s2, tauxbar=%.3f m2/s2 and their covariance p''taux''bar=%.3f m4/s4.\\n', ...\n    pbar(1), tauxbar(1), ptauxbar(1));\n</code></pre> <pre><code>The time-averaged pressure pbar=2.314 m2/s2, tauxbar=-0.032 m2/s2 and their covariance p'taux'bar=0.049 m4/s4.\n</code></pre> <p>The value of <code>pbar</code> returned by both methods is identical. Note that this example is quite exotic as we only had loaded facet data; more conventional covariances are \\overline{w^{\\prime } u^{\\prime } }, \\overline{w^{\\prime } p^{\\prime } } etc.</p>"},{"location":"udales-utility-tutorial/#merge_stat-combine-short-term-time-average-into-a-long-term-time-average","title":"merge_stat: combine short-term time average into a long-term time average","text":"<p>uDALES statistics are collected over fixed time-windows. Sometimes these time windows may be a bit too short. The function <code>merge_stat</code> is able to combine several of time-windows into larger ones.</p> <p>Let's start with loading short-term time-averaged data, for example the 1-D plane average</p> <pre><code>% Use a different simulation\nexpnr = 110;  % Experiment number\nexpdir = 'path_to_experiments\\110';\nsim = udbase(expnr, expdir);\n</code></pre> <pre><code>Warning: prof.inp.110 not found. Assuming equidistant grid.\n</code></pre> <pre><code>% load xy- and time-averaged data\nuxyt = sim.load_stat_xyt('uxyt');        % u-velocity profile (z) [m/s]\nwxyt = sim.load_stat_xyt('wxyt');        % w-velocity profile [m/s]\nupupxyt = sim.load_stat_xyt('upuptxyc'); % u-velocity variance [m\u00b2/s\u00b2]\nupwpxyt = sim.load_stat_xyt('upwpxyt');  % u-w velocity covariance [m\u00b2/s\u00b2]\ntime = sim.load_stat_xyt('time');        % Time coordinate for xyt data [s]\n</code></pre> <p>Check the averaging time interval</p> <pre><code>time\n</code></pre> <pre><code>time = 3x1 single column vector\n1.0e+03\n2.0001\n4.0001\n6.0001\n</code></pre> <pre><code>length(time)\n</code></pre> <pre><code>ans = 3\n</code></pre> <p>So there are three time-averaging intervals. Long-term time averaging can be used by using</p> <pre><code>help merge_stat\n</code></pre> <pre><code>  merge_stat  Merge short-time statistics into longer-time averages\n\n    Xmean = merge_stat(X, n)\n        Computes time-averaged mean for a single variable X.\n        Groups the time series into non-overlapping windows of length n\n        and computes statistics inside each window.\n\n    [Xmean, var] = merge_stat(X, XpXp, n)\n        Computes time-averaged mean and variance for a single variable X.\n        Groups the time series into non-overlapping windows of length n\n        and computes statistics inside each window.\n\n    [Xmean, Ymean, cov] = merge_stat(X, Y, XpYp, n)  \n        Computes time-averaged means and covariance for two variables X and Y.\n        Groups the time series into non-overlapping windows and computes\n        statistics inside each window.\n\n  Inputs:\n    X    - First variable time series (time in final dimension)\n    Y    - Second variable time series (same shape as X) [two-variable case only]\n    XpXp - Instantaneous variance contribution (same shape as X) [single-variable]\n    XpYp - Instantaneous covariance contribution (same shape as X and Y) [two-variable]  \n    n    - Window length (number of time samples per averaged window)\n\n  Outputs:\n    Xmean - Time-averaged X in each window\n    Ymean - Time-averaged Y in each window [two-variable case only]\n    var   - Time-averaged variance in each window [single-variable case]\n    cov   - Time-averaged covariance in each window [two-variable case]\n\n  Examples:\n     X_avg = merge_stat(X, 20);\n    [X_avg, X_var] = merge_stat(X, XpXp, 20);\n    [X_avg, Y_avg, XY_cov] = merge_stat(X, Y, XpYp, 50);\n</code></pre> <p>This function needs all the short-term variables related as the input, plus an average time window. The long-term average is simply the average of the short-term averages, but the long-terms variance contains both contribution from variance in the short-term mean and the short term variance. Please ensure that the last dimension of the input must be the time, as the function merges on that dimension.</p> <p>Let's start with two variables and their covariance, obtaining long-term quantities for \\overline{u}, \\bar{w} and their covariance \\overline{u^{\\prime } w^{\\prime } } over all three time segments:</p> <pre><code>Nwindow = length(time);\n\n% input all the short-term variables related\n[uxyt_longterm, wxyt_longterm, upwpxyt_longterm] = merge_stat(uxyt, wxyt, upwpxyt, Nwindow);\n</code></pre> <p>if you only need one variable, e.g., the long-term quantities for \\overline{u} and \\overline{u^{\\prime } u^{\\prime } } over all time, you can reduce it to:</p> <pre><code>[uxyt_longterm, upupxyt_longterm] = merge_stat(uxyt, upupxyt, Nwindow);\n</code></pre> <p>Naturally both versions return the same value for <code>uxyt_longterm.</code> Let's check the dimension of the short-term and long-term statistics</p> <pre><code>size(uxyt)\n</code></pre> <pre><code>ans = 1x2\n\n256    3\n</code></pre> <pre><code>size(uxyt_longterm)\n</code></pre> <pre><code>ans = 1x2\n\n256    1\n</code></pre> <p>If you want an average over shorter window, you can an optional parameter to <code>merge_stat</code>::</p> <pre><code>Nwindow = 2;\n[uxyt_longterm, upupxyt_longterm] = merge_stat(uxyt, upupxyt, Nwindow);\n\nsize(uxyt_longterm)\n</code></pre> <pre><code>ans = 1x2\n\n256    1\n</code></pre> <p>There were three intervals in uxut, and the last two were used to average over. The first time-interval has been discarded.</p>"},{"location":"udales-utility-tutorial/#coarsegrain_field-coarse-graining-3d-fields","title":"coarsegrain_field: coarse-graining 3D fields","text":"<p>We recently developed a coarse-graining method that is computationally efficient and can be used to coarse-grain data [1]. In order to demonstrate its use, let's load the mean horizontal velocity \\overline{u} from the uDALES data.</p> <pre><code>ut = sim.load_stat_t('ut');\n</code></pre> <p>The coarse-graining routine has the following syntax:</p> <pre><code>help coarsegrain_field\n</code></pre> <pre><code>  coarsegrain_field  Apply 2D spatial filter to 3D field data.\n\n    var_filtered = coarsegrain_field(var, Lflt, xm, ym)\n\n  This function applies 2D spatial (x-y) coarse-graining filters to 3D field data.\n  Multiple filter sizes are applied simultaneously, creating a 4D output\n  where the 4th dimension corresponds to different filter sizes.\n\n  Inputs\n    var     - 3D field data with dimensions [itot, jtot, ktot] where\n              the first two dimensions are horizontal (x, y) and the\n              third is vertical (z) or time. Field is assumed periodic.\n    Lflt    - Array of filter lengths in physical units (meters)\n    xm      - x-coordinates of grid points (meters)\n    ym      - y-coordinates of grid points (meters)\n\n  Outputs\n    var_filtered - 4D filtered data with dimensions [itot, jtot, ktot, length(Lflt)]\n                   where the 4th dimension corresponds to different filter sizes\n\n  Algorithm\n    - Converts physical filter lengths to grid cell numbers (Ng = round(Lflt/dx))\n    - Works at discrete level with normalized periodic filters  \n    - Uses FFT-based convolution for computational efficiency\n\n  Example:\n    % Apply multiple filter sizes to velocity field\n    filter_lengths = [10, 20, 40, 80, 160]; % Physical lengths in meters\n    u_filtered = coarsegrain_field(u_data, filter_lengths, xm, ym);\n</code></pre> <p>The routine takes in multiple filter lengths simultaneously.</p> <pre><code>filter_lengths = [8 32 128];  % Filter widths in meters\n\n% filter the last field\nu_filtered = coarsegrain_field(ut(:,:,:,end), filter_lengths, sim.xm, sim.ym);\n</code></pre> <pre><code> Filter 1/1 (Lflt_x=7.5m, Lflt_y=7.5m) completed\n Filter 2/1 (Lflt_x=32.5m, Lflt_y=32.5m) completed\n Filter 3/1 (Lflt_x=127.5m, Lflt_y=127.5m) completed\nCoarse-graining completed in 0.25 seconds\n</code></pre> <pre><code>% Create figure with subplots comparing original and filtered fields\n\nfigure\nk_level = 10;\n% Original field (unfiltered)\nsubplot(2,2,1)\npcolor(sim.xt, sim.yt, ut(:,:,k_level)');\nshading flat; axis equal tight; colorbar;\nclim([-1 2])\ntitle('Original Field (Unfiltered)')\nxlabel('x [m]'); ylabel('y [m]');\n\n% Filtered fields with increasing filter lengths\nfilter_titles = {\n    sprintf('Filter Length = %.0f m', filter_lengths(1)),\n    sprintf('Filter Length = %.0f m', filter_lengths(2)),\n    sprintf('Filter Length = %.0f m', filter_lengths(3))\n};\n\nfor i = 1:3\n    subplot(2,2,i+1)\n    pcolor(sim.xt, sim.yt, u_filtered(:,:,k_level,i)');\n    shading flat; axis equal tight; colorbar;\n    clim([-1 2])\n    title(filter_titles{i})\n    xlabel('x [m]'); ylabel('y [m]');\nend\n</code></pre> <p></p>"},{"location":"udales-utility-tutorial/#references","title":"References","text":"<p>[1] Maarten van Reeuwijk, Jingzi Huang (2025) Multi-scale Analysis of Flow over Heterogeneous Urban Environments, Bound-Lay. Met. 191, 47.</p>"},{"location":"udales-workflow/","title":"Workflow","text":"<p>Page under development ...</p>"}]}